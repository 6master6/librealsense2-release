From 9036f229ee014811b4eeb7f64bdb32b898b79b44 Mon Sep 17 00:00:00 2001
From: doronhi <doron_hirshberg@hotmail.com>
Date: Mon, 13 Jul 2020 03:24:06 -0700
Subject: [PATCH 13/18] Rebase from 'upstream'

---
 .travis.yml                                   |     5 +-
 CMake/pyrealsense2Config.cmake.in             |    10 +
 common/CMakeLists.txt                         |     4 +
 common/calibration-model.cpp                  |   495 +
 common/calibration-model.h                    |    37 +
 common/fw-update-helper.cpp                   |    16 +-
 common/fw/CMakeLists.txt                      |     4 +-
 common/fw/firmware-version.h                  |     4 +-
 common/measurement.cpp                        |    24 +-
 common/measurement.h                          |     4 +-
 common/metadata-helper.cpp                    |     8 +-
 common/model-views.cpp                        |   481 +-
 common/model-views.h                          |   103 +-
 common/notifications.cpp                      |   128 +-
 common/notifications.h                        |    18 +-
 common/objects-in-frame.h                     |    10 +-
 common/on-chip-calib.cpp                      |    39 +-
 common/on-chip-calib.h                        |     2 +-
 common/output-model.cpp                       |  1099 +
 common/output-model.h                         |   187 +
 common/parser.hpp                             |    14 +-
 common/rendering.h                            |    49 +-
 common/sw-update/dev-updates-profile.cpp      |     6 +-
 common/sw-update/http-downloader.cpp          |     1 -
 common/sw-update/versions-db-manager.cpp      |     2 +-
 common/ux-window.cpp                          |    13 +-
 common/ux-window.h                            |     7 +-
 common/viewer.cpp                             |   137 +-
 common/viewer.h                               |     6 +-
 doc/support-matrix.md                         |    14 +-
 doc/troubleshooting.md                        |     4 +
 examples/cmake/readme.md                      |     2 +-
 examples/post-processing/readme.md            |     1 +
 include/librealsense2/h/rs_device.h           |    62 +
 include/librealsense2/h/rs_internal.h         |   189 +
 include/librealsense2/h/rs_option.h           |     3 +
 include/librealsense2/h/rs_sensor.h           |    48 +
 include/librealsense2/h/rs_terminal_parser.h  |    63 +
 include/librealsense2/h/rs_types.h            |    34 +
 include/librealsense2/hpp/rs_device.hpp       |    75 +-
 include/librealsense2/hpp/rs_export.hpp       |     2 +-
 include/librealsense2/hpp/rs_internal.hpp     |   247 +
 include/librealsense2/hpp/rs_sensor.hpp       |    64 +-
 include/librealsense2/hpp/rs_types.hpp        |     7 +
 include/librealsense2/rs.h                    |     4 +-
 include/librealsense2/rs.hpp                  |     2 +
 include/librealsense2/rsutil.h                |    16 +
 package.xml                                   |     2 +-
 scripts/patch-arch.sh                         |    22 +-
 scripts/patch-realsense-ubuntu-lts.sh         |     2 +-
 scripts/patch-utils.sh                        |    21 +-
 .../realsense-camera-formats-bionic-5.patch   |    32 +-
 ...onic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch |    30 +-
 ...lsense-camera-formats-bionic-hwe-5.4.patch |   159 +
 ...alsense-camera-formats-bionic-master.patch |    46 +-
 ...nial-Ubuntu-hwe-4.13.0-45.50_16.04.1.patch |    28 +-
 ...enial-Ubuntu-hwe-4.8.0-58.63_16.04.1.patch |    46 +-
 ...ense-camera-formats-xenial-hwe-zesty.patch |    40 +-
 .../realsense-camera-formats-xenial-hwe.patch |    28 +-
 scripts/realsense-hid-bionic-hwe-5.4.patch    |   108 +
 ...onic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch |    45 +-
 .../realsense-metadata-bionic-hwe-5.4.patch   |   272 +
 src/CMakeLists.txt                            |    10 +
 src/algo.cpp                                  |     8 +-
 src/algo.h                                    |     2 +-
 src/algo/CMakeLists.txt                       |     5 +
 .../depth-to-rgb-calibration/CMakeLists.txt   |    27 +
 .../calibration-types.h                       |   202 +
 .../depth-to-rgb-calibration/calibration.cpp  |   387 +
 .../depth-to-rgb-calibration/calibration.h    |   166 +
 src/algo/depth-to-rgb-calibration/coeffs.cpp  |   720 +
 src/algo/depth-to-rgb-calibration/coeffs.h    |    41 +
 src/algo/depth-to-rgb-calibration/cost.cpp    |   104 +
 src/algo/depth-to-rgb-calibration/cost.h      |    38 +
 src/algo/depth-to-rgb-calibration/debug.h     |    20 +
 .../depth-to-rgb-calibration/frame-data.h     |   152 +
 .../depth-to-rgb-calibration/k-to-dsm.cpp     |   863 +
 src/algo/depth-to-rgb-calibration/k-to-dsm.h  |   269 +
 .../depth-to-rgb-calibration/optimizer.cpp    |  1731 +
 src/algo/depth-to-rgb-calibration/optimizer.h |   382 +
 .../depth-to-rgb-calibration/pinv_3x3.cpp     |   939 +
 .../rotation-in-angles.cpp                    |   117 +
 src/algo/depth-to-rgb-calibration/svd_3x4.cpp |   792 +
 src/algo/depth-to-rgb-calibration/utils.cpp   |   364 +
 src/algo/depth-to-rgb-calibration/utils.h     |    34 +
 src/algo/depth-to-rgb-calibration/uvmap.cpp   |   150 +
 src/algo/depth-to-rgb-calibration/uvmap.h     |    45 +
 .../valid-results.cpp                         |   397 +
 .../depth-to-rgb-calibration/valid-scene.cpp  |   683 +
 src/android/jni/debug_protocol.cpp            |   328 +-
 src/android/jni/fw_logger.cpp                 |   229 +-
 src/android/jni/stream_profile.cpp            |   160 +
 src/archive.h                                 |     5 +-
 src/calibrated-sensor.h                       |    24 +
 src/concurrency.h                             |     9 +-
 src/context.cpp                               |     8 +-
 src/core/serialization.h                      |     2 +-
 src/depth-to-rgb-calibration.cpp              |   173 +
 src/depth-to-rgb-calibration.h                |    52 +
 src/device-calibration.h                      |    21 +
 src/ds5/advanced_mode/presets.h               |    32 +-
 src/ds5/ds5-auto-calibration.cpp              |     6 +-
 src/ds5/ds5-device.cpp                        |    10 +
 src/ds5/ds5-device.h                          |     4 +
 src/ds5/ds5-factory.cpp                       |   163 +-
 src/ds5/ds5-motion.cpp                        |    67 +-
 src/ds5/ds5-motion.h                          |   271 +-
 src/ds5/ds5-options.h                         |    20 -
 src/ds5/ds5-private.h                         |     5 +-
 src/environment.cpp                           |    33 +-
 src/environment.h                             |     3 +-
 src/firmware_logger_device.cpp                |   133 +
 src/firmware_logger_device.h                  |    62 +
 src/frame-archive.h                           |     2 +-
 src/frame-validator.cpp                       |     5 +-
 src/fw-logs/CMakeLists.txt                    |    15 +
 src/fw-logs/fw-log-data.cpp                   |   107 +
 src/fw-logs/fw-log-data.h                     |   107 +
 src/fw-logs/fw-logs-formating-options.cpp     |    95 +
 src/fw-logs/fw-logs-formating-options.h       |    54 +
 src/fw-logs/fw-logs-parser.cpp                |    90 +
 src/fw-logs/fw-logs-parser.h                  |    31 +
 src/fw-logs/fw-logs-xml-helper.cpp            |   309 +
 src/fw-logs/fw-logs-xml-helper.h              |    48 +
 src/fw-logs/fw-string-formatter.cpp           |   138 +
 src/fw-logs/fw-string-formatter.h             |    28 +
 src/gl/align-gl.cpp                           |    32 +-
 src/gl/colorizer-gl.cpp                       |     4 +-
 src/gl/pc-shader.cpp                          |    11 +-
 src/gl/synthetic-stream-gl.cpp                |     2 +
 src/gl/upload.cpp                             |     2 +
 src/hw-monitor.cpp                            |    30 +-
 src/hw-monitor.h                              |     4 +-
 src/ivcam/sr300.cpp                           |    18 +-
 src/ivcam/sr300.h                             |    13 +-
 src/l500/CMakeLists.txt                       |     4 +
 src/l500/ac-trigger.cpp                       |   968 +
 src/l500/ac-trigger.h                         |   197 +
 src/l500/l500-color.cpp                       |   215 +-
 src/l500/l500-color.h                         |   277 +-
 src/l500/l500-depth.cpp                       |   258 +-
 src/l500/l500-depth.h                         |    69 +-
 src/l500/l500-device.cpp                      |   268 +-
 src/l500/l500-device.h                        |    37 +-
 src/l500/l500-factory.cpp                     |    29 +-
 src/l500/l500-motion.cpp                      |    52 +-
 src/l500/l500-motion.h                        |    10 +-
 src/l500/l500-options.cpp                     |    34 +-
 src/l500/l500-options.h                       |     2 +-
 src/l500/l500-private.cpp                     |    48 +-
 src/l500/l500-private.h                       |   164 +-
 src/media/playback/playback_sensor.cpp        |     1 +
 src/media/record/record_sensor.h              |     1 +
 src/metadata-parser.h                         |     3 +-
 src/mf/mf-uvc.cpp                             |     2 +-
 src/option.h                                  |    22 +
 src/proc/motion-transform.cpp                 |     1 -
 src/proc/occlusion-filter.h                   |     4 +-
 src/proc/pointcloud.cpp                       |    86 +-
 src/proc/pointcloud.h                         |     3 +-
 src/proc/processing-blocks-factory.h          |    21 +-
 src/proc/rates-printer.cpp                    |    12 +-
 src/proc/rates-printer.h                      |     6 +-
 src/proc/sse/sse-pointcloud.cpp               |     4 +-
 src/proc/syncer-processing-block.cpp          |    25 +-
 src/proc/syncer-processing-block.h            |    12 +-
 src/proc/synthetic-stream.cpp                 |     8 +-
 src/realsense.def                             |    36 +
 src/rs.cpp                                    |   374 +-
 src/sensor.cpp                                |     3 +-
 src/sensor.h                                  |     2 +-
 src/stream.h                                  |     4 +-
 src/sync.cpp                                  |    31 +-
 src/terminal-parser.cpp                       |   117 +
 src/terminal-parser.h                         |    34 +
 src/types.cpp                                 |    75 +-
 src/types.h                                   |   169 +-
 src/win/win-helpers.cpp                       |     2 +-
 third-party/imgui/imgui-fonts-monofont.hpp    |  1368 +
 third-party/imgui/imgui.cpp                   |     1 -
 third-party/imgui/imgui_impl_glfw.cpp         |     3 +
 tools/convert/converters/converter-bin.hpp    |     4 +-
 tools/fw-logger/CMakeLists.txt                |    11 +-
 tools/fw-logger/readme.md                     |     8 +-
 tools/fw-logger/rs-fw-logger.cpp              |   124 +-
 tools/realsense-viewer/CMakeLists.txt         |     3 +-
 tools/realsense-viewer/realsense-viewer.cpp   |    59 +-
 tools/rs-imu-calibration/README.md            |     3 +-
 .../rs-imu-calibration/rs-imu-calibration.py  |    28 +-
 unit-tests/CMakeLists.txt                     |    22 +-
 unit-tests/algo/CMakeLists.txt                |     4 +
 unit-tests/algo/algo-common.h                 |    27 +
 unit-tests/algo/d2rgb/CMakeLists.txt          |   391 +
 unit-tests/algo/d2rgb/ac-logger.h             |    47 +
 unit-tests/algo/d2rgb/compare-scene.h         |   742 +
 unit-tests/algo/d2rgb/compare-to-bin-file.h   |   415 +
 unit-tests/algo/d2rgb/d2rgb-common.h          |    49 +
 unit-tests/algo/d2rgb/scene-data.h            |   337 +
 unit-tests/algo/d2rgb/test-reproduction.cpp   |   173 +
 unit-tests/algo/d2rgb/test-scene-2.cpp        |    23 +
 unit-tests/algo/d2rgb/test-scenes.cpp         |   218 +
 unit-tests/algo/dl_algo_file.cmake            |    29 +
 unit-tests/approx.h                           |   158 +
 unit-tests/catch.h                            |    75 +
 unit-tests/catch/catch.hpp                    | 27114 ++++++++++------
 unit-tests/filesystem.h                       |   295 +
 unit-tests/internal/CMakeLists.txt            |     2 +
 .../internal/internal-tests-class-logic.cpp   |     2 +-
 .../internal/internal-tests-extrinsic.cpp     |     4 +-
 unit-tests/internal/internal-tests-main.cpp   |     1 -
 unit-tests/internal/internal-tests-types.cpp  |     2 +-
 unit-tests/internal/internal-tests-usb.cpp    |     2 +-
 unit-tests/internal/internal-tests-uv-map.cpp |     2 +-
 unit-tests/log/log-common.h                   |    11 +-
 unit-tests/log/test-vs-LOG-static.cpp         |     8 +-
 unit-tests/trace.h                            |    16 +
 unit-tests/types/rot.h                        |    19 +
 unit-tests/types/test-pose.cpp                |   261 +
 unit-tests/unit-test-config.py                |    50 +-
 unit-tests/unit-tests-common.h                |    62 +-
 unit-tests/unit-tests-internal.cpp            |    40 +-
 unit-tests/unit-tests-live.cpp                |    78 +-
 unit-tests/unit-tests-main.cpp                |     1 -
 unit-tests/unit-tests-post-processing.cpp     |    40 +-
 unit-tests/unit-tests-post-processing.h       |     8 +-
 .../intel/realsense/capture/MainActivity.java |     2 +-
 .../realsense/multicam/MainActivity.java      |     2 +-
 .../realsense/playback/MainActivity.java      |     2 +-
 .../realsense/processing/MainActivity.java    |     2 +-
 .../realsense/recording/MainActivity.java     |     2 +-
 .../intel/realsense/librealsense/Device.java  |     1 +
 .../librealsense/DistortionType.java          |    16 +
 .../realsense/librealsense/Extension.java     |     5 +-
 .../realsense/librealsense/Extrinsic.java     |    17 +
 .../realsense/librealsense/FrameQueue.java    |     2 +-
 .../realsense/librealsense/FwLogMsg.java      |    40 +
 .../librealsense/FwLogParsedMsg.java          |    29 +
 .../realsense/librealsense/FwLogger.java      |    73 +-
 .../realsense/librealsense/Intrinsic.java     |    38 +
 .../librealsense/MotionIntrinsic.java         |    25 +
 .../librealsense/MotionStreamProfile.java     |    14 +
 .../intel/realsense/librealsense/Option.java  |     5 +-
 .../realsense/librealsense/Pipeline.java      |     2 +-
 .../realsense/librealsense/StreamProfile.java |    13 +
 .../librealsense/VideoStreamProfile.java      |    12 +
 .../realsense/camera/DetachedActivity.java    |     7 +-
 .../intel/realsense/camera/FwLogsThread.java  |   140 +
 .../realsense/camera/PreviewActivity.java     |    50 +-
 .../realsense/camera/SettingsActivity.java    |     5 +-
 .../com/intel/realsense/camera/Streamer.java  |     2 +-
 .../Intel.RealSense/Devices/CMakeLists.txt    |     2 +
 .../Intel.RealSense/Devices/DebugDevice.cs    |    58 +
 .../Devices/FirmwareLogsDevice.cs             |    73 +
 .../csharp/Intel.RealSense/NativeMethods.cs   |    78 +-
 .../Intel.RealSense/Types/CMakeLists.txt      |     3 +
 .../Types/Enums/CMakeLists.txt                |     1 +
 .../Intel.RealSense/Types/Enums/Extension.cs  |     4 +-
 .../Types/Enums/L500VisualPreset.cs           |    18 +
 .../csharp/Intel.RealSense/Types/FwLog.cs     |    49 +
 .../Intel.RealSense/Types/FwParsedLog.cs      |    62 +
 .../Intel.RealSense/Types/TerminalParser.cs   |    64 +
 wrappers/nodejs/src/addon.cpp                 |     2 +
 wrappers/opencv/dnn/rs-dnn.cpp                |     2 +-
 wrappers/python/CMakeLists.txt                |    47 +-
 wrappers/python/c_files.cpp                   |    40 +-
 wrappers/python/pyrs_device.cpp               |    28 +
 wrappers/python/pyrs_frame.cpp                |    20 +-
 wrappers/python/pyrs_internal.cpp             |    35 +
 wrappers/python/pyrs_sensor.cpp               |    12 +
 wrappers/python/python.cpp                    |    34 +-
 wrappers/python/python.hpp                    |     5 +-
 .../ProcessingPipe/PointCloudDepth.asset      |     2 +-
 .../PointCloudDepthAndColor.asset             |     2 +-
 .../PointCloudProcessingBlocks.asset          |     2 +-
 .../Scripts/ProcessingBlocks/RsPointCloud.cs  |     5 +-
 .../Source/RealSense/Public/RealSenseTypes.h  |     2 +
 276 files changed, 42297 insertions(+), 11133 deletions(-)
 create mode 100644 CMake/pyrealsense2Config.cmake.in
 create mode 100644 common/calibration-model.cpp
 create mode 100644 common/calibration-model.h
 create mode 100644 common/output-model.cpp
 create mode 100644 common/output-model.h
 create mode 100644 include/librealsense2/h/rs_terminal_parser.h
 mode change 100644 => 100755 scripts/patch-arch.sh
 create mode 100644 scripts/realsense-camera-formats-bionic-hwe-5.4.patch
 create mode 100644 scripts/realsense-hid-bionic-hwe-5.4.patch
 create mode 100644 scripts/realsense-metadata-bionic-hwe-5.4.patch
 create mode 100644 src/algo/CMakeLists.txt
 create mode 100644 src/algo/depth-to-rgb-calibration/CMakeLists.txt
 create mode 100644 src/algo/depth-to-rgb-calibration/calibration-types.h
 create mode 100644 src/algo/depth-to-rgb-calibration/calibration.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/calibration.h
 create mode 100644 src/algo/depth-to-rgb-calibration/coeffs.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/coeffs.h
 create mode 100644 src/algo/depth-to-rgb-calibration/cost.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/cost.h
 create mode 100644 src/algo/depth-to-rgb-calibration/debug.h
 create mode 100644 src/algo/depth-to-rgb-calibration/frame-data.h
 create mode 100644 src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/k-to-dsm.h
 create mode 100644 src/algo/depth-to-rgb-calibration/optimizer.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/optimizer.h
 create mode 100644 src/algo/depth-to-rgb-calibration/pinv_3x3.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/rotation-in-angles.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/svd_3x4.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/utils.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/utils.h
 create mode 100644 src/algo/depth-to-rgb-calibration/uvmap.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/uvmap.h
 create mode 100644 src/algo/depth-to-rgb-calibration/valid-results.cpp
 create mode 100644 src/algo/depth-to-rgb-calibration/valid-scene.cpp
 rewrite src/android/jni/debug_protocol.cpp (70%)
 rewrite src/android/jni/fw_logger.cpp (77%)
 create mode 100644 src/calibrated-sensor.h
 create mode 100644 src/depth-to-rgb-calibration.cpp
 create mode 100644 src/depth-to-rgb-calibration.h
 create mode 100644 src/device-calibration.h
 create mode 100644 src/firmware_logger_device.cpp
 create mode 100644 src/firmware_logger_device.h
 create mode 100644 src/fw-logs/CMakeLists.txt
 create mode 100644 src/fw-logs/fw-log-data.cpp
 create mode 100644 src/fw-logs/fw-log-data.h
 create mode 100644 src/fw-logs/fw-logs-formating-options.cpp
 create mode 100644 src/fw-logs/fw-logs-formating-options.h
 create mode 100644 src/fw-logs/fw-logs-parser.cpp
 create mode 100644 src/fw-logs/fw-logs-parser.h
 create mode 100644 src/fw-logs/fw-logs-xml-helper.cpp
 create mode 100644 src/fw-logs/fw-logs-xml-helper.h
 create mode 100644 src/fw-logs/fw-string-formatter.cpp
 create mode 100644 src/fw-logs/fw-string-formatter.h
 create mode 100644 src/l500/ac-trigger.cpp
 create mode 100644 src/l500/ac-trigger.h
 rewrite src/l500/l500-color.h (77%)
 create mode 100644 src/terminal-parser.cpp
 create mode 100644 src/terminal-parser.h
 create mode 100644 third-party/imgui/imgui-fonts-monofont.hpp
 create mode 100644 unit-tests/algo/CMakeLists.txt
 create mode 100644 unit-tests/algo/algo-common.h
 create mode 100644 unit-tests/algo/d2rgb/CMakeLists.txt
 create mode 100644 unit-tests/algo/d2rgb/ac-logger.h
 create mode 100644 unit-tests/algo/d2rgb/compare-scene.h
 create mode 100644 unit-tests/algo/d2rgb/compare-to-bin-file.h
 create mode 100644 unit-tests/algo/d2rgb/d2rgb-common.h
 create mode 100644 unit-tests/algo/d2rgb/scene-data.h
 create mode 100644 unit-tests/algo/d2rgb/test-reproduction.cpp
 create mode 100644 unit-tests/algo/d2rgb/test-scene-2.cpp
 create mode 100644 unit-tests/algo/d2rgb/test-scenes.cpp
 create mode 100644 unit-tests/algo/dl_algo_file.cmake
 create mode 100644 unit-tests/approx.h
 create mode 100644 unit-tests/catch.h
 rewrite unit-tests/catch/catch.hpp (70%)
 create mode 100644 unit-tests/filesystem.h
 create mode 100644 unit-tests/trace.h
 create mode 100644 unit-tests/types/rot.h
 create mode 100644 unit-tests/types/test-pose.cpp
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/DistortionType.java
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extrinsic.java
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogMsg.java
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogParsedMsg.java
 rewrite wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogger.java (83%)
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Intrinsic.java
 create mode 100644 wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionIntrinsic.java
 create mode 100644 wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/FwLogsThread.java
 create mode 100644 wrappers/csharp/Intel.RealSense/Devices/DebugDevice.cs
 create mode 100644 wrappers/csharp/Intel.RealSense/Devices/FirmwareLogsDevice.cs
 create mode 100644 wrappers/csharp/Intel.RealSense/Types/Enums/L500VisualPreset.cs
 create mode 100644 wrappers/csharp/Intel.RealSense/Types/FwLog.cs
 create mode 100644 wrappers/csharp/Intel.RealSense/Types/FwParsedLog.cs
 create mode 100644 wrappers/csharp/Intel.RealSense/Types/TerminalParser.cs

diff --git a/.travis.yml b/.travis.yml
index 08cd3da..10423ca 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -65,7 +65,7 @@ matrix:
       sudo: required
       dist: xenial
       python: "2.7"
-      node_js: "6"
+      node_js: "10"
       env: LRS_BUILD_NODEJS=true
       script:
         - cmake .. -DBUILD_PYTHON_BINDINGS=true -DBUILD_NODEJS_BINDINGS=true -DPYBIND11_PYTHON_VERSION=2.7 -DCHECK_FOR_UPDATES=true
@@ -100,7 +100,8 @@ matrix:
 before_install:
   - cd scripts && ./api_check.sh && cd ..
   - if [[ "$LRS_BUILD_NODEJS" == "true" ]]; then
-      nvm use 6;
+      nvm install 10.15.3;
+      nvm use 10.15.3;
       npm install -g node-gyp;
       npm install -g mocha;
       git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git;
diff --git a/CMake/pyrealsense2Config.cmake.in b/CMake/pyrealsense2Config.cmake.in
new file mode 100644
index 0000000..6450294
--- /dev/null
+++ b/CMake/pyrealsense2Config.cmake.in
@@ -0,0 +1,10 @@
+@PACKAGE_INIT@
+
+set(pyrealsense2_VERSION_MAJOR "@REALSENSE_VERSION_MAJOR@")
+set(pyrealsense2_VERSION_MINOR "@REALSENSE_VERSION_MINOR@")
+set(pyrealsense2_VERSION_PATCH "@REALSENSE_VERSION_PATCH@")
+
+set(pyrealsense2_VERSION ${realsense2_VERSION_MAJOR}.${realsense2_VERSION_MINOR}.${realsense2_VERSION_PATCH})
+
+include("${CMAKE_CURRENT_LIST_DIR}/pyrealsense2Targets.cmake")
+set(realsense2_LIBRARY pyrealsense2::pyrealsense2)
diff --git a/common/CMakeLists.txt b/common/CMakeLists.txt
index e9c2d98..8e7d0bc 100644
--- a/common/CMakeLists.txt
+++ b/common/CMakeLists.txt
@@ -7,6 +7,8 @@ set(COMMON_SRC
         "${CMAKE_CURRENT_LIST_DIR}/model-views.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/notifications.h"
         "${CMAKE_CURRENT_LIST_DIR}/notifications.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/calibration-model.h"
+        "${CMAKE_CURRENT_LIST_DIR}/calibration-model.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/viewer.h"
         "${CMAKE_CURRENT_LIST_DIR}/viewer.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/ux-window.h"
@@ -23,6 +25,8 @@ set(COMMON_SRC
         "${CMAKE_CURRENT_LIST_DIR}/fw-update-helper.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/metadata-helper.h"
         "${CMAKE_CURRENT_LIST_DIR}/metadata-helper.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/output-model.h"
+        "${CMAKE_CURRENT_LIST_DIR}/output-model.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/skybox.h"
         "${CMAKE_CURRENT_LIST_DIR}/skybox.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/measurement.h"
diff --git a/common/calibration-model.cpp b/common/calibration-model.cpp
new file mode 100644
index 0000000..c32a56c
--- /dev/null
+++ b/common/calibration-model.cpp
@@ -0,0 +1,495 @@
+#include <glad/glad.h>
+#include "calibration-model.h"
+#include "model-views.h"
+#include "os.h"
+
+#include "../src/ds5/ds5-private.h"
+
+using namespace rs2;
+
+bool calibration_model::supports()
+{
+    bool is_d400 = dev.supports(RS2_CAMERA_INFO_PRODUCT_LINE) ?
+        std::string(dev.get_info(RS2_CAMERA_INFO_PRODUCT_LINE)) == "D400" : false;
+
+    return dev.is<rs2::auto_calibrated_device>() && is_d400;
+}
+
+calibration_model::calibration_model(rs2::device dev) : dev(dev) 
+{
+    _accept = config_file::instance().get_or_default(configurations::calibration::enable_writing, false);
+}
+
+void calibration_model::draw_float(std::string name, float& x, const float& orig, bool& changed)
+{
+    if (abs(x - orig) > 0.00001) ImGui::PushStyleColor(ImGuiCol_FrameBg, regular_blue);
+    else ImGui::PushStyleColor(ImGuiCol_FrameBg, black);
+    if (ImGui::DragFloat(std::string(to_string() << "##" << name).c_str(), &x, 0.001f))
+    {
+        changed = true;
+    }
+    ImGui::PopStyleColor();
+}
+
+void calibration_model::draw_float4x4(std::string name, librealsense::float3x3& feild, 
+                                      const librealsense::float3x3& original, bool& changed)
+{
+    ImGui::SetCursorPosX(10);
+    ImGui::Text("%s:", name.c_str()); ImGui::SameLine();
+    ImGui::SetCursorPosX(200);
+
+    ImGui::PushItemWidth(120);
+    ImGui::SetCursorPosX(200);
+    draw_float(name + "_XX", feild.x.x, original.x.x, changed);
+    ImGui::SameLine();
+    draw_float(name + "_XY", feild.x.y, original.x.y, changed);
+    ImGui::SameLine();
+    draw_float(name + "_XZ", feild.x.z, original.x.z, changed);
+    
+    ImGui::SetCursorPosX(200);
+    draw_float(name + "_YX", feild.y.x, original.y.x, changed);
+    ImGui::SameLine();
+    draw_float(name + "_YY", feild.y.y, original.y.y, changed);
+    ImGui::SameLine();
+    draw_float(name + "_YZ", feild.y.z, original.y.z, changed);
+
+    ImGui::SetCursorPosX(200);
+    draw_float(name + "_ZX", feild.z.x, original.z.x, changed);
+    ImGui::SameLine();
+    draw_float(name + "_ZY", feild.z.y, original.z.y, changed);
+    ImGui::SameLine();
+    draw_float(name + "_ZZ", feild.z.z, original.z.z, changed);
+
+    ImGui::PopItemWidth();
+
+    ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+}
+
+namespace helpers
+{
+    #define UPDC32(octet, crc) (crc_32_tab[((crc) ^ (octet)) & 0xff] ^ ((crc) >> 8))
+
+    static const uint32_t crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
+        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+    };
+
+    /// Calculate CRC code for arbitrary characters buffer
+    uint32_t calc_crc32(const uint8_t *buf, size_t bufsize)
+    {
+        uint32_t oldcrc32 = 0xFFFFFFFF;
+        for (; bufsize; --bufsize, ++buf)
+            oldcrc32 = UPDC32(*buf, oldcrc32);
+        return ~oldcrc32;
+    }
+};
+
+void calibration_model::update(ux_window& window, std::string& error_message)
+{
+    const auto window_name = "Calibration Window";
+
+    if (to_open)
+    {
+        try
+        {
+            _calibration = dev.as<rs2::auto_calibrated_device>().get_calibration_table();
+            _original = _calibration;
+            ImGui::OpenPopup(window_name);
+        }
+        catch(std::exception e)
+        {
+            error_message = e.what();
+        }
+        to_open = false;
+    }
+
+    auto table = (librealsense::ds::coefficients_table*)_calibration.data();
+    auto orig_table = (librealsense::ds::coefficients_table*)_original.data();
+    bool changed = false;
+    
+    const float w = 620;
+    const float h = 500;
+    const float x0 = std::max(window.width() - w, 0.f) / 2;
+    const float y0 = std::max(window.height() - h, 0.f) / 2;
+    ImGui::SetNextWindowPos({ x0, y0 });
+    ImGui::SetNextWindowSize({ w, h });
+
+    auto flags = ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar |
+        ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
+
+    ImGui::PushStyleColor(ImGuiCol_PopupBg, sensor_bg);
+    ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+    ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(5, 5));
+    ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 1);
+
+    if (ImGui::BeginPopupModal(window_name, nullptr, flags))
+    {
+        if (error_message != "") ImGui::CloseCurrentPopup();
+
+        std::string title_message = "CAMERA CALIBRATION";
+        auto title_size = ImGui::CalcTextSize(title_message.c_str());
+        ImGui::SetCursorPosX(w / 2 - title_size.x / 2);
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+        ImGui::PushFont(window.get_large_font());
+        ImGui::PushStyleColor(ImGuiCol_Text, white);
+        ImGui::Text("%s", title_message.c_str());
+        ImGui::PopStyleColor();
+        ImGui::PopFont();
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+
+        ImGui::SetCursorPosX(w / 2 - 260 / 2);
+        if (ImGui::Button(u8"\uF07C Load...", ImVec2(70, 30)))
+        {
+            try
+            {
+                if (auto fn = file_dialog_open(file_dialog_mode::open_file, "Calibration JSON\0*.json\0", nullptr, nullptr))
+                {
+                    config_file cf(fn);
+                    table->baseline = cf.get("baseline");
+
+                    auto load_float3x4 = [&](std::string name, librealsense::float3x3& m){
+                        m.x.x = cf.get(std::string(to_string() << name << ".x.x").c_str());
+                        m.x.y = cf.get(std::string(to_string() << name << ".x.y").c_str());
+                        m.x.z = cf.get(std::string(to_string() << name << ".x.z").c_str());
+
+                        m.y.x = cf.get(std::string(to_string() << name << ".y.x").c_str());
+                        m.y.y = cf.get(std::string(to_string() << name << ".y.y").c_str());
+                        m.y.z = cf.get(std::string(to_string() << name << ".y.z").c_str());
+
+                        m.z.x = cf.get(std::string(to_string() << name << ".z.x").c_str());
+                        m.z.y = cf.get(std::string(to_string() << name << ".z.y").c_str());
+                        m.z.z = cf.get(std::string(to_string() << name << ".z.z").c_str());
+                    };
+
+                    load_float3x4("intrinsic_left", table->intrinsic_left);
+                    load_float3x4("intrinsic_right", table->intrinsic_right);
+                    load_float3x4("world2left_rot", table->world2left_rot);
+                    load_float3x4("world2right_rot", table->world2right_rot);
+
+                    for (int i = 0; i < librealsense::ds::max_ds5_rect_resolutions; i++)
+                    {
+                        table->rect_params[i].x = cf.get(std::string(to_string() << "rectified." << i << ".fx").c_str());
+                        table->rect_params[i].y = cf.get(std::string(to_string() << "rectified." << i << ".fy").c_str());
+
+                        table->rect_params[i].z = cf.get(std::string(to_string() << "rectified." << i << ".ppx").c_str());
+                        table->rect_params[i].w = cf.get(std::string(to_string() << "rectified." << i << ".ppy").c_str());
+                    }
+                }
+
+                changed = true;
+            }
+            catch (const std::exception& ex)
+            {
+                error_message = ex.what();
+                ImGui::CloseCurrentPopup();
+            }
+        }
+        if (ImGui::IsItemHovered())
+        {
+            window.link_hovered();
+            ImGui::SetTooltip("%s", "Load calibration from file");
+        }
+        ImGui::SameLine();
+        if (ImGui::Button(u8"\uF0C7 Save As...", ImVec2(100, 30)))
+        {
+            try 
+            {
+                if (auto fn = file_dialog_open(file_dialog_mode::save_file, "Calibration JSON\0*.json\0", nullptr, nullptr))
+                {
+                    config_file cf(fn);
+                    cf.set("baseline", table->baseline);
+
+                    auto save_float3x4 = [&](std::string name, librealsense::float3x3& m){
+                        cf.set(std::string(to_string() << name << ".x.x").c_str(), m.x.x);
+                        cf.set(std::string(to_string() << name << ".x.y").c_str(), m.x.y);
+                        cf.set(std::string(to_string() << name << ".x.z").c_str(), m.x.z);
+
+                        cf.set(std::string(to_string() << name << ".y.x").c_str(), m.y.x);
+                        cf.set(std::string(to_string() << name << ".y.y").c_str(), m.y.y);
+                        cf.set(std::string(to_string() << name << ".y.z").c_str(), m.y.z);
+
+                        cf.set(std::string(to_string() << name << ".z.x").c_str(), m.z.x);
+                        cf.set(std::string(to_string() << name << ".z.y").c_str(), m.z.y);
+                        cf.set(std::string(to_string() << name << ".z.z").c_str(), m.z.z);
+                    };
+
+                    save_float3x4("intrinsic_left", table->intrinsic_left);
+                    save_float3x4("intrinsic_right", table->intrinsic_right);
+                    save_float3x4("world2left_rot", table->world2left_rot);
+                    save_float3x4("world2right_rot", table->world2right_rot);
+                    
+                    for (int i = 0; i < librealsense::ds::max_ds5_rect_resolutions; i++)
+                    {
+                        auto xy = librealsense::ds::resolutions_list[(librealsense::ds::ds5_rect_resolutions)i];
+                        int w = xy.x; int h = xy.y;
+
+                        cf.set(std::string(to_string() << "rectified." << i << ".width").c_str(), w);
+                        cf.set(std::string(to_string() << "rectified." << i << ".height").c_str(), h);
+
+                        cf.set(std::string(to_string() << "rectified." << i << ".fx").c_str(), table->rect_params[i].x);
+                        cf.set(std::string(to_string() << "rectified." << i << ".fy").c_str(), table->rect_params[i].y);
+
+                        cf.set(std::string(to_string() << "rectified." << i << ".ppx").c_str(), table->rect_params[i].z);
+                        cf.set(std::string(to_string() << "rectified." << i << ".ppy").c_str(), table->rect_params[i].w);
+                    }
+                }
+            }
+            catch (const std::exception& ex)
+            {
+                error_message = ex.what();
+                ImGui::CloseCurrentPopup();
+            }
+        }
+        if (ImGui::IsItemHovered())
+        {
+            window.link_hovered();
+            ImGui::SetTooltip("%s", "Save calibration image to file");
+        }
+        ImGui::SameLine();
+        if (_accept)
+        {
+            if (ImGui::Button(u8"\uF275 Restore Factory", ImVec2(115, 30)))
+            {
+                try
+                {
+                    dev.as<rs2::auto_calibrated_device>().reset_to_factory_calibration();
+                    _calibration = dev.as<rs2::auto_calibrated_device>().get_calibration_table();
+                    _original = _calibration;
+                    changed = true;
+                }
+                catch(const std::exception& ex)
+                {
+                    error_message = ex.what();
+                    ImGui::CloseCurrentPopup();
+                }
+            }
+            if (ImGui::IsItemHovered())
+            {
+                window.link_hovered();
+                ImGui::SetTooltip("%s", "Restore calibration in flash to factory settings");
+            }
+        }
+        else
+        {
+            ImGui::PushStyleColor(ImGuiCol_Text, grey);
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, grey);
+
+            ImGui::Button(u8"\uF275 Restore Factory", ImVec2(115, 30));
+            if (ImGui::IsItemHovered())
+            {
+                ImGui::SetTooltip("%s", "Write selected calibration table to the device. For advanced users");
+            }
+
+            ImGui::PopStyleColor(2);
+        }
+
+        ImGui::PushStyleColor(ImGuiCol_ChildWindowBg, dark_sensor_bg);
+
+        ImGui::BeginChild("##CalibData",ImVec2(w - 15, h - 110), true);
+
+        ImGui::SetCursorPosX(10);
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+        
+        ImGui::Text("Stereo Baseline(mm):"); ImGui::SameLine();
+        ImGui::SetCursorPosX(200);
+
+        ImGui::PushItemWidth(120);
+        draw_float("Baseline", table->baseline, orig_table->baseline, changed);
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+        ImGui::PopItemWidth();
+
+        draw_float4x4("Left Intrinsics", table->intrinsic_left, orig_table->intrinsic_left, changed);
+        draw_float4x4("Right Intrinsics", table->intrinsic_right, orig_table->intrinsic_right, changed);
+        draw_float4x4("World to Left Rotation", table->world2left_rot, orig_table->world2left_rot, changed);
+        draw_float4x4("World to Right Rotation", table->world2right_rot, orig_table->world2right_rot, changed);
+
+        ImGui::SetCursorPosX(10);
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+        
+        ImGui::Text("Rectified Resolution:"); ImGui::SameLine();
+        ImGui::SetCursorPosX(200);
+
+        std::vector<std::string> resolution_names;
+        std::vector<const char*> resolution_names_char;
+        std::vector<int> resolution_offset;
+        for (int i = 0; i < librealsense::ds::max_ds5_rect_resolutions; i++)
+        {
+            auto xy = librealsense::ds::resolutions_list[(librealsense::ds::ds5_rect_resolutions)i];
+            int w = xy.x; int h = xy.y;
+            if (w != 0) {
+                resolution_offset.push_back(i);
+                std::string name = to_string() << w <<" x "<<h;
+                resolution_names.push_back(name);
+            }
+        }
+        for (int i = 0; i < resolution_offset.size(); i++)
+        {
+            resolution_names_char.push_back(resolution_names[i].c_str());
+        }
+
+        ImGui::PushItemWidth(120);
+        ImGui::Combo("##RectifiedResolutions", &selected_resolution, resolution_names_char.data(), resolution_names_char.size());
+
+        ImGui::SetCursorPosX(10);
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+        
+        ImGui::Text("Focal Length:"); ImGui::SameLine();
+        ImGui::SetCursorPosX(200);
+
+        draw_float("FocalX", table->rect_params[selected_resolution].x, orig_table->rect_params[selected_resolution].x, changed);
+        ImGui::SameLine();
+        draw_float("FocalY", table->rect_params[selected_resolution].y, orig_table->rect_params[selected_resolution].y, changed);
+
+        ImGui::SetCursorPosX(10);
+        ImGui::Text("Principal Point:"); ImGui::SameLine();
+        ImGui::SetCursorPosX(200);
+
+        draw_float("PPX", table->rect_params[selected_resolution].z, orig_table->rect_params[selected_resolution].z, changed);
+        ImGui::SameLine();
+        draw_float("PPY", table->rect_params[selected_resolution].w, orig_table->rect_params[selected_resolution].w, changed);
+
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+
+        ImGui::PopItemWidth();
+
+        if (ImGui::IsWindowHovered()) window.set_hovered_over_input();
+
+        ImGui::EndChild();
+        ImGui::PopStyleColor();
+
+        ImGui::SetCursorScreenPos({ (float)(x0 + 10), (float)(y0 + h - 30) });
+        if (ImGui::Checkbox("I know what I'm doing", &_accept))
+        {
+            config_file::instance().set(configurations::calibration::enable_writing, _accept);
+        }
+        if (ImGui::IsItemHovered())
+        {
+            ImGui::SetTooltip("%s", "Changing calibration will affect depth quality. Changes are persistent.\nThere is an option to get back to factory calibration, but it maybe worse than current calibration\nBefore writing to flash, we strongly recommend to make a file backup");
+        }
+
+        ImGui::SetCursorScreenPos({ (float)(x0 + w - 230), (float)(y0 + h - 30) });
+
+        if (ImGui::Button("Cancel", ImVec2(100, 25)))
+        {
+            ImGui::CloseCurrentPopup();
+        }
+        if (ImGui::IsItemHovered())
+        {
+            window.link_hovered();
+            ImGui::SetTooltip("%s", "Close without saving any changes");
+        }
+        ImGui::SameLine();
+
+        auto streams = dev.query_sensors()[0].get_active_streams();
+        if (_accept && streams.size())
+        {
+            if (ImGui::Button(u8"\uF2DB  Write Table", ImVec2(120, 25)))
+            {
+                try
+                {
+                    auto actual_data = _calibration.data() + sizeof(librealsense::ds::table_header);
+                    auto actual_data_size = _calibration.size() - sizeof(librealsense::ds::table_header);
+                    auto crc = helpers::calc_crc32(actual_data, actual_data_size);
+                    table->header.crc32 = crc;
+                    dev.as<rs2::auto_calibrated_device>().set_calibration_table(_calibration);
+                    dev.as<rs2::auto_calibrated_device>().write_calibration();
+                    _original = _calibration;
+                    ImGui::CloseCurrentPopup();
+                }
+                catch (const std::exception& ex)
+                {
+                    error_message = ex.what();
+                    ImGui::CloseCurrentPopup();
+                }
+            }
+            if (ImGui::IsItemHovered())
+            {
+                window.link_hovered();
+                ImGui::SetTooltip("%s", "Write selected calibration table to the device");
+            }
+        }
+        else
+        {
+            ImGui::PushStyleColor(ImGuiCol_Text, grey);
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, grey);
+
+            ImGui::Button(u8"\uF2DB  Write Table", ImVec2(120, 25));
+            if (ImGui::IsItemHovered())
+            {
+                ImGui::SetTooltip("%s", "Write selected calibration table to the device. For advanced users");
+            }
+
+            ImGui::PopStyleColor(2);
+        }
+
+        if (changed && streams.size())
+        {
+            try
+            {
+                dev.as<rs2::auto_calibrated_device>().set_calibration_table(_calibration);
+            }
+            catch (const std::exception& ex)
+            {
+                try
+                {
+                    dev.query_sensors()[0].close();
+                    dev.query_sensors()[0].open(streams);
+                    dev.as<rs2::auto_calibrated_device>().set_calibration_table(_calibration);
+                }
+                catch (const std::exception& ex)
+                {
+                    error_message = ex.what();
+                    ImGui::CloseCurrentPopup();
+                }
+            }
+        }
+
+        if (ImGui::IsWindowHovered()) window.set_hovered_over_input();
+
+        ImGui::EndPopup();
+    }
+    ImGui::PopStyleColor(3);
+    ImGui::PopStyleVar(2);
+}
diff --git a/common/calibration-model.h b/common/calibration-model.h
new file mode 100644
index 0000000..d322f31
--- /dev/null
+++ b/common/calibration-model.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include <librealsense2/rs.hpp>
+#include "ux-window.h"
+
+namespace librealsense
+{
+    struct float3x3;
+}
+
+namespace rs2
+{
+    class calibration_model
+    {
+    public:
+        calibration_model(rs2::device dev);
+
+        bool supports();
+
+        void update(ux_window& window, std::string& error_message);
+
+        void open() { to_open = true; }
+
+    private:
+        void draw_float4x4(std::string name, librealsense::float3x3& feild, const librealsense::float3x3& original, bool& changed);
+        void draw_float(std::string name, float& x, const float& orig, bool& changed);
+
+        rs2::device dev;
+        bool to_open = false;
+        bool _accept = false;
+
+        std::vector<uint8_t> _calibration;
+        std::vector<uint8_t> _original;
+
+        int selected_resolution = 0;
+    };
+}
\ No newline at end of file
diff --git a/common/fw-update-helper.cpp b/common/fw-update-helper.cpp
index a5b08ac..15ce626 100644
--- a/common/fw-update-helper.cpp
+++ b/common/fw-update-helper.cpp
@@ -56,8 +56,6 @@ namespace rs2
 
     std::string get_available_firmware_version(int product_line)
     {
-        bool allow_rc_firmware = config_file::instance().get_or_default(configurations::update::allow_rc_firmware, false);
-
         if (product_line == RS2_PRODUCT_LINE_D400) return FW_D4XX_FW_IMAGE_VERSION;
         //else if (product_line == RS2_PRODUCT_LINE_SR300) return FW_SR3XX_FW_IMAGE_VERSION;
         else if (product_line == RS2_PRODUCT_LINE_L500) return FW_L5XX_FW_IMAGE_VERSION;
@@ -196,7 +194,7 @@ namespace rs2
 
             auto flash = upd.create_flash_backup([&](const float progress)
             {
-                _progress = ((ceil(progress * 5) / 5) * (30 - next_progress)) + next_progress;
+                _progress = int((ceil(progress * 5) / 5) * (30 - next_progress)) + next_progress;
             });
 
             auto temp = get_folder_path(special_folder::app_data);
@@ -221,7 +219,7 @@ namespace rs2
                 if (!check_for([this, serial, &dfu]() {
                     auto devs = _ctx.query_devices();
 
-                    for (int j = 0; j < devs.size(); j++)
+                    for (uint32_t j = 0; j < devs.size(); j++)
                     {
                         try
                         {
@@ -267,7 +265,7 @@ namespace rs2
 
             dfu.update(_fw, [&](const float progress)
             {
-                _progress = (ceil(progress * 10) / 10 * (90 - next_progress)) + next_progress;
+                _progress = int((ceil(progress * 10) / 10 * (90 - next_progress)) + next_progress);
             });
 
             log("Firmware Download completed, await DFU transition event");
@@ -279,15 +277,15 @@ namespace rs2
             auto upd = _dev.as<updatable>();
             upd.update_unsigned(_fw, [&](const float progress)
             {
-                _progress = (ceil(progress * 10) / 10 * (90 - next_progress)) + next_progress;
+                _progress = int((ceil(progress * 10) / 10 * (90 - next_progress)) + next_progress);
             });
             log("Firmware Update completed, waiting for device to reconnect");
         }
 
-        if (!check_for([this, serial, &dfu]() {
+        if (!check_for([this, serial]() {
             auto devs = _ctx.query_devices();
 
-            for (int j = 0; j < devs.size(); j++)
+            for (uint32_t j = 0; j < devs.size(); j++)
             {
                 try
                 {
@@ -341,7 +339,7 @@ namespace rs2
 
             ImGui::SetCursorScreenPos({ float(x + 9), float(y + height - 67) });
 
-            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1. - t));
+            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1.f - t));
 
             if (update_state == RS2_FWU_STATE_INITIAL_PROMPT)
                 ImGui::Text("Firmware updates offer critical bug fixes and\nunlock new camera capabilities.");
diff --git a/common/fw/CMakeLists.txt b/common/fw/CMakeLists.txt
index d0c7ed1..aff05eb 100644
--- a/common/fw/CMakeLists.txt
+++ b/common/fw/CMakeLists.txt
@@ -14,7 +14,7 @@ set(REALSENSE_FIRMWARE_URL "http://realsense-hw-public.s3.amazonaws.com" CACHE S
 string(REGEX MATCH "D4XX_RECOMMENDED_FIRMWARE_VERSION \"([0-9]+.[0-9]+.[0-9]+.[0-9]+)\"" _ ${ver})
 set(D4XX_FW_VERSION ${CMAKE_MATCH_1})
 message(STATUS "D4XX_FW_VERSION: ${D4XX_FW_VERSION}")
-set(D4XX_FW_SHA1 f3a488ea7f07a630a335f024fa9fec662a84c8ed)
+set(D4XX_FW_SHA1 b8161801bffb8880952b23c12c52581a4c62adb6)
 set(D4XX_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/RS4xx/FW")
 
 
@@ -33,7 +33,7 @@ set(T26X_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/TM2/FW/target/${T26X_FW_VERS
 string(REGEX MATCH "L5XX_RECOMMENDED_FIRMWARE_VERSION \"([0-9]+.[0-9]+.[0-9]+.[0-9]+)\"" _ ${ver})
 set(L5XX_FW_VERSION ${CMAKE_MATCH_1})
 message(STATUS "L5XX_FW_VERSION: ${L5XX_FW_VERSION}")
-set(L5XX_FW_SHA1 5bb7d4e68994328f324559db66a0c586c3037afa)
+set(L5XX_FW_SHA1 7e92856a80e7b63a9976718a56b6fb7e51af714f)
 set(L5XX_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/L5xx/FW")
 
 add_library(${PROJECT_NAME} STATIC empty.c)
diff --git a/common/fw/firmware-version.h b/common/fw/firmware-version.h
index 086ce57..c0ca060 100644
--- a/common/fw/firmware-version.h
+++ b/common/fw/firmware-version.h
@@ -3,7 +3,7 @@
 
 #pragma once
 
-#define D4XX_RECOMMENDED_FIRMWARE_VERSION "5.12.5.0"
+#define D4XX_RECOMMENDED_FIRMWARE_VERSION "5.12.6.0"
 #define SR3XX_RECOMMENDED_FIRMWARE_VERSION "3.26.1.0"
 #define T26X_FIRMWARE_VERSION "0.2.0.951"
-#define L5XX_RECOMMENDED_FIRMWARE_VERSION "1.4.1.0"
+#define L5XX_RECOMMENDED_FIRMWARE_VERSION "1.4.1.2"
diff --git a/common/measurement.cpp b/common/measurement.cpp
index 600f5d4..4086690 100644
--- a/common/measurement.cpp
+++ b/common/measurement.cpp
@@ -13,6 +13,7 @@ void measurement::enable() {
 }
 void measurement::disable() { 
     state.points.clear(); 
+    state.edges.clear();
     measurement_active = false;
     config_file::instance().set(configurations::viewer::is_measuring, false);
 }
@@ -84,8 +85,8 @@ void measurement::add_point(interest_point p)
             state.polygons.clear();
         }
 
-        int last = state.points.size();
-        if (current_hovered_point == -1 || 
+        int last = int(state.points.size());
+        if (current_hovered_point == -1 ||
             current_hovered_point >= state.points.size())
         {
             state.points.push_back(p);
@@ -121,7 +122,7 @@ void measurement::add_point(interest_point p)
             log_function(to_string() << "Measured distance of " << length_to_string(dist.length()));
         }
 
-        last_hovered_point = state.points.size() - 1;
+        last_hovered_point = int(state.points.size() - 1);
 
         commit_state();
     }
@@ -185,18 +186,18 @@ void draw_sphere(const float3& pos, float r, int lats, int longs)
 {
     for(int i = 0; i <= lats; i++) 
     {
-        float lat0 = M_PI * (-0.5 + (float) (i - 1) / lats);
+        float lat0 = float(M_PI) * (-0.5f + (float) (i - 1) / lats);
         float z0  = sin(lat0);
         float zr0 =  cos(lat0);
 
-        float lat1 = M_PI * (-0.5 + (float) i / lats);
+        float lat1 = float(M_PI) * (-0.5f + (float) i / lats);
         float z1 = sin(lat1);
         float zr1 = cos(lat1);
 
         glBegin(GL_QUAD_STRIP);
         for(int j = 0; j <= longs; j++) 
         {
-            float lng = 2 * M_PI * (float) (j - 1) / longs;
+            float lng = 2.f * float(M_PI) * (float) (j - 1) / longs;
             float x = cos(lng);
             float y = sin(lng);
 
@@ -304,7 +305,7 @@ void measurement::draw_ruler(ux_window& win, float3 from, float3 to, float heigh
         // calculate center of the ruler line
         float3 ctr = from + (to - from) / 2;
         float distance = (to - from).length();
-        draw_label(win, ctr, distance, height);
+        draw_label(win, ctr, distance, int(height));
     }
 }
 
@@ -351,7 +352,7 @@ void measurement::update_input(ux_window& win, const rs2::rect& viewer_rect)
             if (rect_copy.contains(win.get_mouse().cursor))
             {
                 input_ctrl.click = true;
-                input_ctrl.click_time = glfwGetTime();
+                input_ctrl.click_time = float(glfwGetTime());
             }
         }
     }
@@ -453,7 +454,6 @@ void measurement::draw(ux_window& win)
         if (input_ctrl.mouse_down) size -= _picked.z * 0.01f;
         size += _picked.z * 0.01f * single_wave(input_ctrl.click_period());
 
-        auto end = _picked + _normal * size;
         auto axis1 = cross(vec3d{ _normal.x, _normal.y, _normal.z }, vec3d{ 0.f, 1.f, 0.f });
         auto faxis1 = float3 { axis1.x, axis1.y, axis1.z };
         faxis1.normalize();
@@ -477,8 +477,8 @@ void measurement::draw(ux_window& win)
         const int segments = 50;
         for (int i = 0; i < segments; i++)
         {
-            auto t1 = 2 * M_PI * ((float)i / segments);
-            auto t2 = 2 * M_PI * ((float)(i+1) / segments);
+            auto t1 = 2.f * float(M_PI) * ((float)i / segments);
+            auto t2 = 2.f * float(M_PI) * ((float)(i+1) / segments);
             float4 xy1 { cosf(t1) * size, sinf(t1) * size, 0.f, 1.f };
             xy1 = basis * xy1;
             xy1 = float4 { _picked.x + xy1.x, _picked.y + xy1.y, _picked.z  + xy1.z, 1.f };
@@ -555,7 +555,7 @@ void measurement::draw(ux_window& win)
 
         auto area = calculate_area(points);
 
-        draw_label(win, mid, area, win.framebuf_height(), true);
+        draw_label(win, mid, area, int(win.framebuf_height()), true);
     }
 
     for (int i = 0; i < state.edges.size(); i++)
diff --git a/common/measurement.h b/common/measurement.h
index 2a5e208..ff1b391 100644
--- a/common/measurement.h
+++ b/common/measurement.h
@@ -96,8 +96,8 @@ namespace rs2
             double selection_started = 0.0;
             float2 down_pos { 0.f, 0.f };
             int mouse_wheel = 0;
-            double click_time = 0.0;
-            float click_period() { return clamp((glfwGetTime() - click_time) * 10, 0.f, 1.f); }
+            float click_time = 0.f;
+            float click_period() { return clamp(float(glfwGetTime() - click_time) * 10, 0.f, 1.f); }
         };
         mouse_control input_ctrl;
         int id = 0;
diff --git a/common/metadata-helper.cpp b/common/metadata-helper.cpp
index 1f160ab..7182b27 100644
--- a/common/metadata-helper.cpp
+++ b/common/metadata-helper.cpp
@@ -118,7 +118,7 @@ namespace rs2
                         &cbSecurityDescriptor,   // security descriptor 
                         &ftLastWriteTime);       // last write time 
 
-                    for (int i = 0; i < cSubKeys; i++)
+                    for (auto i = 0ul; i < cSubKeys; i++)
                     {
                         TCHAR achKey[MAX_KEY_LENGTH];
                         DWORD cbName = MAX_KEY_LENGTH;
@@ -133,7 +133,8 @@ namespace rs2
                         {
                             std::wstring suffix = achKey;
                             device_id rdid;
-                            if (parse_device_id(std::string(suffix.begin(), suffix.end()), &rdid))
+                            auto a = std::string(suffix.begin(), suffix.end());
+                            if (parse_device_id(a, &rdid))
                             {
                                 for (auto&& did : kvp.second)
                                 {
@@ -223,6 +224,7 @@ namespace rs2
                         CloseHandle(sei.hProcess);
                         if (exitCode)
                             throw std::runtime_error("Failed to set metadata registry keys!");
+                        return true;
                     }
                 }
                 else
@@ -287,7 +289,7 @@ namespace rs2
 
                 rs2::context ctx;
                 auto list = ctx.query_devices();
-                for (int i = 0; i < list.size(); i++)
+                for (uint32_t i = 0; i < list.size(); i++)
                 {
                     try
                     {
diff --git a/common/model-views.cpp b/common/model-views.cpp
index 9e922a2..fcdc96f 100644
--- a/common/model-views.cpp
+++ b/common/model-views.cpp
@@ -31,22 +31,22 @@
 
 #include "imgui-fonts-karla.hpp"
 #include "imgui-fonts-fontawesome.hpp"
+#include "imgui-fonts-monofont.hpp"
 
 #include "os.h"
 
 #include "metadata-helper.h"
-
+#include "calibration-model.h"
 
 using namespace rs400;
 using namespace nlohmann;
 using namespace rs2::sw_update;
 
-constexpr const char* server_versions_db_url = "http://realsense-hw-public.s3-eu-west-1.amazonaws.com/Releases/rs_versions_db.json";
-
-
 static rs2_sensor_mode resolution_from_width_height(int width, int height)
 {
-    if ((width == 640 && height == 480) || (height == 640 && width == 480))
+    if ((width == 240 && height == 320) || (width == 320 && height == 240))
+        return RS2_SENSOR_MODE_QVGA;
+    else if ((width == 640 && height == 480) || (height == 640 && width == 480))
         return RS2_SENSOR_MODE_VGA;
     else if ((width == 1024 && height == 768) || (height == 768 && width == 1024))
         return RS2_SENSOR_MODE_XGA;
@@ -140,7 +140,7 @@ namespace rs2
         file.write((char*)bytes.data(), bytes.size());
     }
 
-    void imgui_easy_theming(ImFont*& font_14, ImFont*& font_18)
+    void imgui_easy_theming(ImFont*& font_14, ImFont*& font_18, ImFont*& monofont)
     {
         ImGuiStyle& style = ImGui::GetStyle();
 
@@ -181,6 +181,21 @@ namespace rs2
 
         }
 
+        // Load monofont
+        {
+            ImFontConfig config_words;
+            config_words.OversampleV = OVERSAMPLE;
+            config_words.OversampleH = OVERSAMPLE;
+            monofont = io.Fonts->AddFontFromMemoryCompressedTTF(monospace_compressed_data, monospace_compressed_size, 15.f);
+
+            ImFontConfig config_glyphs;
+            config_glyphs.MergeMode = true;
+            config_glyphs.OversampleV = OVERSAMPLE;
+            config_glyphs.OversampleH = OVERSAMPLE;
+            monofont = io.Fonts->AddFontFromMemoryCompressedTTF(font_awesome_compressed_data,
+                font_awesome_compressed_size, 14.f, &config_glyphs, icons_ranges);
+        }
+
         style.WindowRounding = 0.0f;
         style.ScrollbarRounding = 0.0f;
 
@@ -1132,7 +1147,7 @@ namespace rs2
                 {
                     s->set_option( RS2_OPTION_SENSOR_MODE, resolution_from_width_height( res_values[ui.selected_res_id].first, res_values[ui.selected_res_id].second ) );
                 }
-                catch( not_implemented_error const & e )
+                catch( not_implemented_error const &)
                 {
                     // Just ignore for now: need to figure out a way to write to playback sensors...
                 }
@@ -1240,8 +1255,8 @@ namespace rs2
                         auto width = res_values[ui.selected_res_id].first;
                         auto height = res_values[ui.selected_res_id].second;
                         auto res = resolution_from_width_height(width, height);
-                        if (res >= RS2_SENSOR_MODE_XGA && res < RS2_SENSOR_MODE_COUNT)
-                            s->set_option(RS2_OPTION_SENSOR_MODE, res);
+                        if (res >= RS2_SENSOR_MODE_VGA && res < RS2_SENSOR_MODE_COUNT)
+                            s->set_option(RS2_OPTION_SENSOR_MODE, float(res));
                     }
                 }
                 ImGui::PopStyleColor();
@@ -1634,7 +1649,6 @@ namespace rs2
             {
                 if (auto vid_prof = p.as<video_stream_profile>())
                 {
-                    auto key = std::make_tuple(p.fps(), vid_prof.width(), vid_prof.height());
                     if (check_profile(p, [&](stream_profile prof) { return (std::find_if(matching_profiles.begin(), matching_profiles.end(), [&](stream_profile sp)
                     { return (stream_id != p.unique_id() && sp.fps() == p.fps() && sp.as<video_stream_profile>().width() == vid_prof.width() &&
                         sp.as<video_stream_profile>().height() == vid_prof.height()); }) != matching_profiles.end()); },
@@ -1747,7 +1761,7 @@ namespace rs2
     {
         viewer.not_model->add_log("Stopping streaming");
 
-        for_each(stream_display_names.begin(), stream_display_names.end(), [this, &viewer](std::pair<int, std::string> kvp)
+        for_each(stream_display_names.begin(), stream_display_names.end(), [this](std::pair<int, std::string> kvp)
         {
             if ("Pose" == kvp.second)
             {
@@ -1838,7 +1852,7 @@ namespace rs2
         viewer.not_model->add_log(ss.str());
 
         // TODO  - refactor tm2 from viewer to subdevice
-        for_each(stream_display_names.begin(), stream_display_names.end(), [this, &viewer](std::pair<int, std::string> kvp)
+        for_each(stream_display_names.begin(), stream_display_names.end(), [this](std::pair<int, std::string> kvp)
         {
             if ("Pose" == kvp.second)
             {
@@ -1900,7 +1914,7 @@ namespace rs2
                 auto& opt_md = options_metadata[static_cast<rs2_option>(next)];
                 opt_md.update_all_fields(error_message, notifications);
 
-                if (next_option == RS2_OPTION_ENABLE_AUTO_EXPOSURE)
+                if (next == RS2_OPTION_ENABLE_AUTO_EXPOSURE)
                 {
                     auto old_ae_enabled = auto_exposure_enabled;
                     auto_exposure_enabled = opt_md.value > 0;
@@ -3359,6 +3373,7 @@ namespace rs2
 
     device_model::device_model(device& dev, std::string& error_message, viewer_model& viewer)
         : dev(dev),
+        _calib_model(dev),
         syncer(viewer.syncer),
         _update_readonly_options_timer(std::chrono::seconds(6))
         , _detected_objects(std::make_shared< atomic_objects_in_frame >()),
@@ -3995,7 +4010,6 @@ namespace rs2
         duration -= mm;
         auto ss = duration_cast<seconds>(duration);
         duration -= ss;
-        auto ms = duration_cast<milliseconds>(duration);
 
         std::ostringstream stream;
         stream << std::setfill('0') << std::setw(hhh.count() >= 10 ? 2 : 1) << hhh.count() << ':' <<
@@ -4010,7 +4024,7 @@ namespace rs2
         auto pos = ImGui::GetCursorPos();
 
         auto p = dev.as<playback>();
-        rs2_playback_status current_playback_status = p.current_status();
+        //rs2_playback_status current_playback_status = p.current_status();
         int64_t playback_total_duration = p.get_duration().count();
         auto progress = p.get_position();
         double part = (1.0 * progress) / playback_total_duration;
@@ -4112,49 +4126,138 @@ namespace rs2
         return device_names;
     }
 
-    bool yes_no_dialog(const std::string& title, const std::string& message_text, bool& approved, ux_window& window)
+    bool yes_no_dialog(const std::string& title, const std::string& message_text, bool& approved, ux_window& window, const std::string& error_message, bool disabled = false)
     {
         ImGui_ScopePushFont(window.get_font());
         ImGui_ScopePushStyleColor(ImGuiCol_Button, button_color);
         ImGui_ScopePushStyleColor(ImGuiCol_ButtonHovered, sensor_header_light_blue); //TODO: Change color?
         ImGui_ScopePushStyleColor(ImGuiCol_ButtonActive, regular_blue); //TODO: Change color?
-        ImGui_ScopePushStyleColor(ImGuiCol_Text, light_grey);
         ImGui_ScopePushStyleColor(ImGuiCol_TextSelectedBg, light_grey);
         ImGui_ScopePushStyleColor(ImGuiCol_TitleBg, header_color);
         ImGui_ScopePushStyleColor(ImGuiCol_PopupBg, sensor_bg);
-        ImGui_ScopePushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(5, 5));
+        ImGui_ScopePushStyleColor(ImGuiCol_BorderShadow, dark_grey);
+        ImGui_ScopePushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(20, 10));
         auto clicked = false;
+
         ImGui::OpenPopup(title.c_str());
-        if (ImGui::BeginPopupModal(title.c_str(), NULL, ImGuiWindowFlags_AlwaysAutoResize))
+        ImGui::SetNextWindowPos( {window.width() * 0.35f, window.height() * 0.35f });
+        if (ImGui::BeginPopup(title.c_str()))
         {
-            ImGui::Text("\n%s\n\n", message_text.c_str());
-            auto width = ImGui::GetWindowWidth();
-            ImGui::Dummy(ImVec2(0, 0));
-            ImGui::Dummy(ImVec2(width / 4.f, 0));
-            ImGui::SameLine();
-            if (ImGui::Button("Yes", ImVec2(60, 30)))
             {
-                ImGui::CloseCurrentPopup();
-                approved = true;
-                clicked = true;
+                ImGui_ScopePushStyleColor(ImGuiCol_Text, almost_white_bg);
+
+                ImGui::SetWindowFontScale(1.3f);
+                ImGui::Text("%s", title.c_str());
             }
-            ImGui::SameLine();
-            if (ImGui::Button("No", ImVec2(60, 30)))
             {
-                ImGui::CloseCurrentPopup();
-                approved = false;
-                clicked = true;
+                ImGui_ScopePushStyleColor(ImGuiCol_Text, light_grey);
+                ImGui::Separator();
+                ImGui::SetWindowFontScale(1.1f);
+                ImGui::Text("\n%s\n\n", message_text.c_str());
+
+                if (!disabled)
+                {
+                    ImGui::SameLine();
+                    auto width = ImGui::GetWindowWidth();
+                    ImGui::Dummy(ImVec2(0, 0));
+                    ImGui::Dummy(ImVec2(width / 3.f, 0));
+                    ImGui::SameLine();
+                    if (ImGui::Button("Yes", ImVec2(60, 30)))
+                    {
+                        ImGui::CloseCurrentPopup();
+                        approved = true;
+                        clicked = true;
+                    }
+                    ImGui::SameLine();
+                    if (ImGui::Button("No", ImVec2(60, 30)))
+                    {
+                        ImGui::CloseCurrentPopup();
+                        approved = false;
+                        clicked = true;
+                    }
+                }
+                else
+                {
+                    ImGui::NewLine();
+                    auto window_width = ImGui::GetWindowWidth();
+                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + window_width / 2.f - 30.f - ImGui::GetStyle().WindowPadding.x);
+                    if (ImGui::Button("Close", ImVec2(60, 30)))
+                    {
+                        ImGui::CloseCurrentPopup();
+                        approved = false;
+                        clicked = true;
+                    }
+                }
             }
-            ImGui::NewLine();
             ImGui::EndPopup();
         }
         return clicked;
     }
-    bool device_model::prompt_toggle_advanced_mode(bool enable_advanced_mode, const std::string& message_text, std::vector<std::string>& restarting_device_info, viewer_model& view, ux_window& window)
+
+    // Create a process windows with process details from the caller,
+    // and close button activated by the caller
+    bool status_dialog(const std::string& title, const std::string& process_topic_text, const std::string& process_status_text , bool enable_close, ux_window& window)
+    {
+        ImGui_ScopePushFont(window.get_font());
+        ImGui_ScopePushStyleColor(ImGuiCol_Button, button_color);
+        ImGui_ScopePushStyleColor(ImGuiCol_ButtonHovered, sensor_header_light_blue); //TODO: Change color?
+        ImGui_ScopePushStyleColor(ImGuiCol_ButtonActive, regular_blue); //TODO: Change color?
+        ImGui_ScopePushStyleColor(ImGuiCol_Text, light_grey);
+        ImGui_ScopePushStyleColor(ImGuiCol_TextSelectedBg, light_grey);
+        ImGui_ScopePushStyleColor(ImGuiCol_TitleBg, header_color);
+        ImGui_ScopePushStyleColor(ImGuiCol_PopupBg, sensor_bg);
+        ImGui_ScopePushStyleColor(ImGuiCol_BorderShadow, dark_grey);
+        ImGui_ScopePushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(20, 10));
+        auto close_clicked = false;
+
+        ImGui::OpenPopup(title.c_str());
+        ImGui::SetNextWindowPos({ window.width() * 0.35f, window.height() * 0.35f });
+        if (ImGui::BeginPopup(title.c_str()))
+        {
+            {
+                ImGui_ScopePushStyleColor(ImGuiCol_Text, almost_white_bg);
+
+                ImGui::SetWindowFontScale(1.3f);
+                ImGui::Text("%s", title.c_str());
+            }
+            {
+
+                ImGui::Separator();
+                ImGui::SetWindowFontScale(1.1f);
+
+                ImGui::NewLine();
+                ImGui::Text("%s", process_topic_text.c_str());
+                ImGui::NewLine();
+
+                auto window_width = ImGui::GetWindowWidth();
+                auto process_status_text_size = ImGui::CalcTextSize(process_status_text.c_str()).x + ImGui::CalcTextSize("Status: ").x + ImGui::GetStyle().WindowPadding.x;
+                auto future_window_width = std::max(process_status_text_size, window_width);
+                ImGui::SetCursorPosX(ImGui::GetCursorPosX() + future_window_width / 2.f - process_status_text_size / 2.f);
+
+                ImGui::Text("Status: %s", process_status_text.c_str());
+                ImGui::NewLine();
+                window_width = ImGui::GetWindowWidth();
+
+                if (enable_close)
+                {
+                    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + window_width / 2.f - 50.f); // 50 = 30 (button size) + 20 (padding)
+                    if (ImGui::Button("Close", ImVec2(60, 30)))
+                    {
+                        ImGui::CloseCurrentPopup();
+                        close_clicked = true;
+                    }
+                }
+            }
+            ImGui::EndPopup();
+        }
+        return close_clicked;
+    }
+
+    bool device_model::prompt_toggle_advanced_mode(bool enable_advanced_mode, const std::string& message_text, std::vector<std::string>& restarting_device_info, viewer_model& view, ux_window& window, const std::string& error_message)
     {
         bool keep_showing = true;
         bool yes_was_chosen = false;
-        if (yes_no_dialog("Advanced Mode", message_text, yes_was_chosen, window))
+        if (yes_no_dialog("Advanced Mode", message_text, yes_was_chosen, window, error_message))
         {
             if (yes_was_chosen)
             {
@@ -4167,6 +4270,178 @@ namespace rs2
         return keep_showing;
     }
 
+    bool device_model::prompt_trigger_camera_accuracy_health(ux_window& window, viewer_model& viewer, const std::string& error_message)
+    {
+        // This process is built from a 2 stages windows, first a yes/no window and then a process window
+        bool keep_showing = true;
+        bool yes_was_chosen = false;
+
+        switch (cah_model.cah_state.load())
+        {
+        case camera_accuracy_health_model::model_state_type::TRIGGER_MODAL:
+        {
+            // Make sure the firmware meets the minimal version for Trigger Camera Accuracy features
+            const std::string& min_fw_version("1.4.1.0");
+            auto fw_upgrade_needed = is_upgradeable(dev.get_info(rs2_camera_info::RS2_CAMERA_INFO_FIRMWARE_VERSION), min_fw_version);
+            bool is_depth_streaming(false);
+            bool is_color_streaming(false);
+
+            std::string message_text = "Camera Accuracy Health will ensure you get the highest accuracy from your camera.\n\n"
+                "This process may take several minutes and requires special setup to get good results.\n"
+                "While it is working, the viewer will not be usable.\n\n";
+
+            if (fw_upgrade_needed)
+            {
+                std::string fw_upgrade_message = "Camera Accuracy Health requires a minimal FW version of " + min_fw_version +
+                    "\n\nPlease update your firmware and try again. ";
+
+                message_text += fw_upgrade_message;
+            }
+            else
+            {
+                is_depth_streaming = std::any_of(subdevices.begin(), subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<depth_sensor>(); });
+                is_color_streaming = std::any_of(subdevices.begin(), subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<color_sensor>(); });
+
+                if (is_depth_streaming && is_color_streaming)
+                {
+                    message_text += "Are you sure you want to continue?";
+                }
+                else
+                {
+                    std::string stream_missing_message = "Camera Accuracy Health cannot be triggered : both depth & RGB streams must be active.";
+                    message_text += stream_missing_message;
+                }
+
+            }
+
+            bool option_disabled = !is_depth_streaming || !is_color_streaming || fw_upgrade_needed;
+            if (yes_no_dialog("Camera Accuracy Health Trigger", message_text, yes_was_chosen, window, error_message, option_disabled))
+            {
+                if (yes_was_chosen)
+                {
+
+                    auto itr = std::find_if(subdevices.begin(), subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
+                    {
+                        if (sub->s->as<depth_sensor>())
+                            return true;
+                        return false;
+                    });
+
+
+                    if (is_depth_streaming && is_color_streaming && itr != subdevices.end())
+                    {
+                        auto sd = *itr;
+                        sd->s->set_option(RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH, 1.0f);
+                        device_calibration dev_cal(dev);
+                        // Register AC status change callback
+                        if (!cah_model.registered_to_callback)
+                        {
+                            cah_model.registered_to_callback = true;
+                            cah_model.cah_state = camera_accuracy_health_model::model_state_type::PROCESS_MODAL;
+                            cah_model.cah_process_start_time = std::chrono::high_resolution_clock::now();
+                            dev_cal.register_calibration_change_callback([&](rs2_calibration_status cal_status)
+                            {
+                                cah_model.calib_status = cal_status; 
+                            });
+                        }
+
+                    }
+                }
+                else
+                {
+                    keep_showing = false;
+                }
+            }
+        }
+        break;
+
+        case camera_accuracy_health_model::model_state_type::PROCESS_MODAL:
+        {
+            if (!cah_model.process_started)
+            {
+                cah_model.process_started = (cah_model.calib_status == RS2_CALIBRATION_SPECIAL_FRAME || cah_model.calib_status == RS2_CALIBRATION_STARTED);
+            }
+
+            bool process_finished(cah_model.calib_status == RS2_CALIBRATION_SUCCESSFUL || cah_model.calib_status == RS2_CALIBRATION_FAILED || cah_model.calib_status == RS2_CALIBRATION_NOT_NEEDED);
+
+            static std::map<rs2_calibration_status, std::string> status_map{
+                {RS2_CALIBRATION_SPECIAL_FRAME  , "In Progress" },
+                {RS2_CALIBRATION_STARTED        , "In Progress" },
+                {RS2_CALIBRATION_NOT_NEEDED     , "Ended" },
+                {RS2_CALIBRATION_SUCCESSFUL     , "Ended Successfully" },
+                {RS2_CALIBRATION_RETRY          , "In Progress" },
+                {RS2_CALIBRATION_FAILED         , "Ended With Failure" },
+                {RS2_CALIBRATION_SCENE_INVALID  , "In Progress" },
+                {RS2_CALIBRATION_BAD_RESULT     , "In Progress" } };
+
+            rs2_calibration_status calibration_status = cah_model.calib_status;
+
+            // We don't know if AC really started working so we add a timeout for not blocking the viewer forever.
+            if (!cah_model.process_started)
+            {
+                auto now = std::chrono::high_resolution_clock::now();
+                if (now > (cah_model.cah_process_start_time + std::chrono::seconds(30)))
+                {
+                    process_finished = true; // timeout
+                    calibration_status = RS2_CALIBRATION_FAILED;
+                }
+            }
+
+            const std::string & message = process_finished ?    "                                                               " : 
+                                                                "Camera Accuracy Health is In progress, this may take a while...";
+            if (status_dialog("Camera Accuracy Health Status", message, status_map[calibration_status], process_finished, window))
+            {
+                keep_showing = false;
+            }
+        }
+        break;
+        default:
+            break;
+
+        }
+
+        //reset internal elements
+        if (!keep_showing)
+        {
+            cah_model.cah_state = camera_accuracy_health_model::model_state_type::TRIGGER_MODAL;
+            cah_model.calib_status = RS2_CALIBRATION_RETRY;
+            cah_model.process_started = false;
+            cah_model.registered_to_callback = false;
+        }
+        return keep_showing;
+    }
+
+    bool device_model::prompt_reset_camera_accuracy_health(ux_window& window, const std::string& error_message)
+    {
+        bool keep_showing = true;
+        bool yes_was_chosen = false;
+
+        std::string message_text("This will reset the camera settings to their factory-calibrated state.\nYou will lose any improvements made with Camera Accuracy Health.\n\n Are you sure?");
+        if (yes_no_dialog("Camera Accuracy Health Reset", message_text, yes_was_chosen, window,error_message))
+        {
+            if (yes_was_chosen)
+            {
+                auto itr = std::find_if(subdevices.begin(), subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
+                {
+                    if (sub->s->as<depth_sensor>())
+                        return true;
+                    return false;
+                });
+
+
+                if (itr != subdevices.end())
+                {
+                    auto sd = *itr;
+                    sd->s->set_option(RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH, 1.0f);
+
+                }
+            }
+            keep_showing = false;
+        }
+
+        return keep_showing;
+    }
+
     bool device_model::draw_advanced_controls(viewer_model& view, ux_window& window, std::string& error_message)
     {
         bool was_set = false;
@@ -4198,7 +4473,7 @@ namespace rs2
                     }
                     if (show_yes_no_modal)
                     {
-                        show_yes_no_modal = prompt_toggle_advanced_mode(true, "\t\tAre you sure you want to turn on Advanced Mode?\t\t", restarting_device_info, view, window);
+                        show_yes_no_modal = prompt_toggle_advanced_mode(true, "\t\tAre you sure you want to turn on Advanced Mode?\t\t", restarting_device_info, view, window, error_message);
                     }
                 }
             }
@@ -4337,7 +4612,9 @@ namespace rs2
         {
             try
             {
-                sw_update::dev_updates_profile updates_profile(dev, server_versions_db_url);
+
+                auto server_url = config_file::instance().get(configurations::update::sw_updates_url);
+                sw_update::dev_updates_profile updates_profile(dev, server_url);
 
                 bool sw_update_required = updates_profile.retrieve_updates(versions_db_manager::LIBREALSENSE);
                 bool fw_update_required = updates_profile.retrieve_updates(versions_db_manager::FIRMWARE);
@@ -4385,6 +4662,7 @@ namespace rs2
         // TODO: Once auto-calib makes it into the API, switch to querying camera info
     }
 
+
     float device_model::draw_device_panel(float panel_width,
         ux_window& window,
         std::string& error_message,
@@ -4397,6 +4675,7 @@ namespace rs2
         =============================
         */
 
+
         const bool is_playback_device = dev.is<playback>();
         const float device_panel_height = 60.0f;
         auto panel_pos = ImGui::GetCursorPos();
@@ -4493,7 +4772,6 @@ namespace rs2
         ////////////////////////////////////////
         std::string label = to_string() << "device_menu" << id;
         std::string bars_button_name = to_string() << textual_icons::bars << "##" << id;
-
         if (ImGui::Button(bars_button_name.c_str(), device_panel_icons_size))
         {
             ImGui::OpenPopup(label.c_str());
@@ -4506,8 +4784,10 @@ namespace rs2
         ImGui::PopFont();
         ImGui::PushFont(window.get_font());
         static bool keep_showing_advanced_mode_modal = false;
+        bool open_calibration_ui = false;
         if (ImGui::BeginPopup(label.c_str()))
         {
+
             bool something_to_show = false;
             ImGui::PushStyleColor(ImGuiCol_Text, dark_grey);
             if (auto tm2_extensions = dev.as<rs2::tm2>())
@@ -4592,6 +4872,7 @@ namespace rs2
                 }
             }
 
+
             if (allow_remove)
             {
                 something_to_show = true;
@@ -4671,6 +4952,27 @@ namespace rs2
                 }
             }
 
+#if 0 // Currently disable triggering/reseting CAH from UI
+            if (dev.supports(RS2_CAMERA_INFO_PRODUCT_LINE) && dev.supports(RS2_CAMERA_INFO_FIRMWARE_VERSION))
+            { 
+                auto product_line_str = dev.get_info(RS2_CAMERA_INFO_PRODUCT_LINE);
+                if (RS2_PRODUCT_LINE_L500 == parse_product_line(product_line_str))
+                {
+                    if (ImGui::Selectable("Trigger Camera Accuracy Health"))
+                    {
+                        // We cannot open a pop up window here since we are already in a pop up window
+                        // we trigger the pop up and activate it outside the menu pop up
+                        cah_model.show_trigger_camera_accuracy_health_popup = true;
+                    }
+
+                    if (ImGui::Selectable("Reset Camera Accuracy Health"))
+                    {
+                        cah_model.show_reset_camera_accuracy_health_popup = true;
+                    }
+                }
+            }
+#endif
+            
             bool has_autocalib = false;
             for (auto&& sub : subdevices)
             {
@@ -4739,6 +5041,80 @@ namespace rs2
                         ImGui::SetTooltip("Tare calibration is used to adjust camera absolute distance to flat target.\n"
                             "User needs to enter the known ground truth");
 
+                    
+                    if (_calib_model.supports())
+                    {
+                        if (ImGui::Selectable("Calibration Data"))
+                        {
+                            _calib_model.open();
+                        }
+                        if (ImGui::IsItemHovered())
+                            ImGui::SetTooltip("Access low level camera calibration parameters");
+                    }
+
+                    if (auto fwlogger = dev.as<rs2::firmware_logger>())
+                    {
+                        if (ImGui::Selectable("Recover Logs from Flash"))
+                        {
+                            try
+                            {
+                                bool has_parser = false;
+                                std::string hwlogger_xml = config_file::instance().get(configurations::viewer::hwlogger_xml);
+                                std::ifstream f(hwlogger_xml.c_str());
+                                if (f.good())
+                                {
+                                    try
+                                    {
+                                        std::string str((std::istreambuf_iterator<char>(f)),
+                                            std::istreambuf_iterator<char>());
+                                        fwlogger.init_parser(str);
+                                        has_parser = true;
+                                    }
+                                    catch (const std::exception& ex)
+                                    {
+                                        viewer.not_model->output.add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, 
+                                            to_string() << "Invalid Hardware Logger XML at '" << hwlogger_xml << "': " << ex.what() << "\nEither configure valid XML or remove it");
+                                    }
+                                }
+
+                                auto message = fwlogger.create_message();
+                                
+                                while (fwlogger.get_flash_log(message))
+                                {
+                                    auto parsed = fwlogger.create_parsed_message();
+                                    auto parsed_ok = false;
+                                    
+                                    if (has_parser)
+                                    {
+                                        if (fwlogger.parse_log(message, parsed))
+                                        {
+                                            parsed_ok = true;
+
+                                            viewer.not_model->output.add_log(message.get_severity(), 
+                                                parsed.file_name(), parsed.line(), to_string() 
+                                                    << "FW-LOG [" << parsed.thread_name() << "] " << parsed.message());
+                                        }
+                                    }
+
+                                    if (!parsed_ok)
+                                    {
+                                        std::stringstream ss; 
+                                        for (auto& elem : message.data())
+                                            ss << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(elem) << " ";
+                                        viewer.not_model->output.add_log(message.get_severity(), __FILE__, 0, ss.str());
+                                    }                            
+                                }
+                            }
+                            catch(const std::exception& ex)
+                            {
+                                viewer.not_model->output.add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, 
+                                    to_string() << "Failed to fetch firmware logs: " << ex.what());
+                            }
+                        }
+                        if (ImGui::IsItemHovered())
+                            ImGui::SetTooltip("Recovers last set of firmware logs prior to camera shutdown / disconnect");
+                    }
+
                     has_autocalib = true;
                 }
             }
@@ -4756,15 +5132,32 @@ namespace rs2
             }
 
             ImGui::PopStyleColor();
+                
             ImGui::EndPopup();
+
+        }
+
+
+        if (cah_model.show_trigger_camera_accuracy_health_popup)
+        {
+            cah_model.show_trigger_camera_accuracy_health_popup = prompt_trigger_camera_accuracy_health(window, viewer, error_message);
+        }
+
+        if (cah_model.show_reset_camera_accuracy_health_popup)
+        {
+            cah_model.show_reset_camera_accuracy_health_popup = prompt_reset_camera_accuracy_health(window, error_message);
         }
 
         if (keep_showing_advanced_mode_modal)
         {
             const bool is_advanced_mode_enabled = dev.as<advanced_mode>().is_enabled();
             std::string msg = to_string() << "\t\tAre you sure you want to " << (is_advanced_mode_enabled ? "turn off Advanced mode" : "turn on Advanced mode") << "\t\t";
-            keep_showing_advanced_mode_modal = prompt_toggle_advanced_mode(!is_advanced_mode_enabled, msg, restarting_device_info, viewer, window);
+            keep_showing_advanced_mode_modal = prompt_toggle_advanced_mode(!is_advanced_mode_enabled, msg, restarting_device_info, viewer, window, error_message);
         }
+
+        _calib_model.update(window, error_message);
+
+            
         ////////////////////////////////////////
         // Draw icons names
         ////////////////////////////////////////
@@ -4885,7 +5278,6 @@ namespace rs2
             // Disable depth stream on all sub devices
             for (auto&& sub : subdevices)
             {
-                int i = 0;
                 for (auto&& profile : sub->profiles)
                 {
                     if (profile.stream_type() == RS2_STREAM_DEPTH)
@@ -5199,7 +5591,7 @@ namespace rs2
                         }
                         if (keep_showing_popup)
                         {
-                            keep_showing_popup = prompt_toggle_advanced_mode(true, popup_message, restarting_device_info, viewer, window);
+                            keep_showing_popup = prompt_toggle_advanced_mode(true, popup_message, restarting_device_info, viewer, window, error_message);
                         }
                     }
                     catch (const error& e)
@@ -5300,7 +5692,7 @@ namespace rs2
 
         if (require_advanced_mode_enable_prompt)
         {
-            require_advanced_mode_enable_prompt = prompt_toggle_advanced_mode(true, popup_message, restarting_device_info, viewer, window);
+            require_advanced_mode_enable_prompt = prompt_toggle_advanced_mode(true, popup_message, restarting_device_info, viewer, window, error_message);
         }
 
         ImGui::PopFont();
@@ -5612,7 +6004,7 @@ namespace rs2
             if (show_depth_only && !sub->s->is<depth_sensor>()) continue;
 
             const ImVec2 pos = ImGui::GetCursorPos();
-            const ImVec2 abs_pos = ImGui::GetCursorScreenPos();
+            //const ImVec2 abs_pos = ImGui::GetCursorScreenPos();
             //model_to_y[sub.get()] = pos.y;
             //model_to_abs_y[sub.get()] = abs_pos.y;
 
@@ -5935,7 +6327,6 @@ namespace rs2
                             ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
 
                             const ImVec2 pos = ImGui::GetCursorPos();
-                            const ImVec2 abs_pos = ImGui::GetCursorScreenPos();
 
                             draw_later.push_back([windows_width, &window, sub, pos, &viewer, this, pb]() {
                                 if (!sub->streaming || !sub->post_processing_enabled) ImGui::SetCursorPos({ windows_width - 35, pos.y - 3 });
diff --git a/common/model-views.h b/common/model-views.h
index dd245de..9f44ccc 100644
--- a/common/model-views.h
+++ b/common/model-views.h
@@ -26,6 +26,7 @@
 #include "realsense-ui-advanced-mode.h"
 #include "fw-update-helper.h"
 #include "updates-model.h"
+#include "calibration-model.h"
 
 ImVec4 from_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a, bool consistent_color = false);
 ImVec4 operator+(const ImVec4& c, float v);
@@ -57,7 +58,8 @@ static const ImVec4 yellowish = from_rgba(255, 253, 191, 255, true);
 static const ImVec4 green = from_rgba(0x20, 0xe0, 0x20, 0xff, true);
 static const ImVec4 dark_sensor_bg = from_rgba(0x1b, 0x21, 0x25, 170);
 static const ImVec4 red = from_rgba(233, 0, 0, 255, true);
-static const ImVec4 greenish = from_rgba(33, 104, 0, 255);
+static const ImVec4 greenish = from_rgba(67, 163, 97, 255);
+static const ImVec4 orange = from_rgba(255, 157, 0, 255, true);
 
 inline ImVec4 operator*(const ImVec4& color, float t)
 {
@@ -68,44 +70,6 @@ inline ImVec4 operator+(const ImVec4& a, const ImVec4& b)
     return ImVec4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
 }
 
-// Helper class that lets smoothly animate between its values
-template<class T>
-class animated
-{
-private:
-    T _old, _new;
-    std::chrono::system_clock::time_point _last_update;
-    std::chrono::system_clock::duration _duration;
-public:
-    animated(T def, std::chrono::system_clock::duration duration = std::chrono::milliseconds(200))
-        : _duration(duration)
-    {
-        _last_update = std::chrono::system_clock::now();
-    }
-    animated& operator=(const T& other)
-    {
-        if (other != _new)
-        {
-            _old = get();
-            _new = other;
-            _last_update = std::chrono::system_clock::now();
-        }
-        return *this;
-    }
-    T get() const
-    {
-        auto now = std::chrono::system_clock::now();
-        auto ms = std::chrono::duration_cast<std::chrono::microseconds>(now - _last_update).count();
-        auto duration_ms = std::chrono::duration_cast<std::chrono::microseconds>(_duration).count();
-        auto t = (float)ms / duration_ms;
-        t = std::max(0.f, std::min(rs2::smoothstep(t, 0.f, 1.f), 1.f));
-        return _old * (1.f - t) + _new * t;
-    }
-    operator T() const { return get(); }
-    T value() const { return _new; }
-};
-
-
 inline ImVec4 blend(const ImVec4& c, float a)
 {
     return{ c.x, c.y, c.z, a * c.w };
@@ -113,6 +77,8 @@ inline ImVec4 blend(const ImVec4& c, float a)
 
 namespace rs2
 {
+    constexpr const char* server_versions_db_url = "http://realsense-hw-public.s3-eu-west-1.amazonaws.com/Releases/rs_versions_db.json";
+    
     void prepare_config_file();
 
     bool frame_metadata_to_csv(const std::string& filename, rs2::frame frame);
@@ -158,9 +124,15 @@ namespace rs2
         }
         namespace update
         {
-            static const char* allow_rc_firmware   { "update.allow_rc_firmware" };
-            static const char* recommend_updates   { "update.recommend_updates" };
-            static const char* recommend_calibration { "update.recommend_calibration" };
+            static const char* allow_rc_firmware            { "update.allow_rc_firmware" };
+            static const char* recommend_updates            { "update.recommend_updates" };
+            static const char* recommend_calibration        { "update.recommend_calibration" };
+            static const char* sw_updates_url               { "update.sw_update_url" };
+            static const char* sw_updates_official_server   { "update.sw_update_official_server" };
+        }
+        namespace calibration
+        {
+            static const char* enable_writing      { "calibration.enable_writing" };
         }
         namespace viewer
         {
@@ -172,6 +144,8 @@ namespace rs2
             static const char* sdk_version         { "viewer_model.sdk_version" };
             static const char* last_calib_notice   { "viewer_model.last_calib_notice" };
             static const char* is_measuring        { "viewer_model.is_measuring" };
+            static const char* output_open         { "viewer_model.output_open" };
+            static const char* search_term         { "viewer_model.search_term" };
 
             static const char* log_to_console      { "viewer_model.log_to_console" };
             static const char* log_to_file         { "viewer_model.log_to_file" };
@@ -182,6 +156,8 @@ namespace rs2
             static const char* show_stream_details { "viewer_model.show_stream_details" };
             static const char* metric_system       { "viewer_model.metric_system" };
             static const char* shading_mode        { "viewer_model.shading_mode" };
+            static const char* commands_xml        { "viewer_model.commands_xml" };
+            static const char* hwlogger_xml        { "viewer_model.hwlogger_xml" };
 
             static const char* last_ip             { "viewer_model.last_ip" };
         }
@@ -280,7 +256,7 @@ namespace rs2
     class subdevice_model;
     struct notifications_model;
 
-    void imgui_easy_theming(ImFont*& font_14, ImFont*& font_18);
+    void imgui_easy_theming(ImFont*& font_14, ImFont*& font_18, ImFont*& monofont);
 
     // avoid display the following options
     bool static skip_option(rs2_option opt)
@@ -289,7 +265,9 @@ namespace rs2
             opt == RS2_OPTION_STREAM_FORMAT_FILTER ||
             opt == RS2_OPTION_STREAM_INDEX_FILTER ||
             opt == RS2_OPTION_FRAMES_QUEUE_SIZE ||
-            opt == RS2_OPTION_SENSOR_MODE)
+            opt == RS2_OPTION_SENSOR_MODE || 
+            opt == RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH ||
+            opt == RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH)
             return true;
         return false;
     }
@@ -522,7 +500,6 @@ namespace rs2
         const float len_x = 0.1f;
         const float len_y = 0.03f;
         const float len_z = 0.01f;
-        const float lens_radius = 0.005f;
         /*
         4--------------------------3
         /|                         /|
@@ -556,8 +533,6 @@ namespace rs2
             } };
 
         colored_cube camera_box{ { { f1,colors[0] },{ f2,colors[1] },{ f3,colors[2] },{ f4,colors[3] },{ f5,colors[4] },{ f6,colors[5] } } };
-        float3 center_left{ v5.x + len_x / 3, v6.y - len_y / 3, v5.z };
-        float3 center_right{ v6.x - len_x / 3, v6.y - len_y / 3, v5.z };
 
         std::vector<tracked_point> trajectory;
         std::vector<float2> boundary;
@@ -824,6 +799,29 @@ namespace rs2
         std::vector<std::shared_ptr<notification_model>> related_notifications;
 
     private:
+        // This class is in charge of camera accuracy health window parameters,
+        // Needed as a member for reseting the window memory on device disconnection.
+        class camera_accuracy_health_model
+        {
+        public:
+            enum class model_state_type { TRIGGER_MODAL, PROCESS_MODAL };
+            std::atomic<model_state_type> cah_state; // will be set from a different thread callback function
+            std::atomic<rs2_calibration_status> calib_status; // will be set from a different thread callback function
+            bool show_trigger_camera_accuracy_health_popup;
+            bool show_reset_camera_accuracy_health_popup;
+            bool registered_to_callback;
+            std::chrono::high_resolution_clock::time_point cah_process_start_time;
+            bool process_started;
+
+
+            camera_accuracy_health_model():cah_state(model_state_type::TRIGGER_MODAL), calib_status(RS2_CALIBRATION_RETRY),
+                show_trigger_camera_accuracy_health_popup(false), show_reset_camera_accuracy_health_popup(false),
+                registered_to_callback(false), cah_process_start_time(), process_started(false)
+            {}
+
+        };
+
+        camera_accuracy_health_model cah_model;
         void draw_info_icon(ux_window& window, ImFont* font, const ImVec2& size);
         int draw_seek_bar();
         int draw_playback_controls(ux_window& window, ImFont* font, viewer_model& view);
@@ -844,7 +842,11 @@ namespace rs2
         bool prompt_toggle_advanced_mode(bool enable_advanced_mode, const std::string& message_text,
             std::vector<std::string>& restarting_device_info,
             viewer_model& view,
-            ux_window& window);
+            ux_window& window,
+            const std::string& error_message);
+        bool prompt_trigger_camera_accuracy_health(ux_window& window, viewer_model& viewer,  const std::string& error_message);
+        bool prompt_reset_camera_accuracy_health(ux_window& window, const std::string& error_message);
+
         void load_viewer_configurations(const std::string& json_str);
         void save_viewer_configurations(std::ofstream& outfile, nlohmann::json& j);
 
@@ -856,6 +858,7 @@ namespace rs2
         std::shared_ptr< atomic_objects_in_frame > _detected_objects;
         std::shared_ptr<updates_model> _updates;
         sw_update::dev_updates_profile::update_profile _updates_profile;
+        calibration_model _calib_model;
     };
 
     class viewer_model;
@@ -951,10 +954,6 @@ namespace rs2
         std::shared_ptr<std::thread> render_thread;              // Post processing filter rendering Thread running render_loop()
         void render_loop();                     // Post processing filter rendering function
 
-        int last_frame_number = 0;
-        double last_timestamp = 0;
-        int last_stream_id = 0;
-
         std::shared_ptr<gl::uploader> uploader; // GL element that helps pre-emptively copy frames to the GPU
     };
 
diff --git a/common/notifications.cpp b/common/notifications.cpp
index 8e0e3a8..51abe32 100644
--- a/common/notifications.cpp
+++ b/common/notifications.cpp
@@ -135,7 +135,7 @@ namespace rs2
                 auto a = curr_progress_value / 100.f;
                 ImGui::GetWindowDrawList()->AddRectFilled({ float(pos.x + 3 - i), float(pos.y + 3 - i) },
                 { float(pos.x + filled_w + i), float(pos.y + 17 + i) },
-                    ImColor(alpha(light_blue, sqrt(a) * 0.02f)), i);
+                    ImColor(alpha(light_blue, sqrt(a) * 0.02f)), float(i));
             }
 
             ImGui::GetWindowDrawList()->AddRectFilled({ float(pos.x + 3), float(pos.y + 3) },
@@ -170,9 +170,9 @@ namespace rs2
     {
         ImVec4 c;
 
-        ImGui::PushStyleColor(ImGuiCol_Button, saturate(c, 1.3));
-        ImGui::PushStyleColor(ImGuiCol_ButtonActive, saturate(c, 0.9));
-        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, saturate(c, 1.5));
+        ImGui::PushStyleColor(ImGuiCol_Button, saturate(c, 1.3f));
+        ImGui::PushStyleColor(ImGuiCol_ButtonActive, saturate(c, 0.9f));
+        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, saturate(c, 1.5f));
         ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
         c = alpha(white, 1 - t);
         ImGui::PushStyleColor(ImGuiCol_Text, c);
@@ -198,7 +198,7 @@ namespace rs2
     void notification_model::draw_text(const char* msg, int x, int y, int h)
     {
         std::string text_name = to_string() << "##notification_text_" << index;
-        ImGui::PushTextWrapPos(x + width - 100);
+        ImGui::PushTextWrapPos(x + width - 100.f);
         ImGui::PushStyleColor(ImGuiCol_FrameBg, transparent);
         ImGui::PushStyleColor(ImGuiCol_ScrollbarBg, transparent);
         ImGui::PushStyleColor(ImGuiCol_ScrollbarGrab, transparent);
@@ -232,7 +232,7 @@ namespace rs2
     {
         auto title = get_title();
         auto lines = static_cast<int>(std::count(title.begin(), title.end(), '\n') + 1);
-        return (lines + 1) * ImGui::GetTextLineHeight() + 5;
+        return int((lines + 1) * ImGui::GetTextLineHeight() + 5);
     }
 
     void process_notification_model::draw_pre_effect(int x, int y)
@@ -333,8 +333,8 @@ namespace rs2
             {
                 if (last_x > 100000)
                 {
-                    last_x = x + 500;
-                    last_y = y;
+                    last_x = x + 500.f;
+                    last_y = float(y);
                 }
                 last_moved = system_clock::now();
                 animating = true;
@@ -345,12 +345,12 @@ namespace rs2
 
             if (s < 1.f)
             {
-                x = s * x + (1 - s) * last_x;
-                y = s * y + (1 - s) * last_y;
+                x = int(s * x + (1 - s) * last_x);
+                y = int(s * y + (1 - s) * last_y);
             }
             else
             {
-                last_x = x; last_y = y;
+                last_x = float(x); last_y = float(y);
                 animating = false;
                 if (dismissed && !expanded) to_close = true;
             }
@@ -511,7 +511,7 @@ namespace rs2
             }
         }
 
-        add_log(n.get_description());
+        output.add_log(n.get_severity(), __FILE__, __LINE__, n.get_description());
         return result;
     }
 
@@ -538,55 +538,7 @@ namespace rs2
             }
         }
 
-        add_log(model->get_title());
-    }
-
-    void notifications_model::draw_snoozed_button()
-    {
-        auto has_snoozed = snoozed_notifications.size();
-        ImGui::PushStyleColor(ImGuiCol_Text, !has_snoozed ? sensor_bg : light_grey);
-        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, !has_snoozed ? sensor_bg : light_blue);
-
-        const auto width = 50.f;
-
-        using namespace std;
-        using namespace chrono;
-
-        if (!has_snoozed) 
-        {
-            ImGui::ButtonEx(textual_icons::mail, { width, width }, ImGuiButtonFlags_Disabled);
-
-            if (ImGui::IsItemActive())
-                ImGui::SetTooltip("No pending notifications at this point");
-        }
-        else
-        {
-            auto k = duration_cast<milliseconds>(system_clock::now() - last_snoozed).count() / 500.f;
-            if (k <= 1.f)
-            {
-                auto size = 50.f;
-
-                ImGui::PopStyleColor();
-                ImGui::PushStyleColor(ImGuiCol_Text, saturate(white, smoothstep(static_cast<float>(k), 0.f, 1.f)));
-            }
-
-            if (ImGui::Button(textual_icons::mail, { width, width }))
-            {
-                for (auto&& n : snoozed_notifications)
-                {
-                    n->forced = true;
-                    n->snoozed = false;
-                    n->last_y -= 500;
-                    pending_notifications.push_back(n);
-                }
-                snoozed_notifications.clear();
-            }
-
-            if (ImGui::IsItemActive())
-                ImGui::SetTooltip("Pending notifications available. Click to review");
-        }
-
-        ImGui::PopStyleColor(2);
+        output.add_log(model->severity, __FILE__, __LINE__, model->get_title());
     }
 
     void notifications_model::draw(ux_window& win, int w, int h, std::string& error_message)
@@ -600,13 +552,6 @@ namespace rs2
             std::lock_guard<std::recursive_mutex> lock(m);
             if (pending_notifications.size() > 0)
             {
-                snoozed_notifications.erase(std::remove_if(std::begin(snoozed_notifications),
-                    std::end(snoozed_notifications),
-                    [&](std::shared_ptr<notification_model>& n)
-                {
-                    return n->dismissed;
-                }), end(snoozed_notifications));
-
                 // loop over all notifications, remove "old" ones
                 pending_notifications.erase(std::remove_if(std::begin(pending_notifications),
                     std::end(pending_notifications),
@@ -616,8 +561,6 @@ namespace rs2
                     {
                         n->dismissed = false;
                         n->to_close = false;
-                        snoozed_notifications.push_back(n);
-                        last_snoozed = std::chrono::system_clock::now();
                         return true;
                     }
                     return ((n->get_age_in_ms() > n->get_max_lifetime_ms() && 
@@ -642,10 +585,6 @@ namespace rs2
                 }
             }
 
-            auto flags = ImGuiWindowFlags_NoResize |
-                ImGuiWindowFlags_NoMove |
-                ImGuiWindowFlags_NoCollapse |
-                ImGuiWindowFlags_NoTitleBar;
 
             ImGui::PushStyleColor(ImGuiCol_WindowBg, { 0, 0, 0, 0 });
             //ImGui::Begin("Notification parent window", nullptr, flags);
@@ -727,45 +666,6 @@ namespace rs2
         ImGui::PopFont();
     }
 
-    void notifications_model::foreach_log(std::function<void(const std::string& line)> action)
-    {
-        std::lock_guard<std::recursive_mutex> lock(m);
-
-        // Process only the messages that are available upon invocation
-        std::string log_entry;
-        for (size_t len = 0; len < incoming_log_queue.size(); len++)
-        {
-            if (incoming_log_queue.try_dequeue(&log_entry))
-                notification_logs.push_back(log_entry);
-        }
-
-        // Limit the notification window
-        while (notification_logs.size() > 200)
-            notification_logs.pop_front();
-
-        for (auto&& l : notification_logs)
-            action(l);
-
-        auto rc = ImGui::GetCursorPos();
-        ImGui::SetCursorPos({ rc.x, rc.y + 5 });
-
-        if (new_log)
-        {
-            ImGui::SetScrollPosHere();
-            new_log = false;
-        }
-    }
-
-    // Callback function must not include mutex
-    void notifications_model::add_log(std::string line)
-    {
-        if (!line.size()) return;
-
-        if (line[line.size() - 1] != '\n') line += "\n";
-        incoming_log_queue.enqueue(std::move(line));
-        new_log = true;
-    }
-
     version_upgrade_model::version_upgrade_model(int version) 
         : process_notification_model(nullptr), _version(version)
     {
@@ -939,7 +839,7 @@ namespace rs2
 
             ImGui::SetCursorScreenPos({ float(x + 10), float(y + 35) });
 
-            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1. - t));
+            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1.f - t));
 
             std::string s = to_string() << "Saving 3D view to " <<
                 get_file_name(get_manager().get_filename());
diff --git a/common/notifications.h b/common/notifications.h
index 4482747..2aa1e55 100644
--- a/common/notifications.h
+++ b/common/notifications.h
@@ -9,7 +9,8 @@
 #include <chrono>
 
 #include "ux-window.h"
-#include "../src/concurrency.h"
+
+#include "output-model.h"
 
 namespace rs2
 {
@@ -195,25 +196,22 @@ namespace rs2
         void add_notification(std::shared_ptr<notification_model> model);
         void draw(ux_window& win, int w, int h, std::string& error_message);
 
-        void foreach_log(std::function<void(const std::string& line)> action);
-        void add_log(std::string line);
+        notifications_model() {}
 
-        void draw_snoozed_button();
+        void add_log(std::string message) 
+        {            
+            output.add_log(RS2_LOG_SEVERITY_INFO, "", 0, message); 
+        }
 
-        notifications_model() : last_snoozed(std::chrono::system_clock::now()) {}
+        output_model output;
         
     private:
         std::vector<std::shared_ptr<notification_model>> pending_notifications;
-        std::vector<std::shared_ptr<notification_model>> snoozed_notifications;
         int index = 1;
         const int MAX_SIZE = 6;
         std::recursive_mutex m;
-        bool new_log = false;
 
-        single_consumer_queue<std::string> incoming_log_queue;
-        std::deque<std::string> notification_logs;
         std::shared_ptr<notification_model> selected;
-        std::chrono::system_clock::time_point last_snoozed;
     };
 
     inline ImVec4 saturate(const ImVec4& a, float f)
diff --git a/common/objects-in-frame.h b/common/objects-in-frame.h
index 8c58a84..eca9b3c 100644
--- a/common/objects-in-frame.h
+++ b/common/objects-in-frame.h
@@ -15,11 +15,11 @@ struct object_in_frame
     size_t id;
 
     object_in_frame( size_t id, std::string const & name, rs2::rect bbox_color, rs2::rect bbox_depth, float depth )
-        : id( id )
-        , name( name )
-        , normalized_color_bbox( bbox_color )
-        , normalized_depth_bbox( bbox_depth )
-        , mean_depth( depth )
+    : normalized_color_bbox( bbox_color )
+    , normalized_depth_bbox( bbox_depth )
+    , name( name )
+    , mean_depth( depth )
+    , id( id )
     {
     }
 };
diff --git a/common/on-chip-calib.cpp b/common/on-chip-calib.cpp
index 63a1c8d..51db6f3 100644
--- a/common/on-chip-calib.cpp
+++ b/common/on-chip-calib.cpp
@@ -193,7 +193,6 @@ namespace rs2
             bool record,
             std::vector<single_metric_data>& samples)
         {
-            float TO_METERS = sensor.get_depth_scale();
             static const float TO_MM = 1000.f;
             static const float TO_PERCENT = 100.f;
 
@@ -216,10 +215,6 @@ namespace rs2
             {
                 // Find distance from point to the reconstructed plane
                 auto dist2plane = p.a*point.x + p.b*point.y + p.c*point.z + p.d;
-                // Project the point to plane in 3D and find distance to the intersection point
-                rs2::float3 plane_intersect = { float(point.x - dist2plane*p.a),
-                    float(point.y - dist2plane*p.b),
-                    float(point.z - dist2plane*p.c) };
 
                 // Store distance, disparity and gt- error
                 distances.push_back(dist2plane * TO_MM);
@@ -320,9 +315,9 @@ namespace rs2
 
         auto calib_dev = _dev.as<auto_calibrated_device>();
         if (tare)
-            _new_calib = calib_dev.run_tare_calibration(ground_truth, json, [&](const float progress) {_progress = progress;}, 5000);
+            _new_calib = calib_dev.run_tare_calibration(ground_truth, json, [&](const float progress) {_progress = int(progress);}, 5000);
         else
-            _new_calib = calib_dev.run_on_chip_calibration(json, &_health, [&](const float progress) {_progress = progress;}, 5000);
+            _new_calib = calib_dev.run_on_chip_calibration(json, &_health, [&](const float progress) {_progress = int(progress);}, 5000);
     }
 
     void on_chip_calib_manager::process_flow(std::function<void()> cleanup, 
@@ -393,7 +388,7 @@ namespace rs2
 
             _viewer.is_3d_view = _in_3d_view;
 
-            _viewer.ground_truth_r = ground_truth;
+            _viewer.ground_truth_r = uint32_t(ground_truth);
             config_file::instance().set(configurations::viewer::ground_truth_r, ground_truth);
 
             _viewer.synchronization_enable = _synchronized;
@@ -516,7 +511,7 @@ namespace rs2
             else
                 ImGui::SetCursorScreenPos({ float(x + 9), float(y + 27) });
 
-            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1. - t));
+            ImGui::PushStyleColor(ImGuiCol_Text, alpha(light_grey, 1.f - t));
 
             if (update_state == RS2_CALIB_STATE_INITIAL_PROMPT)
             {
@@ -570,7 +565,7 @@ namespace rs2
                     ImGui::SetCursorScreenPos({ float(x + 135), float(y + 30) });
 
                     std::string id = to_string() << "##avg_step_count_" << index;
-                    ImGui::PushItemWidth(width - 145);
+                    ImGui::PushItemWidth(width - 145.f);
                     ImGui::SliderInt(id.c_str(), &get_manager().average_step_count, 1, 30);
                     ImGui::PopItemWidth();
 
@@ -586,7 +581,7 @@ namespace rs2
 
                     id = to_string() << "##step_count_" << index;
 
-                    ImGui::PushItemWidth(width - 145);
+                    ImGui::PushItemWidth(width - 145.f);
                     ImGui::SliderInt(id.c_str(), &get_manager().step_count, 1, 30);
                     ImGui::PopItemWidth();
 
@@ -607,14 +602,14 @@ namespace rs2
                     std::vector<const char*> vals_cstr;
                     for (auto&& s : vals) vals_cstr.push_back(s.c_str());
 
-                    ImGui::PushItemWidth(width - 145);
-                    ImGui::Combo(id.c_str(), &get_manager().accuracy, vals_cstr.data(), vals.size());
-                   
+                    ImGui::PushItemWidth(width - 145.f);
+                    ImGui::Combo(id.c_str(), &get_manager().accuracy, vals_cstr.data(), int(vals.size()));
+
                     ImGui::SetCursorScreenPos({ float(x + 135), float(y + 35 + ImGui::GetTextLineHeightWithSpacing()) });
 
                     ImGui::PopItemWidth();
 
-                    draw_intrinsic_extrinsic(x, y + 3 * ImGui::GetTextLineHeightWithSpacing() - 10);
+                    draw_intrinsic_extrinsic(x, y + 3 * int(ImGui::GetTextLineHeightWithSpacing()) - 10);
 
                     ImGui::SetCursorScreenPos({ float(x + 9), float(y + 52 + 4 * ImGui::GetTextLineHeightWithSpacing()) });
                     id = to_string() << "Apply High-Accuracy Preset##apply_preset_" << index;
@@ -651,7 +646,7 @@ namespace rs2
                 char buff[MAX_SIZE];
                 memcpy(buff, gt.c_str(), gt.size() + 1);
 
-                ImGui::PushItemWidth(width - 145);
+                ImGui::PushItemWidth(width - 145.f);
                 if (ImGui::InputText(id.c_str(), buff, std::max((int)gt.size() + 1, 10)))
                 {
                     std::stringstream ss;
@@ -672,7 +667,7 @@ namespace rs2
                 ImGui::SetCursorScreenPos({ float(x + 5), float(y + height - 25) });
                 if (ImGui::Button(button_name.c_str(), { float(bar_width), 20.f }))
                 {
-                    get_manager().restore_workspace([this](std::function<void()> a){ a(); });
+                    get_manager().restore_workspace([](std::function<void()> a){ a(); });
                     get_manager().reset();
                     get_manager().tare = true;
                     auto _this = shared_from_this();
@@ -704,9 +699,9 @@ namespace rs2
                 std::vector<const char*> vals_cstr;
                 for (auto&& s : vals) vals_cstr.push_back(s.c_str());
 
-                ImGui::PushItemWidth(width - 145);
+                ImGui::PushItemWidth(width - 145.f);
 
-                ImGui::Combo(id.c_str(), &get_manager().speed, vals_cstr.data(), vals.size());
+                ImGui::Combo(id.c_str(), &get_manager().speed, vals_cstr.data(), int(vals.size()));
                 ImGui::PopItemWidth();
 
                 draw_intrinsic_extrinsic(x, y);
@@ -754,7 +749,7 @@ namespace rs2
                 ImGui::SetCursorScreenPos({ float(x + 5), float(y + height - 25) });
                 if (ImGui::Button(button_name.c_str(), { float(bar_width), 20.f }))
                 {
-                    get_manager().restore_workspace([this](std::function<void()> a){ a(); });
+                    get_manager().restore_workspace([](std::function<void()> a){ a(); });
                     get_manager().reset();
                     auto _this = shared_from_this();
                     auto invoke = [_this](std::function<void()> action) {
@@ -961,7 +956,7 @@ namespace rs2
                     }
                     else dismiss(false);
 
-                    get_manager().restore_workspace([this](std::function<void()> a) { a(); });
+                    get_manager().restore_workspace([](std::function<void()> a) { a(); });
                 }
                 if (recommend_keep || get_manager().tare)
                 {
@@ -1066,7 +1061,7 @@ namespace rs2
         if (!use_new_calib && get_manager().done()) 
             get_manager().apply_calib(false);
 
-        get_manager().restore_workspace([this](std::function<void()> a){ a(); });
+        get_manager().restore_workspace([](std::function<void()> a){ a(); });
 
         if (update_state != RS2_CALIB_STATE_TARE_INPUT)
             update_state = RS2_CALIB_STATE_INITIAL_PROMPT;
diff --git a/common/on-chip-calib.h b/common/on-chip-calib.h
index 41ab6de..c2e24e2 100644
--- a/common/on-chip-calib.h
+++ b/common/on-chip-calib.h
@@ -49,7 +49,7 @@ namespace rs2
 
         void update_last_used();
 
-        uint32_t ground_truth = 2500;
+        float ground_truth = 2500;
         int average_step_count = 20;
         int step_count = 20;
         int accuracy = 2;
diff --git a/common/output-model.cpp b/common/output-model.cpp
new file mode 100644
index 0000000..89747b4
--- /dev/null
+++ b/common/output-model.cpp
@@ -0,0 +1,1099 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include <glad/glad.h>
+#include "output-model.h"
+
+#include "model-views.h"
+#include "os.h"
+
+#include <imgui_internal.h>
+#include <librealsense2/hpp/rs_internal.hpp>
+
+using namespace rs2;
+
+void output_model::thread_loop()
+{
+    while (!to_stop)
+    {
+        std::vector<rs2::device> dev_copy;
+        {
+            std::lock_guard<std::mutex> lock(devices_mutex);
+            dev_copy = devices;
+        }
+        if (enable_firmware_logs)
+            for (auto&& dev : devices)
+            {
+                try
+                {
+                    if (auto fwlogger = dev.as<rs2::firmware_logger>())
+                    {
+                        bool has_parser = false;
+                        std::string hwlogger_xml = config_file::instance().get(configurations::viewer::hwlogger_xml);
+                        std::ifstream f(hwlogger_xml.c_str());
+                        if (f.good())
+                        {
+                            try
+                            {
+                                std::string str((std::istreambuf_iterator<char>(f)),
+                                    std::istreambuf_iterator<char>());
+                                fwlogger.init_parser(str);
+                                has_parser = true;
+                            }
+                            catch (const std::exception& ex)
+                            {
+                                add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, 
+                                    to_string() << "Invalid Hardware Logger XML at '" << hwlogger_xml << "': " << ex.what() << "\nEither configure valid XML or remove it");
+                            }
+                        }
+
+                        auto message = fwlogger.create_message();
+                        while (fwlogger.get_firmware_log(message))
+                        {
+                            auto parsed = fwlogger.create_parsed_message();
+                            auto parsed_ok = false;
+                            
+                            if (has_parser)
+                            {
+                                if (fwlogger.parse_log(message, parsed))
+                                {
+                                    parsed_ok = true;
+
+                                    add_log(message.get_severity(), 
+                                        parsed.file_name(), parsed.line(), to_string() 
+                                            << "FW-LOG [" << parsed.thread_name() << "] " << parsed.message());
+                                }
+                            }
+
+                            if (!parsed_ok)
+                            {
+                                std::stringstream ss; 
+                                for (auto& elem : message.data())
+                                    ss << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(elem) << " ";
+                                add_log(message.get_severity(), __FILE__, 0, ss.str());
+                            }                            
+                        }
+                    }
+                }
+                catch(const std::exception& ex)
+                {
+                    add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, 
+                        to_string() << "Failed to fetch firmware logs: " << ex.what());
+                }
+            }
+        std::this_thread::sleep_for(std::chrono::milliseconds(10));
+    }
+}
+
+output_model::~output_model()
+{
+    to_stop = 1;
+    fw_logger.join();
+}
+
+output_model::output_model() : fw_logger([this](){ thread_loop(); })
+{
+    is_output_open = config_file::instance().get_or_default(
+            configurations::viewer::output_open, false);
+    search_line = config_file::instance().get_or_default(
+            configurations::viewer::search_term, std::string(""));
+    if (search_line != "") search_open = true;
+
+    available_dashboards["Frame Drops per Second"] = [&](std::string name){
+        return std::make_shared<frame_drops_dashboard>(name, &number_of_drops, &total_frames);
+    };
+
+    auto front = available_dashboards.begin();
+    dashboards.push_back(front->second(front->first));
+}
+
+bool output_model::round_indicator(ux_window& win, std::string icon,
+    int count, ImVec4 color, std::string tooltip, bool& highlighted, std::string suffix)
+{
+    std::stringstream ss;
+    ss << icon;
+    if (count > 0) ss << " " << count << suffix;
+    auto size = ImGui::CalcTextSize(ss.str().c_str());
+
+    if (count == 0 || (!is_output_open && !highlighted)) {
+        color = dark_sensor_bg;
+        ImGui::PushStyleColor(ImGuiCol_Text, header_color);
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, header_color);
+    }
+    else
+    {
+        if (!highlighted)
+        {
+            color = saturate(color, 0.3f);
+            ImGui::PushStyleColor(ImGuiCol_Text, white);
+        }
+        else
+            ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+    }
+
+    auto pos = ImGui::GetCursorScreenPos();
+    ImGui::GetWindowDrawList()->AddRectFilled({ pos.x, pos.y + 3 },
+                { pos.x + size.x + 15, pos.y + 27 }, ImColor(color), 12, 15);
+
+    auto res = ImGui::Button(ss.str().c_str(), ImVec2(size.x + 15, 28));
+    if (count > 0 && ImGui::IsItemHovered())
+    {
+        highlighted = true;
+        win.link_hovered();
+        ImGui::SetTooltip("%s", tooltip.c_str());
+    }
+    else highlighted = false;
+
+    ImGui::PopStyleColor(2);
+
+    return res;
+}
+
+void output_model::open(ux_window& win)
+{
+    is_output_open = true;
+    config_file::instance().set(configurations::viewer::output_open, true);
+    default_log_h = (win.height() - 100) / 2;
+    new_log = true;
+}
+
+void output_model::draw(ux_window& win, rect view_rect, std::vector<rs2::device> devices)
+{
+    ImGui::PushStyleColor(ImGuiCol_FrameBg, scrollbar_bg);
+
+    auto x = view_rect.x;
+    auto y = view_rect.y;
+    auto w = view_rect.w;
+    auto h = view_rect.h;
+
+    auto flags = ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoTitleBar |
+        ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings;
+
+    ImGui::PushStyleColor(ImGuiCol_WindowBg, sensor_bg);
+    ImGui::PushStyleColor(ImGuiCol_Button, transparent);
+    ImGui::PushStyleColor(ImGuiCol_ButtonActive, transparent);
+    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, transparent);
+    ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+    ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+
+    ImGui::PushFont(win.get_font());
+    ImGui::SetNextWindowPos({ x, y });
+    ImGui::SetNextWindowSize({ w, h });
+    ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(3, 3));
+
+    ImGui::Begin("Output", nullptr, flags);
+
+    ImGui::SetCursorPosX(w - 31);
+    if (!is_output_open)
+    {
+        if (ImGui::Button(u8"\uF139", ImVec2(28, 28)))
+        {
+            open(win);
+        }
+        if (ImGui::IsItemHovered())
+        {
+            win.link_hovered();
+            ImGui::SetTooltip("%s", "Open Debug Console Window");
+        }
+
+        if (default_log_h.value() != 36)
+            default_log_h = 36;
+    }
+    else
+    {
+        if (ImGui::Button(u8"\uF13A", ImVec2(28, 28)))
+        {
+            is_output_open = false;
+            config_file::instance().set(configurations::viewer::output_open, false);
+            default_log_h = 36;
+            search_open = false;
+        }
+        if (ImGui::IsItemHovered())
+        {
+            win.link_hovered();
+            ImGui::SetTooltip("%s", "Collapse Debug Console Window");
+        }
+
+        if (default_log_h.value() != (win.height() - 100) / 2)
+            default_log_h = (win.height() - 100) / 2;
+    }
+
+    ImGui::SameLine();
+    ImGui::SetCursorPosX(5);
+
+    if (errors_selected) errors_highlighted = true;
+    if (round_indicator(win, u8"\uF057", number_of_errors, redish, "Instances of logged errors", errors_highlighted))
+    {
+        errors_selected = !errors_selected;
+        open(win);
+    }
+    ImGui::SameLine();
+
+    if (warnings_selected) warnings_highlighted = true;
+    if (round_indicator(win, u8"\uF071", number_of_warnings, orange, "Instances of logged warnings", warnings_highlighted))
+    {
+        warnings_selected = !warnings_selected;
+        open(win);
+    }
+    ImGui::SameLine();
+
+    if (info_selected) info_highlighted = true;
+    if (round_indicator(win, u8"\uF05A", number_of_info, greenish, "Instances of logged info messages", info_highlighted))
+    {
+        info_selected = !info_selected;
+        open(win);
+    }
+    ImGui::SameLine();
+
+    if (!is_output_open || search_open)
+    {
+        ImGui::PushStyleColor(ImGuiCol_Text, header_color);
+    }
+    else
+    {
+        ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+    }
+    bool focus_search = false;
+    if (ImGui::Button(u8"\uF002", ImVec2(28, 28)))
+    {
+        focus_search = true;
+        search_open = true;
+        open(win);
+    }
+    if (ImGui::IsItemHovered())
+    {
+        win.link_hovered();
+        ImGui::SetTooltip("%s", "Search through logs");
+    }
+    ImGui::PopStyleColor(1);
+    ImGui::SameLine();
+
+    auto curr_x = ImGui::GetCursorPosX();
+    ImGui::SetCursorPosX(curr_x - 5);
+
+
+    int percent = total_frames ? 100 * ((double)number_of_drops / (total_frames)) : 0;
+
+    std::stringstream ss;
+    ss << u8"\uF043";
+    if (percent) ss << " " << percent << "%";
+    auto size = ImGui::CalcTextSize(ss.str().c_str());
+
+    char buff[1024];
+    memcpy(buff, search_line.c_str(), search_line.size());
+    buff[search_line.size()] = 0;
+
+    auto actual_search_width = w - size.x - 100 - curr_x;
+    if (focus_search) search_width = actual_search_width;
+
+    if (search_open && search_width.value() != actual_search_width)
+        search_width = actual_search_width;
+
+    // if (is_output_open && search_width < 1)
+    // {
+    //     search_open = true;
+    // }
+
+    if (search_open)
+    {
+        ImGui::PushFont(win.get_monofont());
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 4);
+        ImGui::PushItemWidth(search_width);
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, regular_blue);
+        if (ImGui::InputText("##SearchInLogs",buff, 1023))
+        {
+            search_line = buff;
+            config_file::instance().set(configurations::viewer::search_term, search_line);
+        }
+        if (focus_search) ImGui::SetKeyboardFocusHere();
+        ImGui::PopItemWidth();
+        ImGui::SameLine();
+        ImGui::PopStyleColor();
+        ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 4);
+        ImGui::PopFont();
+    }
+
+    ImGui::SetCursorPosX(w - size.x - 3 * 30);
+
+    if (enable_firmware_logs)
+    {
+        ImGui::PushStyleColor(ImGuiCol_Text, light_blue);
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, light_blue);
+    }
+    else
+    {
+        if (is_output_open)
+            ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+        else
+            ImGui::PushStyleColor(ImGuiCol_Text, header_color);
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+    }
+
+    if (ImGui::Button(u8"\uF2DB", ImVec2(28, 28)))
+    {
+        enable_firmware_logs = !enable_firmware_logs;
+    }
+    ImGui::PopStyleColor(2);
+    if (ImGui::IsItemHovered())
+    {
+        win.link_hovered();
+        if (enable_firmware_logs) ImGui::SetTooltip("%s", "Disable Firmware Logs");
+        else ImGui::SetTooltip("%s", "Enable Firmware Logs");
+    }
+    ImGui::SameLine();
+
+
+    if (round_indicator(win, u8"\uF043", percent, regular_blue, "Frame drops", drops_highlighted, "%"))
+    {
+        open(win);
+    }
+
+    if (is_output_open)
+    {
+        ImGui::SetCursorPos(ImVec2(3, 35));
+
+
+        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0,0));
+        ImGui::PushStyleColor(ImGuiCol_ChildWindowBg, dark_sensor_bg);
+
+        ImGui::BeginChild("##LogArea",
+            ImVec2(0.7f * w - 4, h - 38 - ImGui::GetTextLineHeightWithSpacing() - 1), true,
+            ImGuiWindowFlags_AlwaysVerticalScrollbar);
+
+        const auto log_area_width = 0.7f * w - 4;
+
+        bool copy_all = false;
+        bool save_all = false;
+        std::vector<std::string> output_strings;
+
+        auto time_now = glfwGetTime();
+
+        int i = 0;
+        foreach_log([&](log_entry& log) 
+        {
+            auto line = log.line;
+            if (log.line_number)
+            {
+                line = log.filename.substr(log.filename.find_last_of("/\\") + 1) + ":";
+                line += std::string(to_string() << log.line_number) + " - ";
+                line += log.line;
+            }
+
+            bool ok = false;
+            if (info_selected || warnings_selected || errors_selected)
+            {
+                if (info_selected && log.severity <= RS2_LOG_SEVERITY_INFO) ok = true;
+                if (warnings_selected && log.severity == RS2_LOG_SEVERITY_WARN) ok = true;
+                if (errors_selected && log.severity >= RS2_LOG_SEVERITY_ERROR) ok = true;
+            }
+            else ok = true;
+
+            if (search_line != "" && to_lower(line).find(to_lower(search_line)) == std::string::npos) ok = false;
+
+            if (!ok) return;
+
+            std::stringstream ss; ss << log.timestamp << " [" << rs2_log_severity_to_string(log.severity) << "] ";
+            if (log.line_number) ss << log.filename << ":" << log.line_number;
+            ss << " - " << log.line;
+            std::string full = ss.str();
+
+            ImGui::PushFont(win.get_monofont());
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, regular_blue);
+            ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
+            ImGui::PushStyleColor(ImGuiCol_FrameBg, transparent);
+
+            ImVec4 color = redish;
+            if (log.severity >= RS2_LOG_SEVERITY_ERROR)
+            {
+                color = redish;
+            } 
+            else if (log.severity >= RS2_LOG_SEVERITY_WARN)
+            {
+                color = orange;
+            } 
+            else
+            {
+                color = greenish;
+            }
+
+            auto margin = ImGui::GetTextLineHeightWithSpacing() - ImGui::GetTextLineHeight();
+            auto size = ImGui::CalcTextSize(line.c_str());
+            
+            auto t = single_wave(time_now - log.time_added + 0.3f) * 0.2f;
+            if (log.selected) t = 0.2f;
+
+            auto pos = ImGui::GetCursorScreenPos();
+            ImGui::GetWindowDrawList()->AddRectFilled({ pos.x, pos.y },
+                        { pos.x + log_area_width, pos.y + size.y + 2 * margin }, 
+                        ImColor(alpha(saturate(color, 0.3f + t), 0.7f + t)));
+            ImGui::GetWindowDrawList()->AddLine({ pos.x, pos.y + size.y + 2 * margin },
+                        { pos.x + log_area_width, pos.y + size.y + 2 * margin }, ImColor(alpha(color, 0.5f)));
+
+            ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 4);
+            ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 4);
+            ImGui::Text("%s", log.timestamp.c_str()); ImGui::SameLine();
+            ImGui::SetCursorPosX(ImGui::GetCursorPosX() - 4);
+            ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 4);
+
+            std::string label = to_string() << "##log_entry" << i++;
+            ImGui::InputTextEx(label.c_str(),
+                        (char*)line.data(),
+                        static_cast<int>(line.size() + 1),
+                        ImVec2(-1, size.y + margin),
+                        ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_ReadOnly);
+
+            ImGui::PushStyleColor(ImGuiCol_PopupBg, almost_white_bg);
+            ImGui::PushStyleColor(ImGuiCol_Text, black);
+            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, light_blue);
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+            ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(5,5));
+            label = to_string() << "##log_entry" << i << "_context_menu";
+            if (ImGui::BeginPopupContextItem(label.c_str())) 
+            {
+                log.selected = true;
+                ImGui::PushFont(win.get_font());
+                if (ImGui::Selectable("Copy Line")) {
+                    glfwSetClipboardString(win, full.c_str());
+                }
+                if (ImGui::Selectable("Copy All")) {
+                    copy_all = true;
+                }
+                if (ImGui::Selectable("Save As...")) {
+                    save_all = true;
+                }
+                ImGui::PopFont();
+                ImGui::EndPopup();
+            }
+            else log.selected = false;
+            ImGui::PopStyleVar();
+            ImGui::PopStyleColor(4);
+
+            ImGui::PopStyleColor(3);
+            ImGui::PopFont();
+            
+            ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 1);
+
+            output_strings.push_back(full);
+        });
+
+        std::stringstream ss;
+        for (auto&& s : output_strings) ss << s << "\n";
+        if (copy_all)
+            glfwSetClipboardString(win, ss.str().c_str());
+
+        if (save_all)
+        {
+            if (auto fn = file_dialog_open(file_dialog_mode::save_file, "Log File\0*.log\0", nullptr, nullptr))
+            {
+                std::ofstream out(fn);
+                if (out.good())
+                {
+                    out << ss.str();
+                }
+                out.close();
+            }
+        }
+
+        ImGui::EndChild();
+        ImGui::PopStyleVar();
+
+
+        ImGui::SetCursorPos(ImVec2(7, h - ImGui::GetTextLineHeightWithSpacing() - 2));
+        ImGui::Text("%s", u8"\uF120"); ImGui::SameLine();
+        ImGui::SetCursorPos(ImVec2(30, h - ImGui::GetTextLineHeightWithSpacing() - 4));
+
+
+        ImGui::PushFont(win.get_monofont());
+        ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, regular_blue);
+        ImGui::PushItemWidth(0.7f * w - 32);
+
+        bool force_refresh = false;
+
+        if (ImGui::IsKeyPressed(GLFW_KEY_UP) || ImGui::IsKeyPressed(GLFW_KEY_DOWN))
+        {
+            if (commands_histroy.size())
+            {
+                if (ImGui::IsKeyPressed(GLFW_KEY_UP)) history_offset = (history_offset + 1) % commands_histroy.size();
+                if (ImGui::IsKeyPressed(GLFW_KEY_DOWN)) history_offset = (history_offset - 1 + commands_histroy.size()) % commands_histroy.size();
+                command_line = commands_histroy[history_offset];
+
+                force_refresh = true;
+            }
+        }
+
+        if (ImGui::IsKeyPressed(GLFW_KEY_TAB))
+        {
+            if (!autocomplete.size() || !starts_with(to_lower(autocomplete.front()), to_lower(command_line)))
+            {
+                std::string commands_xml = config_file::instance().get(configurations::viewer::commands_xml);
+                std::ifstream f(commands_xml.c_str());
+                if (f.good())
+                {
+                    std::string str((std::istreambuf_iterator<char>(f)),
+                        std::istreambuf_iterator<char>());
+
+                    autocomplete.clear();
+                    std::regex exp("Command Name=\"(\\w+)\"");
+                    std::smatch res;
+                    std::string::const_iterator searchStart(str.cbegin());
+                    while (regex_search(searchStart, str.cend(), res, exp))
+                    {
+                        if (starts_with(to_lower(res[1]), to_lower(command_line)))
+                            autocomplete.push_back(res[1]);
+                        searchStart = res.suffix().first;
+                    }
+                }
+            }
+            if (autocomplete.size())
+            {
+                auto temp = autocomplete.front();
+                autocomplete.pop_front();
+                autocomplete.push_back(temp);
+
+                if (starts_with(to_lower(temp), command_line))
+                    command_line = to_lower(autocomplete.front());
+                else
+                    command_line = autocomplete.front();
+                force_refresh = true;
+            }
+        }
+
+        memcpy(buff, command_line.c_str(), command_line.size());
+        buff[command_line.size()] = 0;
+
+        int flags = ImGuiInputTextFlags_EnterReturnsTrue;
+        if (force_refresh) 
+        {
+            flags = ImGuiInputTextFlags_ReadOnly;
+        }
+
+        ImGui::PushStyleColor(ImGuiCol_FrameBg, scrollbar_bg);
+        if (ImGui::InputText("##TerminalCommand", buff, 1023, flags))
+        {
+            
+        }
+        if (!command_focus && !new_log) command_line = buff;
+        ImGui::PopStyleColor();
+        if (command_focus || new_log) ImGui::SetKeyboardFocusHere();
+        ImGui::PopFont();
+        ImGui::PopStyleColor();
+
+        if (ImGui::IsKeyPressed(GLFW_KEY_ENTER) || ImGui::IsKeyPressed(GLFW_KEY_KP_ENTER))
+        {
+            if (commands_histroy.size() > 100) commands_histroy.pop_back();
+            commands_histroy.push_front(command_line);
+            run_command(command_line, devices);
+            command_line = "";
+            command_focus = true;
+        }
+        else command_focus = false;
+
+        if (ImGui::IsKeyPressed(GLFW_KEY_ESCAPE))
+        {
+            command_line = "";
+        }
+
+        ImGui::SetCursorPos(ImVec2(0.7f * w - 2, 35));
+        ImGui::BeginChild("##StatsArea",ImVec2(0.3f * w - 2, h - 38), true);
+
+        auto top = 0;
+        for(auto&& dash : dashboards)
+        {   
+            auto h = dash->get_height();
+            auto r = rect { 0.f, (float)top, 0.3f * w - 2, (float)h };
+            dash->draw(win, r);
+            top += h;
+        }
+
+        dashboards.erase(std::remove_if(dashboards.begin(), dashboards.end(), 
+        [](std::shared_ptr<stream_dashboard> p){
+            return p->closing();
+        }), dashboards.end());
+
+        bool can_add = false;
+        for (auto&& kvp : available_dashboards)
+        {
+            auto name = kvp.first;
+            auto it = std::find_if(dashboards.begin(), dashboards.end(),
+            [name](std::shared_ptr<stream_dashboard> p){
+                return p->get_name() == name;
+            });
+            if (it == dashboards.end()) can_add = true;
+        }
+
+        if (can_add)
+        {
+            ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
+            const auto new_dashboard_name = "new_dashaborad";
+            if (ImGui::Button(u8"\uF0D0 Add Dashboard", ImVec2(-1, 25)))
+            {
+                ImGui::OpenPopup(new_dashboard_name);
+            }
+
+            if (ImGui::IsItemHovered())
+            {
+                ImGui::SetTooltip("Add one of the available stream dashboards to view");
+                win.link_hovered();
+            }
+
+            ImGui::PushStyleColor(ImGuiCol_PopupBg, almost_white_bg);
+            ImGui::PushStyleColor(ImGuiCol_Text, black);
+            ImGui::PushStyleColor(ImGuiCol_HeaderHovered, light_blue);
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, white);
+            ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(5,5));
+            if (ImGui::BeginPopup(new_dashboard_name))
+            {
+                for (auto&& kvp : available_dashboards)
+                {
+                    auto name = kvp.first;
+                    auto it = std::find_if(dashboards.begin(), dashboards.end(),
+                    [name](std::shared_ptr<stream_dashboard> p){
+                        return p->get_name() == name;
+                    });
+                    if (it == dashboards.end())
+                    {
+                        name = name + "##New";
+                        bool selected = false;
+                        if (ImGui::Selectable(name.c_str(), &selected))
+                        {
+                            dashboards.push_back(kvp.second(kvp.first));
+                        }
+                    }
+                }
+
+                ImGui::EndPopup();
+            }
+
+            ImGui::PopStyleColor(4);
+            ImGui::PopStyleVar();
+        }
+        
+
+        ImGui::EndChild();
+
+
+        ImGui::PopStyleColor();
+    }
+    else foreach_log([&](log_entry& log) {});
+    
+
+    ImGui::End();
+    ImGui::PopStyleColor(7);
+    ImGui::PopStyleVar();
+    ImGui::PopFont();
+
+    {
+        std::lock_guard<std::mutex> lock(devices_mutex);
+        this->devices = devices;
+    }
+}
+
+void output_model::foreach_log(std::function<void(log_entry& line)> action)
+{
+    std::lock_guard<std::recursive_mutex> lock(m);
+
+    // Process only the messages that are available upon invocation
+    log_entry le;
+    for (size_t len = 0; len < incoming_log_queue.size(); len++)
+    {
+        if (incoming_log_queue.try_dequeue(&le))
+        {
+            if (le.severity >= RS2_LOG_SEVERITY_ERROR) number_of_errors++;
+            else if (le.severity >= RS2_LOG_SEVERITY_WARN) number_of_warnings++;
+            else number_of_info++;
+
+            notification_logs.push_back(le);
+        }
+    }
+
+    // Limit the notification window
+    while (notification_logs.size() > 1000)
+    {
+        auto&& le = notification_logs.front();
+        if (le.severity >= RS2_LOG_SEVERITY_ERROR) number_of_errors--;
+        else if (le.severity >= RS2_LOG_SEVERITY_WARN) number_of_warnings--;
+        else number_of_info--;
+        notification_logs.pop_front();
+    }
+
+    for (auto&& l : notification_logs)
+        action(l);
+
+    if (new_log)
+    {
+        ImGui::SetScrollPosHere();
+        new_log = false;
+    }
+}
+
+// Callback function must not include mutex
+void output_model::add_log(rs2_log_severity severity, std::string filename, int line_number, std::string line)
+{
+    if (!line.size()) return;
+
+    time_t rawtime;
+    struct tm * timeinfo;
+    char buffer[80];
+    time (&rawtime);
+    timeinfo = localtime(&rawtime);
+    strftime(buffer,sizeof(buffer),"%H:%M:%S",timeinfo);
+
+    log_entry e;
+    e.line = line;
+    e.line_number = line_number;
+    e.filename = filename;
+    e.severity = severity;
+    e.timestamp = buffer;
+    e.time_added = glfwGetTime();
+
+    incoming_log_queue.enqueue(std::move(e));
+    new_log = true;
+}
+
+void output_model::run_command(std::string command, std::vector<rs2::device> devices)
+{
+    try
+    {
+        if (to_lower(command) == "clear")
+        {
+            while (notification_logs.size() > 0)
+            {
+                auto&& le = notification_logs.front();
+                if (le.severity >= RS2_LOG_SEVERITY_ERROR) number_of_errors--;
+                else if (le.severity >= RS2_LOG_SEVERITY_WARN) number_of_warnings--;
+                else number_of_info--;
+                notification_logs.pop_front();
+                for (auto& d : dashboards)
+                    d->clear(true);
+            }
+
+            return;
+        }
+
+        std::regex e("([0-9A-Fa-f]{2}\\s)+");
+
+        if (std::regex_match(command, e))
+        {
+            add_log(RS2_LOG_SEVERITY_INFO, __FILE__, 0, to_string() << "Trying to send " << command << "...");
+
+            std::vector<uint8_t> raw_data;
+            std::stringstream ss(command);
+            std::string word;
+            while (ss >> word)
+            {
+                std::stringstream converter;
+                int temp;
+                converter << std::hex << word;
+                converter >> temp;
+                raw_data.push_back(temp);
+            }
+            if (raw_data.empty())
+                throw std::runtime_error("Invalid input!");
+
+            bool found = false;
+            for (auto&& dev : devices)
+            {
+                if (auto dbg = dev.as<rs2::debug_protocol>())
+                {
+                    found = true;
+                    auto res = dbg.send_and_receive_raw_data(raw_data);
+
+                    std::stringstream ss; 
+                    int i = 0;
+                    for (auto& elem : res)
+                    {
+                        ss << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(elem) << " ";
+                        i++;
+                        if (i > 80) 
+                        {
+                            ss << "\n";
+                            i = 0;
+                        }
+                    }
+                    add_log(RS2_LOG_SEVERITY_INFO, __FILE__, 0, ss.str());
+
+                    return;
+                }
+            }
+
+            if (!found)
+            {
+                add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, "No device is available to receive the command");
+                return;
+            }
+        }
+
+        std::string commands_xml = config_file::instance().get(configurations::viewer::commands_xml);
+        std::ifstream f(commands_xml.c_str());
+        if (f.good())
+        {
+            std::string str((std::istreambuf_iterator<char>(f)),
+                             std::istreambuf_iterator<char>());
+            auto terminal_parser = rs2::terminal_parser(str);
+
+            auto buffer = terminal_parser.parse_command(to_lower(command));
+
+            std::stringstream ss; ss << command << " = ";
+            for (auto& elem : buffer)
+                 ss << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(elem) << " ";
+
+            add_log(RS2_LOG_SEVERITY_INFO, __FILE__, 0, ss.str());
+
+            bool found = false;
+            for (auto&& dev : devices)
+            {
+                if (auto dbg = dev.as<rs2::debug_protocol>())
+                {
+                    found = true;
+                    auto res = dbg.send_and_receive_raw_data(buffer);
+
+                    std::string response = to_string() << "\n" << terminal_parser.parse_response(to_lower(command), res);
+                    add_log(RS2_LOG_SEVERITY_INFO, __FILE__, 0, response);
+                }
+            }
+
+            if (!found)
+                add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, "No device is available to receive the command");
+
+            return;
+        }
+
+        add_log(RS2_LOG_SEVERITY_WARN, __FILE__, __LINE__, to_string() << "Unrecognized command '" << command << "'");
+    } 
+    catch(const std::exception& ex)
+    {
+        add_log(RS2_LOG_SEVERITY_ERROR, __FILE__, __LINE__, ex.what());
+    }
+}
+
+void output_model::update_dashboards(rs2::frame f)
+{
+    for (auto&& d : dashboards)
+        d->add_frame(f);
+}
+
+void stream_dashboard::draw_dashboard(ux_window& win, rect& r)
+{
+    auto min_x = 0.f;
+    auto max_x = 1.f;
+    auto min_y = 0.f;
+    auto max_y = 1.f;
+
+    if (xy.size())
+    {
+        min_x = xy[0].first;
+        max_x = xy[0].first;
+        min_y = xy[0].second;
+        max_y = xy[0].second;
+        for (auto&& p : xy)
+        {
+            min_x = std::min(min_x, p.first);
+            min_y = std::min(min_y, p.second);
+            max_x = std::max(max_x, p.first);
+            max_y = std::max(max_y, p.second);
+        }
+    }
+
+    auto gap_y = max_y - min_y;
+    auto gap_x = max_x - min_x;
+    auto height_y = r.h - 2 * ImGui::GetTextLineHeight() - 10;
+    auto ticks_y = ceil(height_y / ImGui::GetTextLineHeight());
+
+    auto max_y_label_width = 0.f;
+    for (int i = 0; i <= ticks_y; i++)
+    {
+        auto y = max_y - i * (gap_y / ticks_y);
+        std::string y_label = to_string() << std::fixed << std::setprecision(2) << y;
+        auto size = ImGui::CalcTextSize(y_label.c_str());
+        max_y_label_width = std::max(max_y_label_width, 
+            size.x);
+    }
+
+    auto pos = ImGui::GetCursorScreenPos();
+
+    ImGui::PushStyleColor(ImGuiCol_Text, white);
+
+    ImGui::GetWindowDrawList()->AddRectFilled({ pos.x, pos.y },
+                { pos.x + r.w - 1, pos.y + get_height() - 1 }, ImColor(header_color));
+    ImGui::GetWindowDrawList()->AddRect({ pos.x, pos.y },
+                { pos.x + r.w, pos.y + get_height() }, ImColor(dark_sensor_bg));
+
+    auto size = ImGui::CalcTextSize(name.c_str());
+    ImGui::SetCursorPos(ImVec2( r.w / 2 - size.x / 2, 5 ));
+    ImGui::Text("%s", name.c_str());
+    ImGui::SameLine();
+
+    ImGui::PushStyleColor(ImGuiCol_Text, grey);
+    ImGui::SetCursorPosX(r.w - 25);
+    ImGui::SetCursorPosY(3);
+    std::string id = to_string() << u8"\uF00D##Close_" << name;
+    if (ImGui::Button(id.c_str(),ImVec2(22,22)))
+    {
+        close();
+    }
+    if (ImGui::IsItemHovered())
+    {
+        ImGui::SetTooltip("Remove Dashboard from View");
+        win.link_hovered();
+    }
+    ImGui::PopStyleColor();
+
+    ImGui::GetWindowDrawList()->AddRectFilled({ pos.x + max_y_label_width + 15, pos.y + ImGui::GetTextLineHeight() + 5 },
+                 { pos.x + r.w - 10, pos.y + r.h - ImGui::GetTextLineHeight() - 5 }, ImColor(almost_white_bg));
+
+    //ImGui::PushFont(win.get_monofont());
+    for (int i = 0; i <= ticks_y; i++)
+    {
+        auto y = max_y - i * (gap_y / ticks_y);
+        std::string y_label = to_string() << std::fixed << std::setprecision(2) << y;
+        auto y_pixel = ImGui::GetTextLineHeight() + i * (height_y / ticks_y);
+        ImGui::SetCursorPos(ImVec2( 10, y_pixel ));
+        ImGui::Text("%s", y_label.c_str());
+
+        ImGui::GetWindowDrawList()->AddLine({ pos.x + max_y_label_width + 15, pos.y + y_pixel + 5 },
+                 { pos.x + r.w - 10, pos.y + y_pixel + 5 }, ImColor(light_grey));
+    }
+
+    auto graph_width = r.w - max_y_label_width - 25;
+
+    int ticks_x = 2;
+    bool has_room = true;
+    while (has_room)
+    {
+        auto total = 0;
+        for (int i = 0; i <= ticks_x; i++)
+        {
+            auto x = min_x + i * (gap_x / ticks_x);
+            std::string x_label = to_string() << std::fixed << std::setprecision(2) << x;
+            auto size = ImGui::CalcTextSize(x_label.c_str());
+            total += size.x;
+        }
+        if (total < graph_width) ticks_x++;
+        else has_room = false;
+    }
+    ticks_x -= 3;
+
+    for (int i = 0; i < ticks_x; i++)
+    {
+        auto x = min_x + i * (gap_x / ticks_x);
+        std::string x_label = to_string() << std::fixed << std::setprecision(2) << x;
+        ImGui::SetCursorPos(ImVec2( 15 + max_y_label_width+ i * (graph_width / ticks_x), r.h - ImGui::GetTextLineHeight() ));
+        ImGui::Text("%s", x_label.c_str());
+
+        ImGui::GetWindowDrawList()->AddLine({ pos.x + 15 + max_y_label_width + i * (graph_width / ticks_x), pos.y + ImGui::GetTextLineHeight() + 5 },
+                 { pos.x + max_y_label_width + 15 + i * (graph_width / ticks_x), pos.y + ImGui::GetTextLineHeight() + 5 + height_y }, ImColor(light_grey));
+    }
+
+    std::sort(xy.begin(), xy.end(), [](const std::pair<float, float>& a, const std::pair<float, float>& b) { return a.first < b.first; });
+
+    for (int i = 0; i + 1 < xy.size(); i++)
+    {
+        auto x0 = xy[i].first;
+        auto y0 = xy[i].second;
+
+        auto x1 = xy[i+1].first;
+        auto y1 = xy[i+1].second;
+
+        x0 = (x0 - min_x) / (max_x - min_x);
+        x1 = (x1 - min_x) / (max_x - min_x);
+
+        y0 = (y0 - min_y) / (max_y - min_y);
+        y1 = (y1 - min_y) / (max_y - min_y);
+
+        ImGui::GetWindowDrawList()->AddLine({ pos.x + 15 + max_y_label_width + x0 * graph_width, pos.y + ImGui::GetTextLineHeight() + 5 + height_y * (1.f - y0) },
+                 { pos.x + 15 + max_y_label_width + x1 * graph_width, pos.y + ImGui::GetTextLineHeight() + 5 + height_y * (1.f - y1) }, ImColor(black));
+    }
+
+    //ImGui::PopFont();
+    ImGui::PopStyleColor();
+
+    xy.clear();
+}
+
+void frame_drops_dashboard::process_frame(rs2::frame f)
+{
+    write_shared_data([&](){
+        double ts = glfwGetTime();
+        if (method == 1) ts = f.get_timestamp() / 1000.f;
+        auto it = stream_to_time.find(f.get_profile().unique_id());
+        if (it != stream_to_time.end())
+        {
+            auto last = stream_to_time[f.get_profile().unique_id()];
+
+            auto fps = f.get_profile().fps();
+
+            if (f.supports_frame_metadata(RS2_FRAME_METADATA_ACTUAL_FPS))
+                fps = f.get_frame_metadata(RS2_FRAME_METADATA_ACTUAL_FPS);
+
+            if (1000.f * (ts - last) > 1.5f * (1000.f / fps)) {
+                drops++;
+            }
+        }
+
+        counter++;
+
+        if (ts - last_time > 1.f)
+        {
+            if (drops_history.size() > 100) drops_history.pop_front();
+            drops_history.push_back(drops);
+            *total = counter;
+            *frame_drop_count = drops;
+            drops = 0;
+            last_time = ts;
+            counter = 0;
+        }
+
+        stream_to_time[f.get_profile().unique_id()] = ts;
+    });
+}
+
+void frame_drops_dashboard::draw(ux_window& win, rect r)
+{
+    auto hist = read_shared_data<std::deque<int>>([&](){ return drops_history; });
+    for (int i = 0; i < hist.size(); i++)
+    {
+        add_point(i, hist[i]);
+    }
+    r.h -= ImGui::GetTextLineHeightWithSpacing() + 10;
+    draw_dashboard(win, r);
+
+    ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 40);
+    ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 3);
+    ImGui::Text("%s", "Measurement Metric:"); ImGui::SameLine();
+    ImGui::SetCursorPosY(ImGui::GetCursorPosY() - 3);
+
+    ImGui::SetCursorPosX(200);
+
+    std::vector<const char*> methods;
+    methods.push_back("Viewer Processing Rate");
+    methods.push_back("Camera Timestamp Rate");
+
+    ImGui::PushItemWidth(r.w - 207);
+    if (ImGui::Combo("##fps_method", &method, methods.data(), methods.size()))
+    {
+        clear(false);
+    }
+    ImGui::PopItemWidth();
+}
+
+int frame_drops_dashboard::get_height() const 
+{ 
+    return 160.f + ImGui::GetTextLineHeightWithSpacing(); 
+}
+
+void frame_drops_dashboard::clear(bool full) 
+{ 
+    write_shared_data([&](){
+        stream_to_time.clear();
+        last_time = 0;
+        *total = 0;
+        *frame_drop_count = 0;
+        if (full)
+        {
+            drops_history.clear();
+            for (int i = 0; i < 100; i++)
+                drops_history.push_back(0);
+        }
+    });
+}
diff --git a/common/output-model.h b/common/output-model.h
new file mode 100644
index 0000000..b1c9028
--- /dev/null
+++ b/common/output-model.h
@@ -0,0 +1,187 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <functional>
+#include <string>
+
+#include "ux-window.h"
+#include "rendering.h"
+
+#include "../src/concurrency.h"
+
+namespace rs2
+{
+    class stream_dashboard
+    {
+    public:
+        stream_dashboard(std::string name, int size) : q(size), name(name), t([this](){ thread_function(); }) {}
+        virtual ~stream_dashboard()
+        {
+            stop = true;
+            t.join();
+        }
+
+        std::string get_name() const { return name; }
+
+        void add_frame(rs2::frame f) { q.enqueue(f); }
+
+        virtual void draw(ux_window& win, rect r) = 0;
+
+        virtual int get_height() const { return 150.f; }
+
+        virtual void clear(bool full = false) {}
+
+        void close() { to_close = true; }
+        bool closing() const { return to_close; }
+
+    protected:
+        virtual void process_frame(rs2::frame f) = 0;
+
+        void write_shared_data(std::function<void()> action)
+        {
+            std::lock_guard<std::mutex> lock(m);
+            action();
+        }
+
+        template<class T>
+        T read_shared_data(std::function<T()> action)
+        {
+            std::lock_guard<std::mutex> lock(m);
+            T res = action();
+            return res;
+        }
+
+        void add_point(float x, float y) { xy.push_back(std::make_pair(x, y)); }
+        
+        void draw_dashboard(ux_window& win, rect& r);
+
+    private:
+        void thread_function()
+        {
+            while(!stop)
+            {
+                rs2::frame f;
+                if (q.try_wait_for_frame(&f, 100))
+                    process_frame(f);
+            }
+        }
+        std::string name;
+        rs2::frame_queue q;
+        std::mutex m;
+        std::atomic<int> stop { false };
+        std::thread t;
+        std::vector<std::pair<float, float>> xy;
+        bool to_close = false;
+    };
+
+    class frame_drops_dashboard : public stream_dashboard
+    {
+    public:
+        frame_drops_dashboard(std::string name, int* frame_drop_count, int* total) 
+            : stream_dashboard(name, 30), 
+              last_time(glfwGetTime()), frame_drop_count(frame_drop_count), total(total) 
+        {
+            clear(true);
+        }
+
+        void process_frame(rs2::frame f) override;
+        void draw(ux_window& win, rect r) override;
+        int get_height() const override;
+
+        void clear(bool full) override;
+
+    private:
+        std::map<int, double> stream_to_time;
+        int drops = 0;
+        double last_time;
+        std::deque<int> drops_history;
+        int *frame_drop_count, *total;
+        int counter = 0;
+        int method = 0;
+    };
+
+    class output_model
+    {
+    public:
+        struct log_entry
+        {
+            std::string line = "";
+            std::string filename = "";
+            rs2_log_severity severity = RS2_LOG_SEVERITY_FATAL;
+            int line_number = 0;
+            double time_added = 0.0;
+            std::string timestamp = "";
+            bool selected = false;
+        };
+
+        void update_dashboards(rs2::frame f);
+
+        output_model();
+        ~output_model();
+
+        void add_log(rs2_log_severity severity, std::string filename, int line_number, std::string line);
+
+        void draw(ux_window& win, rect view_rect, std::vector<rs2::device> devices);
+
+        int get_output_height() const { return default_log_h; }
+
+        void run_command(std::string command, std::vector<rs2::device> devices);
+
+    private:
+        void open(ux_window& win);
+
+        void foreach_log(std::function<void(log_entry& line)> action);
+        bool round_indicator(ux_window& win, std::string icon, int count, 
+            ImVec4 color, std::string tooltip, bool& highlighted, std::string suffix = "");
+
+        bool new_log = false;
+        std::recursive_mutex m;
+
+        single_consumer_queue<log_entry> incoming_log_queue;
+        std::deque<log_entry> notification_logs;
+
+        animated<int> default_log_h { 36 };
+        bool is_output_open = true;
+
+        bool enable_firmware_logs = false;
+
+        bool errors_selected = false;
+        bool warnings_selected = false;
+        bool info_selected = false;
+
+        bool errors_highlighted = false;
+        bool warnings_highlighted = false;
+        bool info_highlighted = false;
+        bool drops_highlighted = false;
+
+        int number_of_errors = 0;
+        int number_of_warnings = 0;
+        int number_of_info = 0;
+        int number_of_drops = 0;
+        int total_frames = 0;
+
+        animated<int> search_width { 0, std::chrono::milliseconds(400) };
+        bool search_open = false;
+
+        std::deque<std::string> autocomplete;
+
+        std::mutex devices_mutex;
+        std::vector<rs2::device> devices;
+
+        std::string search_line { "" };
+        std::string command_line { "" };
+        std::deque<std::string> commands_histroy;
+        int history_offset = 0;
+        bool command_focus = true;
+
+        std::vector<std::shared_ptr<stream_dashboard>> dashboards;
+        std::map<std::string, std::function<std::shared_ptr<stream_dashboard>(std::string)>> available_dashboards;
+
+        std::atomic<int> to_stop { 0 };
+        std::thread fw_logger;
+
+        void thread_loop();
+    };
+}
diff --git a/common/parser.hpp b/common/parser.hpp
index e07acd6..c52005d 100644
--- a/common/parser.hpp
+++ b/common/parser.hpp
@@ -160,7 +160,7 @@ struct custom_formatter {
     std::vector<kvp> kv;
 };
 
-struct command
+typedef struct command
 {
     std::string name;
     unsigned int op_code;
@@ -179,7 +179,7 @@ struct command
 
     data read_data;
     std::vector<parameter> parameters;
-};
+} command_from_xml;
 
 // units of nibbles
 enum FormatSize {
@@ -190,7 +190,7 @@ enum FormatSize {
 
 struct commands_xml
 {
-    std::map<std::string, command> commands;
+    std::map<std::string, command_from_xml> commands;
     std::map<std::string, custom_formatter> custom_formatters;
 };
 
@@ -253,7 +253,7 @@ inline void parse_xml_from_memory(const char * content, commands_xml& cmd_xml)
     {
         if (!strcmp(NodeI->name(), "Command"))
         {
-            command cmd;
+            command_from_xml cmd;
             for (auto AttI = NodeI->first_attribute(); AttI; AttI = AttI->next_attribute())
             {
                 std::string value = AttI->value();
@@ -323,7 +323,7 @@ inline void parse_xml_from_memory(const char * content, commands_xml& cmd_xml)
                     }
                 }
             }
-            cmd_xml.commands.insert(std::pair<std::string, command>(to_lower(cmd.name), cmd));
+            cmd_xml.commands.insert(std::pair<std::string, command_from_xml>(to_lower(cmd.name), cmd));
         }
         else if (!strcmp(NodeI->name(), "CustomFormatter"))
         {
@@ -538,7 +538,7 @@ inline void update_sections_data(const uint8_t* data_offset, std::vector<section
     }
 }
 
-inline void decode_string_from_raw_data(const command& command, const std::map<std::string, custom_formatter>& custom_formatters, const uint8_t* raw_data_offset, size_t data_size, std::string& output, const std::map<std::string, xml_parser_function>& format_type_to_lambda)
+inline void decode_string_from_raw_data(const command_from_xml& command, const std::map<std::string, custom_formatter>& custom_formatters, const uint8_t* raw_data_offset, size_t data_size, std::string& output, const std::map<std::string, xml_parser_function>& format_type_to_lambda)
 {
     auto data_offset = raw_data_offset + 4;
     data_size -= 4;
@@ -675,7 +675,7 @@ inline void decode_string_from_raw_data(const command& command, const std::map<s
     output = ss_output.str();
 }
 
-inline void encode_raw_data_command(const command& xml_cmd_info, const std::vector<parameter>& params, std::vector<uint8_t>& raw_data)
+inline void encode_raw_data_command(const command_from_xml& xml_cmd_info, const std::vector<parameter>& params, std::vector<uint8_t>& raw_data)
 {
     auto cmd_op_code = xml_cmd_info.op_code;
     auto is_cmd_writes_data = xml_cmd_info.is_cmd_write_data;
diff --git a/common/rendering.h b/common/rendering.h
index 59d5bed..5d70b6e 100644
--- a/common/rendering.h
+++ b/common/rendering.h
@@ -887,7 +887,7 @@ namespace rs2
             }),
                 _measurements.end());
             auto trues = std::count_if(_measurements.begin(), _measurements.end(),
-                [this](std::pair<clock::time_point, bool> pair) {
+                [](std::pair<clock::time_point, bool> pair) {
                 return pair.second;
             });
             return size_t(trues) / (float)_measurements.size(); 
@@ -1019,7 +1019,6 @@ namespace rs2
                     {
                         // Upload vertices
                         data = pc.get_vertices();
-                        auto v = pc.get_vertices();
                         glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, width, height, 0, GL_RGB, GL_FLOAT, data);
                     }
                     else
@@ -1581,6 +1580,43 @@ namespace rs2
         }
     };
 
+    // Helper class that lets smoothly animate between its values
+    template<class T>
+    class animated
+    {
+    private:
+        T _old, _new;
+        std::chrono::system_clock::time_point _last_update;
+        std::chrono::system_clock::duration _duration;
+    public:
+        animated(T def, std::chrono::system_clock::duration duration = std::chrono::milliseconds(200))
+            : _duration(duration), _old(def), _new(def)
+        {
+            _last_update = std::chrono::system_clock::now();
+        }
+        animated& operator=(const T& other)
+        {
+            if (other != _new)
+            {
+                _old = get();
+                _new = other;
+                _last_update = std::chrono::system_clock::now();
+            }
+            return *this;
+        }
+        T get() const
+        {
+            auto now = std::chrono::system_clock::now();
+            auto ms = std::chrono::duration_cast<std::chrono::microseconds>(now - _last_update).count();
+            auto duration_ms = std::chrono::duration_cast<std::chrono::microseconds>(_duration).count();
+            auto t = (float)ms / duration_ms;
+            t = std::max(0.f, std::min(rs2::smoothstep(t, 0.f, 1.f), 1.f));
+            return _old * (1.f - t) + _new * t;
+        }
+        operator T() const { return get(); }
+        T value() const { return _new; }
+    };
+
     inline bool is_integer(float f)
     {
         return (fabs(fmod(f, 1)) < std::numeric_limits<float>::min());
@@ -1656,7 +1692,7 @@ namespace rs2
     inline float single_wave(float x)
     {
         auto c = clamp(x, 0.f, 1.f);
-        return 0.5f * (sinf(2.f * M_PI * c - M_PI_2) + 1.f);
+        return 0.5f * (sinf(2.f * float(M_PI) * c - float(M_PI_2)) + 1.f);
     }
 
     // convert 3d points into 2d viewport coordinates
@@ -1710,8 +1746,7 @@ namespace rs2
         auto mvp = pc * vc * fc;
 
         // test - origin (0, 0, -1.0, 1) should be translated into (0, 0, 0, 0) at this point
-        float4 origin{ 0.f, 0.f, -1.f, 1.f };
-        float4 projected = mvp * origin;
+        //float4 origin{ 0.f, 0.f, -1.f, 1.f };
 
         // translate 3d vertex into 2d windows coordinates
         float4 p3d;
@@ -1737,8 +1772,8 @@ namespace rs2
         p2d.z = clamp(p2d.z, -1.0, 1.0);
 
         // viewport coordinates
-        float x_vp = round((p2d.x + 1.0) / 2.0 * vp[2]) + vp[0];
-        float y_vp = round((p2d.y + 1.0) / 2.0 * vp[3]) + vp[1];
+        float x_vp = round((p2d.x + 1.f) / 2.f * vp[2]) + vp[0];
+        float y_vp = round((p2d.y + 1.f) / 2.f * vp[3]) + vp[1];
 
         float2 p_w;
         p_w.x = x_vp;
diff --git a/common/sw-update/dev-updates-profile.cpp b/common/sw-update/dev-updates-profile.cpp
index dbb4f7e..8d65a4c 100644
--- a/common/sw-update/dev-updates-profile.cpp
+++ b/common/sw-update/dev-updates-profile.cpp
@@ -71,9 +71,9 @@ namespace rs2
             bool query_ok = up_handler.query_versions(dev_name, part, policy, required_version);
             if (query_ok)
             {
-                auto dl_link_ok = up_handler.get_version_download_link(part, required_version, result.download_link);
-                auto rel_ok = up_handler.get_version_release_notes(part, required_version, result.release_page);
-                auto desc_ok = up_handler.get_version_description(part, required_version, result.description);
+                //auto dl_link_ok = up_handler.get_version_download_link(part, required_version, result.download_link);
+                //auto rel_ok = up_handler.get_version_release_notes(part, required_version, result.release_page);
+                //auto desc_ok = up_handler.get_version_description(part, required_version, result.description);
                 result.ver = required_version;
 
                 std::stringstream ss;
diff --git a/common/sw-update/http-downloader.cpp b/common/sw-update/http-downloader.cpp
index 6a8c7c7..45a6251 100644
--- a/common/sw-update/http-downloader.cpp
+++ b/common/sw-update/http-downloader.cpp
@@ -79,7 +79,6 @@ namespace rs2
             if (input_stream && output)
             {
                 std::ofstream &out_stream(*static_cast<std::ofstream*> (output));
-                uint8_t* source_bytes(static_cast<uint8_t*>(input_stream));
 
                 size_t num_of_bytem(nmemb*size);
                 out_stream.write((char *)input_stream, num_of_bytem);
diff --git a/common/sw-update/versions-db-manager.cpp b/common/sw-update/versions-db-manager.cpp
index 523de59..52ecdfc 100644
--- a/common/sw-update/versions-db-manager.cpp
+++ b/common/sw-update/versions-db-manager.cpp
@@ -85,7 +85,7 @@ namespace rs2
 
             // Look for the required version
             auto res = std::find_if(_server_versions_vec.begin(), _server_versions_vec.end(),
-                [this, version, component_str, platform](std::unordered_map<std::string, std::string> version_map)
+                [version, component_str, platform](std::unordered_map<std::string, std::string> version_map)
             {
                 return (versions_db_manager::version(version_map["version"]) == version && component_str == version_map["component"] && (platform == version_map["platform"] || version_map["platform"] == "*"));
             });
diff --git a/common/ux-window.cpp b/common/ux-window.cpp
index 1814a8f..efbb2bd 100644
--- a/common/ux-window.cpp
+++ b/common/ux-window.cpp
@@ -44,6 +44,8 @@ namespace rs2
         config_file::instance().set_default(configurations::update::allow_rc_firmware, false);
         config_file::instance().set_default(configurations::update::recommend_calibration, true);
         config_file::instance().set_default(configurations::update::recommend_updates, true);
+        config_file::instance().set_default(configurations::update::sw_updates_url, server_versions_db_url);
+        config_file::instance().set_default(configurations::update::sw_updates_official_server, true);
 
         config_file::instance().set_default(configurations::window::is_fullscreen, false);
         config_file::instance().set_default(configurations::window::saved_pos, false);
@@ -69,8 +71,12 @@ namespace rs2
         config_file::instance().set_default(configurations::ply::use_normals, false);
         config_file::instance().set_default(configurations::ply::encoding, configurations::ply::binary);
 
+        config_file::instance().set_default(configurations::viewer::commands_xml, "./Commands.xml");
+        config_file::instance().set_default(configurations::viewer::hwlogger_xml, "./HWLoggerEvents.xml");
+
 #ifdef __APPLE__
-        config_file::instance().set_default(configurations::performance::font_oversample, 8);
+
+        config_file::instance().set_default(configurations::performance::font_oversample, 2);
         config_file::instance().set_default(configurations::performance::enable_msaa, true);
         config_file::instance().set_default(configurations::performance::msaa_samples, 4);
         // On Mac-OS, mixing OpenGL 2 with OpenGL 3 is not supported by the driver
@@ -340,7 +346,7 @@ namespace rs2
             _2d_vis = std::make_shared<visualizer_2d>(std::make_shared<splash_screen_shader>());
 
         // Load fonts to be used with the ImGui - TODO move to RAII
-        imgui_easy_theming(_font_14, _font_18);
+        imgui_easy_theming(_font_14, _font_18, _monofont);
 
         // Register for UI-controller events
         glfwSetWindowUserPointer(_win, this);
@@ -395,7 +401,7 @@ namespace rs2
 
     ux_window::ux_window(const char* title, context &ctx) :
         _win(nullptr), _width(0), _height(0), _output_height(0),
-        _font_14(nullptr), _font_18(nullptr), _app_ready(false),
+        _font_14(nullptr), _font_18(nullptr), _monofont(nullptr), _app_ready(false),
         _first_frame(true), _query_devices(true), _missing_device(false),
         _hourglass_index(0), _dev_stat_message{}, _keep_alive(true), _title(title), _ctx(ctx)
     {
@@ -595,6 +601,7 @@ namespace rs2
             glfwSetCursor(_win, nullptr);
         _cross_hovered = false;
         _link_hovered = false;
+        _hovers_any_input_window = false;
 
         return res;
     }
diff --git a/common/ux-window.h b/common/ux-window.h
index 1ad2394..9244e58 100644
--- a/common/ux-window.h
+++ b/common/ux-window.h
@@ -60,6 +60,7 @@ namespace rs2
         void reset();
 
         ImFont* get_large_font() const { return _font_18; }
+        ImFont* get_monofont() const { return _monofont; }
         ImFont* get_font() const { return _font_14; }
 
         rs2::mouse_info& get_mouse() { return _mouse; }
@@ -78,6 +79,9 @@ namespace rs2
         void link_hovered();
         void cross_hovered();
 
+        void set_hovered_over_input() { _hovers_any_input_window = true; }
+        bool get_hovered_over_input() const { return _hovers_any_input_window; }
+
         double time() const { return glfwGetTime(); }
     private:
         void open_window();
@@ -93,7 +97,7 @@ namespace rs2
         int                     _fb_height = 0;
         rs2::rect                _viewer_rect;
 
-        ImFont                   *_font_14, *_font_18;
+        ImFont                   *_font_14, *_font_18, *_monofont;
         rs2::mouse_info          _mouse{};
         std::string              _error_message;
         float                    _scale_factor;
@@ -108,6 +112,7 @@ namespace rs2
         std::vector<std::string> _on_load_message;
         std::mutex               _on_load_message_mtx;
 
+        bool                     _hovers_any_input_window = false;
         bool                     _query_devices = true;
         bool                     _missing_device = false;
         int                      _hourglass_index = 0;
diff --git a/common/viewer.cpp b/common/viewer.cpp
index 87d5e07..020b8fb 100644
--- a/common/viewer.cpp
+++ b/common/viewer.cpp
@@ -328,8 +328,8 @@ namespace rs2
         }
         else
         {
-            ImGui::PushStyleColor(ImGuiCol_Text, grey);
-            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, grey);
+            ImGui::PushStyleColor(ImGuiCol_Text, header_color);
+            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, header_color);
         }
         
         ImGui::SetCursorPos({float(x), float(y)});
@@ -373,8 +373,6 @@ namespace rs2
         auto font = win.get_font();
         auto large_font = win.get_large_font();
 
-        const float combo_box_width = 200;
-
         // Draw pose header if pose stream exists
         bool pose_render = false;
 
@@ -611,7 +609,7 @@ namespace rs2
 
         // ------------ Texture Selection --------------
 
-        auto t = single_wave((glfwGetTime() - texture_update_time) * 2.f);
+        auto t = single_wave(float(glfwGetTime() - texture_update_time) * 2);
         ImVec4 text_color = light_grey * (1.f - t) + light_blue * t;
 
         const auto tex_selection_popup = "Tex Selection";
@@ -979,58 +977,8 @@ namespace rs2
         }
     }
 
-    void viewer_model::show_event_log(ImFont* font_14, float x, float y, float w, float h)
-    {
-        auto flags = ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
-            ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar |
-            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysVerticalScrollbar;
-
-        ImGui::PushFont(font_14);
-        ImGui::SetNextWindowPos({ x, y });
-        ImGui::SetNextWindowSize({ w, h });
-        ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(0, 0));
-
-        is_output_collapsed = ImGui::Begin("Output", nullptr, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
-            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ShowBorders);
-
-        int i = 0;
-        not_model->foreach_log([&](const std::string& line) {
-            ImGui::PushStyleColor(ImGuiCol_TextSelectedBg, light_blue);
-            ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
-
-            auto rc = ImGui::GetCursorPos();
-            ImGui::SetCursorPos({ rc.x + 10, rc.y + 4 });
-
-            ImGui::PushStyleColor(ImGuiCol_Text, light_grey);
-            ImGui::Icon(textual_icons::minus); ImGui::SameLine();
-            ImGui::PopStyleColor();
-
-            rc = ImGui::GetCursorPos();
-            ImGui::SetCursorPos({ rc.x, rc.y - 4 });
-
-            std::string label = to_string() << "##log_entry" << i++;
-            ImGui::InputTextEx(label.c_str(),
-                        (char*)line.data(),
-                        static_cast<int>(line.size() + 1),
-                        ImVec2(-1, ImGui::GetTextLineHeight() * 1.5f * float(std::max(1,(int)std::count(line.begin(),line.end(), '\n')))),
-                        ImGuiInputTextFlags_AutoSelectAll | ImGuiInputTextFlags_ReadOnly);
-            ImGui::PopStyleColor(2);
-
-            rc = ImGui::GetCursorPos();
-            ImGui::SetCursorPos({ rc.x, rc.y - 6 });
-        });
-
-        ImGui::End();
-        ImGui::PopStyleVar();
-        ImGui::PopFont();
-    }
-
     void rs2::viewer_model::show_popup(const ux_window& window, const popup& p)
     {
-        auto flags = ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove |
-            ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar |
-            ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysVerticalScrollbar;
-
         auto font_14 = window.get_font();
 
         ImGui_ScopePushFont(font_14);
@@ -1345,6 +1293,9 @@ namespace rs2
                 last_frames[f.get_profile().unique_id()] = f;
             }
 
+            for(auto&& f : last_frames)
+                not_model->output.update_dashboards(f.second);
+
             for(auto&& frame : last_frames)
             {
                 auto f = frame.second;
@@ -1496,14 +1447,12 @@ namespace rs2
         static const auto colored_ruler_width = 20;
         const auto left_x_colored_ruler = stream_width - left_x_colored_ruler_offset;
         const auto right_x_colored_ruler = stream_width - (left_x_colored_ruler_offset - colored_ruler_width);
-        const auto first_rgb = rgb_per_distance_vec.begin()->rgb_val;
         assert((bottom_y_ruler - top_y_ruler) != 0.f);
         const auto ratio = (bottom_y_ruler - top_y_ruler) / ruler_length;
 
         // Draw numbered ruler
         float y_ruler_val = top_y_ruler;
         static const auto numbered_ruler_width = 20.f;
-        const auto numbered_ruler_height = bottom_y_ruler - top_y_ruler;
 
         const auto right_x_numbered_ruler = right_x_colored_ruler + numbered_ruler_width;
         static const auto hovered_numbered_ruler_opac = 0.8f;
@@ -1883,7 +1832,6 @@ namespace rs2
                     auto depth_vid_profile = stream_mv.profile.as<video_stream_profile>();
                     auto depth_width = depth_vid_profile.width();
                     auto depth_height = depth_vid_profile.height();
-                    auto num_of_pixels = depth_width * depth_height;
                     auto depth_data = static_cast<const uint16_t*>(frame.get_data());
                     auto textured_depth_data = static_cast<const uint8_t*>(textured_frame.get_data());
                     static const auto skip_pixels_factor = 30;
@@ -2464,6 +2412,8 @@ namespace rs2
 
             if (ImGui::BeginPopupModal(settings, nullptr, flags))
             {
+                if (ImGui::IsWindowHovered()) window.set_hovered_over_input();
+
                 ImGui::SetCursorScreenPos({ (float)(x0 + w / 2 - 280), (float)(y0 + 27) });
                 ImGui::PushStyleColor(ImGuiCol_Button, sensor_bg);
                 ImGui::PushStyleColor(ImGuiCol_ButtonHovered, sensor_bg);
@@ -2739,6 +2689,38 @@ namespace rs2
                     }
 
 
+                    ImGui::Separator();
+
+                    {
+                        ImGui::Text("Commands.xml Path:");
+                        ImGui::SameLine();
+                        static char logpath[256];
+                        memset(logpath, 0, 256);
+                        std::string path_str = temp_cfg.get(configurations::viewer::commands_xml);
+                        memcpy(logpath, path_str.c_str(), std::min(255, (int)path_str.size()));
+
+                        if (ImGui::InputText("##commands_xml_path", logpath, 255))
+                        {
+                            path_str = logpath;
+                            temp_cfg.set(configurations::viewer::commands_xml, path_str);
+                        }
+                    }
+
+                    {
+                        ImGui::Text("HWLoggerEvents.xml Path:");
+                        ImGui::SameLine();
+                        static char logpath[256];
+                        memset(logpath, 0, 256);
+                        std::string path_str = temp_cfg.get(configurations::viewer::hwlogger_xml);
+                        memcpy(logpath, path_str.c_str(), std::min(255, (int)path_str.size()));
+
+                        if (ImGui::InputText("##fw_log_xml_path", logpath, 255))
+                        {
+                            path_str = logpath;
+                            temp_cfg.set(configurations::viewer::hwlogger_xml, path_str);
+                        }
+                    }
+                    
                     ImGui::Separator();
 
                     ImGui::Text("RealSense tools settings capture the state of UI, and not of the hardware:");
@@ -2784,7 +2766,7 @@ namespace rs2
                 if (tab == 3)
                 {
                     bool recommend_fw_updates = temp_cfg.get(configurations::update::recommend_updates);
-                    if (ImGui::Checkbox("Recommend Firmware Updates", &recommend_fw_updates))
+                    if (ImGui::Checkbox("Recommend Bundled Firmware", &recommend_fw_updates))
                     {
                         temp_cfg.set(configurations::update::recommend_updates, recommend_fw_updates);
                         refresh_updates = true;
@@ -2793,6 +2775,42 @@ namespace rs2
                     {
                         ImGui::SetTooltip("%s", "When firmware of the device is below the version bundled with this software release\nsuggest firmware update");
                     }
+                    ImGui::Separator();
+                    ImGui::Text("%s", "SW/FW Updates From Server:");
+                    if (ImGui::IsItemHovered())
+                    {
+                        ImGui::SetTooltip("%s", "Select the server URL of the SW/FW updates information");
+                    }
+                    ImGui::SameLine(); 
+
+                    static bool official_url(temp_cfg.get(configurations::update::sw_updates_official_server));
+                    static char custom_url[256] = { 0 };
+                    static std::string url_str = (temp_cfg.get(configurations::update::sw_updates_url));
+                    memcpy(custom_url, url_str.c_str(), std::min(255, (int)url_str.size()));
+                    if (ImGui::RadioButton("Official Server", official_url))
+                    {
+                        official_url = true;
+                        temp_cfg.set(configurations::update::sw_updates_url, server_versions_db_url);
+                        temp_cfg.set(configurations::update::sw_updates_official_server, true);
+                    }
+                    ImGui::SameLine();
+                    if (ImGui::RadioButton("Custom Server", !official_url))
+                    {
+                        official_url = false;
+                    }
+                    if (!official_url)
+                    {
+                        if (ImGui::InputText("##custom_server_url", custom_url, 255))
+                        {
+                            url_str = custom_url;
+                        }
+                        ImGui::SameLine();
+                        if (ImGui::Button("Update URL", ImVec2(80, 20)))
+                        {
+                            temp_cfg.set(configurations::update::sw_updates_url, url_str);
+                            temp_cfg.set(configurations::update::sw_updates_official_server, false);
+                        }
+                    }
                 }
 
                 ImGui::Separator();
@@ -2967,6 +2985,7 @@ namespace rs2
         const rect& viewer_rect, bool force)
     {
         if (_measurements.manipulating()) return;
+        if (win.get_hovered_over_input()) return;
 
         mouse_info& mouse = win.get_mouse();
         auto now = std::chrono::high_resolution_clock::now();
diff --git a/common/viewer.h b/common/viewer.h
index c8c392d..de10a18 100644
--- a/common/viewer.h
+++ b/common/viewer.h
@@ -62,9 +62,8 @@ namespace rs2
 
         const float panel_width = 340.f;
         const float panel_y = 50.f;
-        const float default_log_h = 110.f;
 
-        float get_output_height() const { return (is_output_collapsed ? default_log_h : 15); }
+        float get_output_height() const { return not_model->output.get_output_height(); }
 
         rs2::frame handle_ready_frames(const rect& viewer_rect, ux_window& window, int devices, std::string& error_message);
 
@@ -103,8 +102,6 @@ namespace rs2
 
         void popup_firmware_update_progress(const ux_window& window, const float progress);
 
-        void show_event_log(ImFont* font_14, float x, float y, float w, float h);
-
         void render_pose(rs2::rect stream_rect, float buttons_heights);
         void try_select_pointcloud(ux_window& win);
 
@@ -132,7 +129,6 @@ namespace rs2
 
         context &ctx;
         std::shared_ptr<notifications_model> not_model = std::make_shared<notifications_model>();
-        bool is_output_collapsed = false;
         bool is_3d_view = false;
         bool paused = false;
         bool metric_system = true;
diff --git a/doc/support-matrix.md b/doc/support-matrix.md
index 7bd43c4..0ae9633 100644
--- a/doc/support-matrix.md
+++ b/doc/support-matrix.md
@@ -15,16 +15,24 @@ Validation is done on x86 NUC machines running Windows 10 and Ubuntu 16.04 LTS.
 Additional platforms are tested and supported on demand, driven by community requests and feedback.
 
 ## D400 Stereoscopic Depth Cameras' Features
-Please check the Supported Features matrix at https://dev.intelrealsense.com/docs/sdk-knowledge-base
+Please check the Supported Features matrix at https://dev.intelrealsense.com/docs/supported-features-matrix
 
 
-### SR300 Notes:
+## SR300 Notes:
 
 * Global Timestamp mechanism is not yet available for the SR300
 * D400 JSON presets are not applicable to SR300 devices, since they rely on completely different technology
 * Multicamera is technically supported similar to D400 but SR300 devices suffer from destructive interference, hence should not share field of view
 * On-Chip Calibration is not applicable to the SR300 since the structured light module does not lose depth calibration over time
 
-### T265 Tracking Module Notes:
+## T265 Tracking Module Notes:
 
 * Tracking module is currently not available on Android
+
+## L500 Camera Notes:
+* On Chip calibration is only relevant for D400 stereo cameras
+
+The following features are not available for L500 and can be added upon demand:
+* Win7 support
+* pre-compiled binaries for: Android (7+) & JAVA, LabView and Node.js
+* LabView wrapper
diff --git a/doc/troubleshooting.md b/doc/troubleshooting.md
index b9b770c..e602092 100644
--- a/doc/troubleshooting.md
+++ b/doc/troubleshooting.md
@@ -33,6 +33,10 @@ $ lsusb | grep 8086
 ```bash
 $ dmesg -T
 ```
+-To monitor the Linux Kernel log messages when there any change
+```bash
+$ dmesg -wH
+```
 
 - To clear the dmesg buffer:
 ```bash
diff --git a/examples/cmake/readme.md b/examples/cmake/readme.md
index a0bf811..d84ef60 100644
--- a/examples/cmake/readme.md
+++ b/examples/cmake/readme.md
@@ -29,7 +29,7 @@ Find librealsense installation, this feature is currently available only for Lin
 find_package(realsense2 REQUIRED)
 ```
 
-Enable C++ 11 standard in the applicatoin
+Enable C++ 11 standard in the application
 ```
 # Enable C++11
 set(CMAKE_CXX_STANDARD 11)
diff --git a/examples/post-processing/readme.md b/examples/post-processing/readme.md
index bea240c..2818e65 100644
--- a/examples/post-processing/readme.md
+++ b/examples/post-processing/readme.md
@@ -14,6 +14,7 @@ This example demonstrates usage of the following processing blocks:
 * Temporal
   * Filters depth data by looking into previous frames.
 
+For further infomration please refer to [Depth Post-Processing for Intel RealSense Depth Camera D400 Series](https://dev.intelrealsense.com/docs/depth-post-processing)
 
 ## Expected Output
 ![expected output](https://user-images.githubusercontent.com/22654243/35924136-dd9cd1b6-0c2a-11e8-925a-84a52c0a5b96.gif)
diff --git a/include/librealsense2/h/rs_device.h b/include/librealsense2/h/rs_device.h
index 43ba91b..3ed6031 100644
--- a/include/librealsense2/h/rs_device.h
+++ b/include/librealsense2/h/rs_device.h
@@ -310,6 +310,68 @@ const rs2_raw_data_buffer* rs2_run_on_chip_calibration(rs2_device* device, const
 */
 const rs2_raw_data_buffer* rs2_run_tare_calibration_cpp(rs2_device* dev, float ground_truth_mm, const void* json_content, int content_size, rs2_update_progress_callback* progress_callback, int timeout_ms, rs2_error** error);
 
+
+/**
+ * Used in device_calibration; enumerates the different calibration types
+ * available for that extension.
+ */
+typedef enum rs2_calibration_type
+{
+    RS2_CALIBRATION_DEPTH_TO_RGB,
+    RS2_CALIBRATION_TYPE_COUNT
+} rs2_calibration_type;
+const char* rs2_calibration_type_to_string( rs2_calibration_type );
+
+/**
+ * Used in device_calibration with rs2_calibration_change_callback
+ */
+typedef enum rs2_calibration_status
+{
+    // Anything >= 0 is not an issue
+    RS2_CALIBRATION_SPECIAL_FRAME =  0,  // Special frame received; expect a frame-drop!
+    RS2_CALIBRATION_STARTED       =  1,  // Have all frames in hand; starting processing
+    RS2_CALIBRATION_NOT_NEEDED    =  2,  // Finished; existing calibration within tolerances; nothing done!
+    RS2_CALIBRATION_SUCCESSFUL    =  3,  // Finished; have new calibration in-hand
+
+    RS2_CALIBRATION_RETRY         = -1,  // Initiating retry (asked for a new special frame)
+    RS2_CALIBRATION_FAILED        = -2,
+    RS2_CALIBRATION_SCENE_INVALID = -3,  // Scene was not good enough for calibration; will retry
+    RS2_CALIBRATION_BAD_RESULT    = -4,  // Calibration finished, but results aren't good; will retry
+
+    RS2_CALIBRATION_STATUS_FIRST  = -4,
+    RS2_CALIBRATION_STATUS_LAST   =  3,
+    RS2_CALIBRATION_STATUS_COUNT = RS2_CALIBRATION_STATUS_LAST - RS2_CALIBRATION_STATUS_FIRST + 1,
+} rs2_calibration_status;
+const char* rs2_calibration_status_to_string( rs2_calibration_status );
+
+typedef struct rs2_calibration_change_callback rs2_calibration_change_callback;
+typedef void (*rs2_calibration_change_callback_ptr)(rs2_calibration_status, void* arg);
+
+/**
+ * Adds a callback for a sensor that gets called when calibration (intrinsics) changes, e.g. due to auto-calibration
+ * \param[in] sensor        the sensor
+ * \param[in] callback      the C callback function that gets called
+ * \param[in] user          user argument that gets passed to the callback function
+ * \param[out] error        if non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_register_calibration_change_callback( rs2_device* dev, rs2_calibration_change_callback_ptr callback, void* user, rs2_error** error );
+
+/**
+ * Adds a callback for a sensor that gets called when calibration (intrinsics) changes, e.g. due to auto-calibration
+ * \param[in] sensor        the sensor
+ * \param[in] callback      the C++ callback interface that gets called
+ * \param[out] error        if non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_register_calibration_change_callback_cpp( rs2_device* dev, rs2_calibration_change_callback* callback, rs2_error** error );
+
+/**
+ * Triggers calibration of the given type
+ * \param[in] dev           the device
+ * \param[in] type          the type of calibration requested
+ * \param[out] error        if non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_trigger_device_calibration( rs2_device* dev, rs2_calibration_type type, rs2_error** error );
+
 /**
 * This will adjust camera absolute distance to flat target. User needs to enter the known ground truth.
 * \param[in] ground_truth_mm     Ground truth in mm must be between 2500 - 2000000
diff --git a/include/librealsense2/h/rs_internal.h b/include/librealsense2/h/rs_internal.h
index 3fe6bdc..3807d6b 100644
--- a/include/librealsense2/h/rs_internal.h
+++ b/include/librealsense2/h/rs_internal.h
@@ -347,6 +347,195 @@ void rs2_software_sensor_add_option(rs2_sensor* sensor, rs2_option option, float
 */
 void rs2_software_sensor_detach(rs2_sensor* sensor, rs2_error** error);
 
+
+/**
+* \brief Creates RealSense firmware log message.
+* \param[in] dev            Device from which the FW log will be taken using the created message
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   pointer to created empty firmware log message
+*/
+rs2_firmware_log_message* rs2_create_fw_log_message(rs2_device* dev, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log.
+* \param[in] dev            Device from which the FW log should be taken
+* \param[in] fw_log_msg     Firmware log message object to be filled
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   true for success, false for failure - failure happens if no firmware log was sent by the hardware monitor
+*/
+int rs2_get_fw_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense flash log - this is a fw log that has been written in the device during the previous shutdown of the device
+* \param[in] dev            Device from which the FW log should be taken
+* \param[in] fw_log_msg     Firmware log message object to be filled
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   true for success, false for failure - failure happens if no firmware log was sent by the hardware monitor
+*/
+int rs2_get_flash_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_error** error);
+
+/**
+* Delete RealSense firmware log message
+* \param[in]  device    Realsense firmware log message to delete
+*/
+void rs2_delete_fw_log_message(rs2_firmware_log_message* msg);
+
+/**
+* \brief Gets RealSense firmware log message data.
+* \param[in] msg        firmware log message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               pointer to start of the firmware log message data
+*/
+const unsigned char* rs2_fw_log_message_data(rs2_firmware_log_message* msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log message size.
+* \param[in] msg        firmware log message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               size of the firmware log message data
+*/
+int rs2_fw_log_message_size(rs2_firmware_log_message* msg, rs2_error** error);
+
+
+/**
+* \brief Gets RealSense firmware log message timestamp.
+* \param[in] msg        firmware log message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               timestamp of the firmware log message
+*/
+unsigned int rs2_fw_log_message_timestamp(rs2_firmware_log_message* msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log message severity.
+* \param[in] msg        firmware log message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               severity of the firmware log message data
+*/
+rs2_log_severity rs2_fw_log_message_severity(const rs2_firmware_log_message* msg, rs2_error** error);
+
+/**
+* \brief Initializes RealSense firmware logs parser in device.
+* \param[in] dev            Device from which the FW log will be taken
+* \param[in] xml_content    content of the xml file needed for parsing
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   true for success, false for failure - failure happens if opening the xml from the xml_path input fails
+*/
+int rs2_init_fw_log_parser(rs2_device* dev, const char* xml_content, rs2_error** error);
+
+
+/**
+* \brief Creates RealSense firmware log parsed message.
+* \param[in] dev            Device from which the FW log will be taken using the created message
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   pointer to created empty firmware log message
+*/
+rs2_firmware_log_parsed_message* rs2_create_fw_log_parsed_message(rs2_device* dev, rs2_error** error);
+
+/**
+* \brief Deletes RealSense firmware log parsed message.
+* \param[in] msg            message to be deleted
+*/
+void rs2_delete_fw_log_parsed_message(rs2_firmware_log_parsed_message* fw_log_parsed_msg);
+
+
+/**
+* \brief Gets RealSense firmware log parser
+* \param[in] dev                Device from which the FW log will be taken
+* \param[in] fw_log_msg         firmware log message to be parsed
+* \param[in] parsed_msg         firmware log parsed message - place holder for the resulting parsed message
+* \param[out] error             If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                       true for success, false for failure - failure happens if message could not be parsed
+*/
+int rs2_parse_firmware_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_firmware_log_parsed_message* parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message.
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               message of the firmware log parsed message
+*/
+const char* rs2_get_fw_log_parsed_message(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message file name.
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error     If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return               file name of the firmware log parsed message
+*/
+const char* rs2_get_fw_log_parsed_file_name(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message thread name.
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           thread name of the firmware log parsed message
+*/
+const char* rs2_get_fw_log_parsed_thread_name(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message severity.
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           severity of the firmware log parsed message
+*/
+rs2_log_severity rs2_get_fw_log_parsed_severity(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message relevant line (in the file that is returned by rs2_get_fw_log_parsed_file_name).
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           line number of the firmware log parsed message
+*/
+unsigned int rs2_get_fw_log_parsed_line(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Gets RealSense firmware log parsed message timestamp
+* \param[in] fw_log_parsed_msg      firmware log parsed message object
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           timestamp of the firmware log parsed message
+*/
+unsigned int rs2_get_fw_log_parsed_timestamp(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error);
+
+/**
+* \brief Creates RealSense terminal parser.
+* \param[in] xml_content    content of the xml file needed for parsing
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   pointer to created terminal parser object
+*/
+rs2_terminal_parser* rs2_create_terminal_parser(const char* xml_content, rs2_error** error);
+
+/**
+* \brief Deletes RealSense terminal parser.
+* \param[in] terminal_parser            terminal parser to be deleted
+*/
+void rs2_delete_terminal_parser(rs2_terminal_parser* terminal_parser);
+
+/**
+* \brief Parses terminal command via RealSense terminal parser
+* \param[in] terminal_parser        Terminal parser object
+* \param[in] command                command to be sent to the hw monitor of the device
+* \param[in] size_of_command        size of command to be sent to the hw monitor of the device
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           command to hw monitor, in hex
+*/
+rs2_raw_data_buffer* rs2_terminal_parse_command(rs2_terminal_parser* terminal_parser,
+    const char* command, unsigned int size_of_command, rs2_error** error);
+
+/**
+* \brief Parses terminal response via RealSense terminal parser
+* \param[in] terminal_parser        Terminal parser object
+* \param[in] command                command sent to the hw monitor of the device
+* \param[in] size_of_command        size of the command to sent to the hw monitor of the device
+* \param[in] response               response received by the hw monitor of the device
+* \param[in] size_of_response       size of the response received by the hw monitor of the device
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           answer parsed
+*/
+rs2_raw_data_buffer* rs2_terminal_parse_response(rs2_terminal_parser* terminal_parser,
+    const char* command, unsigned int size_of_command,
+    const void* response, unsigned int size_of_response, rs2_error** error);
+
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/librealsense2/h/rs_option.h b/include/librealsense2/h/rs_option.h
index d0694f7..ad6e5a2 100644
--- a/include/librealsense2/h/rs_option.h
+++ b/include/librealsense2/h/rs_option.h
@@ -94,6 +94,8 @@ extern "C" {
         RS2_OPTION_SENSOR_MODE, /**< The resolution mode: see rs2_sensor_mode for values */
         RS2_OPTION_EMITTER_ALWAYS_ON, /**< Enable Laser On constantly (GS SKU Only) */
         RS2_OPTION_THERMAL_COMPENSATION, /**< Depth Thermal Compensation for selected D400 SKUs */
+        RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH, /**< Enable depth & color frame sync with periodic calibration for proper alignment */
+        RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH,
         RS2_OPTION_COUNT /**< Number of enumeration values. Not a valid input: intended to be used in for-loops. */
     } rs2_option;
 
@@ -150,6 +152,7 @@ extern "C" {
     {
         RS2_SENSOR_MODE_VGA,
         RS2_SENSOR_MODE_XGA,
+        RS2_SENSOR_MODE_QVGA,
         RS2_SENSOR_MODE_COUNT /**< Number of enumeration values. Not a valid input: intended to be used in for-loops. */
     } rs2_sensor_mode;
     const char* rs2_sensor_mode_to_string(rs2_sensor_mode preset);
diff --git a/include/librealsense2/h/rs_sensor.h b/include/librealsense2/h/rs_sensor.h
index c02c02e..975e6ef 100644
--- a/include/librealsense2/h/rs_sensor.h
+++ b/include/librealsense2/h/rs_sensor.h
@@ -464,6 +464,17 @@ void rs2_register_extrinsics(const rs2_stream_profile* from,
     const rs2_stream_profile* to,
     rs2_extrinsics extrin, rs2_error** error);
 
+/**
+ * \brief Override extrinsics of a given sensor that supports calibrated_sensor.
+ *
+ * This will affect extrinsics at the source device and may affect multiple profiles. Used for DEPTH_TO_RGB calibration.
+ *
+* \param[in] sensor       The sensor
+* \param[in] extrinsics   Extrinsics from Depth to the named sensor
+* \param[out] error       If non-null, receives any error that occurs during this call, otherwise, errors are ignored
+*/
+void rs2_override_extrinsics( const rs2_sensor* sensor, const rs2_extrinsics* extrinsics, rs2_error** error );
+
 /**
  * When called on a video profile, returns the intrinsics of specific stream configuration
  * \param[in] mode          input stream profile
@@ -579,6 +590,17 @@ int rs2_send_wheel_odometry(const rs2_sensor* sensor, char wo_sensor_id, unsigne
 */
 void rs2_set_intrinsics(const rs2_sensor* sensor, const rs2_stream_profile* profile , const rs2_intrinsics* intrinsics, rs2_error** error);
 
+/**
+ * \brief Override intrinsics of a given sensor that supports calibrated_sensor.
+ *
+ * This will affect intrinsics at the source and may affect multiple profiles. Used for DEPTH_TO_RGB calibration.
+ *
+* \param[in] sensor       The RealSense device
+* \param[in] intrinsics   Intrinsics value to be written to the sensor
+* \param[out] error       If non-null, receives any error that occurs during this call, otherwise, errors are ignored
+*/
+void rs2_override_intrinsics( const rs2_sensor* sensor, const rs2_intrinsics* intrinsics, rs2_error** error );
+
 /**
  * Set extrinsics between two sensors
  * \param[in]  from_sensor  Origin sensor
@@ -590,6 +612,32 @@ void rs2_set_intrinsics(const rs2_sensor* sensor, const rs2_stream_profile* prof
  */
 void rs2_set_extrinsics(const rs2_sensor* from_sensor, const rs2_stream_profile* from_profile, rs2_sensor* to_sensor, const rs2_stream_profile* to_profile, const rs2_extrinsics* extrinsics, rs2_error** error);
 
+/**
+ * Get the DSM parameters for a sensor
+ * \param[in]  sensor        Sensor that supports the CALIBRATED_SENSOR extension
+ * \param[out] p_params_out  Pointer to the structure that will get the DSM parameters
+ * \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_get_dsm_params( rs2_sensor const * sensor, rs2_dsm_params * p_params_out, rs2_error** error );
+
+/**
+ * Set the sensor DSM parameters
+ * This should ideally be done when the stream is NOT running. If it is, the
+ * parameters may not take effect immediately.
+ * \param[in]  sensor        Sensor that supports the CALIBRATED_SENSOR extension
+ * \param[out] p_params      Pointer to the structure that contains the DSM parameters
+ * \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_override_dsm_params( rs2_sensor const * sensor, rs2_dsm_params const * p_params, rs2_error** error );
+
+/**
+ * Reset the sensor DSM parameters
+ * This should ideally be done when the stream is NOT running. May not take effect immediately.
+ * \param[in]  sensor        Sensor that supports the CALIBRATED_SENSOR extension
+ * \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored
+ */
+void rs2_reset_sensor_calibration( rs2_sensor const * sensor, rs2_error** error );
+
 /**
 * Set motion device intrinsics
 * \param[in]  sensor       Motion sensor 
diff --git a/include/librealsense2/h/rs_terminal_parser.h b/include/librealsense2/h/rs_terminal_parser.h
new file mode 100644
index 0000000..f0728f1
--- /dev/null
+++ b/include/librealsense2/h/rs_terminal_parser.h
@@ -0,0 +1,63 @@
+/* License: Apache 2.0. See LICENSE file in root directory.
+   Copyright(c) 2020 Intel Corporation. All Rights Reserved. */
+
+/** \file rs_terminal.h
+* \brief Exposes RealSense terminal functionality for C compilers
+*/
+
+
+#ifndef LIBREALSENSE_RS2_TERMINAL_H
+#define LIBREALSENSE_RS2_TERMINAL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "rs_types.h"
+
+/**
+* \brief Creates RealSense terminal parser.
+* \param[in] xml_content    content of the xml file needed for parsing
+* \param[out] error         If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                   pointer to created terminal parser object
+*/
+rs2_terminal_parser* rs2_create_terminal_parser(const char* xml_content, rs2_error** error);
+
+/**
+* \brief Deletes RealSense terminal parser.
+* \param[in] terminal_parser            terminal parser to be deleted
+*/
+void rs2_delete_terminal_parser(rs2_terminal_parser* terminal_parser);
+
+/**
+* \brief Parses terminal command via RealSense terminal parser
+* \param[in] terminal_parser        Terminal parser object
+* \param[in] command                command to be sent to the hw monitor of the device
+* \param[in] size_of_command        size of command to be sent to the hw monitor of the device
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           command to hw monitor, in hex
+*/
+rs2_raw_data_buffer* rs2_terminal_parse_command(rs2_terminal_parser* terminal_parser, 
+    const char* command, unsigned int size_of_command, rs2_error** error);
+
+/**
+* \brief Parses terminal response via RealSense terminal parser
+* \param[in] terminal_parser        Terminal parser object
+* \param[in] command                command sent to the hw monitor of the device
+* \param[in] size_of_command        size of the command to sent to the hw monitor of the device
+* \param[in] response               response received by the hw monitor of the device
+* \param[in] size_of_response       size of the response received by the hw monitor of the device
+* \param[out] error                 If non-null, receives any error that occurs during this call, otherwise, errors are ignored.
+* \return                           answer parsed
+*/
+rs2_raw_data_buffer* rs2_terminal_parse_response(rs2_terminal_parser* terminal_parser,
+    const char* command, unsigned int size_of_command,
+    const void* response, unsigned int size_of_response, rs2_error** error);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff --git a/include/librealsense2/h/rs_types.h b/include/librealsense2/h/rs_types.h
index da7cc50..ef2ef62 100644
--- a/include/librealsense2/h/rs_types.h
+++ b/include/librealsense2/h/rs_types.h
@@ -67,6 +67,32 @@ typedef struct rs2_intrinsics
     float         coeffs[5]; /**< Distortion coefficients */
 } rs2_intrinsics;
 
+/** \brief Video DSM (Digital Sync Module) parameters for calibration (same layout as in FW ac_depth_params)
+    This is the block in MC that converts angles to dimensionless integers reported to MA (using "DSM coefficients").
+*/
+typedef struct rs2_dsm_params
+{
+    unsigned long long timestamp;   /**< system_clock::time_point::time_since_epoch().count() */
+    unsigned short version;         /**< MAJOR<<12 | MINOR<<4 | PATCH */
+    unsigned char model;            /**< rs2_dsm_correction_model */
+    unsigned char flags[5];         /**< TBD, now 0s */
+    float         h_scale;          /**< the scale factor to horizontal DSM scale thermal results */
+    float         v_scale;          /**< the scale factor to vertical DSM scale thermal results */
+    float         h_offset;         /**< the offset to horizontal DSM offset thermal results */
+    float         v_offset;         /**< the offset to vertical DSM offset thermal results */
+    float         rtd_offset;       /**< the offset to the Round-Trip-Distance delay thermal results */
+    unsigned char temp_x2;          /**< the temperature recorded times 2 (ldd for depth; hum for rgb) */
+    unsigned char reserved[11];
+} rs2_dsm_params;
+
+typedef enum rs2_dsm_correction_model
+{
+    RS2_DSM_CORRECTION_NONE,        /**< hFactor and hOffset are not used, and no artificial error is induced */
+    RS2_DSM_CORRECTION_AOT,         /**< Aging-over-thermal (default); aging-induced error is uniform across temperature */
+    RS2_DSM_CORRECTION_TOA,         /**< Thermal-over-aging; aging-induced error changes alongside temperature */
+    RS2_DSM_CORRECTION_COUNT
+} rs2_dsm_correction_model;
+
 /** \brief Motion device intrinsics: scale, bias, and variances. */
 typedef struct rs2_motion_device_intrinsic
 {
@@ -180,6 +206,10 @@ typedef enum rs2_extension
     RS2_EXTENSION_FISHEYE_SENSOR,
     RS2_EXTENSION_DEPTH_HUFFMAN_DECODER,
     RS2_EXTENSION_SERIALIZABLE,
+    RS2_EXTENSION_FW_LOGGER,
+    RS2_EXTENSION_AUTO_CALIBRATION_FILTER,
+    RS2_EXTENSION_DEVICE_CALIBRATION,
+    RS2_EXTENSION_CALIBRATED_SENSOR,
     RS2_EXTENSION_COUNT
 } rs2_extension;
 const char* rs2_extension_type_to_string(rs2_extension type);
@@ -244,6 +274,10 @@ typedef struct rs2_options_list rs2_options_list;
 typedef struct rs2_devices_changed_callback rs2_devices_changed_callback;
 typedef struct rs2_notification rs2_notification;
 typedef struct rs2_notifications_callback rs2_notifications_callback;
+typedef struct rs2_firmware_log_message rs2_firmware_log_message;
+typedef struct rs2_firmware_log_parsed_message rs2_firmware_log_parsed_message;
+typedef struct rs2_firmware_log_parser rs2_firmware_log_parser;
+typedef struct rs2_terminal_parser rs2_terminal_parser;
 typedef void (*rs2_log_callback_ptr)(rs2_log_severity, rs2_log_message const *, void * arg);
 typedef void (*rs2_notification_callback_ptr)(rs2_notification*, void*);
 typedef void(*rs2_software_device_destruction_callback_ptr)(void*);
diff --git a/include/librealsense2/hpp/rs_device.hpp b/include/librealsense2/hpp/rs_device.hpp
index 2ea3748..b23f177 100644
--- a/include/librealsense2/hpp/rs_device.hpp
+++ b/include/librealsense2/hpp/rs_device.hpp
@@ -226,7 +226,7 @@ namespace rs2
 
             results.insert(results.begin(), start, start + size);
 
-return results;
+            return results;
         }
 
         // Update an updatable device to the provided unsigned firmware. This call is executed on the caller's thread.
@@ -242,7 +242,7 @@ return results;
         void update_unsigned(const std::vector<uint8_t>& image, T callback, int update_mode = RS2_UNSIGNED_UPDATE_MODE_UPDATE) const
         {
             rs2_error* e = nullptr;
-            rs2_update_firmware_unsigned_cpp(_dev.get(), image.data(), image.size(), new update_progress_callback<T>(std::move(callback)), update_mode, &e);
+            rs2_update_firmware_unsigned_cpp(_dev.get(), image.data(), int(image.size()), new update_progress_callback<T>(std::move(callback)), update_mode, &e);
             error::handle(e);
         }
     };
@@ -277,7 +277,7 @@ return results;
         void update(const std::vector<uint8_t>& fw_image, T callback) const
         {
             rs2_error* e = nullptr;
-            rs2_update_firmware_cpp(_dev.get(), fw_image.data(), fw_image.size(), new update_progress_callback<T>(std::move(callback)), &e);
+            rs2_update_firmware_cpp(_dev.get(), fw_image.data(), int(fw_image.size()), new update_progress_callback<T>(std::move(callback)), &e);
             error::handle(e);
         }
     };
@@ -353,7 +353,7 @@ return results;
 
             rs2_error* e = nullptr;
             std::shared_ptr<const rs2_raw_data_buffer> list(
-                rs2_run_on_chip_calibration_cpp(_dev.get(), json_content.data(), json_content.size(), health, new update_progress_callback<T>(std::move(callback)), timeout_ms, &e),
+                rs2_run_on_chip_calibration_cpp(_dev.get(), json_content.data(), int(json_content.size()), health, new update_progress_callback<T>(std::move(callback)), timeout_ms, &e),
                 rs2_delete_raw_data);
             error::handle(e);
 
@@ -434,7 +434,7 @@ return results;
 
             rs2_error* e = nullptr;
             std::shared_ptr<const rs2_raw_data_buffer> list(
-                rs2_run_tare_calibration_cpp(_dev.get(), ground_truth_mm, json_content.data(), json_content.size(), new update_progress_callback<T>(std::move(callback)), timeout_ms, &e),
+                rs2_run_tare_calibration_cpp(_dev.get(), ground_truth_mm, json_content.data(), int(json_content.size()), new update_progress_callback<T>(std::move(callback)), timeout_ms, &e),
                 rs2_delete_raw_data);
             error::handle(e);
 
@@ -527,6 +527,71 @@ return results;
  
     };
 
+    /*
+        Wrapper around any callback function that is given to calibration_change_callback.
+    */
+    template< class callback >
+    class calibration_change_callback : public rs2_calibration_change_callback
+    {
+        //using callback = std::function< void( rs2_calibration_status ) >;
+        callback _callback;
+    public:
+        calibration_change_callback( callback cb ) : _callback( cb ) {}
+
+        void on_calibration_change( rs2_calibration_status status ) noexcept override
+        {
+            _callback( status );
+        }
+        void release() override { delete this; }
+    };
+
+    class device_calibration : public device
+    {
+    public:
+        device_calibration( device d )
+            : device( d.get() )
+        {
+            rs2_error* e = nullptr;
+            if( rs2_is_device_extendable_to( _dev.get(), RS2_EXTENSION_DEVICE_CALIBRATION, &e ) == 0 && !e )
+            {
+                _dev.reset();
+            }
+            error::handle( e );
+        }
+
+        /*
+        Your callback should look like this, for example:
+            sensor.register_calibration_change_callback(
+                []( rs2_calibration_status ) noexcept
+                {
+                    ...
+                })
+        */
+        template< typename T >
+        void register_calibration_change_callback( T callback )
+        {
+            // We wrap the callback with an interface and pass it to librealsense, who will
+            // now manage its lifetime. Rather than deleting it, though, it will call its
+            // release() function, where (back in our context) it can be safely deleted:
+            rs2_error* e = nullptr;
+            rs2_register_calibration_change_callback_cpp(
+                _dev.get(),
+                new calibration_change_callback< T >( std::move( callback )),
+                &e );
+            error::handle( e );
+        }
+
+        /**
+        * This will trigger the given calibration, if available
+        */
+        void trigger_device_calibration( rs2_calibration_type type )
+        {
+            rs2_error* e = nullptr;
+            rs2_trigger_device_calibration( _dev.get(), type, &e );
+            error::handle( e );
+        }
+    };
+
     class debug_protocol : public device
     {
     public:
diff --git a/include/librealsense2/hpp/rs_export.hpp b/include/librealsense2/hpp/rs_export.hpp
index 19eff98..55f52f0 100644
--- a/include/librealsense2/hpp/rs_export.hpp
+++ b/include/librealsense2/hpp/rs_export.hpp
@@ -99,7 +99,7 @@ namespace rs2
                 if (fabs(verts[i].x) >= min_distance || fabs(verts[i].y) >= min_distance ||
                     fabs(verts[i].z) >= min_distance)
                 {
-                    idx_map[i] = new_verts.size();
+                    idx_map[int(i)] = int(new_verts.size());
                     new_verts.push_back({ verts[i].x, -1 * verts[i].y, -1 * verts[i].z });
                     if (use_texcoords)
                     {
diff --git a/include/librealsense2/hpp/rs_internal.hpp b/include/librealsense2/hpp/rs_internal.hpp
index 076a49c..3d36a53 100644
--- a/include/librealsense2/hpp/rs_internal.hpp
+++ b/include/librealsense2/hpp/rs_internal.hpp
@@ -363,5 +363,252 @@ namespace rs2
         }
     };
 
+    class firmware_log_message
+    {
+    public:
+        explicit firmware_log_message(std::shared_ptr<rs2_firmware_log_message> msg) :
+            _fw_log_message(msg) {}
+
+        rs2_log_severity get_severity() const {
+            rs2_error* e = nullptr;
+            rs2_log_severity severity = rs2_fw_log_message_severity(_fw_log_message.get(), &e);
+            error::handle(e);
+            return severity;
+        }
+        std::string get_severity_str() const {
+            return rs2_log_severity_to_string(get_severity());
+        }
+
+        uint32_t get_timestamp() const
+        {
+            rs2_error* e = nullptr;
+            uint32_t timestamp = rs2_fw_log_message_timestamp(_fw_log_message.get(), &e);
+            error::handle(e);
+            return timestamp;
+        }
+
+        int size() const
+        {
+            rs2_error* e = nullptr;
+            int size = rs2_fw_log_message_size(_fw_log_message.get(), &e);
+            error::handle(e);
+            return size;
+        }
+
+        std::vector<uint8_t> data() const
+        {
+            rs2_error* e = nullptr;
+            auto size = rs2_fw_log_message_size(_fw_log_message.get(), &e);
+            error::handle(e);
+            std::vector<uint8_t> result;
+            if (size > 0)
+            {
+                auto start = rs2_fw_log_message_data(_fw_log_message.get(), &e);
+                error::handle(e);
+                result.insert(result.begin(), start, start + size);
+            }
+            return result;
+        }
+
+        const std::shared_ptr<rs2_firmware_log_message> get_message() const { return _fw_log_message; }
+
+    private:
+        std::shared_ptr<rs2_firmware_log_message> _fw_log_message;
+    };
+
+    class firmware_log_parsed_message
+    {
+    public:
+        explicit firmware_log_parsed_message(std::shared_ptr<rs2_firmware_log_parsed_message> msg) :
+            _parsed_fw_log(msg) {}
+
+        std::string message() const
+        {
+            rs2_error* e = nullptr;
+            std::string msg(rs2_get_fw_log_parsed_message(_parsed_fw_log.get(), &e));
+            error::handle(e);
+            return msg;
+        }
+        std::string file_name() const
+        {
+            rs2_error* e = nullptr;
+            std::string file_name(rs2_get_fw_log_parsed_file_name(_parsed_fw_log.get(), &e));
+            error::handle(e);
+            return file_name;
+        }
+        std::string thread_name() const
+        {
+            rs2_error* e = nullptr;
+            std::string thread_name(rs2_get_fw_log_parsed_thread_name(_parsed_fw_log.get(), &e));
+            error::handle(e);
+            return thread_name;
+        }
+        std::string severity() const
+        {
+            rs2_error* e = nullptr;
+            rs2_log_severity sev = rs2_get_fw_log_parsed_severity(_parsed_fw_log.get(), &e);
+            error::handle(e);
+            return std::string(rs2_log_severity_to_string(sev));
+        }
+        uint32_t line() const
+        {
+            rs2_error* e = nullptr;
+            uint32_t line(rs2_get_fw_log_parsed_line(_parsed_fw_log.get(), &e));
+            error::handle(e);
+            return line;
+        }
+        uint32_t timestamp() const
+        {
+            rs2_error* e = nullptr;
+            uint32_t timestamp(rs2_get_fw_log_parsed_timestamp(_parsed_fw_log.get(), &e));
+            error::handle(e);
+            return timestamp;
+        }
+
+        const std::shared_ptr<rs2_firmware_log_parsed_message> get_message() const { return _parsed_fw_log; }
+
+    private:
+        std::shared_ptr<rs2_firmware_log_parsed_message> _parsed_fw_log;
+    };
+
+    class firmware_logger : public device
+    {
+    public:
+        firmware_logger(device d)
+            : device(d.get())
+        {
+            rs2_error* e = nullptr;
+            if (rs2_is_device_extendable_to(_dev.get(), RS2_EXTENSION_FW_LOGGER, &e) == 0 && !e)
+            {
+                _dev.reset();
+            }
+            error::handle(e);
+        }
+
+        rs2::firmware_log_message create_message()
+        {
+            rs2_error* e = nullptr;
+            std::shared_ptr<rs2_firmware_log_message> msg(
+                rs2_create_fw_log_message(_dev.get(), &e),
+                rs2_delete_fw_log_message);
+            error::handle(e);
+
+            return firmware_log_message(msg);
+        }
+
+        rs2::firmware_log_parsed_message create_parsed_message()
+        {
+            rs2_error* e = nullptr;
+            std::shared_ptr<rs2_firmware_log_parsed_message> msg(
+                rs2_create_fw_log_parsed_message(_dev.get(), &e),
+                rs2_delete_fw_log_parsed_message);
+            error::handle(e);
+
+            return firmware_log_parsed_message(msg);
+        }
+
+        bool get_firmware_log(rs2::firmware_log_message& msg) const
+        {
+            rs2_error* e = nullptr;
+            rs2_firmware_log_message* m = msg.get_message().get();
+            bool fw_log_pulling_status =
+                rs2_get_fw_log(_dev.get(), m, &e);
+
+            error::handle(e);
+
+            return fw_log_pulling_status;
+        }
+
+        bool get_flash_log(rs2::firmware_log_message& msg) const
+        {
+            rs2_error* e = nullptr;
+            rs2_firmware_log_message* m = msg.get_message().get();
+            bool flash_log_pulling_status =
+                rs2_get_flash_log(_dev.get(), m, &e);
+
+            error::handle(e);
+
+            return flash_log_pulling_status;
+        }
+
+        bool init_parser(const std::string& xml_content)
+        {
+            rs2_error* e = nullptr;
+
+            bool parser_initialized = rs2_init_fw_log_parser(_dev.get(), xml_content.c_str(), &e);
+            error::handle(e);
+
+            return parser_initialized;
+        }
+
+        bool parse_log(const rs2::firmware_log_message& msg, const rs2::firmware_log_parsed_message& parsed_msg)
+        {
+            rs2_error* e = nullptr;
+
+            bool parsingResult = rs2_parse_firmware_log(_dev.get(), msg.get_message().get(), parsed_msg.get_message().get(), &e);
+            error::handle(e);
+
+            return parsingResult;
+        }
+    };
+
+    class terminal_parser
+    {
+    public:
+        terminal_parser(const std::string& xml_content)
+        {
+            rs2_error* e = nullptr;
+
+            _terminal_parser = std::shared_ptr<rs2_terminal_parser>(
+                rs2_create_terminal_parser(xml_content.c_str(), &e),
+                rs2_delete_terminal_parser);
+            error::handle(e);
+        }
+
+        std::vector<uint8_t> parse_command(const std::string& command)
+        {
+            rs2_error* e = nullptr;
+
+            std::shared_ptr<const rs2_raw_data_buffer> list(
+                rs2_terminal_parse_command(_terminal_parser.get(), command.c_str(), command.size(), &e),
+                rs2_delete_raw_data);
+            error::handle(e);
+
+            auto size = rs2_get_raw_data_size(list.get(), &e);
+            error::handle(e);
+
+            auto start = rs2_get_raw_data(list.get(), &e);
+
+            std::vector<uint8_t> results;
+            results.insert(results.begin(), start, start + size);
+
+            return results;
+        }
+
+        std::string parse_response(const std::string& command, const std::vector<uint8_t>& response)
+        {
+            rs2_error* e = nullptr;
+
+            std::shared_ptr<const rs2_raw_data_buffer> list(
+                rs2_terminal_parse_response(_terminal_parser.get(), command.c_str(), command.size(),
+                (void*)response.data(), response.size(), &e),
+                rs2_delete_raw_data);
+            error::handle(e);
+
+            auto size = rs2_get_raw_data_size(list.get(), &e);
+            error::handle(e);
+
+            auto start = rs2_get_raw_data(list.get(), &e);
+
+            std::string results;
+            results.insert(results.begin(), start, start + size);
+
+            return results;
+        }
+
+    private:
+        std::shared_ptr<rs2_terminal_parser> _terminal_parser;
+    };
+
 }
 #endif // LIBREALSENSE_RS2_INTERNAL_HPP
diff --git a/include/librealsense2/hpp/rs_sensor.hpp b/include/librealsense2/hpp/rs_sensor.hpp
index 26a2e36..45b0247 100644
--- a/include/librealsense2/hpp/rs_sensor.hpp
+++ b/include/librealsense2/hpp/rs_sensor.hpp
@@ -99,7 +99,6 @@ namespace rs2
     };
 
 
-
     class sensor : public options
     {
     public:
@@ -213,7 +212,6 @@ namespace rs2
             error::handle(e);
         }
 
-
         /**
         * Retrieves the list of stream profiles supported by the sensor.
         * \return   list of stream profiles that given sensor can provide
@@ -664,5 +662,67 @@ namespace rs2
         operator bool() const { return _sensor.get() != nullptr; }
         explicit wheel_odometer(std::shared_ptr<rs2_sensor> dev) : wheel_odometer(sensor(dev)) {}
     };
+
+    class calibrated_sensor : public sensor
+    {
+    public:
+        calibrated_sensor( sensor s )
+            : sensor( s.get() )
+        {
+            rs2_error* e = nullptr;
+            if( rs2_is_sensor_extendable_to( _sensor.get(), RS2_EXTENSION_CALIBRATED_SENSOR, &e ) == 0 && !e )
+            {
+                _sensor.reset();
+            }
+            error::handle( e );
+        }
+
+        operator bool() const { return _sensor.get() != nullptr; }
+
+        /** Override the intrinsics at the sensor level, as DEPTH_TO_RGB calibration does */
+        void override_intrinsics( rs2_intrinsics const& intr )
+        {
+            rs2_error* e = nullptr;
+            rs2_override_intrinsics( _sensor.get(), &intr, &e );
+            error::handle( e );
+        }
+
+        /** Override the intrinsics at the sensor level, as DEPTH_TO_RGB calibration does */
+        void override_extrinsics( rs2_extrinsics const& extr )
+        {
+            rs2_error* e = nullptr;
+            rs2_override_extrinsics( _sensor.get(), &extr, &e );
+            error::handle( e );
+        }
+
+        /** Override the intrinsics at the sensor level, as DEPTH_TO_RGB calibration does */
+        rs2_dsm_params get_dsm_params() const
+        {
+            rs2_error* e = nullptr;
+            rs2_dsm_params params;
+            rs2_get_dsm_params( _sensor.get(), &params, &e );
+            error::handle( e );
+            return params;
+        }
+
+        /** Set the sensor DSM parameters
+         * This should ideally be done when the stream is NOT running. If it is, the
+         * parameters may not take effect immediately. */
+        void override_dsm_params( rs2_dsm_params const & params )
+        {
+            rs2_error* e = nullptr;
+            rs2_override_dsm_params( _sensor.get(), &params, &e );
+            error::handle( e );
+        }
+
+        /** Reset the sensor DSM calibration
+         */
+        void reset_calibration()
+        {
+            rs2_error* e = nullptr;
+            rs2_reset_sensor_calibration( _sensor.get(), &e );
+            error::handle( e );
+        }
+    };
 }
 #endif // LIBREALSENSE_RS2_SENSOR_HPP
diff --git a/include/librealsense2/hpp/rs_types.hpp b/include/librealsense2/hpp/rs_types.hpp
index cde4673..eece655 100644
--- a/include/librealsense2/hpp/rs_types.hpp
+++ b/include/librealsense2/hpp/rs_types.hpp
@@ -59,6 +59,13 @@ struct rs2_log_callback
     virtual                                 ~rs2_log_callback() {}
 };
 
+struct rs2_calibration_change_callback
+{
+    virtual void                            on_calibration_change( rs2_calibration_status ) noexcept = 0;
+    virtual void                            release() = 0;
+    virtual                                 ~rs2_calibration_change_callback() {}
+};
+
 struct rs2_devices_changed_callback
 {
     virtual void                            on_devices_changed(rs2_device_list* removed, rs2_device_list* added) = 0;
diff --git a/include/librealsense2/rs.h b/include/librealsense2/rs.h
index 6976fff..5cc362a 100644
--- a/include/librealsense2/rs.h
+++ b/include/librealsense2/rs.h
@@ -23,8 +23,8 @@ extern "C" {
 #include "h/rs_sensor.h"
 
 #define RS2_API_MAJOR_VERSION    2
-#define RS2_API_MINOR_VERSION    35
-#define RS2_API_PATCH_VERSION    2
+#define RS2_API_MINOR_VERSION    36
+#define RS2_API_PATCH_VERSION    0
 #define RS2_API_BUILD_VERSION    0
 
 #ifndef STRINGIFY
diff --git a/include/librealsense2/rs.hpp b/include/librealsense2/rs.hpp
index 2a9ee2e..8922881 100644
--- a/include/librealsense2/rs.hpp
+++ b/include/librealsense2/rs.hpp
@@ -148,5 +148,7 @@ inline std::ostream & operator << (std::ostream & o, rs2_exception_type exceptio
 inline std::ostream & operator << (std::ostream & o, rs2_playback_status status) { return o << rs2_playback_status_to_string(status); }
 inline std::ostream & operator << (std::ostream & o, rs2_l500_visual_preset preset) {return o << rs2_l500_visual_preset_to_string(preset);}
 inline std::ostream & operator << (std::ostream & o, rs2_sensor_mode mode) { return o << rs2_sensor_mode_to_string(mode); }
+inline std::ostream & operator << (std::ostream & o, rs2_calibration_type mode) { return o << rs2_calibration_type_to_string(mode); }
+inline std::ostream & operator << (std::ostream & o, rs2_calibration_status mode) { return o << rs2_calibration_status_to_string(mode); }
 
 #endif // LIBREALSENSE_RS2_HPP
diff --git a/include/librealsense2/rsutil.h b/include/librealsense2/rsutil.h
index 4242c4a..35260e4 100644
--- a/include/librealsense2/rsutil.h
+++ b/include/librealsense2/rsutil.h
@@ -33,6 +33,22 @@ static void rs2_project_point_to_pixel(float pixel[2], const struct rs2_intrinsi
         x = dx;
         y = dy;
     }
+
+    if (intrin->model == RS2_DISTORTION_BROWN_CONRADY)
+    {
+        float r2 = x * x + y * y;
+        float f = 1 + intrin->coeffs[0] * r2 + intrin->coeffs[1] * r2*r2 + intrin->coeffs[4] * r2*r2*r2;
+
+        float xf = x * f;
+        float yf = y * f;
+
+        float dx = xf + 2 * intrin->coeffs[2] * x*y + intrin->coeffs[3] * (r2 + 2 * x*x);
+        float dy = yf + 2 * intrin->coeffs[3] * x*y + intrin->coeffs[2] * (r2 + 2 * y*y);
+
+        x = dx;
+        y = dy;
+    }
+
     if (intrin->model == RS2_DISTORTION_FTHETA)
     {
         float r = sqrtf(x*x + y*y);
diff --git a/package.xml b/package.xml
index a6180fa..4e7c47e 100644
--- a/package.xml
+++ b/package.xml
@@ -7,7 +7,7 @@
 <package format="2">
   <name>librealsense2</name>
   <!-- The version tag needs to be updated with each new release of librealsense -->
-  <version>2.35.2</version>
+  <version>2.36.0</version>
   <description>
   Library for capturing data from the Intel(R) RealSense(TM) SR300, D400 Depth cameras and T2xx Tracking devices. This effort was initiated to better support researchers, creative coders, and app developers in domains such as robotics, virtual reality, and the internet of things. Several often-requested features of RealSense(TM); devices are implemented in this project.
   </description>
diff --git a/scripts/patch-arch.sh b/scripts/patch-arch.sh
old mode 100644
new mode 100755
index 1dcde18..3c5d224
--- a/scripts/patch-arch.sh
+++ b/scripts/patch-arch.sh
@@ -8,9 +8,10 @@ SRC_VERSION_NAME=linux
 FULL_NAME=$( uname -r | tr "-" "\n")
 read -a VERSION <<< $FULL_NAME
 
-SRC_VERSION_ID=${VERSION[0]}  ## e.g. : 4.5.6
-SRC_VERSION_REL=${VERSION[1]} ## e.g. : 1
-LINUX_TYPE=${VERSION[2]}      ## e.g. : ARCH
+SRC_VERSION_ID=${VERSION[0]}             ## e.g. : 4.5.6
+SRC_VERSION_MAJOR=${SRC_VERSION_ID:0:1}  ## e.g. : 4
+SRC_VERSION_REL=${VERSION[1]}            ## e.g. : 1
+LINUX_TYPE=${VERSION[2]}                 ## e.g. : ARCH
 
 LINUX_BRANCH=archlinux-$SRC_VERSION_ID
 KERNEL_NAME=linux-$SRC_VERSION_ID
@@ -22,9 +23,9 @@ mkdir kernel
 cd kernel
 
 ## Get the kernel
-wget https://www.kernel.org/pub/linux/kernel/v4.x/$KERNEL_NAME.tar.xz
-wget https://www.kernel.org/pub/linux/kernel/v4.x/$PATCH_NAME.xz
-wget https://www.kernel.org/pub/linux/kernel/v4.x/$PATCH_NAME.sign
+wget https://www.kernel.org/pub/linux/kernel/v${SRC_VERSION_MAJOR}.x/$KERNEL_NAME.tar.xz
+wget https://www.kernel.org/pub/linux/kernel/v${SRC_VERSION_MAJOR}.x/$PATCH_NAME.xz
+#wget https://www.kernel.org/pub/linux/kernel/v${SRC_VERSION_MAJOR}.x/$PATCH_NAME.sign
 
 echo "Extract the kernel"
 tar xf $KERNEL_NAME.tar.xz
@@ -40,9 +41,14 @@ cd $KERNEL_NAME
 
 echo "RealSense patch..."
 
-# Apply our RealSense specific patch
+# TODO: The patches should be chosen to fit to the kernel version
+
+# Apply our RealSense specific camera formats patch
 patch -p1 < ../../realsense-camera-formats.patch
 
+# Apply our RealSense specific metadata patch
+patch -p1 < ../../realsense-metadata-bionic-5.patch
+
 # Prepare to compile modules
 
 ## Get the config
@@ -94,7 +100,7 @@ if [ -e $MODULE_NAME.xz ]; then
 
     # compress
     xz uvcvideo.ko
-    sudo cp uvcvideo.ko.xz $MODULE_NAME
+    sudo cp uvcvideo.ko.xz $MODULE_NAME.xz
 fi
 
 if [ -e $MODULE_NAME.gz ]; then
diff --git a/scripts/patch-realsense-ubuntu-lts.sh b/scripts/patch-realsense-ubuntu-lts.sh
index 6330aa1..c849e02 100755
--- a/scripts/patch-realsense-ubuntu-lts.sh
+++ b/scripts/patch-realsense-ubuntu-lts.sh
@@ -83,7 +83,7 @@ cd ${kernel_name}
 #then
 #Search the repository for the tag that matches the mmaj.min.patch-build of Ubuntu kernel
 kernel_full_num=$(echo $LINUX_BRANCH | cut -d '-' -f 1,2)
-kernel_git_tag=$(git ls-remote --tags origin | grep ${kernel_full_num} | grep '[^^{}]$' | tail -n 1 | awk -F/ '{print $NF}')
+kernel_git_tag=$(git ls-remote --tags origin | grep "${kernel_full_num}\." | grep '[^^{}]$' | tail -n 1 | awk -F/ '{print $NF}')
 echo -e "\e[32mFetching Ubuntu LTS tag \e[47m${kernel_git_tag}\e[0m \e[32m to the local kernel sources folder\e[0m"
 git fetch origin tag ${kernel_git_tag} --no-tags
 
diff --git a/scripts/patch-utils.sh b/scripts/patch-utils.sh
index e4e4741..84dd546 100755
--- a/scripts/patch-utils.sh
+++ b/scripts/patch-utils.sh
@@ -22,7 +22,7 @@ function require_package {
 
 #Based on the current kernel version select the branch name to fetch the kernel source code
 # The reference name are pulled here : http://kernel.ubuntu.com/git/ubuntu/ubuntu-xenial.git/
-# As of Jun 21, the status is 
+# As of Jun 19
 #	Branch		Commit message								Author							Age
 #	hwe			UBUNTU: Ubuntu-hwe-4.15.0-24.26~16.04.1		Andy Whitcroft					6 days
 #	hwe-edge	UBUNTU: Ubuntu-hwe-4.15.0-23.25~16.04.1		Kleber Sacilotto de Souza		4 weeks
@@ -30,11 +30,13 @@ function require_package {
 #	master		UBUNTU: Ubuntu-4.4.0-128.154				Stefan Bader					4 weeks
 #	master-next	UBUNTU: SAUCE: Redpine: fix soft-ap invisible issue	Sanjay Kumar Konduri	2 days
 
-# As of Jan  21, 2020
+# As of Jun  21, 2020
 #Ubuntu bionic repo : http://kernel.ubuntu.com/git/ubuntu/ubuntu-bionic.git/
-#	hwe	UBUNTU: Ubuntu-hwe-5.3.0-28.30~18.04.1	Sultan Alsawaf	6 days
-#	hwe-edge	UBUNTU: Ubuntu-hwe-edge-5.3.0-24.26~18.04.2	Kleber Sacilotto de Souza	8 weeks
-#	master	UBUNTU: Ubuntu-4.15.0-74.84	Khalid Elmously	5 weeks
+#   hwe	UBUNTU: Ubuntu-hwe-5.3.0-56.50~18.04.1	Kleber Sacilotto de Souza	3 weeks
+#   hwe-5.0	UBUNTU: Ubuntu-hwe-5.0-5.0.0-53.57~18.04.1	Sultan Alsawaf	7 days
+#   hwe-5.4	UBUNTU: Ubuntu-hwe-5.4-5.4.0-38.42~18.04.1	Stefan Bader	4 days
+#   hwe-edge	UBUNTU: Ubuntu-hwe-edge-5.3.0-24.26~18.04.2	Kleber Sacilotto de Souza	7 months
+#   master	UBUNTU: Ubuntu-4.15.0-106.107	Kleber Sacilotto de Souza	2 weeks
 #	master-current	UBUNTU: Ubuntu-4.15.0-66.75	Khalid Elmously	4 months
 
 function choose_kernel_branch {
@@ -80,10 +82,15 @@ function choose_kernel_branch {
 			echo Ubuntu-hwe-4.18.0-25.26_18.04.1
 			;;
 		"5.0")									# kernel 5.0 for Ubuntu 18/Bionic Beaver
-			echo 5
+			#echo hwe-5.0
+            echo 5
 			;;
 		"5.3")									# kernel 5.3
-			echo 5
+			#echo hwe
+            echo 5
+			;;
+		"5.4")									# kernel 5.4
+			echo hwe-5.4
 			;;
 		*)
 			#error message shall be redirected to stderr to be printed properly
diff --git a/scripts/realsense-camera-formats-bionic-5.patch b/scripts/realsense-camera-formats-bionic-5.patch
index 5785570..e95d7fa 100644
--- a/scripts/realsense-camera-formats-bionic-5.patch
+++ b/scripts/realsense-camera-formats-bionic-5.patch
@@ -15,7 +15,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index 33a22c016..a7b76c987 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -219,6 +219,43 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -219,6 +219,58 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_CNF4,
  		.fcc		= V4L2_PIX_FMT_CNF4,
  	},
@@ -55,6 +55,21 @@ index 33a22c016..a7b76c987 100644
 +		.name		= "Z16 Huffman Compression",
 +		.guid		= UVC_GUID_FORMAT_Z16H,
 +		.fcc		= V4L2_PIX_FMT_Z16H,
++	},
++	{
++		.name		= "Frame Grabber (FG  )",
++		.guid		= UVC_GUID_FORMAT_FG,
++		.fcc		= V4L2_PIX_FMT_FG,
++	},
++	{
++		.name		= "SR300 Depth/Confidence (INZC)",
++		.guid		= UVC_GUID_FORMAT_INZC,
++		.fcc		= V4L2_PIX_FMT_INZC,
++	},
++	{
++		.name		= "Relative IR (PAIR)",
++		.guid		= UVC_GUID_FORMAT_PAIR,
++		.fcc		= V4L2_PIX_FMT_PAIR,
 +	},
  };
  
@@ -63,7 +78,7 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index 9b41b14ce..4b88f31f5 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -165,6 +165,28 @@
+@@ -165,6 +165,37 @@
  	{0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, \
  	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
  
@@ -89,6 +104,15 @@ index 9b41b14ce..4b88f31f5 100644
 +	#define UVC_GUID_FORMAT_Z16H \
 +	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_FG \
++	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
++	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_INZC \
++	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
++	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	#define UVC_GUID_FORMAT_PAIR \
++	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
++	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
  
  /* ------------------------------------------------------------------------
   * Driver specific constants.
@@ -103,7 +127,7 @@ index 90aad465f..e2d757e9a 100644
 +	/* Librealsense formats*/
 +	case V4L2_PIX_FMT_RW16:		descr = "16-bit Raw data"; break;
 +	case V4L2_PIX_FMT_W10:		descr = "10-bit packed 8888[2222]"; break;
-+	case V4L2_META_FMT_D4XX:		descr = "D4XX Payload Header metadata"; break;
++	case V4L2_META_FMT_D4XX:	descr = "D4XX Payload Header metadata"; break;
 +	case V4L2_PIX_FMT_CONFIDENCE_MAP:	descr = "Packed [44] confidence data"; break;
 +	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
 +	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
@@ -122,7 +146,7 @@ index b5671ce27..8954f78be 100644
  #define V4L2_PIX_FMT_CNF4     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
 +#define V4L2_PIX_FMT_RW16     v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
 +#define V4L2_PIX_FMT_W10      v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
-+#define V4L2_PIX_FMT_CONFIDENCE_MAP	v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
++#define V4L2_PIX_FMT_CONFIDENCE_MAP    v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
 +/*  Librealsense development*/
 +#define V4L2_PIX_FMT_FG       v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
 +#define V4L2_PIX_FMT_INZC     v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
diff --git a/scripts/realsense-camera-formats-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch b/scripts/realsense-camera-formats-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
index e130292..bd6c755 100644
--- a/scripts/realsense-camera-formats-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
+++ b/scripts/realsense-camera-formats-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
@@ -15,7 +15,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index 8e1382013..6f1dd1a9e 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -209,6 +209,48 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -209,6 +209,63 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_INZI,
  		.fcc		= V4L2_PIX_FMT_INZI,
  	},
@@ -60,6 +60,21 @@ index 8e1382013..6f1dd1a9e 100644
 +		.name		= "Z16 Huffman Compression",
 +		.guid		= UVC_GUID_FORMAT_Z16H,
 +		.fcc		= V4L2_PIX_FMT_Z16H,
++	},
++	{
++		.name		= "Frame Grabber (FG  )",
++		.guid		= UVC_GUID_FORMAT_FG,
++		.fcc		= V4L2_PIX_FMT_FG,
++	},
++	{
++		.name		= "SR300 Depth/Confidence (INZC)",
++		.guid		= UVC_GUID_FORMAT_INZC,
++		.fcc		= V4L2_PIX_FMT_INZC,
++	},
++	{
++		.name		= "Relative IR (PAIR)",
++		.guid		= UVC_GUID_FORMAT_PAIR,
++		.fcc		= V4L2_PIX_FMT_PAIR,
 +	},
  };
  
@@ -68,7 +83,7 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index be5cf1792..f405e5fe6 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -158,6 +158,31 @@
+@@ -158,6 +158,40 @@
  	{0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, \
  	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
  
@@ -96,7 +111,16 @@ index be5cf1792..f405e5fe6 100644
 +		0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +	#define UVC_GUID_FORMAT_Z16H \
 +	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
-+	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_FG \
++	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_INZC \
++	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
++		0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	#define UVC_GUID_FORMAT_PAIR \
++	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
++		0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
  
  /* ------------------------------------------------------------------------
   * Driver specific constants.
diff --git a/scripts/realsense-camera-formats-bionic-hwe-5.4.patch b/scripts/realsense-camera-formats-bionic-hwe-5.4.patch
new file mode 100644
index 0000000..3ee3ffe
--- /dev/null
+++ b/scripts/realsense-camera-formats-bionic-hwe-5.4.patch
@@ -0,0 +1,159 @@
+Subject: [PATCH] Streaming formats for Ubuntu 18.04 (Bionic Beaver), Kernel 5.4
+From 120e2ef648e5f906555407ff7265ce729fc6d503 Mon Sep 17 00:00:00 2001
+From: Evgeni Raikhel <evgeni.raikhel@intel.com>
+Signed-off-by: Evgeni Raikhel <evgeni.raikhel@intel.com>
+Date: Mon, 24 Jun 2019 10:25:39 +0300
+
+---
+ drivers/media/usb/uvc/uvc_driver.c   | 37 ++++++++++++++++++++++++++++
+ drivers/media/usb/uvc/uvcvideo.h     | 22 +++++++++++++++++
+ drivers/media/v4l2-core/v4l2-ioctl.c |  8 ++++++
+ include/uapi/linux/videodev2.h       |  8 ++++++
+ 4 files changed, 75 insertions(+)
+
+diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
+index 99883550375e..443ecea63bd8 100644
+--- a/drivers/media/usb/uvc/uvc_driver.c
++++ b/drivers/media/usb/uvc/uvc_driver.c
+@@ -214,6 +214,58 @@ static struct uvc_format_desc uvc_fmts[] = {
+ 		.guid		= UVC_GUID_FORMAT_CNF4,
+ 		.fcc		= V4L2_PIX_FMT_CNF4,
+ 	},
++	{
++		.name		= "Depth data 16-bit (D16)",
++		.guid		= UVC_GUID_FORMAT_D16,
++		.fcc		= V4L2_PIX_FMT_Z16,
++	},
++	{
++		.name		= "Packed raw data 10-bit",
++		.guid		= UVC_GUID_FORMAT_W10,
++		.fcc		= V4L2_PIX_FMT_W10,
++	},
++	{
++		.name		= "Confidence data (C   )",
++		.guid		= UVC_GUID_FORMAT_CONFIDENCE_MAP,
++		.fcc		= V4L2_PIX_FMT_CONFIDENCE_MAP,
++	},
++	/* FishEye 8-bit monochrome */
++	{
++		.name		= "Raw data 8-bit (RAW8)",
++		.guid		= UVC_GUID_FORMAT_RAW8,
++		.fcc		= V4L2_PIX_FMT_GREY,
++	},
++	/* Legacy formats for backward-compatibility*/
++	{
++		.name		= "Raw data 16-bit (RW16)",
++		.guid		= UVC_GUID_FORMAT_RW16,
++		.fcc		= V4L2_PIX_FMT_RW16,
++	},
++	{
++		.name		= "16-bit Bayer BGBG/GRGR",
++		.guid		= UVC_GUID_FORMAT_BAYER16,
++		.fcc		= V4L2_PIX_FMT_SBGGR16,
++	},
++	{
++		.name		= "Z16 Huffman Compression",
++		.guid		= UVC_GUID_FORMAT_Z16H,
++		.fcc		= V4L2_PIX_FMT_Z16H,
++	},
++	{
++		.name		= "Frame Grabber (FG  )",
++		.guid		= UVC_GUID_FORMAT_FG,
++		.fcc		= V4L2_PIX_FMT_FG,
++	},
++	{
++		.name		= "SR300 Depth/Confidence (INZC)",
++		.guid		= UVC_GUID_FORMAT_INZC,
++		.fcc		= V4L2_PIX_FMT_INZC,
++	},
++	{
++		.name		= "Relative IR (PAIR)",
++		.guid		= UVC_GUID_FORMAT_PAIR,
++		.fcc		= V4L2_PIX_FMT_PAIR,
++	},
+ };
+ 
+ /* ------------------------------------------------------------------------
+diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
+index 24e3d8c647e7..1aa8493a24d1 100644
+--- a/drivers/media/usb/uvc/uvcvideo.h
++++ b/drivers/media/usb/uvc/uvcvideo.h
+@@ -165,6 +165,37 @@
+ 	{0x32, 0x00, 0x00, 0x00, 0x02, 0x00, 0x10, 0x00, \
+ 	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
+ 
++	#define UVC_GUID_FORMAT_D16 \
++	{ 'P', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_W10 \
++	{ 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_RAW8 \
++	{ 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
++		0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
++	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	/* Legacy formats */
++	#define UVC_GUID_FORMAT_RW16 \
++	{ 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
++		0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_BAYER16 \
++	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
++		0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	#define UVC_GUID_FORMAT_Z16H \
++	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_FG \
++	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
++	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_INZC \
++	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
++	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	#define UVC_GUID_FORMAT_PAIR \
++	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
++	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
+ 
+ /* ------------------------------------------------------------------------
+  * Driver specific constants.
+diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c
+index 58868d7129eb..c29033b8439c 100644
+--- a/drivers/media/v4l2-core/v4l2-ioctl.c
++++ b/drivers/media/v4l2-core/v4l2-ioctl.c
+@@ -1330,6 +1330,14 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
+ 	case V4L2_META_FMT_VSP1_HGT:	descr = "R-Car VSP1 2-D Histogram"; break;
+ 	case V4L2_META_FMT_UVC:		descr = "UVC Payload Header Metadata"; break;
+ 	case V4L2_META_FMT_D4XX:	descr = "Intel D4xx UVC Metadata"; break;
++	/* Librealsense formats*/
++	case V4L2_PIX_FMT_RW16:		descr = "16-bit Raw data"; break;
++	case V4L2_PIX_FMT_W10:		descr = "10-bit packed 8888[2222]"; break;
++	case V4L2_PIX_FMT_CONFIDENCE_MAP:	descr = "Packed [44] confidence data"; break;
++	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
++	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
++	case V4L2_PIX_FMT_PAIR:		descr = "Relative IR (PAIR)"; break;
++	case V4L2_PIX_FMT_Z16H:		descr = "Z16 Huffman Compression"; break;
+ 
+ 	default:
+ 		/* Compressed formats */
+diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
+index 530638dffd93..d7c85713e32c 100644
+--- a/include/uapi/linux/videodev2.h
++++ b/include/uapi/linux/videodev2.h
+@@ -727,6 +727,14 @@ struct v4l2_pix_format {
+ #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
+ #define V4L2_PIX_FMT_SUNXI_TILED_NV12 v4l2_fourcc('S', 'T', '1', '2') /* Sunxi Tiled NV12 Format */
+ #define V4L2_PIX_FMT_CNF4     v4l2_fourcc('C', 'N', 'F', '4') /* Intel 4-bit packed depth confidence information */
++#define V4L2_PIX_FMT_RW16     v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
++#define V4L2_PIX_FMT_W10      v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
++#define V4L2_PIX_FMT_CONFIDENCE_MAP	v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
++/*  Librealsense development*/
++#define V4L2_PIX_FMT_FG       v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
++#define V4L2_PIX_FMT_INZC     v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
++#define V4L2_PIX_FMT_PAIR     v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_Z16H     v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
+ 
+ /* 10bit raw bayer packed, 32 bytes for every 25 pixels, last LSB 6 bits unused */
+ #define V4L2_PIX_FMT_IPU3_SBGGR10	v4l2_fourcc('i', 'p', '3', 'b') /* IPU3 packed 10-bit BGGR bayer */
+-- 
+2.17.1
+
diff --git a/scripts/realsense-camera-formats-bionic-master.patch b/scripts/realsense-camera-formats-bionic-master.patch
index 2ac38bf..e0d81d5 100644
--- a/scripts/realsense-camera-formats-bionic-master.patch
+++ b/scripts/realsense-camera-formats-bionic-master.patch
@@ -27,7 +27,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index 28b91b7d7..f50a2b148 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -203,6 +203,48 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -203,6 +203,63 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_INZI,
  		.fcc		= V4L2_PIX_FMT_INZI,
  	},
@@ -72,6 +72,21 @@ index 28b91b7d7..f50a2b148 100644
 +		.name		= "Z16 Huffman Compression",
 +		.guid		= UVC_GUID_FORMAT_Z16H,
 +		.fcc		= V4L2_PIX_FMT_Z16H,
++	},
++	{
++		.name		= "Frame Grabber (FG  )",
++		.guid		= UVC_GUID_FORMAT_FG,
++		.fcc		= V4L2_PIX_FMT_FG,
++	},
++	{
++		.name		= "SR300 Depth/Confidence (INZC)",
++		.guid		= UVC_GUID_FORMAT_INZC,
++		.fcc		= V4L2_PIX_FMT_INZC,
++	},
++	{
++		.name		= "Relative IR (PAIR)",
++		.guid		= UVC_GUID_FORMAT_PAIR,
++		.fcc		= V4L2_PIX_FMT_PAIR,
 +	},
  };
 
@@ -80,35 +95,44 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index 05398784d..8c99aabef 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -153,6 +153,31 @@
+@@ -153,6 +153,40 @@
  #define UVC_GUID_FORMAT_INVI \
  	{ 'I',  'N',  'V',  'I', 0xdb, 0x57, 0x49, 0x5e, \
  	 0x8e, 0x3f, 0xf4, 0x79, 0x53, 0x2b, 0x94, 0x6f}
-+#define UVC_GUID_FORMAT_L8 \
++	#define UVC_GUID_FORMAT_L8 \
 +	{ '2', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-+#define UVC_GUID_FORMAT_D16 \
++	#define UVC_GUID_FORMAT_D16 \
 +	{ 'P', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-+#define UVC_GUID_FORMAT_W10 \
++	#define UVC_GUID_FORMAT_W10 \
 +	{ 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-+#define UVC_GUID_FORMAT_RAW8 \
++	#define UVC_GUID_FORMAT_RAW8 \
 +	{ 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
 +	0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
-+#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
++	#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
 +	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
 +	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-+/* Legacy formats */
-+#define UVC_GUID_FORMAT_RW16 \
++	/* Legacy formats */
++	#define UVC_GUID_FORMAT_RW16 \
 +	{ 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
 +	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
-+#define UVC_GUID_FORMAT_BAYER16 \
++	#define UVC_GUID_FORMAT_BAYER16 \
 +	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
 +	0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
-+#define UVC_GUID_FORMAT_Z16H \
++	#define UVC_GUID_FORMAT_Z16H \
 +	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_FG \
++	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
++	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	#define UVC_GUID_FORMAT_INZC \
++	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
++	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	#define UVC_GUID_FORMAT_PAIR \
++	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
++	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
 
  /* ------------------------------------------------------------------------
   * Driver specific constants.
diff --git a/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.13.0-45.50_16.04.1.patch b/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.13.0-45.50_16.04.1.patch
index 5de9acc..c9dba91 100644
--- a/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.13.0-45.50_16.04.1.patch
+++ b/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.13.0-45.50_16.04.1.patch
@@ -16,7 +16,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index 70842c5..2c92aa0 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -203,6 +203,58 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -203,6 +203,63 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_INZI,
  		.fcc		= V4L2_PIX_FMT_INZI,
  	},
@@ -71,6 +71,11 @@ index 70842c5..2c92aa0 100644
 +		.name		= "Relative IR (PAIR)",
 +		.guid		= UVC_GUID_FORMAT_PAIR,
 +		.fcc		= V4L2_PIX_FMT_PAIR,
++	},
++	{
++		.name		= "Z16 Huffman Compression",
++		.guid		= UVC_GUID_FORMAT_Z16H,
++		.fcc		= V4L2_PIX_FMT_Z16H,
 +	},
  };
 
@@ -79,7 +84,7 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index 15e415e..1ade6ee 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -152,6 +152,40 @@
+@@ -152,6 +155,40 @@
  #define UVC_GUID_FORMAT_INVI \
  	{ 'I',  'N',  'V',  'I', 0xdb, 0x57, 0x49, 0x5e, \
  	 0x8e, 0x3f, 0xf4, 0x79, 0x53, 0x2b, 0x94, 0x6f}
@@ -117,6 +122,9 @@ index 15e415e..1ade6ee 100644
 +#define UVC_GUID_FORMAT_PAIR \
 +	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
 +	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++	#define UVC_GUID_FORMAT_Z16H \
++	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
  
  /* ------------------------------------------------------------------------
   * Driver specific constants.
@@ -124,7 +132,7 @@ diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2
 index cab63bb..f9fcf13 100644
 --- a/drivers/media/v4l2-core/v4l2-ioctl.c
 +++ b/drivers/media/v4l2-core/v4l2-ioctl.c
-@@ -1239,7 +1239,13 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
+@@ -1239,7 +1239,14 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
  	case V4L2_TCH_FMT_TU08:		descr = "8-bit unsigned touch data"; break;
  	case V4L2_META_FMT_VSP1_HGO:	descr = "R-Car VSP1 1-D Histogram"; break;
  	case V4L2_META_FMT_VSP1_HGT:	descr = "R-Car VSP1 2-D Histogram"; break;
@@ -136,6 +144,7 @@ index cab63bb..f9fcf13 100644
 +	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
 +	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
 +	case V4L2_PIX_FMT_PAIR:		descr = "Relative IR (PAIR)"; break;
++	case V4L2_PIX_FMT_Z16H:		descr = "Z16 Huffman Compression"; break;
  	default:
  		/* Compressed formats */
  		flags = V4L2_FMT_FLAG_COMPRESSED;
@@ -143,18 +152,19 @@ diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
 index 45cf735..6944a02 100644
 --- a/include/uapi/linux/videodev2.h
 +++ b/include/uapi/linux/videodev2.h
-@@ -662,6 +662,14 @@ struct v4l2_pix_format {
+@@ -662,6 +662,15 @@ struct v4l2_pix_format {
  #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
  #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
  #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
-+#define V4L2_PIX_FMT_RW16	v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
-+#define V4L2_PIX_FMT_W10	v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
++#define V4L2_PIX_FMT_RW16      v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
++#define V4L2_PIX_FMT_W10       v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
 +#define V4L2_PIX_FMT_CONFIDENCE_MAP  v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
 +
 +/*  Librealsense development*/
-+#define V4L2_PIX_FMT_FG	v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
-+#define V4L2_PIX_FMT_INZC	v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
-+#define V4L2_PIX_FMT_PAIR	v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_FG        v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
++#define V4L2_PIX_FMT_INZC      v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
++#define V4L2_PIX_FMT_PAIR      v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_Z16H      v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
  
  /* SDR formats - used only for Software Defined Radio devices */
  #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.8.0-58.63_16.04.1.patch b/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.8.0-58.63_16.04.1.patch
index b4d7918..45d1a84 100644
--- a/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.8.0-58.63_16.04.1.patch
+++ b/scripts/realsense-camera-formats-xenial-Ubuntu-hwe-4.8.0-58.63_16.04.1.patch
@@ -28,7 +28,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index cde43b6..54bd175 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -168,6 +168,103 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -168,6 +168,108 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_RW10,
  		.fcc		= V4L2_PIX_FMT_SRGGB10P,
  	},
@@ -128,6 +128,11 @@ index cde43b6..54bd175 100644
 +		.name		= "Relative IR (PAIR)",
 +		.guid		= UVC_GUID_FORMAT_PAIR,
 +		.fcc		= V4L2_PIX_FMT_PAIR,
++	},
++	{
++		.name		= "Z16 Huffman Compression",
++		.guid		= UVC_GUID_FORMAT_Z16H,
++		.fcc		= V4L2_PIX_FMT_Z16H,
 +	},
  };
  
@@ -136,16 +141,16 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index 7e4d3ee..e517d8f 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -131,6 +131,57 @@
+@@ -131,6 +131,60 @@
  #define UVC_GUID_FORMAT_RW10 \
  	{ 'R',  'W',  '1',  '0', 0x00, 0x00, 0x10, 0x00, \
  	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_RAW8 \
-+    { 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
-+     0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	{ 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_RW16 \
-+    { 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
-+     0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	{ 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_INVZ \
 +	{ 'I',  'N',  'V',  'Z', 0x90, 0x2d, 0x58, 0x4a, \
 +	 0x92, 0x0b, 0x77, 0x3f, 0x1f, 0x2c, 0x55, 0x6b}
@@ -174,23 +179,26 @@ index 7e4d3ee..e517d8f 100644
 +	{ 'P', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_BAYER16 \
-+    { 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
-+     0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_W10 \
-+    { 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
++	{ 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
 +	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_FG \
 +	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_INZC \
 +	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
-+	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	 0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
 +#define UVC_GUID_FORMAT_PAIR \
 +	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
-+	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++	 0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++#define UVC_GUID_FORMAT_Z16H \
++	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
  
  /* ------------------------------------------------------------------------
   * Driver specific constants.
@@ -198,7 +206,7 @@ diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2
 index 51a0fa1..391c2b3 100644
 --- a/drivers/media/v4l2-core/v4l2-ioctl.c
 +++ b/drivers/media/v4l2-core/v4l2-ioctl.c
-@@ -1243,6 +1243,16 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
+@@ -1243,6 +1243,17 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
  	case V4L2_SDR_FMT_CS8:		descr = "Complex S8"; break;
  	case V4L2_SDR_FMT_CS14LE:	descr = "Complex S14LE"; break;
  	case V4L2_SDR_FMT_RU12LE:	descr = "Real U12LE"; break;
@@ -212,6 +220,7 @@ index 51a0fa1..391c2b3 100644
 +	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
 +	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
 +	case V4L2_PIX_FMT_PAIR:		descr = "Relative IR (PAIR)"; break;
++	case V4L2_PIX_FMT_Z16H:		descr = "Z16 Huffman Compression"; break;
  
  	default:
  		/* Compressed formats */
@@ -219,7 +228,7 @@ diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
 index 724f43e..29bcba5 100644
 --- a/include/uapi/linux/videodev2.h
 +++ b/include/uapi/linux/videodev2.h
-@@ -627,6 +627,18 @@ struct v4l2_pix_format {
+@@ -627,6 +627,19 @@ struct v4l2_pix_format {
  #define V4L2_PIX_FMT_Y8I      v4l2_fourcc('Y', '8', 'I', ' ') /* Greyscale 8-bit L/R interleaved */
  #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
  #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
@@ -232,9 +241,10 @@ index 724f43e..29bcba5 100644
 +#define V4L2_PIX_FMT_W10      v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
 +#define V4L2_PIX_FMT_CONFIDENCE_MAP  v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
 +/*  Librealsense development*/
-+#define V4L2_PIX_FMT_FG	v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
-+#define V4L2_PIX_FMT_INZC	v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
-+#define V4L2_PIX_FMT_PAIR	v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_FG        v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
++#define V4L2_PIX_FMT_INZC      v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
++#define V4L2_PIX_FMT_PAIR      v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_Z16H      v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
  
  /* SDR formats - used only for Software Defined Radio devices */
  #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/scripts/realsense-camera-formats-xenial-hwe-zesty.patch b/scripts/realsense-camera-formats-xenial-hwe-zesty.patch
index 4c6307c..2ad52d8 100644
--- a/scripts/realsense-camera-formats-xenial-hwe-zesty.patch
+++ b/scripts/realsense-camera-formats-xenial-hwe-zesty.patch
@@ -16,7 +16,7 @@ diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driv
 index 04bf350..bb8fefb 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -188,6 +188,88 @@ static struct uvc_format_desc uvc_fmts[] = {
+@@ -188,6 +188,93 @@ static struct uvc_format_desc uvc_fmts[] = {
  		.guid		= UVC_GUID_FORMAT_GR16,
  		.fcc		= V4L2_PIX_FMT_SGRBG16,
  	},
@@ -101,6 +101,11 @@ index 04bf350..bb8fefb 100644
 +		.name		= "Relative IR (PAIR)",
 +		.guid		= UVC_GUID_FORMAT_PAIR,
 +		.fcc		= V4L2_PIX_FMT_PAIR,
++	},
++	{
++		.name		= "Z16 Huffman Compression",
++		.guid		= UVC_GUID_FORMAT_Z16H,
++		.fcc		= V4L2_PIX_FMT_Z16H,
 +	},
  };
  
@@ -109,16 +114,16 @@ diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
 index 3d6cc62..6ffdc0e 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -143,6 +143,48 @@
+@@ -143,6 +143,51 @@
  #define UVC_GUID_FORMAT_RW10 \
  	{ 'R',  'W',  '1',  '0', 0x00, 0x00, 0x10, 0x00, \
  	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_RAW8 \
-+    { 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
-+     0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++   { 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
++    0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_RW16 \
-+    { 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
-+     0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++   { 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
++    0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_INVZ \
 +	{ 'I',  'N',  'V',  'Z', 0x90, 0x2d, 0x58, 0x4a, \
 +	 0x92, 0x0b, 0x77, 0x3f, 0x1f, 0x2c, 0x55, 0x6b}
@@ -138,23 +143,26 @@ index 3d6cc62..6ffdc0e 100644
 +	{ 'P', 0x00,  0x00,  0x00, 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_BAYER16 \
-+    { 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
-+     0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_W10 \
-+    { 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
++	{ 'W',  '1',  '0',  ' ', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
 +	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_FG \
 +	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_INZC \
 +	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
-+	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	 0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
 +#define UVC_GUID_FORMAT_PAIR \
 +	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
-+	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++	 0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++#define UVC_GUID_FORMAT_Z16H \
++	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
  
  /* ------------------------------------------------------------------------
   * Driver specific constants.
@@ -162,7 +170,7 @@ diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2
 index 0c3f238..5347286 100644
 --- a/drivers/media/v4l2-core/v4l2-ioctl.c
 +++ b/drivers/media/v4l2-core/v4l2-ioctl.c
-@@ -1217,7 +1217,13 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
+@@ -1217,7 +1217,14 @@ static void v4l_fill_fmtdesc(struct v4l2_fmtdesc *fmt)
  	case V4L2_TCH_FMT_DELTA_TD08:	descr = "8-bit signed deltas"; break;
  	case V4L2_TCH_FMT_TU16:		descr = "16-bit unsigned touch data"; break;
  	case V4L2_TCH_FMT_TU08:		descr = "8-bit unsigned touch data"; break;
@@ -174,6 +182,7 @@ index 0c3f238..5347286 100644
 +	case V4L2_PIX_FMT_FG:		descr = "Frame Grabber (FG  )"; break;
 +	case V4L2_PIX_FMT_INZC:		descr = "Planar Depth/Confidence (INZC)"; break;
 +	case V4L2_PIX_FMT_PAIR:		descr = "Relative IR (PAIR)"; break;
++	case V4L2_PIX_FMT_Z16H:		descr = "Z16 Huffman Compression"; break;
  	default:
  		/* Compressed formats */
  		flags = V4L2_FMT_FLAG_COMPRESSED;
@@ -181,7 +190,7 @@ diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
 index 45184a2..e7f6029 100644
 --- a/include/uapi/linux/videodev2.h
 +++ b/include/uapi/linux/videodev2.h
-@@ -661,7 +661,16 @@ struct v4l2_pix_format {
+@@ -661,7 +661,17 @@ struct v4l2_pix_format {
  #define V4L2_PIX_FMT_Y12I     v4l2_fourcc('Y', '1', '2', 'I') /* Greyscale 12-bit L/R interleaved */
  #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
  #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
@@ -196,6 +205,7 @@ index 45184a2..e7f6029 100644
 +#define V4L2_PIX_FMT_FG	v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
 +#define V4L2_PIX_FMT_INZC	v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
 +#define V4L2_PIX_FMT_PAIR	v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_Z16H     v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
  /* SDR formats - used only for Software Defined Radio devices */
  #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
  #define V4L2_SDR_FMT_CU16LE       v4l2_fourcc('C', 'U', '1', '6') /* IQ u16le */
diff --git a/scripts/realsense-camera-formats-xenial-hwe.patch b/scripts/realsense-camera-formats-xenial-hwe.patch
index 684af46..40b1f0d 100644
--- a/scripts/realsense-camera-formats-xenial-hwe.patch
+++ b/scripts/realsense-camera-formats-xenial-hwe.patch
@@ -110,29 +110,29 @@ index 0539878..401882d 100644
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_RAW8 \
 +	{ 'R',  'A',  'W',  '8', 0x66, 0x1a, 0x42, 0xa2, \
-+	0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_CONFIDENCE_MAP \
 +	{ 'C',  ' ',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +/* Legacy/Development formats */
 +#define UVC_GUID_FORMAT_RW16 \
 +	{ 'R',  'W',  '1',  '6', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_BAYER16 \
 +	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
-+	0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_BAYER16 \
 +	{ 'R',  'W',  '1',  '6', 0x66, 0x1a, 0x42, 0xa2, \
-+	0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
++	 0x90, 0x65, 0xd0, 0x18, 0x14, 0xa8, 0xef, 0x8a}
 +#define UVC_GUID_FORMAT_FG \
 +	{ 'F',  'G',  ' ',  ' ', 0x00, 0x00, 0x10, 0x00, \
-+	0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
++	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
 +#define UVC_GUID_FORMAT_INZC \
 +	{ 'I',  'N',  'Z',  'C', 0x02, 0xb6, 0x0f, 0x48, \
-+	0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
++	 0x97, 0x8c, 0xe4, 0xe8, 0x8a, 0xe8, 0x9b, 0x89}
 +#define UVC_GUID_FORMAT_PAIR \
 +	{ 'P',  'A',  'I',  'R', 0x36, 0x85, 0x41, 0x48, \
-+	0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
++	 0xb6, 0xbf, 0x8f, 0xc6, 0xff, 0xb0, 0x83, 0xa8}
 +#define UVC_GUID_FORMAT_Z16H \
 +	{ 'Z',  '1',  '6',  'H', 0x00, 0x00, 0x10, 0x00, \
 +	 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71}
@@ -167,15 +167,15 @@ index 1c095b5..959bf0b 100644
  #define V4L2_PIX_FMT_Z16      v4l2_fourcc('Z', '1', '6', ' ') /* Depth data 16-bit */
  #define V4L2_PIX_FMT_MT21C    v4l2_fourcc('M', 'T', '2', '1') /* Mediatek compressed block mode  */
  #define V4L2_PIX_FMT_INZI     v4l2_fourcc('I', 'N', 'Z', 'I') /* Intel Planar Greyscale 10-bit and Depth 16-bit */
-+#define V4L2_PIX_FMT_RW16	v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
-+#define V4L2_PIX_FMT_W10	v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
++#define V4L2_PIX_FMT_RW16      v4l2_fourcc('R', 'W', '1', '6') /* Raw data 16-bit */
++#define V4L2_PIX_FMT_W10       v4l2_fourcc('W', '1', '0', ' ') /* Packed raw data 10-bit */
 +#define V4L2_PIX_FMT_CONFIDENCE_MAP  v4l2_fourcc('C', ' ', ' ', ' ') /* Two pixels in one byte */
 +
 +/*  Librealsense development*/
-+#define V4L2_PIX_FMT_FG	v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
-+#define V4L2_PIX_FMT_INZC	v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
-+#define V4L2_PIX_FMT_PAIR	v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
-+#define V4L2_PIX_FMT_Z16H	v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
++#define V4L2_PIX_FMT_FG        v4l2_fourcc('F', 'G', ' ', ' ') /* Frame Grabber */
++#define V4L2_PIX_FMT_INZC      v4l2_fourcc('I', 'N', 'Z', 'C') /* Planar Depth/Confidence */
++#define V4L2_PIX_FMT_PAIR      v4l2_fourcc('P', 'A', 'I', 'R') /* Relative IR */
++#define V4L2_PIX_FMT_Z16H      v4l2_fourcc('Z', '1', '6', 'H') /* Depth Z16 custom Huffman Code compression*/
  
  /* SDR formats - used only for Software Defined Radio devices */
  #define V4L2_SDR_FMT_CU8          v4l2_fourcc('C', 'U', '0', '8') /* IQ u8 */
diff --git a/scripts/realsense-hid-bionic-hwe-5.4.patch b/scripts/realsense-hid-bionic-hwe-5.4.patch
new file mode 100644
index 0000000..a83a885
--- /dev/null
+++ b/scripts/realsense-hid-bionic-hwe-5.4.patch
@@ -0,0 +1,108 @@
+Signed-off-by: Evgeni <evgeni.raikhel@intel.com>
+From 001649b143e1a4e0924ac6fc47883a45ba28ff63 Mon Sep 17 00:00:00 2001
+Date: Fri, 19 Jun 2020 12:38:24 +0300
+Subject: [PATCH] Adding missing HID timestamp patch for Gyro sensor.
+         Ubuntu 18.04 Bionic Beaver with Kernel 5.4
+	A symmetric patch for Accelerator was already upstreamed,
+	this patch was skipped from upstream
+	The patch was written by Srinivas Pandruvada <srinivas.pandruvada@intel.com>
+	Additionally, timestamp conversion is fixed
+
+---
+ drivers/iio/accel/hid-sensor-accel-3d.c |  1 +
+ drivers/iio/gyro/hid-sensor-gyro-3d.c   | 31 ++++++++++++++++++-------
+ 2 files changed, 24 insertions(+), 8 deletions(-)
+
+diff --git a/drivers/iio/accel/hid-sensor-accel-3d.c b/drivers/iio/accel/hid-sensor-accel-3d.c
+index 0d9e2def2b25..ad90203c87c1 100644
+--- a/drivers/iio/accel/hid-sensor-accel-3d.c
++++ b/drivers/iio/accel/hid-sensor-accel-3d.c
+@@ -276,6 +276,7 @@ static int accel_3d_capture_sample(struct hid_sensor_hub_device *hsdev,
+ 			hid_sensor_convert_timestamp(
+ 					&accel_state->common_attributes,
+ 					*(int64_t *)raw_data);
++		ret = 0;
+ 	break;
+ 	default:
+ 		break;
+diff --git a/drivers/iio/gyro/hid-sensor-gyro-3d.c b/drivers/iio/gyro/hid-sensor-gyro-3d.c
+index 08cacbbf31e6..f6e88eecd145 100644
+--- a/drivers/iio/gyro/hid-sensor-gyro-3d.c
++++ b/drivers/iio/gyro/hid-sensor-gyro-3d.c
+@@ -29,11 +29,13 @@ struct gyro_3d_state {
+ 	struct hid_sensor_hub_callbacks callbacks;
+ 	struct hid_sensor_common common_attributes;
+ 	struct hid_sensor_hub_attribute_info gyro[GYRO_3D_CHANNEL_MAX];
+-	u32 gyro_val[GYRO_3D_CHANNEL_MAX];
++	/* Reserve for 3 channels + padding + timestamp */
++	u32 gyro_val[GYRO_3D_CHANNEL_MAX + 3];
+ 	int scale_pre_decml;
+ 	int scale_post_decml;
+ 	int scale_precision;
+ 	int value_offset;
++	int64_t timestamp;
+ };
+ 
+ static const u32 gyro_3d_addresses[GYRO_3D_CHANNEL_MAX] = {
+@@ -74,7 +76,8 @@ static const struct iio_chan_spec gyro_3d_channels[] = {
+ 		BIT(IIO_CHAN_INFO_SAMP_FREQ) |
+ 		BIT(IIO_CHAN_INFO_HYSTERESIS),
+ 		.scan_index = CHANNEL_SCAN_INDEX_Z,
+-	}
++	},
++	IIO_CHAN_SOFT_TIMESTAMP(3)
+ };
+ 
+ /* Adjust channel real bits based on report descriptor */
+@@ -181,11 +184,11 @@ static const struct iio_info gyro_3d_info = {
+ };
+ 
+ /* Function to push data to buffer */
+-static void hid_sensor_push_data(struct iio_dev *indio_dev, const void *data,
+-	int len)
++static void hid_sensor_push_data(struct iio_dev *indio_dev, void *data,
++	int len, int64_t timestamp)
+ {
+ 	dev_dbg(&indio_dev->dev, "hid_sensor_push_data\n");
+-	iio_push_to_buffers(indio_dev, data);
++	iio_push_to_buffers_with_timestamp(indio_dev, data, timestamp);
+ }
+ 
+ /* Callback handler to send event after all samples are received and captured */
+@@ -197,11 +200,16 @@ static int gyro_3d_proc_event(struct hid_sensor_hub_device *hsdev,
+ 	struct gyro_3d_state *gyro_state = iio_priv(indio_dev);
+ 
+ 	dev_dbg(&indio_dev->dev, "gyro_3d_proc_event\n");
+-	if (atomic_read(&gyro_state->common_attributes.data_ready))
++	if (atomic_read(&gyro_state->common_attributes.data_ready)) {
++		if (!gyro_state->timestamp)
++			gyro_state->timestamp = iio_get_time_ns(indio_dev);
++
+ 		hid_sensor_push_data(indio_dev,
+ 				gyro_state->gyro_val,
+-				sizeof(gyro_state->gyro_val));
+-
++				sizeof(gyro_state->gyro_val),
++				gyro_state->timestamp);
++		gyro_state->timestamp = 0;
++	}
+ 	return 0;
+ }
+ 
+@@ -225,6 +233,13 @@ static int gyro_3d_capture_sample(struct hid_sensor_hub_device *hsdev,
+ 						*(u32 *)raw_data;
+ 		ret = 0;
+ 	break;
++	case HID_USAGE_SENSOR_TIME_TIMESTAMP:
++		gyro_state->timestamp =
++			hid_sensor_convert_timestamp(
++					&gyro_state->common_attributes,
++					*(int64_t *)raw_data);
++		ret = 0;
++	break;
+ 	default:
+ 		break;
+ 	}
+-- 
+2.17.1
+
diff --git a/scripts/realsense-metadata-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch b/scripts/realsense-metadata-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
index 39736d5..3a0b0cd 100644
--- a/scripts/realsense-metadata-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
+++ b/scripts/realsense-metadata-bionic-Ubuntu-hwe-4.18.0-25.26_18.04.1.patch
@@ -1,20 +1,19 @@
-From 2be737f3c795751dcab548e0d8dbd7b1c2c89a49 Mon Sep 17 00:00:00 2001
-From: Evgeni <evgeni.raikhel@intel.com>
-Date: Mon, 1 Apr 2019 15:54:03 +0300
-Subject: [PATCH] Enabling UVC Metadata attributes with Ubuntu 18.04. Kernel 4.18
-
 Signed-off-by: Evgeni <evgeni.raikhel@intel.com>
+From 90588aff339a66dde0462042729692b8fa44373e Mon Sep 17 00:00:00 2001
+From: Evgeni Raikhel <evgeni.raikhel@intel.com>
+Date: Sat, 20 Jun 2020 14:55:57 +0300
+Subject: [PATCH] Enabling UVC Metadata attributes with Ubuntu 18.04. Kernel 5.18
 ---
- drivers/media/usb/uvc/uvc_driver.c | 172 +++++++++++++++++++++++++++++
+ drivers/media/usb/uvc/uvc_driver.c | 236 +++++++++++++++++++++++++++++
  drivers/media/usb/uvc/uvcvideo.h   |   2 +-
  include/uapi/linux/videodev2.h     |   1 +
- 3 files changed, 174 insertions(+), 1 deletion(-)
+ 3 files changed, 238 insertions(+), 1 deletion(-)
 
 diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
-index 8e1382013..880765a5e 100644
+index d74c9a2d3b0b..ae9f847c061d 100644
 --- a/drivers/media/usb/uvc/uvc_driver.c
 +++ b/drivers/media/usb/uvc/uvc_driver.c
-@@ -2340,6 +2340,8 @@ static const struct uvc_device_info uvc_quirk_force_y8 = {
+@@ -2397,6 +2397,8 @@ static const struct uvc_device_info uvc_quirk_force_y8 = {
  };
  
  #define UVC_QUIRK_INFO(q) (kernel_ulong_t)&(struct uvc_device_info){.quirks = q}
@@ -23,10 +22,19 @@ index 8e1382013..880765a5e 100644
  
  /*
   * The Logitech cameras listed below have their interface class set to
-@@ -2813,6 +2815,240 @@ static const struct usb_device_id uvc_ids[] = {
+@@ -2870,6 +2872,240 @@ static const struct usb_device_id uvc_ids[] = {
  	  .bInterfaceSubClass	= 1,
  	  .bInterfaceProtocol	= 0,
  	  .driver_info		= (kernel_ulong_t)&uvc_quirk_force_y8 },
++	  /* Intel SR300 depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0aa5,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_QUIRK_META(V4L2_META_FMT_D4XX) },
 +	/* Intel D400/PSR depth camera*/
 +	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 +				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -153,15 +161,6 @@ index 8e1382013..880765a5e 100644
 +	  .bInterfaceSubClass	= 1,
 +	  .bInterfaceProtocol	= 0,
 +	  .driver_info		= UVC_QUIRK_META(V4L2_META_FMT_D4XX) },
-+	  /* Intel SR300 depth camera */
-+	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
-+				| USB_DEVICE_ID_MATCH_INT_INFO,
-+	  .idVendor			= 0x8086,
-+	  .idProduct		= 0x0aa5,
-+	  .bInterfaceClass	= USB_CLASS_VIDEO,
-+	  .bInterfaceSubClass	= 1,
-+	  .bInterfaceProtocol	= 0,
-+	  .driver_info		= UVC_QUIRK_META(V4L2_META_FMT_D4XX) },
 +	  /* Intel D405 S depth camera */
 +	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
 +				| USB_DEVICE_ID_MATCH_INT_INFO,
@@ -265,10 +264,10 @@ index 8e1382013..880765a5e 100644
  	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_UNDEFINED) },
  	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_15) },
 diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
-index be5cf1792..42c82f3d3 100644
+index 3edb18288ab9..c86e44543b62 100644
 --- a/drivers/media/usb/uvc/uvcvideo.h
 +++ b/drivers/media/usb/uvc/uvcvideo.h
-@@ -170,7 +170,7 @@
+@@ -204,7 +204,7 @@
  /* Maximum number of packets per URB. */
  #define UVC_MAX_PACKETS		32
  /* Maximum status buffer size in bytes of interrupt URB. */
@@ -278,10 +277,10 @@ index be5cf1792..42c82f3d3 100644
  #define UVC_CTRL_CONTROL_TIMEOUT	500
  #define UVC_CTRL_STREAMING_TIMEOUT	5000
 diff --git a/include/uapi/linux/videodev2.h b/include/uapi/linux/videodev2.h
-index 082dc1439..fab1e7a37 100644
+index 3a6656d8abc1..bc2b184eee8a 100644
 --- a/include/uapi/linux/videodev2.h
 +++ b/include/uapi/linux/videodev2.h
-@@ -707,6 +707,7 @@ struct v4l2_pix_format {
+@@ -715,6 +715,7 @@ struct v4l2_pix_format {
  #define V4L2_META_FMT_VSP1_HGO    v4l2_fourcc('V', 'S', 'P', 'H') /* R-Car VSP1 1-D Histogram */
  #define V4L2_META_FMT_VSP1_HGT    v4l2_fourcc('V', 'S', 'P', 'T') /* R-Car VSP1 2-D Histogram */
  #define V4L2_META_FMT_UVC         v4l2_fourcc('U', 'V', 'C', 'H') /* UVC Payload Header metadata */
diff --git a/scripts/realsense-metadata-bionic-hwe-5.4.patch b/scripts/realsense-metadata-bionic-hwe-5.4.patch
new file mode 100644
index 0000000..5472adb
--- /dev/null
+++ b/scripts/realsense-metadata-bionic-hwe-5.4.patch
@@ -0,0 +1,272 @@
+From 91f4e0a84b9754fd98a8b8a086fdc628bf4a6493 Mon Sep 17 00:00:00 2001
+From: ev-mp <ev_mp@yahoo.com>
+Date: Fri, 19 Jun 2020 12:34:08 +0300
+Signed-off-by: Evgeni <evgeni.raikhel@intel.com>
+Subject: [PATCH] Enabling UVC Metadata attributes with Ubuntu 18.04. Kernel 5.4
+
+---
+ drivers/media/usb/uvc/uvc_driver.c | 234 +++++++++++++++++++++++++++++
+ drivers/media/usb/uvc/uvcvideo.h   |   2 +-
+ 2 files changed, 235 insertions(+), 1 deletion(-)
+
+diff --git a/drivers/media/usb/uvc/uvc_driver.c b/drivers/media/usb/uvc/uvc_driver.c
+index 443ecea63bd8..d3a5c5f8abb9 100644
+--- a/drivers/media/usb/uvc/uvc_driver.c
++++ b/drivers/media/usb/uvc/uvc_driver.c
+@@ -2945,6 +2945,240 @@ static const struct usb_device_id uvc_ids[] = {
+ 	  .bInterfaceSubClass	= 1,
+ 	  .bInterfaceProtocol	= 0,
+ 	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel SR300 depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0aa5,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	/* Intel D400/PSR depth camera*/
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad1,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D410/ASR depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad2,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D415/ASRC depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad3,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D430/AWG depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad4,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	/* Intel D450/AWGT depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad5,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	/* USB2 Descriptor, Depth Sensor */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0ad6,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D400 IMU Module */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0af2,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	/* Intel D420/PWG depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0af6,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	/* Intel D420_MM/PWGT depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0afe,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D410_MM/ASRT depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0aff,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D400_MM/PSRT depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b00,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D430_MM/AWGCT depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b01,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D460/DS5U depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b03,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D435/AWGC depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b07,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D405 S depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b0c,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel L500 depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b0d,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D435i depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b3a,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel L515 Pre-PRQ */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b3d,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel SR305 Depth Camera*/
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b48,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D416 Depth Camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b49,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D430i depth camera */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b4b,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D465 */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b4d,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D405 */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b5b,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel D455 */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b5c,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
++	  /* Intel L515 */
++	{ .match_flags		= USB_DEVICE_ID_MATCH_DEVICE
++				| USB_DEVICE_ID_MATCH_INT_INFO,
++	  .idVendor			= 0x8086,
++	  .idProduct		= 0x0b64,
++	  .bInterfaceClass	= USB_CLASS_VIDEO,
++	  .bInterfaceSubClass	= 1,
++	  .bInterfaceProtocol	= 0,
++	  .driver_info		= UVC_INFO_META(V4L2_META_FMT_D4XX) },
+ 	/* Generic USB Video Class */
+ 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_UNDEFINED) },
+ 	{ USB_INTERFACE_INFO(USB_CLASS_VIDEO, 1, UVC_PC_PROTOCOL_15) },
+diff --git a/drivers/media/usb/uvc/uvcvideo.h b/drivers/media/usb/uvc/uvcvideo.h
+index 1aa8493a24d1..2b22379756d8 100644
+--- a/drivers/media/usb/uvc/uvcvideo.h
++++ b/drivers/media/usb/uvc/uvcvideo.h
+@@ -199,7 +199,7 @@
+ /* Maximum number of packets per URB. */
+ #define UVC_MAX_PACKETS		32
+ /* Maximum status buffer size in bytes of interrupt URB. */
+-#define UVC_MAX_STATUS_SIZE	16
++#define UVC_MAX_STATUS_SIZE	32
+ 
+ #define UVC_CTRL_CONTROL_TIMEOUT	500
+ #define UVC_CTRL_STREAMING_TIMEOUT	5000
+-- 
+2.17.1
+
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 5887b17..24bd47b 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,6 +1,7 @@
 # License: Apache 2.0. See LICENSE file in root directory.
 # Copyright(c) 2019 Intel Corporation. All Rights Reserved.
 string(REPLACE ${PROJECT_SOURCE_DIR}/ "" _rel_path ${CMAKE_CURRENT_LIST_DIR})
+include(${_rel_path}/algo/CMakeLists.txt)
 include(${_rel_path}/core/CMakeLists.txt)
 include(${_rel_path}/ds5/CMakeLists.txt)
 include(${_rel_path}/ivcam/CMakeLists.txt)
@@ -11,6 +12,7 @@ include(${_rel_path}/proc/CMakeLists.txt)
 include(${_rel_path}/res/CMakeLists.txt)
 include(${_rel_path}/pipeline/CMakeLists.txt)
 include(${_rel_path}/usb/CMakeLists.txt)
+include(${_rel_path}/fw-logs/CMakeLists.txt)
 include(${_rel_path}/fw-update/CMakeLists.txt)
 
 message(STATUS "using ${BACKEND}")
@@ -77,6 +79,7 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/device_hub.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/environment.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/error-handling.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/firmware_logger_device.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/global_timestamp_reader.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/hw-monitor.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/image.cpp"
@@ -89,9 +92,11 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/source.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/stream.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/sync.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/terminal-parser.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/types.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/verify.c"
         "${CMAKE_CURRENT_LIST_DIR}/frame-validator.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/depth-to-rgb-calibration.cpp"
 
         "${CMAKE_CURRENT_LIST_DIR}/algo.h"
         "${CMAKE_CURRENT_LIST_DIR}/api.h"
@@ -104,6 +109,7 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/environment.h"
         "${CMAKE_CURRENT_LIST_DIR}/log.h"
         "${CMAKE_CURRENT_LIST_DIR}/error-handling.h"
+        "${CMAKE_CURRENT_LIST_DIR}/firmware_logger_device.h"
         "${CMAKE_CURRENT_LIST_DIR}/frame-archive.h"
         "${CMAKE_CURRENT_LIST_DIR}/global_timestamp_reader.h"
         "${CMAKE_CURRENT_LIST_DIR}/hw-monitor.h"
@@ -117,9 +123,13 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/source.h"
         "${CMAKE_CURRENT_LIST_DIR}/stream.h"
         "${CMAKE_CURRENT_LIST_DIR}/sync.h"
+        "${CMAKE_CURRENT_LIST_DIR}/terminal-parser.h"
         "${CMAKE_CURRENT_LIST_DIR}/types.h"
         "${CMAKE_CURRENT_LIST_DIR}/command_transfer.h"
         "${CMAKE_CURRENT_LIST_DIR}/frame-validator.h"
         "${CMAKE_CURRENT_LIST_DIR}/auto-calibrated-device.h"
+        "${CMAKE_CURRENT_LIST_DIR}/device-calibration.h"
+        "${CMAKE_CURRENT_LIST_DIR}/calibrated-sensor.h"
         "${CMAKE_CURRENT_LIST_DIR}/serializable-interface.h"
+        "${CMAKE_CURRENT_LIST_DIR}/depth-to-rgb-calibration.h"
 )
diff --git a/src/algo.cpp b/src/algo.cpp
index 73f1cd9..fe4cfc1 100644
--- a/src/algo.cpp
+++ b/src/algo.cpp
@@ -47,10 +47,10 @@ void auto_exposure_state::set_auto_exposure_step(float value)
 }
 
 auto_exposure_mechanism::auto_exposure_mechanism(option& gain_option, option& exposure_option, const auto_exposure_state& auto_exposure_state)
-    : _auto_exposure_algo(auto_exposure_state),
-      _keep_alive(true), _frames_counter(0),
-      _skip_frames(auto_exposure_state.skip_frames), _data_queue(queue_size),
-      _gain_option(gain_option), _exposure_option(exposure_option)
+    : _gain_option(gain_option), _exposure_option(exposure_option),
+      _auto_exposure_algo(auto_exposure_state),
+      _keep_alive(true), _data_queue(queue_size), _frames_counter(0),
+      _skip_frames(auto_exposure_state.skip_frames)
 {
     _exposure_thread = std::make_shared<std::thread>(
                 [this]()
diff --git a/src/algo.h b/src/algo.h
index e23af66..dd9fea0 100644
--- a/src/algo.h
+++ b/src/algo.h
@@ -94,7 +94,7 @@ namespace librealsense
         float exposure = 10.0f, gain = 2.0f, target_exposure = 0.0f;
         uint8_t under_exposure_limit = 5, over_exposure_limit = 250; int under_exposure_noise_limit = 50, over_exposure_noise_limit = 50;
         int direction = 0, prev_direction = 0; float hysteresis = 0.075f;// 05;
-        float eps = 0.01f, minimal_exposure_step = 0.01f;
+        float eps = 0.01f;
         std::atomic<float> exposure_step;
         auto_exposure_state state; float flicker_cycle; bool anti_flicker_mode = true;
         region_of_interest roi{};
diff --git a/src/algo/CMakeLists.txt b/src/algo/CMakeLists.txt
new file mode 100644
index 0000000..3a130e5
--- /dev/null
+++ b/src/algo/CMakeLists.txt
@@ -0,0 +1,5 @@
+# License: Apache 2.0. See LICENSE file in root directory.
+# Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+include(${CMAKE_CURRENT_LIST_DIR}/depth-to-rgb-calibration/CMakeLists.txt)
+
diff --git a/src/algo/depth-to-rgb-calibration/CMakeLists.txt b/src/algo/depth-to-rgb-calibration/CMakeLists.txt
new file mode 100644
index 0000000..bb302df
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/CMakeLists.txt
@@ -0,0 +1,27 @@
+# License: Apache 2.0. See LICENSE file in root directory.
+# Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+target_sources(${LRS_TARGET}
+    PRIVATE
+        "${CMAKE_CURRENT_LIST_DIR}/calibration-types.h"
+        "${CMAKE_CURRENT_LIST_DIR}/calibration.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/calibration.h"
+        "${CMAKE_CURRENT_LIST_DIR}/coeffs.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/coeffs.h"
+        "${CMAKE_CURRENT_LIST_DIR}/cost.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/cost.h"
+        "${CMAKE_CURRENT_LIST_DIR}/debug.h"
+        "${CMAKE_CURRENT_LIST_DIR}/frame-data.h"
+        "${CMAKE_CURRENT_LIST_DIR}/uvmap.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/uvmap.h"
+        "${CMAKE_CURRENT_LIST_DIR}/optimizer.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/optimizer.h"
+        "${CMAKE_CURRENT_LIST_DIR}/k-to-dsm.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/k-to-dsm.h"
+        "${CMAKE_CURRENT_LIST_DIR}/svd_3x4.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/pinv_3x3.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/utils.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/utils.h"
+        "${CMAKE_CURRENT_LIST_DIR}/rotation-in-angles.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/valid-scene.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/valid-results.cpp"
+)
diff --git a/src/algo/depth-to-rgb-calibration/calibration-types.h b/src/algo/depth-to-rgb-calibration/calibration-types.h
new file mode 100644
index 0000000..cfec12b
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/calibration-types.h
@@ -0,0 +1,202 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <cstdint>  // all the basic types (uint8_t)
+#include <vector>  // all the basic types (uint8_t)
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    struct double3
+    {
+        double x, y, z;
+        double & operator [] ( int i ) { return (&x)[i]; }
+        bool operator == (const double3 d) { return x == d.x && y == d.y && z == d.z; }
+        bool operator != (const double3 d) { return !(*this == d); }
+        double3 operator-(const double3& other) {
+            return { x - other.x, y - other.y , z - other.z };
+        }
+
+        double get_norm() const
+        {
+            return x*x + y * y + z * z;
+        }
+
+        double3 operator*(const double& scalar) const {
+            return { x * scalar , y * scalar , z * scalar };
+        }
+
+        double operator*(const double3& s) const {
+            return x * s.x + y * s.y + z * s.z;
+        }
+    };
+
+    struct double2
+    {
+        double x, y;
+        double & operator [] ( int i ) { return (&x)[i]; };
+        bool operator == (const double2 & d) const { return x == d.x && y == d.y; }
+        bool operator != (const double2 & d) const { return !(*this == d); }
+    };
+
+        struct double3x3
+    {
+        /* double3x3(double arr[9])
+         {
+             for (auto i = 0; i < 3; i++)
+             {
+                 for (auto j = 0; j < 3; j++)
+                 {
+                     mat[i][j] = arr[i * 3 + j];
+                 }
+             }
+         }*/
+        double mat[3][3];
+        double3x3 transpose()
+        {
+            double3x3 res = { {0} };
+
+            for( auto i = 0; i < 3; i++ )
+            {
+                for( auto j = 0; j < 3; j++ )
+                {
+                    res.mat[i][j] = mat[j][i];
+                }
+            }
+            return res;
+        }
+
+        double3x3 operator*( const double3x3 & other )
+        {
+            double3x3 res = { {0} };
+
+            for( auto i = 0; i < 3; i++ )
+            {
+                for( auto j = 0; j < 3; j++ )
+                {
+                    double sum = 0;
+                    for( auto l = 0; l < 3; l++ )
+                    {
+                        sum += mat[i][l] * other.mat[l][j];
+                    }
+                    res.mat[i][j] = sum;
+                }
+            }
+            return res;
+        }
+
+        double3 operator*( const double3 & other )
+        {
+            double3 res = { 0 };
+
+            res.x = mat[0][0] * other.x + mat[0][1] * other.y + mat[0][2] * other.z;
+            res.y = mat[1][0] * other.x + mat[1][1] * other.y + mat[1][2] * other.z;
+            res.z = mat[2][0] * other.x + mat[2][1] * other.y + mat[2][2] * other.z;
+            return res;
+        }
+
+        std::vector< double > to_vector()
+        {
+            std::vector< double > res;
+            for( auto i = 0; i < 3; i++ )
+            {
+                for( auto j = 0; j < 3; j++ )
+                {
+                    res.push_back( mat[i][j] );
+                }
+            }
+            return res;
+        }
+    };
+
+    enum direction :uint8_t
+    {
+        //deg_111, //to be aligned with matlab (maybe should be removed later) 
+        deg_0, // 0, 1
+        deg_45, //1, 1
+        deg_90, //1, 0
+        deg_135, //1, -1
+        deg_180, //
+        deg_225, //
+        deg_270, //
+        deg_315, //
+        deg_none
+    };
+    enum svm_model :uint8_t
+    {
+        linear,
+        gaussian
+    };
+    struct translation
+    {
+        double t1;
+        double t2;
+        double t3;
+    };
+
+    struct matrix_3x3
+    {
+        double rot[9];
+
+        matrix_3x3 transposed() const
+        {
+            return { rot[0], rot[3], rot[6], 
+                rot[1], rot[4], rot[7],
+                rot[2], rot[5], rot[8] };
+        }
+    };
+
+    struct rotation_in_angles
+    {
+        double alpha;
+        double beta;
+        double gamma;
+
+        bool operator==(const rotation_in_angles& other)
+        {
+            return alpha == other.alpha && beta == other.beta && gamma == other.gamma;
+        }
+        bool operator!=(const rotation_in_angles& other)
+        {
+            return !(*this == other);
+        }
+        bool operator<(const rotation_in_angles& other)
+        {
+            return (alpha < other.alpha) ||
+                (alpha == other.alpha && beta < other.beta) ||
+                (alpha == other.alpha && beta == other.beta && gamma < other.gamma);
+
+        }
+    };
+
+    matrix_3x3 extract_rotation_from_angles( const rotation_in_angles & rot_angles );
+    rotation_in_angles extract_angles_from_rotation( const double r[9] );
+
+    struct k_matrix
+    {
+        k_matrix() = default;
+        k_matrix(matrix_3x3 const & mat)
+            :k_mat(mat)
+        {}
+
+        double get_fx() const { return k_mat.rot[0]; }
+        double get_fy() const { return k_mat.rot[4]; }
+        double get_ppx() const { return k_mat.rot[2]; }
+        double get_ppy() const { return k_mat.rot[5]; }
+
+        matrix_3x3 k_mat;
+
+        matrix_3x3 as_3x3()
+        {
+            return k_mat;
+        }
+    };
+
+}  // librealsense::algo::depth_to_rgb_calibration
+}  // librealsense::algo
+}  // librealsense
diff --git a/src/algo/depth-to-rgb-calibration/calibration.cpp b/src/algo/depth-to-rgb-calibration/calibration.cpp
new file mode 100644
index 0000000..e2a0b36
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/calibration.cpp
@@ -0,0 +1,387 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "calibration.h"
+#include "debug.h"
+#include "utils.h"
+
+
+using namespace librealsense::algo::depth_to_rgb_calibration;
+
+
+calib::calib( rs2_intrinsics_double const & intrin, rs2_extrinsics_double const & extrin )
+{
+    auto const & r = extrin.rotation;
+    auto const & t = extrin.translation;
+    auto const & c = intrin.coeffs;
+
+    height = intrin.height;
+    width = intrin.width;
+    rot = { r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8] };
+    trans = { t[0], t[1], t[2] };
+    k_mat = matrix_3x3{ intrin.fx, 0,intrin.ppx,
+        0,intrin.fy, intrin.ppy,
+        0,0,1 };
+
+    coeffs[0] = c[0];
+    coeffs[1] = c[1];
+    coeffs[2] = c[2];
+    coeffs[3] = c[3];
+    coeffs[4] = c[4];
+    model = intrin.model;
+}
+
+calib::calib( rs2_intrinsics const & intrin, rs2_extrinsics const & extrin )
+{
+    auto const & r = extrin.rotation;
+    auto const & t = extrin.translation;
+    auto const & c = intrin.coeffs;
+
+    height = intrin.height;
+    width = intrin.width;
+    rot = { r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8] };
+    trans = { t[0], t[1], t[2] };
+    k_mat = matrix_3x3{ intrin.fx, 0,intrin.ppx,
+        0,intrin.fy, intrin.ppy,
+        0,0,1 };
+    coeffs[0] = c[0];
+    coeffs[1] = c[1];
+    coeffs[2] = c[2];
+    coeffs[3] = c[3];
+    coeffs[4] = c[4];
+    model = intrin.model;
+}
+
+rs2_intrinsics_double calib::get_intrinsics() const
+{
+    return {
+        width, height,
+        k_mat,
+        model, coeffs };
+}
+
+rs2_extrinsics_double calib::get_extrinsics() const
+{
+    auto & r = rot.rot;
+    auto & t = trans;
+    return {
+        { r[0] , r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8] },
+        { t.t1, t.t2, t.t3 }
+    };
+}
+
+p_matrix const calib::calc_p_mat() const
+{
+    auto r = rot.rot;
+    auto t = trans;
+    auto k = k_mat.k_mat.rot;
+   /* auto fx = k_mat.fx;
+    auto fy = k_mat.fy;
+    auto ppx = k_mat.ppx;
+    auto ppy = k_mat.ppy;*/
+    p_matrix p_mat = {
+        k[0] * r[0] + k[1] * r[3] + k[2] * r[6], 
+        k[0] * r[1] + k[1] * r[4] + k[2] * r[7], 
+        k[0] * r[2] + k[1] * r[5] + k[2] * r[8], 
+        k[0] * t.t1 + k[1] * t.t2 + k[2] * t.t3,
+
+        k[3] * r[0] + k[4] * r[3] + k[5] * r[6], 
+        k[3] * r[1] + k[4] * r[4] + k[5] * r[7], 
+        k[3] * r[2] + k[4] * r[5] + k[5] * r[8], 
+        k[3] * t.t1 + k[4] * t.t2 + k[5] * t.t3,
+
+        r[6], 
+        r[7], 
+        r[8], 
+        t.t3 
+    };
+
+    return p_mat;
+}
+
+void calib::copy_coefs( calib & obj ) const
+{
+    obj.width = this->width;
+    obj.height = this->height;
+
+    obj.coeffs[0] = this->coeffs[0];
+    obj.coeffs[1] = this->coeffs[1];
+    obj.coeffs[2] = this->coeffs[2];
+    obj.coeffs[3] = this->coeffs[3];
+    obj.coeffs[4] = this->coeffs[4];
+
+    obj.model = this->model;
+}
+
+calib calib::operator*( double step_size ) const
+{
+    calib res;
+    for (auto i = 0; i < 9; i++)
+    {
+        res.k_mat.k_mat.rot[i] = k_mat.k_mat.rot[i] * step_size;;
+    }
+
+    for (auto i = 0; i < 9; i++)
+        res.rot.rot[i] = this->rot.rot[i] * step_size;
+
+    res.trans.t1 = this->trans.t1 *step_size;
+    res.trans.t2 = this->trans.t2 * step_size;
+    res.trans.t3 = this->trans.t3 *step_size;
+
+    copy_coefs( res );
+
+    return res;
+}
+
+calib calib::operator/( double factor ) const
+{
+    return (*this)*(1.f / factor);
+}
+
+calib calib::operator+( const calib & c ) const
+{
+    calib res;
+
+    for (auto i = 0; i < 9; i++)
+    {
+        res.k_mat.k_mat.rot[i] = k_mat.k_mat.rot[i] + c.k_mat.k_mat.rot[i];
+    }
+
+    for (auto i = 0; i < 9; i++)
+        res.rot.rot[i] = this->rot.rot[i] + c.rot.rot[i];
+
+    res.trans.t1 = this->trans.t1 + c.trans.t1;
+    res.trans.t2 = this->trans.t2 + c.trans.t2;
+    res.trans.t3 = this->trans.t3 + c.trans.t3;
+
+    copy_coefs( res );
+
+    return res;
+}
+
+calib calib::operator-( const calib & c ) const
+{
+    calib res;
+    for (auto i = 0; i < 9; i++)
+    {
+        res.k_mat.k_mat.rot[i] = k_mat.k_mat.rot[i] - c.k_mat.k_mat.rot[i];
+    }
+
+    for (auto i = 0; i < 9; i++)
+        res.rot.rot[i] = this->rot.rot[i] - c.rot.rot[i];
+
+    res.trans.t1 = this->trans.t1 - c.trans.t1;
+    res.trans.t2 = this->trans.t2 - c.trans.t2;
+    res.trans.t3 = this->trans.t3 - c.trans.t3;
+
+    copy_coefs( res );
+
+    return res;
+}
+
+calib calib::operator/( const calib & c ) const
+{
+    calib res;
+
+    for (auto i = 0; i < 9; i++)
+    {
+        res.k_mat.k_mat.rot[i] = k_mat.k_mat.rot[i] / c.k_mat.k_mat.rot[i];
+    }
+
+    for (auto i = 0; i < 9; i++)
+        res.rot.rot[i] = this->rot.rot[i] / c.rot.rot[i];
+
+
+    res.trans.t1 = this->trans.t1 / c.trans.t1;
+    res.trans.t2 = this->trans.t2 / c.trans.t2;
+    res.trans.t3 = this->trans.t3 / c.trans.t3;
+
+    copy_coefs( res );
+
+    return res;
+}
+
+
+p_matrix p_matrix::operator*(double step_size) const
+{
+    p_matrix res;
+
+    for (auto i = 0; i < 12; i++)
+        res.vals[i] = vals[i] * step_size;
+
+    return res;
+}
+
+p_matrix p_matrix::operator/(double factor) const
+{
+    return (*this)*(1.f / factor);
+}
+
+p_matrix p_matrix::operator+(const p_matrix & c) const
+{
+    p_matrix res;
+    for (auto i = 0; i < 12; i++)
+        res.vals[i] = vals[i] + c.vals[i];
+
+    return res;
+}
+
+p_matrix p_matrix::operator-(const p_matrix & c) const
+{
+    p_matrix res;
+    for (auto i = 0; i < 12; i++)
+        res.vals[i] = vals[i] - c.vals[i];
+
+    return res;
+}
+
+p_matrix p_matrix::operator*(const p_matrix & c) const
+{
+    p_matrix res;
+    for (auto i = 0; i < 12; i++)
+        res.vals[i] = vals[i] * c.vals[i];
+
+    return res;
+}
+
+p_matrix p_matrix::operator/(const p_matrix & c) const
+{
+    p_matrix res;
+    for (auto i = 0; i < 12; i++)
+        res.vals[i] = c.vals[i] == 0 ? 0 : vals[i] / c.vals[i];
+
+    return res;
+}
+
+double p_matrix::get_norma() const
+{
+    double grads_norm = 0;
+
+    for (auto i = 0; i < 12; i++)
+        grads_norm += vals[i] * vals[i];
+
+    grads_norm = sqrt(grads_norm);
+
+    return grads_norm;
+}
+
+static inline bool rtIsNaN( double value ) { return (value != value); }
+static inline bool rtIsInf( double value )
+{
+    return ( value == std::numeric_limits< double >::infinity()
+             || value == -std::numeric_limits< double >::infinity() );
+}
+
+double p_matrix::matrix_norm() const
+{
+    // Code generated by Matlab Coder!
+    double absx;
+    double n = 0;
+    double m[12];
+    m[0] = vals[0];
+    m[1] = vals[4];
+    m[2] = vals[8];
+    m[3] = vals[1];
+    m[4] = vals[5];
+    m[5] = vals[9];
+    m[6] = vals[2];
+    m[7] = vals[6];
+    m[8] = vals[10];
+    m[9] = vals[3];
+    m[10] = vals[7];
+    m[11] = vals[11];
+    for( int j = 0; j < 4; j++ )
+    {
+        absx = std::abs( m[3 * j] );
+        if( rtIsNaN( absx ) || ( absx > n ) )
+            n = absx;
+
+        absx = std::abs( m[1 + 3 * j] );
+        if( rtIsNaN( absx ) || ( absx > n ) )
+            n = absx;
+
+        absx = std::abs( m[2 + 3 * j] );
+        if( rtIsNaN( absx ) || ( absx > n ) )
+            n = absx;
+    }
+    if( ( ! rtIsInf( n ) ) && ( ! rtIsNaN( n ) ) )
+    {
+        double dv0[3];
+        svd_3x4( m, dv0 );
+        n = dv0[0];
+    }
+    return n;
+}
+
+double p_matrix::sum() const
+{
+    double res = 0;
+    for( auto i = 0; i < 12; i++ )
+        res += vals[i];
+    return res;
+}
+
+p_matrix p_matrix::normalize( double const norma ) const
+{
+    p_matrix res;
+    for( auto i = 0; i < 12; i++ )
+        res.vals[i] = vals[i] / norma;
+    return res;
+}
+
+krt p_matrix::decompose() const
+{
+    //%firstThreeCols = P(:,1:3);% This is Krgb*R
+    double3x3 first_three_cols = { vals[0], vals[1], vals[2],
+                                   vals[4], vals[5], vals[6],
+                                   vals[8], vals[9], vals[10] };
+
+    //%KSquare = firstThreeCols*firstThreeCols';% This is Krgb*R*R'*Krgb' = Krgb*Krgb'
+    auto k_square = first_three_cols * first_three_cols.transpose();
+    //%KSquareInv = inv(KSquare); % Returns a matrix that is equal to: inv(Krgb')*inv(Krgb)
+    std::vector<double> inv_k_square_vac( 9, 0 );
+    inv( k_square.to_vector().data(), inv_k_square_vac.data() );
+
+    double3x3 inv_k_square = { inv_k_square_vac[0], inv_k_square_vac[3], inv_k_square_vac[6],
+                               inv_k_square_vac[1], inv_k_square_vac[4], inv_k_square_vac[7],
+                               inv_k_square_vac[2], inv_k_square_vac[5], inv_k_square_vac[8] };
+
+    //%KInv = cholesky3x3(KSquareInv)';% Cholsky decomposition 3 by 3. returns a lower triangular matrix 3x3. Equal to inv(Krgb')
+    auto k_inv = cholesky3x3( inv_k_square ).transpose();
+    //%K = inv(KInv);
+    matrix_3x3 k_vac = { 0 };
+    inv( k_inv.to_vector().data(), k_vac.rot );
+    //%K = K/K(end);
+    for( auto i = 0; i < 9; i++ )
+        k_vac.rot[i] /= k_vac.rot[9 - 1];
+
+    //%t = KInv*P(:,4);
+    auto t = k_inv * double3{ vals[3], vals[7], vals[11] };
+
+    //%R = KInv*firstThreeCols;
+    auto r = (k_inv * first_three_cols).to_vector();
+
+    krt calibration;
+    for( auto i = 0; i < r.size(); i++ )
+        calibration.rot.rot[i] = r[i];
+
+    calibration.trans = { t.x, t.y, t.z };
+
+    calibration.k_mat = matrix_3x3(k_vac);
+
+    return calibration;
+}
+
+calib librealsense::algo::depth_to_rgb_calibration::decompose( p_matrix const & in_mat,
+                                                               calib const & in_calibration )
+{
+    auto krt = in_mat.decompose();
+
+    calib calibration;
+    calibration.rot = krt.rot;
+    calibration.trans = krt.trans;
+    calibration.k_mat = krt.k_mat;
+    in_calibration.copy_coefs( calibration );
+
+    return calibration;
+}
diff --git a/src/algo/depth-to-rgb-calibration/calibration.h b/src/algo/depth-to-rgb-calibration/calibration.h
new file mode 100644
index 0000000..19392cc
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/calibration.h
@@ -0,0 +1,166 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "calibration-types.h"
+#include <types.h>  // librealsense types (intr/extr)
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    /** \brief Video stream intrinsics. */
+    struct rs2_intrinsics_double
+    {
+        rs2_intrinsics_double() = default;
+
+        rs2_intrinsics_double( const int width, const int height,
+            const k_matrix& k_mat, const rs2_distortion model, const double coeffs[5] )
+            :width( width ), height( height ),
+            ppx( k_mat.get_ppx() ), ppy( k_mat.get_ppy()),
+            fx( k_mat.get_fx()), fy( k_mat.get_fy()),
+            model( model ),
+            coeffs{ coeffs[0], coeffs[1], coeffs[2], coeffs[3], coeffs[4] }
+        {}
+
+        rs2_intrinsics_double( const rs2_intrinsics& obj )
+            :width( obj.width ), height( obj.height ),
+            ppx( obj.ppx ), ppy( obj.ppy ),
+            fx( obj.fx ), fy( obj.fy ),
+            model( obj.model ),
+            coeffs{ obj.coeffs[0], obj.coeffs[1], obj.coeffs[2], obj.coeffs[3], obj.coeffs[4] }
+        {}
+
+        operator rs2_intrinsics() const
+        {
+            return
+            { width, height,
+                float( ppx ), float( ppy ),
+                float( fx ), float( fy ),
+                model,
+            {float( coeffs[0] ), float( coeffs[1] ), float( coeffs[2] ), float( coeffs[3] ), float( coeffs[4] )} };
+        }
+
+        operator k_matrix() const
+        {
+            matrix_3x3 res =
+                        { fx, 0, ppx,
+                        0, fy, ppy,
+                        0,0,1 };
+            return res;
+        }
+
+        int           width;     /**< Width of the image in pixels */
+        int           height;    /**< Height of the image in pixels */
+        double         ppx;       /**< Horizontal coordinate of the principal point of the image, as a pixel offset from the left edge */
+        double         ppy;       /**< Vertical coordinate of the principal point of the image, as a pixel offset from the top edge */
+        double         fx;        /**< Focal length of the image plane, as a multiple of pixel width */
+        double         fy;        /**< Focal length of the image plane, as a multiple of pixel height */
+        rs2_distortion model;    /**< Distortion model of the image */
+        double         coeffs[5]; /**< Distortion coefficients */
+    };
+
+    /** \brief Cross-stream extrinsics: encodes the topology describing how the different devices are oriented. */
+    struct rs2_extrinsics_double
+    {
+        rs2_extrinsics_double() {}
+        rs2_extrinsics_double( const matrix_3x3& rot, const translation& trans )
+            :rotation{ rot.rot[0], rot.rot[1],rot.rot[2],
+                  rot.rot[3], rot.rot[4], rot.rot[5],
+                  rot.rot[6], rot.rot[7], rot.rot[8] },
+            translation{ trans.t1, trans.t2 , trans.t3 }
+        {}
+
+        rs2_extrinsics_double( const rs2_extrinsics& other )
+            :rotation{ other.rotation[0], other.rotation[1], other.rotation[2],
+                  other.rotation[3], other.rotation[4], other.rotation[5],
+                  other.rotation[6], other.rotation[7], other.rotation[8] },
+            translation{ other.translation[0], other.translation[1] , other.translation[2] }
+        {}
+
+        operator rs2_extrinsics()
+        {
+            return { {float( rotation[0] ), float( rotation[1] ), float( rotation[2] ),
+            float( rotation[3] ), float( rotation[4] ), float( rotation[5] ),
+            float( rotation[6] ), float( rotation[7] ), float( rotation[8] )} ,
+            {float( translation[0] ), float( translation[1] ), float( translation[2] )} };
+        }
+
+        double rotation[9];    /**< Column-major 3x3 rotation matrix */
+        double translation[3]; /**< Three-element translation vector, in meters */
+    };
+
+    struct krt
+    {
+        matrix_3x3 rot = { { 0 } };
+        translation trans = { 0 };
+        k_matrix k_mat = matrix_3x3{ 0 };
+    };
+
+    struct p_matrix
+    {
+        double vals[12];
+
+        bool operator<( const p_matrix & other ) const
+        {
+            for (auto i = 0; i < 12; i++)
+            {
+                if (vals[i] < other.vals[i])
+                    return false;
+                if (vals[i] > other.vals[i])
+                    return true;
+            }
+            return true;
+        }
+        p_matrix operator*(double step_size) const;
+        p_matrix operator/(double factor) const;
+        p_matrix operator+(const p_matrix& c) const;
+        p_matrix operator-(const p_matrix& c) const;
+        p_matrix operator/(const p_matrix& c) const;
+        p_matrix operator*(const p_matrix& c) const;
+
+        double get_norma() const;
+        double sum() const;
+        p_matrix normalize( double norm ) const;
+        double matrix_norm() const;
+
+        krt decompose() const;
+    };
+
+    struct calib
+    {
+        matrix_3x3 rot = { { 0 } };
+        translation trans = { 0 };
+        k_matrix k_mat = matrix_3x3{ 0};
+        int           width = 0;
+        int           height = 0;
+        rs2_distortion model;
+        double         coeffs[5];
+
+        calib() = default;
+        calib( calib const & ) = default;
+        explicit calib( rs2_intrinsics_double const & rgb_intrinsics, rs2_extrinsics_double const & depth_to_rgb_extrinsics);
+        explicit calib( rs2_intrinsics const & rgb_intrinsics, rs2_extrinsics const & depth_to_rgb_extrinsics);
+
+        rs2_intrinsics_double get_intrinsics() const;
+        rs2_extrinsics_double get_extrinsics() const;
+
+        p_matrix const calc_p_mat() const;
+
+        void copy_coefs( calib & obj ) const;
+        calib operator*( double step_size ) const;
+        calib operator/( double factor ) const;
+        calib operator+( const calib& c ) const;
+        calib operator-( const calib& c ) const;
+        calib operator/( const calib& c ) const;
+    };
+
+    calib decompose( p_matrix const & mat, calib const & );
+
+}
+}
+}
+
diff --git a/src/algo/depth-to-rgb-calibration/coeffs.cpp b/src/algo/depth-to-rgb-calibration/coeffs.cpp
new file mode 100644
index 0000000..5f0ec4d
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/coeffs.cpp
@@ -0,0 +1,720 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "coeffs.h"
+#include "calibration.h"
+#include "frame-data.h"
+#include "optimizer.h"
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    double calculate_rotation_x_alpha_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = (double)sin( rot_angles.alpha );
+        auto sin_b = (double)sin( rot_angles.beta );
+        auto sin_g = (double)sin( rot_angles.gamma );
+
+        auto cos_a = (double)cos( rot_angles.alpha );
+        auto cos_b = (double)cos( rot_angles.beta );
+        auto cos_g = (double)cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = v.x;
+        auto y = v.y;
+        auto z = v.z;
+
+
+        auto exp1 = z * (0 * sin_b + 1 * cos_a*cos_b - 0 * cos_b*sin_a)
+            + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                + 1 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                + 0 * cos_b*cos_g)
+            + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                + 1 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                - 0 * cos_b*sin_g)
+            + 1 * (0 * t[0] + 0 * t[1] + 1 * t[2]);
+
+        auto res = (((x*(0 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+            - 1 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+            ) + y * (0 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                - 1 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                ) + z * (0 * cos_a*cos_b + 1 * cos_b*sin_a)
+            )*(z*(fx*sin_b + ppx * cos_a*cos_b - 0 * cos_b*sin_a)
+                + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                    + ppx * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                    + fx * cos_b*cos_g)
+                + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                    + ppx * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                    - fx * cos_b*sin_g)
+                + 1 * (fx*t[0] + 0 * t[1] + ppx * t[2])
+                ) - (x*(0 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                    - ppx * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                    ) + y * (0 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                        - ppx * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                        ) + z * (0 * cos_a*cos_b + ppx * cos_b*sin_a)
+                    )*(z*(0 * sin_b + 1 * cos_a*cos_b - 0 * cos_b*sin_a)
+                        + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                            + 1 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                            + 0 * cos_b*cos_g)
+                        + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                            + 1 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                            - 0 * cos_b*sin_g)
+                        + 1 * (0 * t[0] + 0 * t[1] + 1 * t[2])
+                        ))
+            *(rc + 6 * d[3] * x1 + 2 * d[2] * y1 + x1 * (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))
+            ) / (exp1*exp1) + (fx*((x*(0 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                - 1 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                ) + y * (0 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                    - 1 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                    ) + z * (0 * cos_a*cos_b + 1 * cos_b*sin_a)
+                )*(z*(0 * sin_b + ppy * cos_a*cos_b - fy * cos_b*sin_a)
+                    + x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b)
+                        + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                        + 0 * cos_b*cos_g)
+                    + y * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g)
+                        + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                        - 0 * cos_b*sin_g)
+                    + 1 * (0 * t[0] + fy * t[1] + ppy * t[2])
+                    ) - (x*(fy*(sin_a*sin_g - cos_a * cos_g*sin_b)
+                        - ppy * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                        ) + y * (fy*(cos_g*sin_a + cos_a * sin_b*sin_g)
+                            - ppy * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                            ) + z * (fy*cos_a*cos_b + ppy * cos_b*sin_a)
+                        )*(z*(0 * sin_b + 1 * cos_a*cos_b - 0 * cos_b*sin_a)
+                            + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                                + 1 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                                + 0 * cos_b*cos_g)
+                            + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                                + 1 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                                - 0 * cos_b*sin_g)
+                            + 1 * (0 * t[0] + 0 * t[1] + 1 * t[2])
+                            ))
+                *(2 * d[2] * x1 + 2 * d[3] * y1 + x1 * (2 * d[0] * y1 + 4 * d[1] * y1*(xy2)+6 * d[4] * y1*x2_y2))
+                ) / (fy*(exp1*exp1));
+        return res;
+    }
+
+    static double calculate_rotation_x_beta_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = sin( rot_angles.alpha );
+        auto sin_b = sin( rot_angles.beta );
+        auto sin_g = sin( rot_angles.gamma );
+
+        auto cos_a = cos( rot_angles.alpha );
+        auto cos_b = cos( rot_angles.beta );
+        auto cos_g = cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = (double)v.x;
+        auto y = (double)v.y;
+        auto z = (double)v.z;
+
+        auto exp1 = z * (cos_a*cos_b) +
+            x * ((sin_a*sin_g - cos_a * cos_g*sin_b))
+            + y * ((cos_g*sin_a + cos_a * sin_b*sin_g))
+            + (t[2]);
+
+        auto res = -(((z*(0 * cos_b - 1 * cos_a*sin_b + 0 * sin_a*sin_b)
+            - x * (0 * cos_g*sin_b + 1 * cos_a*cos_b*cos_g - 0 * cos_b*cos_g*sin_a)
+            + y * (0 * sin_b*sin_g + 1 * cos_a*cos_b*sin_g - 0 * cos_b*sin_a*sin_g)
+            )*(z*(fx*sin_b + ppx * cos_a*cos_b - 0 * cos_b*sin_a)
+                + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                    + ppx * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                    + fx * cos_b*cos_g)
+                + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                    + ppx * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                    - fx * cos_b*sin_g)
+                + 1 * (fx*t[0] + 0 * t[1] + ppx * t[2])
+                ) - (z*(fx*cos_b - ppx * cos_a*sin_b + 0 * sin_a*sin_b)
+                    - x * (fx*cos_g*sin_b + ppx * cos_a*cos_b*cos_g - 0 * cos_b*cos_g*sin_a)
+                    + y * (fx*sin_b*sin_g + ppx * cos_a*cos_b*sin_g - 0 * cos_b*sin_a*sin_g)
+                    )*(z*(0 * sin_b + 1 * cos_a*cos_b - 0 * cos_b*sin_a)
+                        + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                            + 1 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                            + 0 * cos_b*cos_g)
+                        + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                            + 1 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                            - 0 * cos_b*sin_g)
+                        + 1 * (0 * t[0] + 0 * t[1] + 1 * t[2])))
+            *(rc + 6 * d[3] * x1 + 2 * d[2] * y1 + x1 * (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))
+            ) / (exp1* exp1) - (fx*((z*(0 * cos_b - 1 * cos_a*sin_b + 0 * sin_a*sin_b)
+                - x * (0 * cos_g*sin_b + 1 * cos_a*cos_b*cos_g - 0 * cos_b*cos_g*sin_a)
+                + y * (0 * sin_b*sin_g + 1 * cos_a*cos_b*sin_g - 0 * cos_b*sin_a*sin_g)
+                )*(z*(0 * sin_b + ppy * cos_a*cos_b - fy * cos_b*sin_a)
+                    + x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b)
+                        + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                        + 0 * cos_b*cos_g)
+                    + y * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g)
+                        + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                        - 0 * cos_b*sin_g)
+                    + 1 * (0 * t[0] + fy * t[1] + ppy * t[2])
+                    ) - (z*(0 * cos_b - ppy * cos_a*sin_b + fy * sin_a*sin_b)
+                        - x * (0 * cos_g*sin_b + ppy * cos_a*cos_b*cos_g - fy * cos_b*cos_g*sin_a)
+                        + y * (0 * sin_b*sin_g + ppy * cos_a*cos_b*sin_g - fy * cos_b*sin_a*sin_g)
+                        )*(z*(0 * sin_b + 1 * cos_a*cos_b - 0 * cos_b*sin_a)
+                            + x * (0 * (cos_a*sin_g + cos_g * sin_a*sin_b)
+                                + 1 * (sin_a*sin_g - cos_a * cos_g*sin_b)
+                                + 0 * cos_b*cos_g)
+                            + y * (0 * (cos_a*cos_g - sin_a * sin_b*sin_g)
+                                + 1 * (cos_g*sin_a + cos_a * sin_b*sin_g)
+                                - 0 * cos_b*sin_g)
+                            + 1 * (0 * t[0] + 0 * t[1] + 1 * t[2])
+                            ))*(2 * d[2] * x1 + 2 * d[3] * y1 + x1 * (2 * d[0] * y1 + 4 * d[1] * y1*(xy2)+6 * d[4] * y1*x2_y2))
+                ) / (fy*(exp1*exp1));
+
+        return res;
+    }
+
+    double calculate_rotation_x_gamma_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = (double)sin( rot_angles.alpha );
+        auto sin_b = (double)sin( rot_angles.beta );
+        auto sin_g = (double)sin( rot_angles.gamma );
+
+        auto cos_a = (double)cos( rot_angles.alpha );
+        auto cos_b = (double)cos( rot_angles.beta );
+        auto cos_g = (double)cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = (double)v.x;
+        auto y = (double)v.y;
+        auto z = (double)v.z;
+
+        auto exp1 = z * cos_a*cos_b +
+            x * (sin_a*sin_g - cos_a * cos_g*sin_b) +
+            y * (cos_g*sin_a + cos_a * sin_b*sin_g) +
+            t[2];
+
+        auto res = (
+            ((y*(sin_a*sin_g - cos_a * cos_g*sin_b) - x * (cos_g*sin_a + cos_a * sin_b*sin_g))*
+            (z*(fx*sin_b + ppx * cos_a*cos_b) +
+                x * (ppx*(sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g) +
+                y * (ppx*(cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g) +
+                (fx*t[0] + ppx * t[2])) -
+                (y*(ppx* (sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g) -
+                    x * (ppx*(cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g))*
+                    (z*(cos_a*cos_b) + x * (sin_a*sin_g - cos_a * cos_g*sin_b) +
+                        y * (cos_g*sin_a + cos_a * sin_b*sin_g) + t[2]))*
+                        (rc + 6 * d[3] * x1 + 2 * d[2] * y1 + x1 * (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))
+            )
+            /
+            (exp1* exp1) + (fx*((y*(sin_a*sin_g - cos_a * cos_g*sin_b) -
+                x * (cos_g*sin_a + cos_a * sin_b*sin_g))*
+                (z*(ppy*cos_a*cos_b - fy * cos_b*sin_a) +
+                    x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b) + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)) + y *
+                    (fy*(cos_a*cos_g - sin_a * sin_b*sin_g) + ppy *
+                    (cos_g*sin_a + cos_a * sin_b*sin_g)) +
+                        (fy * t[1] + ppy * t[2])) -
+                    (y*(fy*(cos_a*sin_g + cos_g * sin_a*sin_b) +
+                        ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)) - x *
+                        (fy*(cos_a*cos_g - sin_a * sin_b*sin_g) + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g)))*
+                        (z*cos_a*cos_b + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) +
+                            y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + t[2]))*(2 * d[2] * x1 + 2 * d[3] * y1 + x1 *
+                            (2 * d[0] * y1 + 4 * d[1] * y1*xy2 + 6 * d[4] * y1*x2_y2)) / (fy*exp1*exp1));
+
+        return res;
+    }
+
+    double calculate_rotation_y_alpha_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = (double)sin( rot_angles.alpha );
+        auto sin_b = (double)sin( rot_angles.beta );
+        auto sin_g = (double)sin( rot_angles.gamma );
+
+        auto cos_a = (double)cos( rot_angles.alpha );
+        auto cos_b = (double)cos( rot_angles.beta );
+        auto cos_g = (double)cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        /* x1 = 1;
+            y1 = 1;*/
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = (double)v.x;
+        auto y = (double)v.y;
+        auto z = (double)v.z;
+
+
+        auto exp1 = z * (cos_a*cos_b) + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) +
+            y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + t[2];
+
+        auto res = (((x*(-(cos_a*sin_g + cos_g * sin_a*sin_b)) + y * (-1 * (cos_a*cos_g - sin_a * sin_b*sin_g)) + z *
+            (cos_b*sin_a))*(z*(ppy * cos_a*cos_b - fy * cos_b*sin_a) + x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b) +
+                ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)) + y * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g) +
+                    ppy * (cos_g*sin_a + cos_a * sin_b*sin_g)) + (fy * t[1] + ppy * t[2])) - (x*(fy*(sin_a*sin_g - cos_a * cos_g*sin_b) -
+                        ppy * (cos_a*sin_g + cos_g * sin_a*sin_b)) + y * (fy*(cos_g*sin_a + cos_a * sin_b*sin_g) -
+                            ppy * (cos_a*cos_g - sin_a * sin_b*sin_g)) + z * (fy*cos_a*cos_b + ppy * cos_b*sin_a))*
+                            (z*(cos_a*cos_b) + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) + y * ((cos_g*sin_a + cos_a * sin_b*sin_g) - 0 * cos_b*sin_g) + (t[2])))*
+            (rc + 2 * d[3] * x1 + 6 * d[2] * y1 + y1 * (2 * d[0] * y1 + 4 * d[1] * y1*(xy2)+6 * d[4] * y1*x2_y2))) /
+            (exp1*exp1) + (fy*((x*(-(cos_a*sin_g + cos_g * sin_a*sin_b)) + y * (-(cos_a*cos_g - sin_a * sin_b*sin_g)) +
+                z * (cos_b*sin_a))*(z*(fx*sin_b + ppx * cos_a*cos_b) + x * (ppx*(sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g) + y *
+                (ppx*(cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g) + (fx*t[0] + ppx * t[2])) - (x*(-ppx * (cos_a*sin_g + cos_g * sin_a*sin_b)) +
+                    y * (-ppx * (cos_a*cos_g - sin_a * sin_b*sin_g)) + z * (ppx*cos_b*sin_a))*(z*(cos_a*cos_b - 0 * cos_b*sin_a) + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) +
+                        y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + (t[2])))*(2 * d[2] * x1 + 2 * d[3] * y1 + y1 * (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))) / (fx*(exp1*exp1));
+
+        return res;
+    }
+
+    double calculate_rotation_y_beta_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = (double)sin( rot_angles.alpha );
+        auto sin_b = (double)sin( rot_angles.beta );
+        auto sin_g = (double)sin( rot_angles.gamma );
+
+        auto cos_a = (double)cos( rot_angles.alpha );
+        auto cos_b = (double)cos( rot_angles.beta );
+        auto cos_g = (double)cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = (double)v.x;
+        auto y = (double)v.y;
+        auto z = (double)v.z;
+
+        auto exp1 = z * (cos_a*cos_b) + x * ((sin_a*sin_g - cos_a * cos_g*sin_b))
+            + y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + (t[2]);
+
+        auto res = -(((z*(-cos_a * sin_b) - x * (cos_a*cos_b*cos_g)
+            + y * (cos_a*cos_b*sin_g))*(z*(ppy * cos_a*cos_b - fy * cos_b*sin_a)
+                + x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b) + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b))
+                + y * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g) + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g))
+                + (fy * t[1] + ppy * t[2])) - (z*(0 * cos_b - ppy * cos_a*sin_b + fy * sin_a*sin_b)
+                    - x * (ppy * cos_a*cos_b*cos_g - fy * cos_b*cos_g*sin_a) + y * (ppy * cos_a*cos_b*sin_g - fy * cos_b*sin_a*sin_g))*
+                    (z*(cos_a*cos_b) + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) + y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + t[2]))
+            *(rc + 2 * d[3] * x1 + 6 * d[2] * y1 + y1 * (2 * d[0] * y1 + 4 * d[1] * y1*(xy2)+6 * d[4] * y1*x2_y2))) /
+            (exp1*exp1) - (fy*((z*(-cos_a * sin_b) - x * (cos_a*cos_b*cos_g) + y * (cos_a*cos_b*sin_g))*(z*(fx*sin_b + ppx * cos_a*cos_b)
+                + x * (ppx * (sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g) + y * (+ppx * (cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g)
+                + (fx*t[0] + ppx * t[2])) - (z*(fx*cos_b - ppx * cos_a*sin_b) - x * (fx*cos_g*sin_b + ppx * cos_a*cos_b*cos_g) + y
+                    * (fx*sin_b*sin_g + ppx * cos_a*cos_b*sin_g))*(z*(cos_a*cos_b) + x * (sin_a*sin_g - cos_a * cos_g*sin_b) + y
+                        * (cos_g*sin_a + cos_a * sin_b*sin_g) + t[2]))*(2 * d[2] * x1 + 2 * d[3] * y1 + y1 *
+                        (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))) / (fx*(exp1*exp1));
+
+        return res;
+
+    }
+
+    double calculate_rotation_y_gamma_coeff(
+        rotation_in_angles const & rot_angles,
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & yuy_intrin_extrin
+    )
+    {
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto sin_a = (double)sin( rot_angles.alpha );
+        auto sin_b = (double)sin( rot_angles.beta );
+        auto sin_g = (double)sin( rot_angles.gamma );
+
+        auto cos_a = (double)cos( rot_angles.alpha );
+        auto cos_b = (double)cos( rot_angles.beta );
+        auto cos_g = (double)cos( rot_angles.gamma );
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto x = v.x;
+        auto y = v.y;
+        auto z = v.z;
+
+        auto exp1 = z * (cos_a*cos_b) + x * (+(sin_a*sin_g - cos_a * cos_g*sin_b))
+            + y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + t[2];
+
+        auto res = (((y*(+(sin_a*sin_g - cos_a * cos_g*sin_b)) - x * ((cos_g*sin_a + cos_a * sin_b*sin_g)))
+            *(z*(ppy * cos_a*cos_b - fy * cos_b*sin_a) + x * (fy*(cos_a*sin_g + cos_g * sin_a*sin_b)
+                + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b)) + y * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g)
+                    + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g))
+                + (fy * t[1] + ppy * t[2])) - (y*(fy*(cos_a*sin_g + cos_g * sin_a*sin_b) + ppy * (sin_a*sin_g - cos_a * cos_g*sin_b))
+                    - x * (fy*(cos_a*cos_g - sin_a * sin_b*sin_g) + ppy * (cos_g*sin_a + cos_a * sin_b*sin_g)))*(z*(cos_a*cos_b)
+                        + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) + y * (+(cos_g*sin_a + cos_a * sin_b*sin_g)) + (t[2])))
+            *(rc + 2 * d[3] * x1 + 6 * d[2] * y1 + y1 * (2 * d[0] * y1 + 4 * d[1] * y1*(xy2)+6 * d[4] * y1*x2_y2)))
+            / (exp1*exp1) + (fy*((y*(+(sin_a*sin_g - cos_a * cos_g*sin_b)) - x * (+(cos_g*sin_a + cos_a * sin_b*sin_g)))
+                *(z*(fx*sin_b + ppx * cos_a*cos_b) + x * (ppx * (sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g)
+                    + y * (+ppx * (cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g) + (fx*t[0] + ppx * t[2]))
+                - (y*(ppx * (sin_a*sin_g - cos_a * cos_g*sin_b) + fx * cos_b*cos_g) - x
+                    * (+ppx * (cos_g*sin_a + cos_a * sin_b*sin_g) - fx * cos_b*sin_g))*(z*(cos_a*cos_b)
+                        + x * ((sin_a*sin_g - cos_a * cos_g*sin_b)) + y * ((cos_g*sin_a + cos_a * sin_b*sin_g)) + (t[2])))
+                *(2 * d[2] * x1 + 2 * d[3] * y1 + y1 * (2 * d[0] * x1 + 4 * d[1] * x1*(xy2)+6 * d[4] * x1*x2_y2))
+                ) / (fx*(exp1*exp1));
+
+        return res;
+    }
+
+    p_matrix calculate_p_x_coeff(
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & cal,
+        const p_matrix & p_mat
+    )
+    {
+        p_matrix res;
+        auto r = cal.rot.rot;
+        double t[3] = { cal.trans.t1, cal.trans.t2, cal.trans.t3 };
+        auto d = cal.coeffs;
+        auto ppx = (double)cal.k_mat.get_ppx();
+        auto ppy = (double)cal.k_mat.get_ppy();
+        auto fx = (double)cal.k_mat.get_fx();
+        auto fy = (double)cal.k_mat.get_fy();
+        auto p = p_mat.vals;
+
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto r2 = x2 + y2;
+        auto r4 = r2 * r2;
+
+        auto x = v.x;
+        auto y = v.y;
+        auto z = v.z;
+
+        res.vals[1] = res.vals[2] = res.vals[3] = res.vals[4] =
+            res.vals[5] = res.vals[6] = res.vals[7] = res.vals[8] =
+            res.vals[9] = res.vals[10] = res.vals[11] = { 0 };
+
+        res.vals[0] = (x*(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1);
+        
+        res.vals[1] = (y*(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1);
+
+        res.vals[2] = (z*(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1);
+
+        res.vals[3] = (1*(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1);
+
+        res.vals[4] = (fx*x*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+            )/ (fy*(p[8]*x + p[9]*y + p[10]*z + p[11]*1));
+
+        res.vals[5] = (fx*y*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+            )/ (fy*(p[8]*x + p[9]*y + p[10]*z + p[11]*1));
+
+        res.vals[6] = (fx*z*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+            )/ (fy*(p[8]*x + p[9]*y + p[10]*z + p[11]*1));
+
+        res.vals[7] = (fx*1*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+            )/ (fy*(p[8]*x + p[9]*y + p[10]*z + p[11]*1));
+
+        double exp =  p[8] * x + p[9] * y + p[10] * z + p[11];
+        double exp2 =  exp * exp;
+       
+        res.vals[8] = -(x*(p[0]*x + p[1]*y + p[2]*z + p[3]*1)
+            *(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+            )/ exp2 - (fx*x*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+                *(p[4]*x + p[5]*y + p[6]*z + p[7]*1)
+                )/ (fy*(exp2));
+        
+
+        res.vals[9] = - (y*(p[0]*x + p[1]*y + p[2]*z + p[3]*1)
+                *(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                ) / exp2 - (fx*y*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+                *(p[4]*x + p[5]*y + p[6]*z + p[7]*1)
+                )/ (fy*exp2);
+
+        res.vals[10] = - (z*(p[0]*x + p[1]*y + p[2]*z + p[3]*1)
+                *(rc + 6*d[3]*x1 + 2*d[2]*y1 + x1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                ) / exp2 - (fx*z*(2*d[2]*x1 + 2*d[3]*y1 + x1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4))
+                *(p[4]*x + p[5]*y + p[6]*z + p[7]*1)
+                ) / (fy*exp2);
+
+        res.vals[11] = -(1 * (p[0] * x + p[1] * y + p[2] * z + p[3] * 1)
+            *(rc + 6 * d[3] * x1 + 2 * d[2] * y1 + x1 * (2 * d[0] * x1 + 4 * d[1] * x1*(r2)+6 * d[4] * x1*r4))
+            ) / exp2 - (fx * 1 * (2 * d[2] * x1 + 2 * d[3] * y1 + x1 * (2 * d[0] * y1 + 4 * d[1] * y1*(r2)+6 * d[4] * y1*r4))
+                *(p[4] * x + p[5] * y + p[6] * z + p[7] * 1)
+                ) / (fy*exp2);
+
+        return res;
+    }
+
+    p_matrix calculate_p_y_coeff(
+        double3 const & v,
+        double rc,
+        double2 const & xy,
+        const calib & cal,
+        const p_matrix & p_mat
+    )
+    {
+        p_matrix res;
+        auto r = cal.rot.rot;
+        double t[3] = { cal.trans.t1, cal.trans.t2, cal.trans.t3 };
+        auto d = cal.coeffs;
+        auto ppx = (double)cal.k_mat.get_ppx();
+        auto ppy = (double)cal.k_mat.get_ppy();
+        auto fx = (double)cal.k_mat.get_fx();
+        auto fy = (double)cal.k_mat.get_fy();
+        auto p = p_mat.vals;
+
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto r2 = x2 + y2;
+        auto r4 = r2 * r2;
+
+        auto x = v.x;
+        auto y = v.y;
+        auto z = v.z;
+
+        double exp = p[8] * x + p[9] * y + p[10] * z + p[11] * 1;
+        double exp2 = exp * exp;
+        res.vals[0] = (fy*x*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4)) 
+            )/ (fx*(p[8]*x + p[9]*y + p[10]*z + p[11]*1)); 
+        res.vals[1] = (fy*y*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4)) 
+            )/ (fx*(p[8]*x + p[9]*y + p[10]*z + p[11]*1)); 
+        res.vals[2] = (fy*z*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4)) 
+            )/ (fx*(p[8]*x + p[9]*y + p[10]*z + p[11]*1)); 
+        res.vals[3] = (fy*1*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4)) 
+            )/ (fx*(p[8]*x + p[9]*y + p[10]*z + p[11]*1)); 
+        res.vals[4] = (x*(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1); 
+        res.vals[5] = (y*(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1); 
+        res.vals[6] = (z*(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1); 
+        res.vals[7] = (1*(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+            )/ (p[8]*x + p[9]*y + p[10]*z + p[11]*1); 
+        res.vals[8] = - (x*(p[4]*x + p[5]*y + p[6]*z + p[7]*1) 
+                *(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+                )/ exp2 - (fy*x*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                *(p[0]*x + p[1]*y + p[2]*z + p[3]*1) 
+                )/ (fx*exp2);
+        res.vals[9] = - (y*(p[4]*x + p[5]*y + p[6]*z + p[7]*1) 
+                *(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+                )/ exp2 - (fy*y*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                *(p[0]*x + p[1]*y + p[2]*z + p[3]*1) 
+                )/ (fx*exp2);
+        res.vals[10] = - (z*(p[4]*x + p[5]*y + p[6]*z + p[7]*1) 
+                *(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+                )/ exp2 - (fy*z*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                *(p[0]*x + p[1]*y + p[2]*z + p[3]*1) 
+                )/ (fx*exp2);
+        res.vals[11] = - (1*(p[4]*x + p[5]*y + p[6]*z + p[7]*1) 
+                *(rc + 2*d[3]*x1 + 6*d[2]*y1 + y1*(2*d[0]*y1 + 4*d[1]*y1*(r2)+6*d[4]*y1*r4)) 
+                )/ exp2 - (fy*1*(2*d[2]*x1 + 2*d[3]*y1 + y1*(2*d[0]*x1 + 4*d[1]*x1*(r2)+6*d[4]*x1*r4))
+                *(p[0]*x + p[1]*y + p[2]*z + p[3]*1) 
+                )/ (fx*exp2);
+        return res;
+    }
+
+    coeffs<rotation_in_angles> calc_rotation_coefs(
+        const z_frame_data & z_data,
+        const yuy2_frame_data & yuy_data,
+        const calib & yuy_intrin_extrin,
+        const std::vector<double>& rc,
+        const std::vector<double2>& xy
+    )
+    {
+        coeffs<rotation_in_angles> res;
+        auto engles = extract_angles_from_rotation( yuy_intrin_extrin.rot.rot );
+        auto v = z_data.vertices;
+        res.x_coeffs.resize( v.size() );
+        res.y_coeffs.resize( v.size() );
+
+        for( auto i = 0; i < v.size(); i++ )
+        {
+            res.x_coeffs[i].alpha = calculate_rotation_x_alpha_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+            res.x_coeffs[i].beta = calculate_rotation_x_beta_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+            res.x_coeffs[i].gamma = calculate_rotation_x_gamma_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+
+            res.y_coeffs[i].alpha = calculate_rotation_y_alpha_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+            res.y_coeffs[i].beta = calculate_rotation_y_beta_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+            res.y_coeffs[i].gamma = calculate_rotation_y_gamma_coeff( engles, v[i], rc[i], xy[i], yuy_intrin_extrin );
+        }
+
+        return res;
+    }
+
+    translation calculate_translation_x_coeff( double3 v, double rc, double2 xy, const calib & yuy_intrin_extrin )
+    {
+        translation res;
+
+        auto x1 = (double)xy.x;
+        auto y1 = (double)xy.y;
+
+        auto x2 = x1 * x1;
+        auto y2 = y1 * y1;
+        auto xy2 = x2 + y2;
+        auto x2_y2 = xy2 * xy2;
+
+        auto r = yuy_intrin_extrin.rot.rot;
+        double t[3] = { yuy_intrin_extrin.trans.t1, yuy_intrin_extrin.trans.t2, yuy_intrin_extrin.trans.t3 };
+        auto d = yuy_intrin_extrin.coeffs;
+        auto ppx = (double)yuy_intrin_extrin.k_mat.get_ppx();
+        auto ppy = (double)yuy_intrin_extrin.k_mat.get_ppy();
+        auto fx = (double)yuy_intrin_extrin.k_mat.get_fx();
+        auto fy = (double)yuy_intrin_extrin.k_mat.get_fy();
+
+        auto x = (double)v.x;
+        auto y = (double)v.y;
+        auto z = (double)v.z;
+
+        auto exp1 = rc + 6 * (double)d[3] * x1 + 2 * (double)d[2] * y1 + x1 *
+            (2 * (double)d[0] * x1 + 4 * (double)d[1] * x1*(xy2)+6 * (double)d[4] * x1*(x2_y2));
+        auto exp2 = fx * (double)r[2] * x + fx * (double)r[5] * y + fx * (double)r[8] * z + fx * (double)t[2];
+        auto exp3 = (double)r[2] * x + (double)r[5] * y + (double)r[8] * z + (double)t[2];
+
+        res.t1 = (exp1 * exp2) / (exp3 * exp3);
+
+        auto exp4 = 2 * (double)d[2] * x1 + 2 * (double)d[3] * y1 + x1 *
+            (2 * (double)d[0] * y1 + 4 * (double)d[1] * y1*xy2 + 6 * (double)d[4] * y1*x2_y2);
+        auto exp5 = -fy * (double)r[2] * x - fy * (double)r[5] * y - fy * (double)r[8] * z - fy * (double)t[2];
+        auto exp6 = (double)r[2] * x + (double)r[5] * y + (double)r[8] * z + (double)t[2];
+
+        res.t2 = -(fx*exp4 * exp5) / (fy*exp6 * exp6);
+
+        exp1 = rc + 6 * (double)d[3] * x1 + 2 * (double)d[2] * y1 + x1
+            * (2 * (double)d[0] * x1 + 4 * (double)d[1] * x1*(xy2)+6 * (double)d[4] * x1*x2_y2);
+        exp2 = fx * (double)r[0] * x + fx * (double)r[3] * y + fx * (double)r[6] * z + fx * (double)t[0];
+        exp3 = (double)r[2] * x + (double)r[5] * y + (double)r[8] * z + (double)t[2];
+        exp4 = fx * (2 * (double)d[2] * x1 + 2 * (double)d[3] * y1 +
+            x1 * (2 * (double)d[0] * y1 + 4 * (double)d[1] * y1*(xy2)+6 * (double)d[4] * y1*x2_y2));
+        exp5 = +fy * (double)r[1] * x + fy * (double)r[4] * y + fy * (double)r[7] * z + fy * (double)t[1];
+        exp6 = (double)r[2] * x + (double)r[5] * y + (double)r[8] * z + (double)t[2];
+
+        res.t3 = -(exp1 * exp2) / (exp3 * exp3) - (exp4 * exp5) / (fy*exp6 * exp6);
+
+        return res;
+
+    }
+
+    coeffs< p_matrix > calc_p_coefs(const z_frame_data& z_data,
+        const std::vector<double3>& new_vertices,
+        const yuy2_frame_data& yuy_data,
+        const calib & cal,
+        const p_matrix & p_mat,
+        const std::vector<double>& rc,
+        const std::vector<double2>& xy)
+    {
+        coeffs<p_matrix> res;
+
+        auto v = new_vertices;
+        res.y_coeffs.resize(v.size());
+        res.x_coeffs.resize(v.size());
+
+        for (auto i = 0; i < rc.size(); i++)
+        {
+            res.x_coeffs[i] = calculate_p_x_coeff(v[i], rc[i], xy[i], cal, p_mat);
+            res.y_coeffs[i] = calculate_p_y_coeff(v[i], rc[i], xy[i], cal, p_mat);
+        }
+
+        return res;
+    }
+
+}
+}
+}
diff --git a/src/algo/depth-to-rgb-calibration/coeffs.h b/src/algo/depth-to-rgb-calibration/coeffs.h
new file mode 100644
index 0000000..8975569
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/coeffs.h
@@ -0,0 +1,41 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "calibration-types.h"
+#include "calibration.h"
+#include <vector>
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    template< class T >
+    struct coeffs
+    {
+        std::vector<T> x_coeffs;
+        std::vector<T> y_coeffs;
+    };
+
+    struct z_frame_data;
+    struct yuy2_frame_data;
+    struct calib;
+
+    coeffs< p_matrix > calc_p_coefs(
+        const z_frame_data& z_data,
+        const std::vector<double3>& new_vertices,
+        const yuy2_frame_data& yuy_data,
+        const calib & cal,
+        const p_matrix & p_mat,
+        const std::vector<double>& rc,
+        const std::vector<double2>& xy
+    );
+
+    struct data_collect;
+
+}  // librealsense::algo::depth_to_rgb_calibration
+}  // librealsense::algo
+}  // librealsense
diff --git a/src/algo/depth-to-rgb-calibration/cost.cpp b/src/algo/depth-to-rgb-calibration/cost.cpp
new file mode 100644
index 0000000..1011529
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/cost.cpp
@@ -0,0 +1,104 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "cost.h"
+#include "debug.h"
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    std::vector< double > calc_cost_per_vertex(
+        std::vector<double> const & d_vals,
+        z_frame_data const & z_data,
+        yuy2_frame_data const & yuy_data,
+        std::function< void( size_t i, double d_val, double weight, double vertex_cost ) > fn
+    )
+    {
+        double cost = 0;
+        std::vector< double > cost_per_vertex(d_vals.size());
+
+        for (size_t i = 0; i < z_data.weights.size(); i++)
+        {
+            double d_val = d_vals[i];  // may be std::numeric_limits<double>::max()?
+            double weight = z_data.weights[i];
+            double cost = d_val;
+            if (d_val != std::numeric_limits<double>::max())
+                cost = d_val * weight;
+
+            cost_per_vertex[i] = cost;
+            fn(i, d_val, weight, cost);
+
+        }
+        return cost_per_vertex;
+    }
+
+    double calc_cost_per_vertex_diff(z_frame_data const & z_data, yuy2_frame_data const & yuy_data, const uvmap_t & uvmap_old, const uvmap_t & uvmap_new)
+    {
+        //old
+        auto d_vals_old = biliniar_interp(yuy_data.edges_IDT, yuy_data.width, yuy_data.height, uvmap_old);
+
+        auto cost_per_vertex_old = calc_cost_per_vertex(d_vals_old, z_data, yuy_data,
+            [&](size_t i, double d_val, double weight, double vertex_cost) {});
+
+        //new
+        auto d_vals_new = biliniar_interp(yuy_data.edges_IDT, yuy_data.width, yuy_data.height, uvmap_new);
+
+        auto cost_per_vertex_new = calc_cost_per_vertex(d_vals_new, z_data, yuy_data,
+            [&](size_t i, double d_val, double weight, double vertex_cost) {});
+
+        double diff = 0;
+        auto num = 0;
+        for (auto i = 0; i < cost_per_vertex_new.size(); i++)
+        {
+            if (cost_per_vertex_old[i] != std::numeric_limits<double>::max() &&
+                cost_per_vertex_new[i] != std::numeric_limits<double>::max())
+            {
+                diff += cost_per_vertex_old[i] - cost_per_vertex_new[i];
+                num++;
+            }
+        }
+        return diff / num;
+    }
+
+    std::vector<double> calc_cost_per_vertex(z_frame_data const & z_data, yuy2_frame_data const & yuy_data,
+        const uvmap_t & uvmap)
+    {
+        auto d_vals = biliniar_interp(yuy_data.edges_IDT, yuy_data.width, yuy_data.height, uvmap);
+
+        return calc_cost_per_vertex(d_vals, z_data, yuy_data,
+            [&](size_t i, double d_val, double weight, double vertex_cost)
+        {});
+    }
+
+    double calc_cost(
+        const z_frame_data & z_data,
+        const yuy2_frame_data & yuy_data,
+        const std::vector< double2 > & uv,
+        std::vector< double > * p_interpolated_edges // = nullptr
+    )
+    {
+        double cost = 0;
+        size_t N = 0;
+
+        auto d_vals = biliniar_interp(yuy_data.edges_IDT, yuy_data.width, yuy_data.height, uv);
+
+        auto cost_per_vertex = calc_cost_per_vertex(d_vals, z_data, yuy_data,
+            [&]( size_t i, double d_val, double weight, double vertex_cost )
+            {
+                if( d_val != std::numeric_limits<double>::max() )
+                {
+                    cost += vertex_cost;
+                    ++N;
+                }
+            } );
+        if( p_interpolated_edges )
+            *p_interpolated_edges = d_vals;
+        return N ? cost / N : 0.;
+    }
+
+
+}
+}
+}
\ No newline at end of file
diff --git a/src/algo/depth-to-rgb-calibration/cost.h b/src/algo/depth-to-rgb-calibration/cost.h
new file mode 100644
index 0000000..4e4ce0d
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/cost.h
@@ -0,0 +1,38 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "uvmap.h"
+#include "frame-data.h"
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    std::vector< double > calc_cost_per_vertex(
+        std::vector<double> const & d_vals,
+        z_frame_data const & z_data,
+        yuy2_frame_data const & yuy_data,std::function< void( size_t i, double d_val, double weight, double vertex_cost ) > fn
+    );
+
+    double calc_cost_per_vertex_diff(
+        z_frame_data const & z_data,
+        yuy2_frame_data const & yuy_data,
+        const uvmap_t & uvmap_old,
+        const uvmap_t & uvmap_new
+    );
+
+    double calc_cost(
+        const z_frame_data & z_data,
+        const yuy2_frame_data & yuy_data,
+        const uvmap_t & uvmap,
+        std::vector< double > * p_interpolated_edges = nullptr
+    );
+
+
+}
+}
+}
diff --git a/src/algo/depth-to-rgb-calibration/debug.h b/src/algo/depth-to-rgb-calibration/debug.h
new file mode 100644
index 0000000..e5ffbe6
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/debug.h
@@ -0,0 +1,20 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+
+// DEBUG HELPERS -- should be included from .cpp only!!
+
+
+#define AC_F_PREC  std::setprecision( std::numeric_limits< float >::max_digits10 )
+#define AC_D_PREC  std::setprecision( std::numeric_limits< double >::max_digits10 )
+
+
+#define AC_LOG_PREFIX "CAH: "
+#define AC_LOG_PREFIX_LEN 5
+
+#define AC_LOG(TYPE,MSG) LOG_##TYPE( AC_LOG_PREFIX << (std::string)( librealsense::to_string() << MSG ))
+//#define AC_LOG(TYPE,MSG) std::cout << (std::string)( to_string() << "-" << #TYPE [0] << "- " << MSG ) << std::endl; //LOG_INFO((std::string)( to_string() << "-" << #TYPE [0] << "- " << MSG ));
+//#define AC_LOG_CONTINUE(TYPE,MSG) std::cout << (std::string)( to_string() << "-" << #TYPE [0] << "- " << MSG )
+
diff --git a/src/algo/depth-to-rgb-calibration/frame-data.h b/src/algo/depth-to-rgb-calibration/frame-data.h
new file mode 100644
index 0000000..309527e
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/frame-data.h
@@ -0,0 +1,152 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <vector>
+#include <map>
+#include <types.h>
+
+#include "calibration-types.h"
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    struct frame_data
+    {
+        size_t width;
+        size_t height;
+    };
+
+    typedef uint16_t yuy_t;
+    typedef uint8_t ir_t;
+    typedef uint16_t z_t;
+
+    struct ir_frame_data : frame_data
+    {
+        std::vector< ir_t > ir_frame;
+        std::vector<double> edges;
+        std::vector< double > local_edges;
+
+        // smearing
+        std::vector<double> gradient_x;
+        std::vector<double> gradient_y;
+        std::vector< byte > section_map_depth;
+        std::vector< byte > valid_edge_pixels_by_ir;
+        std::vector<byte> valid_section_map;
+        std::vector<double>valid_gradient_x;
+        std::vector<double>valid_gradient_y;
+        std::vector<direction> directions;
+        std::vector<double> direction_deg;
+        std::vector<double> valid_location_rc_x;
+        std::vector<double> valid_location_rc_y;
+        std::vector<double> valid_location_rc;
+        std::vector<double> direction_per_pixel;
+        std::vector<double> direction_per_pixel_x; //for debug
+        std::vector<double> direction_per_pixel_y; // for debug
+        std::vector<double> local_region[4];
+        std::vector<double> local_region_x[4];//for debug
+        std::vector<double> local_region_y[4]; // for debug
+        std::vector< byte > is_supressed;
+        std::vector<double> fraq_step;
+
+    };
+
+    struct z_frame_data : frame_data
+    {
+        rs2_intrinsics_double orig_intrinsics;
+        rs2_intrinsics_double new_intrinsics;
+        rs2_dsm_params orig_dsm_params;
+        /*algo_calibration_registers algo_calibration_registers;
+        regs regs;*/
+        float depth_units;
+
+        std::vector< z_t > frame;
+        std::vector<double> gradient_x;
+        std::vector<double> gradient_y;
+        std::vector<double> edges;
+        std::vector< byte > supressed_edges;
+        size_t n_strong_edges;
+        std::vector<double> subpixels_x;
+        std::vector<double> subpixels_y;
+        std::vector<double> subpixels_y_round;
+        std::vector<double> subpixels_x_round;
+        std::vector<double> valid_weights;
+        std::vector<uint8_t> relevant_pixels_image;
+
+        std::vector<double> weights;
+        std::vector<double> direction_deg;
+        std::vector<double3> vertices_all; 
+
+        //smearing
+        std::vector< byte > section_map_depth;
+        std::vector< byte > section_map_depth_inside;
+        std::vector<double> local_x;
+        std::vector<double> local_y;
+        std::vector<double> gradient;
+        std::vector<double> local_values;
+        std::vector<double> grad_in_direction;
+        std::vector<double> grad_in_direction_valid;
+        std::vector<double> grad_in_direction_inside;
+        std::vector<double> values_for_subedges;
+        std::vector<double> closest;
+        std::vector<double> direction_per_pixel;
+        std::vector<double> valid_direction_per_pixel;
+        std::vector<byte> valid_section_map;
+        std::vector<double> local_rc_subpixel;
+        std::vector<double> edge_sub_pixel;
+        std::vector<double> valid_directions;
+        std::vector<double> directions;
+        std::vector<double> valid_edge_sub_pixel;
+        std::vector<double > valid_edge_sub_pixel_x;
+        std::vector<double > valid_edge_sub_pixel_y;
+        std::vector<double> sub_points;
+        std::vector<double3> vertices;
+        std::vector<double3> orig_vertices;
+        std::vector<double> vertices3;
+        std::vector<double2> uvmap;
+        std::vector< byte > is_inside;
+        // input validation
+        std::vector<byte> section_map;
+        bool is_edge_distributed;
+        std::vector<double>sum_weights_per_section;
+        std::vector<double> sum_weights_per_direction;
+        double min_max_ratio;
+
+        // output validation
+        std::vector< double > cost_diff_per_section;
+
+        //svm
+        double dir_ratio1;
+    };
+
+    struct yuy2_frame_data : frame_data
+    {
+        std::vector< yuy_t > orig_frame;
+        std::vector< yuy_t > prev_frame;
+        std::vector<uint8_t> lum_frame;
+        std::vector<uint8_t> prev_lum_frame;
+        std::vector<double> yuy_diff;
+        std::vector<uint8_t> dilated_image;
+        std::vector<double> gaussian_filtered_image;
+        std::vector<double> gaussian_diff_masked;
+        std::vector<uint8_t> move_suspect;
+        std::vector<double> edges;                          // W*H, pre-smearing
+        std::vector<double> prev_edges;                     // W*H, for prev_frame
+        std::vector<uint8_t> logic_edges;
+        std::vector<uint8_t> prev_logic_edges;
+        std::vector<double> edges_IDT;                      // W*H, smeared, for cost
+        std::vector<double> edges_IDTx;                     // W*H, smeared, dedge/dx, for gradients
+        std::vector<double> edges_IDTy;                     // W*H, smeared, dedge/dy, for gradients
+        std::vector<unsigned char> section_map;
+        bool is_edge_distributed;
+        std::vector<double>sum_weights_per_section;
+        double min_max_ratio;
+    };
+
+}  // librealsense::algo::depth_to_rgb_calibration
+}  // librealsense::algo
+}  // librealsense
diff --git a/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp b/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
new file mode 100644
index 0000000..d2c8b59
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
@@ -0,0 +1,863 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "k-to-dsm.h"
+#include "optimizer.h"
+#include "debug.h"
+#include "utils.h"
+#include <math.h>
+
+using namespace librealsense::algo::depth_to_rgb_calibration;
+
+
+std::ostream &
+librealsense::algo::depth_to_rgb_calibration::operator<<( std::ostream & s,
+                                                          rs2_dsm_params_double const & self )
+{
+    s << "[ ";
+    switch( self.model )
+    {
+    case RS2_DSM_CORRECTION_NONE: break;
+    case RS2_DSM_CORRECTION_AOT: s << "AoT "; break;
+    case RS2_DSM_CORRECTION_TOA: s << "ToA "; break;
+    }
+    s << "x[" << self.h_scale << " " << self.v_scale << "] ";
+    if( self.h_offset  ||  self.v_offset )
+        s << "+[" << self.h_offset << " " << self.v_offset;
+    if( self.rtd_offset )
+        s << " rtd " << self.rtd_offset;
+    s << " ]";
+    return s;
+}
+
+
+rs2_intrinsics_double rotate_k_mat(const rs2_intrinsics_double& k_mat)
+{
+    rs2_intrinsics_double res = k_mat;
+    res.ppx = k_mat.width - 1 - k_mat.ppx;
+    res.ppy = k_mat.height - 1 - k_mat.ppy;
+
+    return res;
+}
+
+k_to_DSM::k_to_DSM( const rs2_dsm_params_double & orig_dsm_params,
+                    algo_calibration_info const & cal_info,
+                    algo_calibration_registers const & cal__regs,
+                    const double & max_scaling_step )
+    : _regs( cal_info )
+    , _dsm_regs( cal__regs )
+    , _max_scaling_step( max_scaling_step )
+{
+}
+
+algo_calibration_registers
+k_to_DSM::apply_ac_res_on_dsm_model( const rs2_dsm_params_double & ac_data,
+                                     const algo_calibration_registers & dsm_regs,
+                                     const ac_to_dsm_dir & type )
+{
+    algo_calibration_registers res;
+
+    if (type == direct) // convert from original model to modified model
+    {
+        switch (ac_data.model)
+        {
+        case RS2_DSM_CORRECTION_NONE:
+            res = dsm_regs;
+            break;
+        case RS2_DSM_CORRECTION_AOT:
+            res.EXTLdsmXscale =  (double)dsm_regs.EXTLdsmXscale * ac_data.h_scale ;
+            res.EXTLdsmYscale = (double)dsm_regs.EXTLdsmYscale * ac_data.v_scale ;
+            res.EXTLdsmXoffset
+                =  ( (double)dsm_regs.EXTLdsmXoffset + (double)ac_data.h_offset )
+                         / (double)ac_data.h_scale ;
+            res.EXTLdsmYoffset
+                =  ( (double)dsm_regs.EXTLdsmYoffset + (double)ac_data.v_offset )
+                         / (double)ac_data.v_scale ;
+            break;
+        case RS2_DSM_CORRECTION_TOA:
+            res.EXTLdsmXscale =  (double)dsm_regs.EXTLdsmXscale * ac_data.h_scale ;
+            res.EXTLdsmYscale =  (double)dsm_regs.EXTLdsmYscale * ac_data.v_scale ;
+            res.EXTLdsmXoffset
+                =  ( (double)dsm_regs.EXTLdsmXoffset + (double)ac_data.h_offset )
+                         / (double)dsm_regs.EXTLdsmXscale ;
+            res.EXTLdsmYoffset
+                =  ( (double)dsm_regs.EXTLdsmYoffset + (double)ac_data.v_offset )
+                         / (double)dsm_regs.EXTLdsmYscale ;
+            break;
+        default:
+            throw std::runtime_error( "invalid model " + std::to_string( ac_data.model ) );
+        }
+    }
+    else if (type == inverse) // revert from modified model to original model
+    {
+        switch (ac_data.model)
+        {
+        case RS2_DSM_CORRECTION_NONE:
+            res = dsm_regs;
+            break;
+        case RS2_DSM_CORRECTION_AOT:
+            res.EXTLdsmXscale = (double)dsm_regs.EXTLdsmXscale / (double)ac_data.h_scale;
+            res.EXTLdsmYscale = (double)dsm_regs.EXTLdsmYscale / (double)ac_data.v_scale;
+            res.EXTLdsmXoffset = (double)dsm_regs.EXTLdsmXoffset* (double)ac_data.h_scale - (double)ac_data.h_offset;
+            res.EXTLdsmYoffset = (double)dsm_regs.EXTLdsmYoffset* (double)ac_data.v_scale - (double)ac_data.v_offset;
+            break;
+        case RS2_DSM_CORRECTION_TOA:
+            res.EXTLdsmXscale = (double)dsm_regs.EXTLdsmXscale / (double)ac_data.h_scale;
+            res.EXTLdsmYscale = (double)dsm_regs.EXTLdsmYscale / (double)ac_data.v_scale;
+            res.EXTLdsmXoffset = (double)dsm_regs.EXTLdsmXoffset - (double)ac_data.h_offset / (double)res.EXTLdsmXscale;
+            res.EXTLdsmYoffset = (double)dsm_regs.EXTLdsmYoffset - (double)ac_data.v_offset / (double)res.EXTLdsmYscale;
+            break;
+        default:
+            throw std::runtime_error( "invalid valid model " + std::to_string( ac_data.model ) );
+            break;
+        }
+    }
+    return res;
+}
+
+los_shift_scaling
+k_to_DSM::convert_ac_data_to_los_error( const algo_calibration_registers & dsm_regs,
+                                        const rs2_dsm_params_double & ac_data )
+{
+    los_shift_scaling res;
+    switch (ac_data.model)
+    {
+    case RS2_DSM_CORRECTION_NONE:
+        res.los_scaling_x = 1;
+        res.los_scaling_y = 1;
+        res.los_shift_x = 0;
+        res.los_shift_y = 0;
+        break;
+    case RS2_DSM_CORRECTION_AOT:
+        res.los_scaling_x = 1/ (double)ac_data.h_scale;
+        res.los_scaling_y = 1/ (double)ac_data.v_scale;
+        res.los_shift_x = -(double)ac_data.h_offset*res.los_scaling_x;
+        res.los_shift_y = -(double)ac_data.v_offset*res.los_scaling_y;
+        break;
+    case RS2_DSM_CORRECTION_TOA:
+        res.los_scaling_x = 1 / (double)ac_data.h_scale;
+        res.los_scaling_y = 1 / (double)ac_data.v_scale;
+
+        auto dsm_orig = apply_ac_res_on_dsm_model(ac_data, dsm_regs, inverse);
+
+        res.los_shift_x = -(double)ac_data.h_offset / (double)dsm_orig.EXTLdsmXscale - (double)dsm_orig.EXTLdsmXoffset*(1 - res.los_scaling_x);
+        res.los_shift_y = -(double)ac_data.v_offset / (double)dsm_orig.EXTLdsmYscale - (double)dsm_orig.EXTLdsmYoffset*(1 - res.los_scaling_y);
+        break;
+    }
+    return res;
+}
+
+pre_process_data k_to_DSM::pre_processing
+(
+    const algo_calibration_info& regs,
+    const rs2_dsm_params_double& ac_data,
+    const algo_calibration_registers& algo_calibration_registers,
+    const rs2_intrinsics_double& orig_k_raw,
+    const std::vector<uint8_t>& relevant_pixels_image,
+    data_collect* data
+)
+{
+    pre_process_data res;
+    res.orig_k = orig_k_raw;
+    res.relevant_pixels_image_rot = relevant_pixels_image;
+    res.last_los_error = convert_ac_data_to_los_error(algo_calibration_registers, ac_data);
+
+    res.vertices_orig = calc_relevant_vertices(relevant_pixels_image, orig_k_raw);
+    auto dsm_res_orig = apply_ac_res_on_dsm_model(ac_data, algo_calibration_registers, inverse);
+
+    convert_norm_vertices_to_los_data* vertices_to_los_data = nullptr;
+    if (data)
+        vertices_to_los_data = &data->k2dsm_data_p.first_norm_vertices_to_los_data;
+
+    res.los_orig = convert_norm_vertices_to_los(regs, dsm_res_orig, res.vertices_orig, vertices_to_los_data);
+    return res;
+}
+
+rs2_dsm_params_double k_to_DSM::convert_new_k_to_DSM
+(
+    const rs2_intrinsics_double& old_k,
+    const rs2_intrinsics_double& new_k,
+    const z_frame_data& z,
+    std::vector<double3> & new_vertices,
+    rs2_dsm_params_double const & previous_dsm_params,
+    algo_calibration_registers& new_dsm_regs,
+    data_collect* data
+)
+{
+    if (data)
+    {
+        data->k2dsm_data_p.inputs.old_k = old_k;
+        data->k2dsm_data_p.inputs.new_k = new_k;
+        data->k2dsm_data_p.inputs.z = z;
+        data->k2dsm_data_p.inputs.new_vertices = new_vertices;
+        data->k2dsm_data_p.inputs.previous_dsm_params = previous_dsm_params;
+        data->k2dsm_data_p.inputs.new_dsm_regs = new_dsm_regs;
+    }
+
+
+    auto w = old_k.width;
+    auto h = old_k.height;
+
+    auto old_k_raw = rotate_k_mat(old_k);
+    auto new_k_raw = rotate_k_mat(new_k);
+
+    auto dsm_orig = apply_ac_res_on_dsm_model( previous_dsm_params, new_dsm_regs, inverse);
+
+    std::vector<uint8_t> relevant_pixels_image_rot(z.relevant_pixels_image.size(), 0);
+    rotate_180(z.relevant_pixels_image.data(), relevant_pixels_image_rot.data(), w, h);
+
+    _pre_process_data = pre_processing(_regs, previous_dsm_params, new_dsm_regs, old_k_raw, relevant_pixels_image_rot, data);
+
+    auto new_los_scaling = convert_k_to_los_error(_regs, new_dsm_regs, new_k_raw, data);
+    double2 los_shift = { 0 };
+    auto ac_data_cand = convert_los_error_to_ac_data( previous_dsm_params, new_dsm_regs, los_shift, new_los_scaling);
+    auto dsm_regs_cand = apply_ac_res_on_dsm_model(ac_data_cand, dsm_orig, direct);
+
+    auto sc_vertices = new_vertices;
+
+    for (auto i = 0; i < sc_vertices.size(); i++)
+    {
+        sc_vertices[i].x *= -1;
+        sc_vertices[i].y *= -1;
+    }
+
+    convert_norm_vertices_to_los_data* vertices_to_los_data = nullptr;
+    if (data)
+        vertices_to_los_data = &data->k2dsm_data_p.second_norm_vertices_to_los_data;
+    auto los_orig = convert_norm_vertices_to_los(_regs, new_dsm_regs, sc_vertices, vertices_to_los_data);
+    new_vertices = convert_los_to_norm_vertices(_regs, dsm_regs_cand, los_orig, data);
+
+    if (data)
+    {
+        data->k2dsm_data_p.dsm_regs_orig = dsm_orig;
+        data->k2dsm_data_p.relevant_pixels_image_rot = relevant_pixels_image_rot;
+        data->k2dsm_data_p.new_los_scaling = new_los_scaling;
+        data->k2dsm_data_p.dsm_regs_cand = dsm_regs_cand;
+        data->k2dsm_data_p.los_orig = los_orig;
+    }
+
+    for (auto i = 0; i < new_vertices.size(); i++)
+    {
+        new_vertices[i].x = new_vertices[i].x / new_vertices[i].z* sc_vertices[i].z;
+        new_vertices[i].y = new_vertices[i].y / new_vertices[i].z* sc_vertices[i].z;
+        new_vertices[i].z = new_vertices[i].z / new_vertices[i].z* sc_vertices[i].z;
+
+        new_vertices[i].x *= -1;
+        new_vertices[i].y *= -1;
+    }
+
+    std::vector<double3> projed(new_vertices.size());
+    std::vector<double> xim_new(new_vertices.size());
+    std::vector<double> yim_new(new_vertices.size());
+
+    for (auto i = 0; i < new_vertices.size(); i++)
+    {
+        projed[i].x = new_vertices[i].x*old_k.fx + new_vertices[i].z*old_k.ppx;
+        projed[i].y = new_vertices[i].y*old_k.fy + new_vertices[i].z*old_k.ppy;
+        projed[i].z = new_vertices[i].z;
+
+        xim_new[i] = projed[i].x / projed[i].z;
+        yim_new[i] = projed[i].y / projed[i].z;
+    }
+    AC_LOG( DEBUG, "    new DSM params: " << AC_D_PREC << ac_data_cand );
+    new_dsm_regs = dsm_regs_cand;
+    return ac_data_cand;
+}
+
+const pre_process_data& k_to_DSM::get_pre_process_data() const
+{
+    return _pre_process_data;
+}
+
+double2 k_to_DSM::convert_k_to_los_error
+(
+    algo_calibration_info const & regs,
+    algo_calibration_registers const &dsm_regs,
+    rs2_intrinsics_double const & new_k_raw,
+    data_collect* data
+)
+{
+    double2 focal_scaling;
+
+    focal_scaling.x = new_k_raw.fx / _pre_process_data.orig_k.fx;
+    focal_scaling.y = new_k_raw.fy / _pre_process_data.orig_k.fy;
+
+    double coarse_grid[5] = { -1, -0.5, 0, 0.5, 1 };
+    double fine_grid[5] = { -1, -0.5, 0, 0.5, 1 };
+
+    double coarse_grid_x[5];
+    double coarse_grid_y[5];
+
+    for (auto i = 0; i < 5; i++)
+    {
+        coarse_grid_x[i] = coarse_grid[i] * _max_scaling_step + (double)_pre_process_data.last_los_error.los_scaling_x;
+        coarse_grid_y[i] = coarse_grid[i] * _max_scaling_step + (double)_pre_process_data.last_los_error.los_scaling_y;
+        fine_grid[i] = fine_grid[i] * 0.6* _max_scaling_step;
+    }
+
+    double grid_y[SIZE_OF_GRID_X];
+    double grid_x[SIZE_OF_GRID_X];
+    ndgrid_my(coarse_grid_y, coarse_grid_x, grid_y, grid_x);
+
+    auto opt_scaling = run_scaling_optimization_step(regs, dsm_regs, grid_x, grid_y, focal_scaling, data);
+
+    if (data)
+    {
+        data->k2dsm_data_p.focal_scaling = focal_scaling;
+        data->k2dsm_data_p.opt_scaling = opt_scaling;
+    }
+        
+
+    double fine_grid_x[SIZE_OF_GRID_X] = { 0 };
+    double fine_grid_y[SIZE_OF_GRID_X] = { 0 };
+
+    for (auto i = 0; i < 5; i++)
+    {
+        fine_grid_x[i] = fine_grid[i] + opt_scaling.x;
+        fine_grid_y[i] = fine_grid[i] + opt_scaling.y;
+    }
+
+    ndgrid_my(fine_grid_y, fine_grid_x, grid_y, grid_x);
+    auto los_scaling = run_scaling_optimization_step(regs, dsm_regs, grid_x, grid_y, focal_scaling);
+
+    auto max_step_with_margin = 1.01*_max_scaling_step;
+
+    los_scaling.x
+        = std::min( std::max( los_scaling.x, _pre_process_data.last_los_error.los_scaling_x
+                                                 - max_step_with_margin ),
+                    _pre_process_data.last_los_error.los_scaling_x + max_step_with_margin );
+    los_scaling.y
+        = std::min( std::max( los_scaling.y, _pre_process_data.last_los_error.los_scaling_y
+                                                 - max_step_with_margin ),
+                    _pre_process_data.last_los_error.los_scaling_y + max_step_with_margin );
+
+    return los_scaling;
+}
+
+rs2_dsm_params_double k_to_DSM::convert_los_error_to_ac_data
+(
+    const rs2_dsm_params_double& ac_data,
+    const algo_calibration_registers& dsm_regs,
+    double2 los_shift, 
+    double2 los_scaling
+)
+{
+    rs2_dsm_params_double ac_data_out = ac_data;
+    ac_data_out.model = ac_data.model;
+    switch (ac_data_out.model)
+    {
+    case RS2_DSM_CORRECTION_NONE:
+        ac_data_out.h_scale = 1;
+        ac_data_out.v_scale = 1;
+        ac_data_out.h_offset = 0;
+        ac_data_out.v_offset = 0;
+        break;
+    case RS2_DSM_CORRECTION_AOT:
+        ac_data_out.h_scale =  1 / los_scaling.x ;
+        ac_data_out.v_scale = 1 / los_scaling.y ;
+        ac_data_out.h_offset =  -los_shift.x / los_scaling.x;
+        ac_data_out.v_offset =  -los_shift.y / los_scaling.y;
+        break;
+    case RS2_DSM_CORRECTION_TOA:
+        ac_data_out.h_scale =  1 / los_scaling.x;
+        ac_data_out.v_scale =  1 / los_scaling.y;
+        _dsm_regs = apply_ac_res_on_dsm_model(ac_data, dsm_regs, inverse); // the one used for assessing LOS error
+        ac_data_out.h_offset
+            =  -( _dsm_regs.EXTLdsmXoffset * ( 1 - los_scaling.x ) + los_shift.x )
+                     * _dsm_regs.EXTLdsmXscale ;
+        ac_data_out.v_offset
+            =  -( _dsm_regs.EXTLdsmYoffset * ( 1 - los_scaling.y ) + los_shift.y )
+                     * _dsm_regs.EXTLdsmYscale ;
+        break;
+        
+    }
+    return ac_data_out;
+}
+
+double2 k_to_DSM::run_scaling_optimization_step
+(
+    algo_calibration_info const & regs,
+    algo_calibration_registers const &dsm_regs,
+    double scaling_grid_x[SIZE_OF_GRID_X],
+    double scaling_grid_y[SIZE_OF_GRID_X],
+    double2 focal_scaling,
+    data_collect* data)
+{
+    auto opt_k = optimize_k_under_los_error(regs, dsm_regs, scaling_grid_x, scaling_grid_y);
+
+    double fx_scaling_on_grid[SIZE_OF_GRID_X];
+    double fy_scaling_on_grid[SIZE_OF_GRID_X];
+
+    for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+    {
+        fx_scaling_on_grid[i] = opt_k[i].mat[0][0] / _pre_process_data.orig_k.fx;
+        fy_scaling_on_grid[i] = opt_k[i].mat[1][1] / _pre_process_data.orig_k.fy;
+    }
+    double err_l2[SIZE_OF_GRID_X];
+    for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+    {
+        err_l2[i] = std::sqrt(std::pow(fx_scaling_on_grid[i] - focal_scaling.x, 2) + std::pow(fy_scaling_on_grid[i] - focal_scaling.y, 2));
+    }
+    
+    double sg_mat[SIZE_OF_GRID_X][SIZE_OF_GRID_Y];
+    
+    for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+    {
+        sg_mat[i][0] = scaling_grid_x[i] * scaling_grid_x[i];
+        sg_mat[i][1] = scaling_grid_y[i] * scaling_grid_y[i];
+        sg_mat[i][2] = scaling_grid_x[i] * scaling_grid_y[i];
+        sg_mat[i][3] = scaling_grid_x[i];
+        sg_mat[i][4] = scaling_grid_y[i];
+        sg_mat[i][5] = 1;
+    }
+
+    double sg_mat_tag_x_sg_mat[36] = { 0 };
+    double sg_mat_tag_x_err_l2[6] = { 0 };
+
+    for (auto i = 0; i < 6; i++)
+    {
+        for (auto j = 0; j < 6; j++)
+        {
+            for (auto l = 0; l < 25; l++)
+            {
+                sg_mat_tag_x_sg_mat[i * 6 + j] += sg_mat[l][i] * sg_mat[l][j];
+            }
+            
+        }
+    }
+
+    for (auto j = 0; j < 6; j++)
+    {
+        for (auto l = 0; l < 25; l++)
+        {
+            sg_mat_tag_x_err_l2[j] += sg_mat[l][j] * err_l2[l];
+        }
+    }
+
+    double quad_coef[6];
+    direct_inv_6x6(sg_mat_tag_x_sg_mat, sg_mat_tag_x_err_l2, quad_coef);
+
+    if (data)
+    {
+        data->k2dsm_data_p.errL2 = std::vector<double>(std::begin(err_l2), std::end(err_l2));
+
+        data->k2dsm_data_p.sg_mat.resize(SIZE_OF_GRID_X);
+        for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+        {
+            data->k2dsm_data_p.sg_mat[i].resize(SIZE_OF_GRID_Y);
+            for (auto j = 0; j < SIZE_OF_GRID_Y; j++)
+            {
+                data->k2dsm_data_p.sg_mat[i][j] = sg_mat[i][j];
+            }
+        }
+
+        data->k2dsm_data_p.sg_mat_tag_x_sg_mat = std::vector<double>(std::begin(sg_mat_tag_x_sg_mat), std::end(sg_mat_tag_x_sg_mat));
+        data->k2dsm_data_p.sg_mat_tag_x_err_l2 = std::vector<double>(std::begin(sg_mat_tag_x_err_l2), std::end(sg_mat_tag_x_err_l2));
+        data->k2dsm_data_p.quad_coef = std::vector<double>(std::begin(quad_coef), std::end(quad_coef));
+    }
+
+    double A[4] = { quad_coef[0], quad_coef[2] / 2, quad_coef[2] / 2, quad_coef[1] };
+    double B[2] = { quad_coef[3] / 2, quad_coef[4] / 2 };
+    double opt_scaling[2];
+
+    direct_inv_2x2(A, B, opt_scaling);
+    opt_scaling[0] = -opt_scaling[0];
+    opt_scaling[1] = -opt_scaling[1];
+
+    // sanity check
+
+    double min_x, min_y, max_x, max_y;
+    min_x = max_x = scaling_grid_x[0];
+    min_y = max_y = scaling_grid_y[0];
+
+    for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+    {
+        if (min_x > scaling_grid_x[i])
+            min_x = scaling_grid_x[i];
+
+        if (min_y > scaling_grid_y[i])
+            min_y = scaling_grid_y[i];
+
+        if (max_x < scaling_grid_x[i])
+            max_x = scaling_grid_x[i];
+
+        if (max_y < scaling_grid_y[i])
+            max_y = scaling_grid_y[i];
+    }
+
+    auto is_pos_def = (quad_coef[0] + quad_coef[1]) > 0 && (quad_coef[0] * quad_coef[1] - quad_coef[2] * quad_coef[2] / 4) > 0;
+    auto is_with_in_lims = (opt_scaling[0] > min_x) && (opt_scaling[0] < max_y) && (opt_scaling[1] > min_y) && (opt_scaling[1] < max_y);
+
+    if (!is_pos_def || !is_with_in_lims)
+    {
+        double min_err = err_l2[0];
+        int ind_min = 0;
+        for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+        {
+            if (min_err > err_l2[i])
+            {
+                min_err = err_l2[i];
+                ind_min = i;
+            }
+        }
+        opt_scaling[0] = scaling_grid_x[ind_min];
+        opt_scaling[1] = scaling_grid_y[ind_min];
+    }
+    return { opt_scaling[0], opt_scaling[1] };
+}
+
+std::vector<double3x3> k_to_DSM::optimize_k_under_los_error
+(
+    algo_calibration_info const & regs,
+    algo_calibration_registers const &dsm_regs,
+    double scaling_grid_x[SIZE_OF_GRID_X],
+    double scaling_grid_y[SIZE_OF_GRID_X]
+)
+{
+    auto orig_k = _pre_process_data.orig_k;
+
+    std::vector<double3x3> res(SIZE_OF_GRID_X, { 0 });
+
+    for (auto i = 0; i < SIZE_OF_GRID_X; i++)
+    {
+        std::vector<double2> los(_pre_process_data.los_orig.size());
+        std::vector<double3> updated_pixels(_pre_process_data.los_orig.size());
+
+        for (auto j = 0; j < updated_pixels.size(); j++)
+        {
+            los[j].x = scaling_grid_x[i] * _pre_process_data.los_orig[j].x;
+            los[j].y = scaling_grid_y[i] * _pre_process_data.los_orig[j].y;
+        } 
+        auto updated_vertices = convert_los_to_norm_vertices(regs, dsm_regs, los);
+       
+        for (auto i = 0; i < updated_vertices.size(); i++)
+        {
+            updated_pixels[i].x = updated_vertices[i].x*orig_k.fx + updated_vertices[i].z*orig_k.ppx;
+            updated_pixels[i].y = updated_vertices[i].y*orig_k.fy + updated_vertices[i].z*orig_k.ppy;
+            updated_pixels[i].z = updated_vertices[i].z;
+        }
+
+        std::vector<double2> v1(updated_pixels.size());
+        std::vector<double2> v2(updated_pixels.size());
+        std::vector<double> p1(updated_pixels.size());
+        std::vector<double> p2(updated_pixels.size());
+
+        for (auto i = 0; i < v1.size(); i++)
+        {
+            v1[i].x = _pre_process_data.vertices_orig[i].x;
+            v1[i].y = 0;
+
+            v2[i].x = 0;
+            v2[i].y = _pre_process_data.vertices_orig[i].y;
+
+            p1[i] = updated_pixels[i].x - orig_k.ppx*_pre_process_data.vertices_orig[i].z;
+            p2[i] = updated_pixels[i].y - orig_k.ppy*_pre_process_data.vertices_orig[i].z;
+        }
+        v1.insert(v1.end(), v2.begin(), v2.end());
+        p1.insert(p1.end(), p2.begin(), p2.end());
+
+        double vtag_x_v[4] = { 0 };
+        double vtag_x_p[2] = { 0 };
+
+        for (auto i = 0; i < v1.size(); i++)
+        {
+            vtag_x_v[0] += v1[i].x*v1[i].x;
+            vtag_x_v[1] += v1[i].x*v1[i].y;
+            vtag_x_v[2] += v1[i].y*v1[i].x;
+            vtag_x_v[3] += v1[i].y*v1[i].y;
+
+            vtag_x_p[0] += v1[i].x*p1[i];
+            vtag_x_p[1] += v1[i].y*p1[i];
+        }
+
+        double inv[2];
+
+        direct_inv_2x2(vtag_x_v, vtag_x_p, inv);
+
+        double3x3 mat = { inv[0],0.0,orig_k.ppx ,
+                            0.0,inv[1],orig_k.ppy ,
+                            0.0,0.0,1.0 };
+
+        res[i] = mat;
+    }
+    return res;
+}
+
+std::vector<double3> k_to_DSM::convert_los_to_norm_vertices
+(
+    algo_calibration_info const & regs,
+    algo_calibration_registers const &dsm_regs,
+    std::vector<double2> los,
+    data_collect* data
+)
+{
+    std::vector<double3> fove_x_indicent_direction(los.size());
+    std::vector<double3> fove_y_indicent_direction(los.size());
+
+    auto laser_incident = laser_incident_direction({ (double)regs.FRMWlaserangleH , (double)regs.FRMWlaserangleV + 180 });
+
+    std::vector<double2> dsm(los.size());
+
+    for (auto i = 0; i < los.size(); i++)
+    {
+        dsm[i].x = (los[i].x + (double)dsm_regs.EXTLdsmXoffset)*(double)dsm_regs.EXTLdsmXscale - (double)2047;
+        dsm[i].y = (los[i].y + (double)dsm_regs.EXTLdsmYoffset)*(double)dsm_regs.EXTLdsmYscale - (double)2047;
+
+        auto dsm_x = dsm[i].x;
+        auto dsm_y = dsm[i].y;
+
+        auto dsm_x_corr_coarse = dsm_x + (dsm_x / 2047)*(double)regs.FRMWpolyVars[0] +
+            std::pow(dsm_x / 2047, 2)*(double)regs.FRMWpolyVars[1] +
+            std::pow(dsm_x / 2047, 3)*(double)regs.FRMWpolyVars[2];
+
+        auto dsm_y_corr_coarse = dsm_y + (dsm_x / 2047)*(double)regs.FRMWpitchFixFactor;
+
+        auto dsm_x_corr = dsm_x_corr_coarse + (dsm_x_corr_coarse / 2047)*(double)regs.FRMWundistAngHorz[0] +
+            std::pow(dsm_x_corr_coarse / 2047, 2)*(double)regs.FRMWundistAngHorz[1] +
+            std::pow(dsm_x_corr_coarse / 2047, 3)*(double)regs.FRMWundistAngHorz[2] +
+            std::pow(dsm_x_corr_coarse / 2047, 4)*(double)regs.FRMWundistAngHorz[3];
+
+        auto dsm_y_corr = dsm_y_corr_coarse;
+
+        auto mode = 1;
+        auto ang_x = dsm_x_corr * ((double)regs.FRMWxfov[mode] * 0.25 / 2047);
+        auto ang_y = dsm_y_corr * ((double)regs.FRMWyfov[mode] * 0.25 / 2047);
+        
+        auto mirror_normal_direction = laser_incident_direction({ ang_x ,ang_y });
+        
+        fove_x_indicent_direction[i] = laser_incident - mirror_normal_direction*(2 * (mirror_normal_direction*laser_incident));
+    }
+
+    if (data)
+        data->k2dsm_data_p.dsm = dsm;
+
+    for (auto i = 0; i < fove_x_indicent_direction.size(); i++)
+    {
+        fove_x_indicent_direction[i].x /= sqrt(fove_x_indicent_direction[i].get_norm());
+        fove_x_indicent_direction[i].y /= sqrt(fove_x_indicent_direction[i].get_norm());
+        fove_x_indicent_direction[i].z /= sqrt(fove_x_indicent_direction[i].get_norm());
+    }
+
+    auto outbound_direction = fove_x_indicent_direction;
+    if (regs.FRMWfovexExistenceFlag)
+    {
+        std::fill(outbound_direction.begin(), outbound_direction.end(), double3{ 0,0,0 });
+        for (auto i = 0; i < fove_x_indicent_direction.size(); i++)
+        {
+            auto ang_pre_exp = rad_to_deg(std::acos(fove_x_indicent_direction[i].z));
+            auto ang_post_exp = ang_pre_exp + ang_pre_exp * (double)regs.FRMWfovexNominal[0] +
+                std::pow(ang_pre_exp, 2) * (double)regs.FRMWfovexNominal[1] +
+                std::pow(ang_pre_exp, 3) * (double)regs.FRMWfovexNominal[2] +
+                std::pow(ang_pre_exp, 4) * (double)regs.FRMWfovexNominal[3];
+
+            outbound_direction[i].z = std::cos(deg_to_rad(ang_post_exp));
+            auto xy_norm = fove_x_indicent_direction[i].x*fove_x_indicent_direction[i].x + 
+                fove_x_indicent_direction[i].y*fove_x_indicent_direction[i].y;
+
+            auto xy_factor = std::sqrt((1 - outbound_direction[i].z*outbound_direction[i].z) / xy_norm);
+            outbound_direction[i].x = fove_x_indicent_direction[i].x*xy_factor;
+            outbound_direction[i].y = fove_x_indicent_direction[i].y*xy_factor;
+        };
+
+    }
+    for (auto i = 0; i < outbound_direction.size(); i++)
+    {
+        outbound_direction[i].x /= outbound_direction[i].z;
+        outbound_direction[i].y /= outbound_direction[i].z;
+        outbound_direction[i].z /= outbound_direction[i].z;
+    }
+    return outbound_direction;
+}
+
+std::vector<double3> k_to_DSM::calc_relevant_vertices
+(
+    const std::vector<uint8_t>& relevant_pixels_image, 
+    const rs2_intrinsics_double & k
+)
+{
+    std::vector<double3> res;
+
+    double k_arr[9] = { k.fx, 0, 0,
+                        0, k.fy, 0,
+                        k.ppx , k.ppy, 1 };
+
+    double k_arr_inv[9] = { 0 };
+
+    inv(k_arr, k_arr_inv);
+
+    double k_t[9] = { 0 };
+
+    transpose(k_arr_inv, k_t);
+
+    for (auto i = 0; i < k.height; i++)
+    {
+        for (auto j = 0; j < k.width; j++)
+        {
+            if (relevant_pixels_image[i*k.width + j])
+            {
+                double3 ver;
+                double3 pix = { (double)j, (double)i, (double)1 };
+
+                ver.x = pix.x*k_t[0] + pix.y*k_t[1] + pix.z*k_t[2];
+                ver.y = pix.x*k_t[3] + pix.y*k_t[4] + pix.z*k_t[5];
+                ver.z = pix.x*k_t[6] + pix.y*k_t[7] + pix.z*k_t[8];
+
+                res.push_back(ver);
+            }
+        }
+    }
+    return res;
+}
+
+std::vector<double2> k_to_DSM::convert_norm_vertices_to_los
+(
+    algo_calibration_info const &regs,
+    algo_calibration_registers const &dsm_regs,
+    std::vector<double3> vertices,
+    convert_norm_vertices_to_los_data* data
+)
+{
+    const size_t angle = 45;
+    auto directions = transform_to_direction(vertices);
+
+    auto fovex_indicent_direction = directions;
+    if (_regs.FRMWfovexExistenceFlag)
+    {
+        std::fill(fovex_indicent_direction.begin(), fovex_indicent_direction.end(), double3{ 0,0,0 });
+        std::vector<double> ang_post_exp(fovex_indicent_direction.size(), 0);
+        for (auto i = 0; i < ang_post_exp.size(); i++)
+        {
+            ang_post_exp[i] = std::acos(directions[i].z)* (double)180. / (double)M_PI;
+        }
+
+        std::vector<double> ang_grid(angle, 0);
+        std::vector<double> ang_out_on_grid(angle, 0);
+
+        for (auto i = 0; i < angle; i++)
+        {
+            ang_grid[i] = i;
+            auto fovex_nominal = std::pow(i,1)* (double)regs.FRMWfovexNominal[0] +
+                std::pow(i, 2)* (double)regs.FRMWfovexNominal[1] +
+                std::pow(i, 3)* (double)regs.FRMWfovexNominal[2] +
+                std::pow(i, 4)* (double)regs.FRMWfovexNominal[3];
+
+            ang_out_on_grid[i] = (double)i + fovex_nominal;
+        }
+        std::vector<double> ang_pre_exp = interp1(ang_out_on_grid, ang_grid, ang_post_exp);
+        //std::vector<double> xy_norm(directions.size(), 0);
+        for (auto i = 0; i < fovex_indicent_direction.size(); i++)
+        {
+            fovex_indicent_direction[i].z = std::cos(ang_pre_exp[i] * M_PI / (double)180.);
+            auto xy_norm = directions[i].x*directions[i].x + directions[i].y*directions[i].y;
+            auto xy_factor = sqrt(((double)1 - (fovex_indicent_direction[i].z* fovex_indicent_direction[i].z)) / xy_norm);
+            fovex_indicent_direction[i].x = directions[i].x*xy_factor;
+            fovex_indicent_direction[i].y = directions[i].y*xy_factor;
+        }
+    }
+
+    auto laser_incident = laser_incident_direction({ (double)_regs.FRMWlaserangleH , (double)_regs.FRMWlaserangleV + (double)180 });
+
+    std::vector<double3> mirror_normal_direction(fovex_indicent_direction.size());
+    std::vector<double> dsm_x_corr(fovex_indicent_direction.size());
+    std::vector<double> dsm_y_corr(fovex_indicent_direction.size());
+    std::vector<double> ang_x(fovex_indicent_direction.size());
+    std::vector<double> ang_y(fovex_indicent_direction.size());
+
+    for (auto i = 0; i < fovex_indicent_direction.size(); i++)
+    {
+        mirror_normal_direction[i].x = fovex_indicent_direction[i].x - laser_incident[0];
+        mirror_normal_direction[i].y = fovex_indicent_direction[i].y - laser_incident[1];
+        mirror_normal_direction[i].z = fovex_indicent_direction[i].z - laser_incident[2];
+
+        auto norm = sqrt(mirror_normal_direction[i].x*mirror_normal_direction[i].x +
+            mirror_normal_direction[i].y* mirror_normal_direction[i].y +
+            mirror_normal_direction[i].z* mirror_normal_direction[i].z);
+
+        mirror_normal_direction[i].x /= norm;
+        mirror_normal_direction[i].y /= norm;
+        mirror_normal_direction[i].z /= norm;
+
+        ang_x[i] = std::atan(mirror_normal_direction[i].x / mirror_normal_direction[i].z)* (double)180. / (double)M_PI;
+        ang_y[i] = std::asin(mirror_normal_direction[i].y)* (double)180. / (double)M_PI;
+        
+        int mirror_mode = 1/*_regs.frmw.mirrorMovmentMode*/;
+
+        dsm_x_corr[i] = ang_x[i] / (double)(regs.FRMWxfov[mirror_mode - 1] * (double)0.25 / (double)2047);
+        dsm_y_corr[i] = ang_y[i] / (double)(regs.FRMWyfov[mirror_mode - 1] * (double)0.25 / (double)2047);
+    }
+
+    std::vector<double> dsm_grid(421);
+
+    auto ind = 0;
+    for (auto i = -2100; i <= 2100; i += 10)
+    {
+        dsm_grid[ind++] = i;
+    }
+
+    std::vector<double> dsm_x_coarse_on_grid(dsm_grid.size());
+    std::vector<double> dsm_x_corr_on_grid(dsm_grid.size());
+    for (auto i = 0; i < dsm_grid.size(); i ++)
+    {
+        double rot[3] = { std::pow((dsm_grid[i] / (double)2047), 1), std::pow((dsm_grid[i] / 2047), 2), std::pow((dsm_grid[i] / 2047), 3) };
+        dsm_x_coarse_on_grid[i] = dsm_grid[i] + rot[0] * (double)_regs.FRMWpolyVars[0] + rot[1] * (double)_regs.FRMWpolyVars[1] + rot[2] * (double)_regs.FRMWpolyVars[2];
+        auto val = dsm_x_coarse_on_grid[i] / (double)2047;
+        double vals2[4] = { std::pow(val , 1),std::pow(val , 2), std::pow(val , 3) , std::pow(val , 4) };
+        dsm_x_corr_on_grid[i] = dsm_x_coarse_on_grid[i] + vals2[0] * (double)_regs.FRMWundistAngHorz[0] +
+            vals2[1] * (double)_regs.FRMWundistAngHorz[1] +
+            vals2[2] * (double)_regs.FRMWundistAngHorz[2] +
+            vals2[3] * (double)_regs.FRMWundistAngHorz[3];
+    }
+
+    auto dsm_x = interp1(dsm_x_corr_on_grid, dsm_grid, dsm_x_corr);
+    std::vector<double> dsm_y(dsm_x.size());
+
+    for (auto i = 0; i < dsm_y.size(); i++)
+    {
+        dsm_y[i] = dsm_y_corr[i] - (dsm_x[i] / (double)2047)*(double)_regs.FRMWpitchFixFactor;
+    }
+   
+    std::vector<double2> res(dsm_x.size());
+
+    if (data)
+    {
+        data->laser_incident = laser_incident;
+        data->fovex_indicent_direction = fovex_indicent_direction;
+        data->mirror_normal_direction = mirror_normal_direction;
+        data->ang_x = ang_x;
+        data->ang_y = ang_y;
+        data->dsm_x_corr = dsm_x_corr;
+        data->dsm_y_corr = dsm_y_corr;
+        data->dsm_y = dsm_y;
+        data->dsm_x = dsm_x;
+        data->dsm_y = dsm_y;
+    }
+    for (auto i = 0; i < res.size(); i++)
+    {
+        res[i].x = (dsm_x[i] + (double)2047) / (double)dsm_regs.EXTLdsmXscale - (double)dsm_regs.EXTLdsmXoffset;
+        res[i].y = (dsm_y[i] + (double)2047) / (double)dsm_regs.EXTLdsmYscale - (double)dsm_regs.EXTLdsmYoffset;
+    }
+    return res;
+}
+
+double3 k_to_DSM::laser_incident_direction(double2 angle_rad)
+{
+    double2 angle_deg = { angle_rad.x * (double)M_PI / (double)180., (angle_rad.y)* (double)M_PI / (double)180. };
+
+    double3 laser_incident_direction = { std::cos(angle_deg.y)*std::sin(angle_deg.x),
+                                        std::sin(angle_deg.y),
+                                        std::cos(angle_deg.y)*std::cos(angle_deg.x) };
+
+    return laser_incident_direction;
+}
+
+std::vector<double3> k_to_DSM::transform_to_direction(std::vector<double3> vec)
+{
+   std::vector<double3> res(vec.size());
+
+   for (auto i = 0; i < vec.size(); i++)
+   {
+       auto norm = sqrt(vec[i].x*vec[i].x + vec[i].y*vec[i].y + vec[i].z*vec[i].z);
+       res[i] = { vec[i].x / norm, vec[i].y / norm, vec[i].z / norm };
+   }
+   return res;
+}
diff --git a/src/algo/depth-to-rgb-calibration/k-to-dsm.h b/src/algo/depth-to-rgb-calibration/k-to-dsm.h
new file mode 100644
index 0000000..ddb1c5d
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/k-to-dsm.h
@@ -0,0 +1,269 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "calibration.h"
+#include "frame-data.h"
+#include <librealsense2/h/rs_types.h>
+
+#include <types.h>  // librealsense types (intr/extr)
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+    static const int SIZE_OF_GRID_X = 25;
+    static const int SIZE_OF_GRID_Y = 6;
+
+    enum ac_to_dsm_dir
+    {
+        direct,
+        inverse
+    };
+
+
+    struct los_shift_scaling
+    {
+        double los_scaling_x;
+        double los_scaling_y;
+        double los_shift_x;
+        double los_shift_y;
+    };
+
+    struct rs2_dsm_params_double
+    {
+        rs2_dsm_correction_model model;
+        double h_scale;    /**< the scale factor to horizontal DSM scale thermal results */
+        double v_scale;    /**< the scale factor to vertical DSM scale thermal results */
+        double h_offset;   /**< the offset to horizontal DSM offset thermal results */
+        double v_offset;   /**< the offset to vertical DSM offset thermal results */
+        double rtd_offset; /**< the offset to the Round-Trip-Distance delay thermal results */
+
+        rs2_dsm_params_double() = default;
+        rs2_dsm_params_double( rs2_dsm_params const & obj )
+            : model( rs2_dsm_correction_model( obj.model ) )
+            , h_scale( obj.h_scale )
+            , v_scale( obj.v_scale )
+            , h_offset( obj.h_offset )
+            , v_offset( obj.v_offset )
+            , rtd_offset( obj.rtd_offset )
+        {
+            //todo: flags
+        }
+
+        void copy_to( rs2_dsm_params & o )
+        {
+            o.h_scale = float( h_scale );
+            o.v_scale = float( v_scale );
+            o.h_offset = float( h_offset );
+            o.v_offset = float( v_offset );
+            o.rtd_offset = float( rtd_offset );
+            o.model = model;
+        }
+    };
+
+    std::ostream & operator<<( std::ostream &, rs2_dsm_params_double const & );
+
+#pragma pack(push, 1)
+    // This table is read from FW and is used in the optimizer
+    // Best way to see this table and its formatting is in the Algo source code, under:
+    //     eepromStructure/eepromStructure.mat
+    struct algo_calibration_info
+    {
+        static const int table_id = 0x313;
+
+        uint32_t DIGGundistFx;  // x frequency of undist lut (1/distance between to neighbors in lut)
+        uint32_t DIGGundistFy;  // y frequency of undist lut (1/distance between to neighbors in lut)
+        int32_t  DIGGundistX0;  // x input added offset- luts start from 0-0 but we can have negative x/y input
+        int32_t  DIGGundistY0;  // y input added offset- luts start from 0-0 but we can have negative x/y input
+        uint8_t  DESThbaseline;  // 0:/5;1:/95
+        float    DESTbaseline;  // [-35.0:35.0]:/50;[-160.0:160.0]:/45;[100.0:1000.0]:/5
+        float    DESTtxFRQpd[3];     //!!
+        float    FRMWxfov[5];  // output projection x fov [7.0:100.0]:/50;72.0:/50
+        float    FRMWyfov[5];  // output projection y fov [7.0:90.0]:/50;56.0:/50
+        float    FRMWprojectionYshear[5];  // output projection y shearing [-0.03:0.03]
+        float    FRMWlaserangleH;  // laser-mems angle [-3.0:3.0]
+        float    FRMWlaserangleV;
+        int16_t  FRMWcalMarginL;  // image margin [-256:1280]
+        int16_t  FRMWcalMarginR;
+        int16_t  FRMWcalMarginT;
+        int16_t  FRMWcalMarginB;
+        uint8_t  FRMWxR2L;  // case the input angle arrives from high to low
+        uint8_t  FRMWyflip;  // flip the sign of the fast scan
+        float    EXTLdsmXscale;  // DSM conversion parameter [0.0:100000.0]
+        float    EXTLdsmYscale;
+        float    EXTLdsmXoffset;
+        float    EXTLdsmYoffset;
+        uint32_t EXTLconLocDelaySlow;  // RegsAnsyncAsLateLatencyFixEn
+        uint32_t EXTLconLocDelayFastC;  // RegsProjConLocDelay
+        uint32_t EXTLconLocDelayFastF;  // RegsProjConLocDelayHfclkRes
+        uint16_t FRMWcalImgHsize;  // horizontal image size in pixels
+        uint16_t FRMWcalImgVsize;  // vertical image size in pixels
+        float    FRMWpolyVars[3];  // horizontal angle stage 1 undist x^1 coefficient
+        float    FRMWpitchFixFactor;  // vertical angle stage 1 undist x^1 coefficient
+        uint32_t FRMWzoRawCol[5];  // Cal resolution zero order raw -x location
+        uint32_t FRMWzoRawRow[5];  // Cal resolution zero order raw -y location
+        float    FRMWdfzCalTmp;  // DFZ Calibration temperature [-1.0:90.0]
+        float    FRMWdfzVbias[3];  // DFZ Calibration vBias1 [0.0:90.0]
+        float    FRMWdfzIbias[3];  // DFZ Calibration iBias1 [0.0:90.0]
+        float    FRMWdfzApdCalTmp;  // DFZ Apd Calibration temperature [-1.0:90.0]
+        float    FRMWatlMinVbias1;  // Algo Thermal Loop Calibration min vBias1 [0.0:90.0]
+        float    FRMWatlMaxVbias1;  // Algo Thermal Loop Calibration max vBias1 [0.0:90.0]
+        float    FRMWatlMinVbias2;  // Algo Thermal Loop Calibration min vBias2 [0.0:90.0]
+        float    FRMWatlMaxVbias2;  // Algo Thermal Loop Calibration max vBias2 [0.0:90.0]
+        float    FRMWatlMinVbias3;  // Algo Thermal Loop Calibration min vBias3 [0.0:90.0]
+        float    FRMWatlMaxVbias3;  // Algo Thermal Loop Calibration max vBias3 [0.0:90.0]
+        float    FRMWundistAngHorz[4];  // horz angle stage 2 undist: x^# coefficient
+        float    FRMWundistAngVert[4];  // vert angle stage 2 undist: y^# coefficient
+        uint8_t  FRMWfovexExistenceFlag;  // fovex existence flag (0 = no FOVex)
+        float    FRMWfovexNominal[4];  // fovex nominal opening model: r^# coefficient
+        uint8_t  FRMWfovexLensDistFlag;  // fovex lens distortion flag (1 = apply lens distortion model)
+        float    FRMWfovexRadialK[3];  // fovex radial distortion: r^# coefficient 
+        float    FRMWfovexTangentP[2];  // fovex tangential distortion: r^2+2x^2 coefficient
+        float    FRMWfovexCenter[2];  // fovex distortion center (horz & vert)
+        uint32_t FRMWcalibVersion;
+        uint32_t FRMWconfigVersion;
+        uint32_t FRMWeepromVersion;  // EEPROM structure version
+        float    FRMWconLocDelaySlowSlope;  // slope of Z-IR delay correction vs. LDD temperature [nsec/deg]
+        float    FRMWconLocDelayFastSlope;  // slope of Z delay correction vs. LDD temperature [nsec/deg]
+        int16_t  FRMWatlMinAngXL;  // min DSM X angle on the lower side
+        int16_t  FRMWatlMinAngXR;  // min DSM X angle on the higher side
+        int16_t  FRMWatlMaxAngXL;  // max DSM X angle on the lower side
+        int16_t  FRMWatlMaxAngXR;  // max DSM X angle on the higher side
+        int16_t  FRMWatlMinAngYU;  // min DSM Y angle on the lower side
+        int16_t  FRMWatlMinAngYB;  // min DSM Y angle on the higher side
+        int16_t  FRMWatlMaxAngYU;  // max DSM Y angle on the lower side
+        int16_t  FRMWatlMaxAngYB;  // max DSM Y angle on the higher side
+        float    FRMWatlSlopeMA;  // Thermal rtd fix slope - deltaRtd = ma*slope + offset
+        float    FRMWatlMaCalTmp;  // Final ATC MA Calibration temperature
+        uint8_t  FRMWvddVoltValues[3];  // sampled vdd voltage as measured during ACC calibration (2 uint12 values, or 24 bits total)
+        int16_t  FRMWvdd2RtdDiff;  // Range difference between 2nd vdd voltage and the 1st vdd voltage
+        int16_t  FRMWvdd3RtdDiff;
+        int16_t  FRMWvdd4RtdDiff;
+        float    FRMWdfzCalibrationLddTemp;  // ldd temperature during DFZ calibration at the ACC
+        float    FRMWdfzCalibrationVddVal;  // vdd value as measured during DFZ calibration at the ACC
+        float    FRMWhumidApdTempDiff;  // difference between SHTW2 and TSense readings at first TSense temperature above 20deg
+        float    FRMWlosAtMirrorRestHorz;  // horizontal LOS report at mirror rest during DSM calibration
+        float    FRMWlosAtMirrorRestVert;  // vertical LOS report at mirror rest during DSM calibration
+        uint8_t  reserved[90];
+    };
+
+    struct algo_calibration_registers
+    {
+        double EXTLdsmXscale;
+        double EXTLdsmYscale;
+        double EXTLdsmXoffset;
+        double EXTLdsmYoffset;
+    };
+#pragma pack(pop)
+
+    struct pre_process_data
+    {
+        rs2_intrinsics_double orig_k;
+        los_shift_scaling last_los_error;
+        std::vector<double3> vertices_orig;
+        std::vector<uint8_t> relevant_pixels_image_rot;
+        std::vector<double2> los_orig;
+
+    };
+    struct data_collect;
+    struct convert_norm_vertices_to_los_data;
+
+    class k_to_DSM
+    {
+    public:
+        k_to_DSM(const rs2_dsm_params_double& orig_dsm_params,
+            algo_calibration_info const & cal_info,
+            algo_calibration_registers const & cal_regs,
+            const double& max_scaling_step);
+
+        algo_calibration_registers apply_ac_res_on_dsm_model(const rs2_dsm_params_double& ac_data,
+            const algo_calibration_registers& regs, 
+            const ac_to_dsm_dir& type);
+
+        los_shift_scaling convert_ac_data_to_los_error(const algo_calibration_registers& algo_calibration_registers, 
+            const rs2_dsm_params_double& ac_data);
+
+        pre_process_data pre_processing(const algo_calibration_info& regs,
+            const rs2_dsm_params_double& ac_data,
+            const algo_calibration_registers& algo_calibration_registers,
+            const rs2_intrinsics_double& k_raw,
+            const std::vector<uint8_t>& relevant_pixels_image,
+            data_collect* data = nullptr);
+
+        //return rs2_dsm_params and new vertices
+        rs2_dsm_params_double convert_new_k_to_DSM(
+            const rs2_intrinsics_double& old_k,
+            const rs2_intrinsics_double& new_k,
+            const z_frame_data& z,
+            std::vector<double3>& new_vertices,
+            rs2_dsm_params_double const & previous_dsm_params,
+            algo_calibration_registers& new_dsm_regs,
+            data_collect* data = nullptr);
+
+        const pre_process_data& get_pre_process_data() const;
+
+        algo_calibration_info const & get_calibration_info() const { return _regs; }
+        algo_calibration_registers const & get_calibration_registers() const { return _dsm_regs; }
+
+    private:
+        double2 convert_k_to_los_error(
+            algo::depth_to_rgb_calibration::algo_calibration_info const & regs,
+            algo_calibration_registers const &dsm_regs,
+            rs2_intrinsics_double const & k_raw,
+            data_collect* data = nullptr);
+
+        rs2_dsm_params_double convert_los_error_to_ac_data(
+            const rs2_dsm_params_double& ac_data,
+            const algo_calibration_registers& dsm_regs,
+            double2 los_shift, double2 los_scaling);
+
+        double2 run_scaling_optimization_step(
+            algo::depth_to_rgb_calibration::algo_calibration_info const & regs,
+            algo_calibration_registers const &dsm_regs,
+            double scaling_grid_x[SIZE_OF_GRID_X],
+            double scaling_grid_y[SIZE_OF_GRID_X],
+            double2 focal_scaling,
+            data_collect* data = nullptr);
+
+        std::vector<double3x3> optimize_k_under_los_error(
+            algo::depth_to_rgb_calibration::algo_calibration_info const & regs,
+            algo_calibration_registers const &dsm_regs, 
+            double scaling_grid_x[25],
+            double scaling_grid_y[25] );
+
+        std::vector<double3> convert_los_to_norm_vertices(
+            algo::depth_to_rgb_calibration::algo_calibration_info const & regs,
+            algo_calibration_registers const &dsm_regs,
+            std::vector<double2> los,
+            data_collect* data = nullptr);
+
+        std::vector<double3> calc_relevant_vertices(const std::vector<uint8_t>& relevant_pixels_image, 
+            const rs2_intrinsics_double& k);
+
+        std::vector<double2> convert_norm_vertices_to_los(const algo_calibration_info& regs, 
+            const algo_calibration_registers& algo_calibration_registers, 
+            std::vector<double3> vertices, 
+            convert_norm_vertices_to_los_data* data = nullptr);
+
+        double3 laser_incident_direction(double2 angle_rad);
+        std::vector<double3> transform_to_direction(std::vector<double3>);
+        
+        pre_process_data _pre_process_data;
+
+        //input camera params
+        algo::depth_to_rgb_calibration::algo_calibration_info _regs;
+        algo::depth_to_rgb_calibration::algo_calibration_registers _dsm_regs;
+
+        //algorithem params
+        double _max_scaling_step;
+    };
+   
+
+
+}
+}
+}
+
+
diff --git a/src/algo/depth-to-rgb-calibration/optimizer.cpp b/src/algo/depth-to-rgb-calibration/optimizer.cpp
new file mode 100644
index 0000000..e1449d3
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/optimizer.cpp
@@ -0,0 +1,1731 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "optimizer.h"
+#include <librealsense2/rsutil.h>
+#include <algorithm>
+#include <array>
+#include "coeffs.h"
+#include "cost.h"
+#include "uvmap.h"
+#include "k-to-dsm.h"
+#include "debug.h"
+#include "utils.h"
+
+using namespace librealsense::algo::depth_to_rgb_calibration;
+
+
+namespace
+{
+    std::vector<double> calc_intensity( std::vector<double> const & image1, std::vector<double> const & image2 )
+    {
+        std::vector<double> res( image1.size(), 0 );
+
+        for( auto i = 0; i < image1.size(); i++ )
+        {
+            res[i] = sqrt( pow( image1[i], 2 ) + pow( image2[i], 2 ) );
+        }
+        return res;
+    }
+
+    template<class T>
+    double dot_product( std::vector<T> const & sub_image, std::vector<double> const & mask )
+    {
+        double res = 0;
+
+        for( auto i = 0; i < sub_image.size(); i++ )
+        {
+            res += sub_image[i] * mask[i];
+        }
+
+        return res;
+    }
+
+    template<class T>
+    std::vector<double> convolution(std::vector<T> const& image,
+        size_t image_width, size_t image_height,
+        size_t mask_width, size_t mask_height,
+        std::function< double(std::vector<T> const& sub_image) > convolution_operation
+        )
+    {
+        std::vector<double> res(image.size(), 0);
+
+        for (auto i = 0; i < image_height - mask_height + 1; i++)
+        {
+            for (size_t j = 0; j < image_width - mask_width + 1; j++)
+            {
+                std::vector<T> sub_image(mask_width * mask_height, 0);
+                auto ind = 0;
+                for (size_t l = 0; l < mask_height; l++)
+                {
+                    for (size_t k = 0; k < mask_width; k++)
+                    {
+                        size_t p = (i + l) * image_width + j + k;
+                        sub_image[ind++] = (image[p]);
+                    }
+
+                }
+                auto mid = (i + mask_height / 2) * image_width + j + mask_width / 2;
+
+                res[mid] = convolution_operation(sub_image);
+
+            }
+        }
+        return res;
+    }
+   
+    template<class T>
+    std::vector<double> calc_horizontal_gradient( std::vector<T> const & image, size_t image_width, size_t image_height )
+    {
+        std::vector<double> horizontal_gradients = { -1, -2, -1,
+                                                      0,  0,  0,
+                                                      1,  2,  1 };
+
+        return convolution<T>( image, image_width, image_height, 3, 3, [&]( std::vector<T> const & sub_image )
+            {return dot_product( sub_image, horizontal_gradients ) / (double)8; } );
+    }
+
+    template<class T>
+    std::vector<double> calc_vertical_gradient( std::vector<T> const & image, size_t image_width, size_t image_height )
+    {
+        std::vector<double> vertical_gradients = { -1, 0, 1,
+                                                   -2, 0, 2,
+                                                   -1, 0, 1 };
+
+        return convolution<T>( image, image_width, image_height, 3, 3, [&]( std::vector<T> const & sub_image )
+            {return dot_product( sub_image, vertical_gradients ) / (double)8; } );;
+    }
+
+    template<class T>
+    std::vector<double> calc_edges( std::vector<T> const & image, size_t image_width, size_t image_height )
+    {
+        auto vertical_edge = calc_vertical_gradient( image, image_width, image_height );
+
+        auto horizontal_edge = calc_horizontal_gradient( image, image_width, image_height );
+
+        auto edges = calc_intensity( vertical_edge, horizontal_edge );
+
+        return edges;
+    }
+
+    std::pair<int, int> const dir_map[direction::deg_none] =
+    {
+        { 1, 0},  // dir_0
+        { 1, 1},  // dir_45
+        { 0, 1},  // deg_90
+        {-1, 1}   // deg_135
+    };
+
+}
+
+
+optimizer::optimizer()
+{
+}
+
+static std::vector< double > get_direction_deg(
+    std::vector<double> const & gradient_x,
+    std::vector<double> const & gradient_y
+)
+{
+    std::vector<double> res( gradient_x.size(), deg_none );
+
+    for( auto i = 0; i < gradient_x.size(); i++ )
+    {
+        int closest = -1;
+        auto angle = atan2( gradient_y[i], gradient_x[i] )* 180.f / M_PI;
+        angle = angle < 0 ? 180 + angle : angle;
+        auto dir = fmod( angle, 180 );
+
+
+        res[i] = dir;
+    }
+    return res;
+}
+static std::vector< double > get_direction_deg2(
+    std::vector<double> const& gradient_x,
+    std::vector<double> const& gradient_y
+    )
+{
+    std::vector<double> res(gradient_x.size(), deg_none);
+
+    for (auto i = 0; i < gradient_x.size(); i++)
+    {
+        int closest = -1;
+        auto angle = atan2(gradient_y[i], gradient_x[i])*180.f  / M_PI;
+        angle = angle < 0 ?  360+angle : angle;
+        auto dir = fmod(angle, 360);
+
+
+        res[i] = dir;
+    }
+    return res;
+}
+static
+std::pair< int, int > get_prev_index(
+    direction dir,
+    int i, int j,
+    size_t width, size_t height )
+{
+    int edge_minus_idx = 0;
+    int edge_minus_idy = 0;
+
+    auto & d = dir_map[dir];
+    if( j < d.first )
+        edge_minus_idx = int(width) - 1 - j;
+    else if( j - d.first >= width )
+        edge_minus_idx = 0;
+    else
+        edge_minus_idx = j - d.first;
+
+    if( i - d.second < 0 )
+        edge_minus_idy = int(height) - 1 - i;
+    else if( i - d.second >= height )
+        edge_minus_idy = 0;
+    else
+        edge_minus_idy = i - d.second;
+
+    return { edge_minus_idx, edge_minus_idy };
+}
+
+static
+std::pair< int, int > get_next_index(
+    direction dir,
+    int i, int j,
+    size_t width, size_t height
+)
+{
+    auto & d = dir_map[dir];
+
+    int edge_plus_idx = 0;
+    int edge_plus_idy = 0;
+
+    if( j + d.first < 0 )
+        edge_plus_idx = int(width) - 1 - j;
+    else if( j + d.first >= width )
+        edge_plus_idx = 0;
+    else
+        edge_plus_idx = j + d.first;
+
+    if( i + d.second < 0 )
+        edge_plus_idy = int(height) - 1 - i;
+    else if( i + d.second >= height )
+        edge_plus_idy = 0;
+    else
+        edge_plus_idy = i + d.second;
+
+    return { edge_plus_idx, edge_plus_idy };
+}
+
+void set_margin(
+    std::vector<double>& gradient,
+    double margin,
+    size_t width,
+    size_t height)
+{
+    auto it = gradient.begin();
+    for (auto i = 0; i < width; i++)
+    {
+        // zero mask of 2nd row, and row before the last
+        *(it + width + i) = 0;
+        *(it + width*(height-2) + i) = 0;
+    }
+    for (auto i = 0; i < height; i++)
+    {
+        // zero mask of 2nd column, and column before the last
+        *(it + i*width+1) = 0;
+        *(it + i * width + (width-2)) = 0;
+    }
+}
+
+template < class T >
+void sample_by_mask( std::vector< T > & filtered,
+                     std::vector< T > const & origin,
+                     std::vector< byte > const & valid_edge_by_ir,
+                     size_t const width,
+                     size_t const height )
+{
+    //%function [values] = sampleByMask(I,binMask)
+    //%    % Extract values from image I using the binMask with the order being
+    //%    % row and then column
+    //%    I = I';
+    //%    values = I(binMask');
+    //end
+    for( auto x = 0; x < origin.size(); ++x )
+        if( valid_edge_by_ir[x] )
+            filtered.push_back( origin[x] );
+}
+
+template < class T >
+void depth_filter( std::vector< T > & filtered,
+                   std::vector< T > const & origin,
+                   std::vector< byte > const & valid_edge_by_ir,
+                   size_t const width,
+                   size_t const height )
+{
+    // origin and valid_edge_by_ir are of same size
+    for( auto j = 0; j < width; j++ )
+    {
+        for( auto i = 0; i < height; i++ )
+        {
+            auto idx = i * width + j;
+            if( valid_edge_by_ir[idx] )
+            {
+                filtered.push_back( origin[idx] );
+            }
+        }
+    }
+}
+
+void grid_xy(
+    std::vector<double>& gridx,
+    std::vector<double>& gridy,
+    size_t width,
+    size_t height)
+{
+    for (auto i = 1; i <= height; i++)
+    {
+        for (auto j = 1; j <= width; j++)
+        {
+            gridx.push_back(j);
+            gridy.push_back(i);
+        }
+    }
+}
+template<class T>
+std::vector< double > interpolation( std::vector< T > const & grid_points,
+                                     std::vector< double > const x[], std::vector< double > const y[],
+                                     size_t dim, size_t valid_size, size_t valid_width )
+{
+    // interpolation 
+
+    std::vector<double> local_interp;
+    auto iedge_it = grid_points.begin();// iEdge   
+    std::vector<double>::const_iterator loc_reg_x[4];
+    std::vector<double>::const_iterator loc_reg_y[4];
+    for( auto i = 0; i < dim; i++ )
+    {
+        loc_reg_x[i] = x[i].begin();
+        loc_reg_y[i] = y[i].begin();
+    }
+    for (auto i = 0; i < valid_size; i++)
+    {
+        for (auto k = 0; k < dim; k++)
+        {
+            auto idx = *(loc_reg_x[k] + i) - 1;
+            auto idy = *(loc_reg_y[k] + i) - 1;
+            //assert(_ir.width * idy + idx <= _ir.width * _ir.height);
+            auto val = *( iedge_it + size_t( valid_width * idy + idx ) );  // find value in iEdge
+            local_interp.push_back(val);
+        }
+    }
+    return local_interp;
+}
+std::vector<uint8_t> is_suppressed(std::vector<double> const & local_edges, size_t valid_size)
+{
+    std::vector<uint8_t> is_supressed;
+    auto loc_edg_it = local_edges.begin();
+    for (auto i = 0; i < valid_size; i++)
+    {
+        //isSupressed = localEdges(:,3) >= localEdges(:,2) & localEdges(:,3) >= localEdges(:,4);
+        auto vec2 = *(loc_edg_it + 1);
+        auto vec3 = *(loc_edg_it + 2);
+        auto vec4 = *(loc_edg_it + 3);
+        loc_edg_it += 4;
+        bool res = (vec3 >= vec2) && (vec3 >= vec4);
+        is_supressed.push_back(res);
+    }
+    return is_supressed;
+}
+
+std::vector<double> depth_mean(std::vector<double>& local_x, std::vector<double>& local_y)
+{
+    std::vector<double> res;
+    size_t size = local_x.size() / 2;
+    auto itx = local_x.begin();
+    auto ity = local_y.begin();
+    for (auto i = 0; i < size; i++, ity += 2, itx += 2)
+    {
+        double valy = (*ity + *(ity + 1)) / 2;
+        double valx = (*itx + *(itx + 1)) / 2;
+        res.push_back(valy);
+        res.push_back(valx);
+    }
+
+    return res;
+}
+std::vector<double> sum_gradient_depth(std::vector<double> &gradient, std::vector<double> &direction_per_pixel)
+{
+    std::vector<double> res;
+    size_t size = direction_per_pixel.size() / 2;
+    auto it_dir = direction_per_pixel.begin();
+    auto it_grad = gradient.begin();
+    for (auto i = 0; i < size; i++, it_dir+=2, it_grad+=2)
+    {
+        // normalize : res = val/sqrt(row_sum)
+        auto rorm_dir1 = *it_dir / sqrt(abs(*it_dir) + abs(*(it_dir + 1)));
+        auto rorm_dir2 = *(it_dir+1) / sqrt(abs(*it_dir) + abs(*(it_dir + 1)));
+        auto val = abs(*it_grad * rorm_dir1 + *(it_grad + 1) * rorm_dir2);
+        res.push_back(val);
+    }
+    return res;
+}
+
+std::vector< byte > find_valid_depth_edges( std::vector< double > const & grad_in_direction,
+                                            std::vector< byte > const & is_supressed,
+                                            std::vector< double > const & values_for_subedges,
+                                            int const gradZTh )
+{
+    std::vector< byte > res;
+    res.reserve( grad_in_direction.size() );
+    //%validEdgePixels = zGradInDirection > params.gradZTh & isSupressed & zValuesForSubEdges > 0;
+    for (int i = 0; i < grad_in_direction.size(); i++)
+    {
+        bool cond1 = grad_in_direction[i] > gradZTh;
+        bool cond2 = is_supressed[i];
+        bool cond3 = values_for_subedges[i] > 0;
+        res.push_back( cond1 && cond2 && cond3 );
+    }
+    return res;
+}
+
+std::vector<double> find_local_values_min(std::vector<double>& local_values)
+{
+    std::vector<double> res;
+    size_t size = local_values.size() / 4;
+    auto it = local_values.begin();
+    for (auto i = 0; i < size; i++)
+    {
+        auto val1 = *it;
+        auto val2 = *(it + 1);
+        auto val3 = *(it + 2);
+        auto val4 = *(it + 3);
+        it += 4;
+        double res_val = std::min(val1, std::min(val2, std::min(val3, val4)));
+        res.push_back(res_val);
+    }
+    return res;
+}
+void optimizer::set_z_data( std::vector< z_t > && depth_data,
+                            rs2_intrinsics_double const & depth_intrinsics,
+                            rs2_dsm_params const & dsm_params,
+                            algo_calibration_info const & cal_info,
+                            algo_calibration_registers const & cal_regs, float depth_units )
+{
+    _original_dsm_params = dsm_params;
+    _k_to_DSM = std::make_shared<k_to_DSM>(dsm_params, cal_info, cal_regs, _params.max_scaling_step);
+
+    /*[zEdge,Zx,Zy] = OnlineCalibration.aux.edgeSobelXY(uint16(frame.z),2); % Added the second input - margin to zero out
+    [iEdge,Ix,Iy] = OnlineCalibration.aux.edgeSobelXY(uint16(frame.i),2); % Added the second input - margin to zero out
+    validEdgePixelsByIR = iEdge>params.gradITh; */
+    _params.set_depth_resolution(depth_intrinsics.width, depth_intrinsics.height);
+    _z.width = depth_intrinsics.width;
+    _z.height = depth_intrinsics.height;
+    _z.orig_intrinsics = depth_intrinsics;
+    _z.orig_dsm_params = dsm_params;
+    _z.depth_units = depth_units;
+
+    _z.frame = std::move(depth_data);
+
+    _z.gradient_x = calc_vertical_gradient(_z.frame, depth_intrinsics.width, depth_intrinsics.height);
+    _z.gradient_y = calc_horizontal_gradient(_z.frame, depth_intrinsics.width, depth_intrinsics.height);
+    _ir.gradient_x = calc_vertical_gradient(_ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height);
+    _ir.gradient_y = calc_horizontal_gradient(_ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height);
+
+    // set margin of 2 pixels to 0
+    set_margin(_z.gradient_x, 2, _z.width, _z.height);
+    set_margin(_z.gradient_y, 2, _z.width, _z.height);
+    set_margin(_ir.gradient_x, 2, _z.width, _z.height);
+    set_margin(_ir.gradient_y, 2, _z.width, _z.height);
+
+    _z.edges = calc_intensity(_z.gradient_x, _z.gradient_y);
+    _ir.edges = calc_intensity(_ir.gradient_x, _ir.gradient_y);
+
+    for( auto it = _ir.edges.begin(); it < _ir.edges.end(); it++ )
+        _ir.valid_edge_pixels_by_ir.push_back( *it > _params.grad_ir_threshold );
+
+    /*sz = size(frame.i);
+    [gridX,gridY] = meshgrid(1:sz(2),1:sz(1)); % gridX/Y contains the indices of the pixels
+    sectionMapDepth = OnlineCalibration.aux.sectionPerPixel(params);
+    */
+    // Get a map for each pixel to its corresponding section
+    _z.section_map_depth.resize(_z.width * _z.height);
+    size_t const section_w = _params.num_of_sections_for_edge_distribution_x;  //% params.numSectionsH
+    size_t const section_h = _params.num_of_sections_for_edge_distribution_y;  //% params.numSectionsH
+    section_per_pixel(_z, section_w, section_h, _z.section_map_depth.data());
+
+    //%locRC = [sampleByMask( gridY, validEdgePixelsByIR ), sampleByMask( gridX, validEdgePixelsByIR )];
+    //%sectionMapValid = sampleByMask( sectionMapDepth, validEdgePixelsByIR );
+    //%IxValid = sampleByMask( Ix, validEdgePixelsByIR );
+    //%IyValid = sampleByMask( Iy, validEdgePixelsByIR );
+
+    std::vector<double> grid_x;
+    std::vector<double> grid_y;
+    grid_xy(grid_x, grid_y, _z.width, _z.height);
+
+    sample_by_mask( _ir.valid_location_rc_x, grid_x, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( _ir.valid_location_rc_y, grid_y, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( _ir.valid_section_map, _z.section_map_depth, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( _ir.valid_gradient_x, _ir.gradient_x, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( _ir.valid_gradient_y, _ir.gradient_y, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+
+    auto itx = _ir.valid_location_rc_x.begin();
+    auto ity = _ir.valid_location_rc_y.begin();
+    for (auto i = 0; i < _ir.valid_location_rc_x.size(); i++)
+    {
+        auto x = *(itx + i);
+        auto y = *(ity + i);
+        _ir.valid_location_rc.push_back(y);
+        _ir.valid_location_rc.push_back(x);
+    }
+
+    /*
+    directionInDeg = atan2d(IyValid,IxValid);
+    directionInDeg(directionInDeg<0) = directionInDeg(directionInDeg<0) + 360;
+    [~,directionIndex] = min(abs(directionInDeg - [0:45:315]),[],2); % Quantize the direction to 4 directions (don't care about the sign)
+    */
+
+    _ir.direction_deg = get_direction_deg2(_ir.valid_gradient_x, _ir.valid_gradient_y); // used for debug only
+    _ir.directions = get_direction2(_ir.valid_gradient_x, _ir.valid_gradient_y);
+
+    /*dirsVec = [0,1; 1,1; 1,0; 1,-1]; % These are the 4 directions
+    dirsVec = [dirsVec;-dirsVec];
+    if 1
+        % Take the right direction
+        dirPerPixel = dirsVec(directionIndex,:);
+        localRegion = locRC + dirPerPixel.*reshape(vec(-2:1),1,1,[]);
+        localEdges = squeeze(interp2(iEdge,localRegion(:,2,:),localRegion(:,1,:)));
+        isSupressed = localEdges(:,3) >= localEdges(:,2) & localEdges(:,3) >= localEdges(:,4);
+
+        fraqStep = (-0.5*(localEdges(:,4)-localEdges(:,2))./(localEdges(:,4)+localEdges(:,2)-2*localEdges(:,3))); % The step we need to move to reach the subpixel gradient i nthe gradient direction
+        fraqStep((localEdges(:,4)+localEdges(:,2)-2*localEdges(:,3))==0) = 0;
+
+        locRCsub = locRC + fraqStep.*dirPerPixel;*/
+    double directions[8][2] = { {0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1} };
+    std::vector<double> direction_per_pixel_x; //used later when finding valid direction per pixel
+    for (auto i = 0; i < _ir.directions.size(); i++)
+    {
+        int idx = _ir.directions[i];
+        _ir.direction_per_pixel.push_back(directions[idx][0]);
+        _ir.direction_per_pixel.push_back(directions[idx][1]);
+        direction_per_pixel_x.push_back(directions[idx][0]);
+    }
+    double vec[4] = { -2,-1,0,1 }; // one pixel along gradient direction, 2 pixels against gradient direction
+
+    auto loc_it = _ir.valid_location_rc.begin();
+    auto dir_pp_it = _ir.direction_per_pixel.begin();
+
+    for (auto k = 0; k < 4; k++)
+    {
+        for (auto i = 0; i < _ir.direction_per_pixel.size(); i++)
+        {
+            double val = *(loc_it + i) + *(dir_pp_it + i) * vec[k];
+            _ir.local_region[k].push_back(val);
+        }
+    }
+    for (auto k = 0; k < 4; k++)
+    {
+        for (auto i = 0; i < 2 * _ir.valid_location_rc_x.size(); i++)
+        {
+            _ir.local_region_y[k].push_back(*(_ir.local_region[k].begin() + i));
+            i++;
+            _ir.local_region_x[k].push_back(*(_ir.local_region[k].begin() + i));
+        }
+    }
+    // interpolation 
+    _ir.local_edges = interpolation(_ir.edges, _ir.local_region_x, _ir.local_region_y, 4, _ir.valid_location_rc_x.size(), _ir.width);
+
+    // is suppressed
+    _ir.is_supressed = is_suppressed(_ir.local_edges, _ir.valid_location_rc_x.size());
+
+
+    /*fraqStep = (-0.5*(localEdges(:,4)-localEdges(:,2))./(localEdges(:,4)+localEdges(:,2)-2*localEdges(:,3))); % The step we need to move to reach the subpixel gradient i nthe gradient direction
+       fraqStep((localEdges(:,4)+localEdges(:,2)-2*localEdges(:,3))==0) = 0;
+
+       locRCsub = locRC + fraqStep.*dirPerPixel;
+
+       % Calculate the Z gradient for thresholding
+       localZx = squeeze(interp2(Zx,localRegion(:,2,2:3),localRegion(:,1,2:3)));
+       localZy = squeeze(interp2(Zy,localRegion(:,2,2:3),localRegion(:,1,2:3)));
+       zGrad = [mean(localZy,2) ,mean(localZx,2)];
+       zGradInDirection = abs(sum(zGrad.*normr(dirPerPixel),2));
+       % Take the z value of the closest part of the edge
+       localZvalues = squeeze(interp2(frame.z,localRegion(:,2,:),localRegion(:,1,:)));
+
+       zValuesForSubEdges = min(localZvalues,[],2);
+       edgeSubPixel = fliplr(locRCsub);% From Row-Col to XY*/
+
+    std::vector< double > ::iterator loc_edg_it = _ir.local_edges.begin();
+    //std::vector<double > ::iterator loc_rc_sub_it = _depth.local_rc_subpixel.begin(); // locRCsub
+    auto valid_loc_rc = _ir.valid_location_rc.begin(); // locRC
+    auto dir_per_pixel_it = _ir.direction_per_pixel.begin(); // dirPerPixel
+
+    std::vector< double > edge_sub_pixel_x;
+    std::vector< double > edge_sub_pixel_y;
+
+    for (auto i = 0; i < _ir.valid_location_rc_x.size(); i++)
+    {
+        double vec2 = *(loc_edg_it + 1);
+        double vec3 = *(loc_edg_it + 2);
+        double vec4 = *(loc_edg_it + 3);
+        loc_edg_it += 4;
+
+        // The step we need to move to reach the subpixel gradient in the gradient direction
+        //%fraqStep = (-0.5*(localEdges(:,4) - localEdges(:,2)). / (localEdges(:,4) + localEdges(:,2) - 2 * localEdges(:,3)));
+        //%fraqStep( (localEdges(:,4) + localEdges(:,2) - 2 * localEdges(:,3)) == 0 ) = 0;
+        double const denom = vec4 + vec2 - 2 * vec3;
+        double const res = ( denom == 0 ) ? 0 : ( -0.5 * ( vec4 - vec2 ) / denom );
+        _ir.fraq_step.push_back( res );
+
+        auto valx = *valid_loc_rc + *dir_per_pixel_it * res;
+        valid_loc_rc++;
+        dir_per_pixel_it++;
+        auto valy = *valid_loc_rc + *dir_per_pixel_it * res;
+        valid_loc_rc++;
+        dir_per_pixel_it++;
+        _z.local_rc_subpixel.push_back(valx);
+        _z.local_rc_subpixel.push_back(valy);
+
+        _z.edge_sub_pixel.push_back(valy);
+        _z.edge_sub_pixel.push_back(valx);
+        edge_sub_pixel_x.push_back(valy);
+        edge_sub_pixel_y.push_back(valx);
+    }
+
+    std::vector<double> local_region_x[2] = { _ir.local_region_x[1] ,_ir.local_region_x[2] };
+    std::vector<double> local_region_y[2] = { _ir.local_region_y[1] ,_ir.local_region_y[2] };
+    _z.local_x = interpolation(_z.gradient_x, local_region_x, local_region_y, 2, _ir.valid_location_rc_x.size(), _z.width);
+    _z.local_y = interpolation(_z.gradient_y, local_region_x, local_region_y, 2, _ir.valid_location_rc_x.size(), _z.width);
+    _z.gradient = depth_mean(_z.local_x, _z.local_y);
+    _z.grad_in_direction = sum_gradient_depth(_z.gradient, _ir.direction_per_pixel);
+    _z.local_values = interpolation(_z.frame, _ir.local_region_x, _ir.local_region_y, 4, _ir.valid_location_rc_x.size(), _z.width);
+    _z.values_for_subedges = find_local_values_min(_z.local_values);
+
+    //_params.alpha;
+    /* validEdgePixels = zGradInDirection > params.gradZTh & isSupressed & zValuesForSubEdges > 0;
+
+   zGradInDirection = zGradInDirection(validEdgePixels);
+   edgeSubPixel = edgeSubPixel(validEdgePixels,:);
+   zValuesForSubEdges = zValuesForSubEdges(validEdgePixels);
+   dirPerPixel = dirPerPixel(validEdgePixels);
+   sectionMapDepth = sectionMapValid(validEdgePixels);
+   directionIndex = directionIndex(validEdgePixels);
+   directionIndex(directionIndex>4) = directionIndex(directionIndex>4)-4;% Like taking abosoulte value on the direction
+   */
+    _z.supressed_edges = find_valid_depth_edges( _z.grad_in_direction,
+                                                 _ir.is_supressed,
+                                                 _z.values_for_subedges,
+                                                 _params.grad_z_threshold );
+    std::vector<double> valid_values_for_subedges;
+
+
+
+    depth_filter(_z.grad_in_direction_valid, _z.grad_in_direction, _z.supressed_edges, 1, _z.supressed_edges.size());
+    depth_filter(_z.valid_edge_sub_pixel_x, edge_sub_pixel_x, _z.supressed_edges, 1, _z.supressed_edges.size()); //edgeSubPixel = edgeSubPixel(validEdgePixels,:);
+    depth_filter(_z.valid_edge_sub_pixel_y, edge_sub_pixel_y, _z.supressed_edges, 1, _z.supressed_edges.size());
+    for (auto i = 0; i < _z.valid_edge_sub_pixel_x.size(); i++)
+    {
+        _z.valid_edge_sub_pixel.push_back(*(_z.valid_edge_sub_pixel_x.begin() + i));
+        _z.valid_edge_sub_pixel.push_back(*(_z.valid_edge_sub_pixel_y.begin() + i));
+        // subPoints : subPoints = [xim,yim,ones(size(yim))];
+        _z.sub_points.push_back(*(_z.valid_edge_sub_pixel_x.begin() + i)-1);
+        _z.sub_points.push_back(*(_z.valid_edge_sub_pixel_y.begin() + i)-1);
+        _z.sub_points.push_back(1);
+    }
+    depth_filter(valid_values_for_subedges, _z.values_for_subedges, _z.supressed_edges, 1, _z.supressed_edges.size());
+    depth_filter(_z.valid_direction_per_pixel, direction_per_pixel_x, _z.supressed_edges, 1, _z.supressed_edges.size());
+    depth_filter(_z.valid_section_map, _ir.valid_section_map, _z.supressed_edges, 1, _z.supressed_edges.size());
+    std::vector<double> edited_ir_directions;
+
+    for (auto i = 0; i < _ir.directions.size(); i++)
+    {
+        auto val = double(*(_ir.directions.begin() + i));
+        val = val + 1;// +1 to align with matlab
+        val = val > 4 ? val - 4 : val;
+        edited_ir_directions.push_back(val);
+    }
+    depth_filter(_z.valid_directions, edited_ir_directions, _z.supressed_edges, 1, _z.supressed_edges.size());
+
+    _z.values_for_subedges = valid_values_for_subedges;
+
+    /* weights = min(max(zGradInDirection - params.gradZTh,0),params.gradZMax - params.gradZTh);
+    if params.constantWeights
+        weights(:) = params.constantWeightsValue;
+    end
+    xim = edgeSubPixel(:,1)-1;
+    yim = edgeSubPixel(:,2)-1;
+
+    subPoints = [xim,yim,ones(size(yim))];
+    vertices = subPoints*(pinv(params.Kdepth)').*zValuesForSubEdges/single(params.zMaxSubMM);
+
+    [uv,~,~] = OnlineCalibration.aux.projectVToRGB(vertices,params.rgbPmat,params.Krgb,params.rgbDistort);
+    isInside = OnlineCalibration.aux.isInsideImage(uv,params.rgbRes);
+   
+    xim = xim(isInside);
+    yim = yim(isInside);
+    zValuesForSubEdges = zValuesForSubEdges(isInside);
+    zGradInDirection = zGradInDirection(isInside);
+    directionIndex = directionIndex(isInside);
+    weights = weights(isInside);
+    vertices = vertices(isInside,:);
+    sectionMapDepth = sectionMapDepth(isInside);*/
+    k_matrix k = depth_intrinsics;
+    matrix_3x3 k_depth_pinv = { 0 };
+    pinv_3x3( k.as_3x3().rot, k_depth_pinv.rot );
+    transform(_z.valid_edge_sub_pixel_x.begin(), _z.valid_edge_sub_pixel_x.end(), _z.valid_edge_sub_pixel_x.begin(), bind2nd(std::plus<double>(), -1.0));
+    transform(_z.valid_edge_sub_pixel_y.begin(), _z.valid_edge_sub_pixel_y.end(), _z.valid_edge_sub_pixel_y.begin(), bind2nd(std::plus<double>(), -1.0));
+    for (auto i = 0; i < _z.sub_points.size(); i += 3)
+    {
+        //%vertices = subPoints * pinv(params.Kdepth)' .* zValuesForSubEdges / params.zMaxSubMM;
+        double sub_points_mult[3];
+        double x = _z.sub_points[i];
+        double y = _z.sub_points[i + 1];
+        double z = _z.sub_points[i + 2];
+        for (auto jj = 0; jj < 3; jj++)
+        {
+            sub_points_mult[jj] = x * k_depth_pinv.rot[3 * jj + 0]
+                                + y * k_depth_pinv.rot[3 * jj + 1]
+                                + z * k_depth_pinv.rot[3 * jj + 2];
+        }
+        auto z_value_for_subedge = _z.values_for_subedges[i / 3];
+        auto val1 = sub_points_mult[0] * z_value_for_subedge / _params.max_sub_mm_z;
+        auto val2 = sub_points_mult[1] * z_value_for_subedge / _params.max_sub_mm_z;
+        auto val3 = sub_points_mult[2] * z_value_for_subedge / _params.max_sub_mm_z;
+        _z.vertices_all.push_back( { val1, val2, val3 } );
+    }
+    _z.uvmap = get_texture_map( _z.vertices_all,
+                                _original_calibration,
+                                _original_calibration.calc_p_mat() );
+
+
+    for (auto i = 0; i < _z.uvmap.size(); i++)
+    {
+        //%isInside = xy(:,1) >= 0 & ...
+        //%           xy(:,1) <= res(2) - 1 & ...
+        //%           xy(:,2) >= 0 & ...
+        //%           xy(:,2) <= res(1) - 1;
+        bool cond_x = (_z.uvmap[i].x >= 0) && (_z.uvmap[i].x <= _yuy.width-1);
+        bool cond_y = (_z.uvmap[i].y >= 0) && (_z.uvmap[i].y <= _yuy.height-1);
+        _z.is_inside.push_back( cond_x && cond_y );
+    }
+
+    /*xim = xim(isInside);
+    yim = yim(isInside); 
+    zValuesForSubEdges = zValuesForSubEdges(isInside);
+    zGradInDirection = zGradInDirection(isInside);
+    directionIndex = directionIndex(isInside);
+    weights = weights(isInside);
+    vertices = vertices(isInside,:);
+    sectionMapDepth = sectionMapDepth(isInside);*/
+    //std::vector<double> weights;
+    for (auto i = 0; i < _z.is_inside.size(); i++) {
+
+        _z.valid_weights.push_back(_params.constant_weights);
+    }
+    depth_filter(_z.subpixels_x, _z.valid_edge_sub_pixel_x, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.subpixels_y, _z.valid_edge_sub_pixel_y, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.closest, _z.values_for_subedges, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.grad_in_direction_inside, _z.grad_in_direction_valid, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.directions, _z.valid_directions, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.vertices, _z.vertices_all, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.section_map_depth_inside, _z.valid_section_map, _z.is_inside, 1, _z.is_inside.size());
+    depth_filter(_z.weights, _z.valid_weights, _z.is_inside, 1, _z.is_inside.size());
+
+    _z.relevant_pixels_image.resize(_z.width * _z.height, 0);
+    std::vector<double> sub_pixel_x = _z.subpixels_x;
+    std::vector<double> sub_pixel_y= _z.subpixels_y;
+
+    transform(_z.subpixels_x.begin(), _z.subpixels_x.end(), sub_pixel_x.begin(), [](double x) {return round(x + 1); });
+    transform(_z.subpixels_y.begin(), _z.subpixels_y.end(), sub_pixel_y.begin(), [](double x) {return round(x + 1); });
+
+    _z.subpixels_y_round = sub_pixel_y;
+    _z.subpixels_x_round = sub_pixel_x;
+
+    for (auto i = 0; i < sub_pixel_x.size(); i++)
+    {
+        auto x = _z.subpixels_x_round[i];
+        auto y = _z.subpixels_y_round[i];
+
+        _z.relevant_pixels_image[size_t( ( y - 1 ) * _z.width + x - 1 )] = 1;
+    }
+}
+
+
+void optimizer::set_yuy_data(
+    std::vector< yuy_t > && yuy_data,
+    std::vector< yuy_t > && prev_yuy_data,
+    calib const & calibration
+)
+{
+    _original_calibration = calibration;
+    _original_calibration.model = RS2_DISTORTION_BROWN_CONRADY; //change to ac model
+    _yuy.width = calibration.width;
+    _yuy.height = calibration.height;
+    _params.set_rgb_resolution( _yuy.width, _yuy.height );
+
+    _yuy.orig_frame = std::move( yuy_data );
+    _yuy.prev_frame = std::move( prev_yuy_data );
+
+    _yuy.lum_frame = get_luminance_from_yuy2( _yuy.orig_frame );
+    _yuy.prev_lum_frame = get_luminance_from_yuy2( _yuy.prev_frame );
+
+    _yuy.edges = calc_edges( _yuy.lum_frame, _yuy.width, _yuy.height );
+    _yuy.prev_edges = calc_edges(_yuy.prev_lum_frame, _yuy.width, _yuy.height);
+
+    _yuy.edges_IDT = blur_edges( _yuy.edges, _yuy.width, _yuy.height );
+
+    _yuy.edges_IDTx = calc_vertical_gradient( _yuy.edges_IDT, _yuy.width, _yuy.height );
+
+    _yuy.edges_IDTy = calc_horizontal_gradient( _yuy.edges_IDT, _yuy.width, _yuy.height );
+}
+
+void optimizer::set_ir_data(
+    std::vector< ir_t > && ir_data,
+    size_t width,
+    size_t height
+)
+{
+    _ir.width = width;
+    _ir.height = height;
+    
+    _ir.ir_frame = std::move( ir_data );
+    _ir.edges = calc_edges( _ir.ir_frame, width, height );
+}
+
+calib optimizer::decompose_p_mat(p_matrix p)
+{
+    auto calib = decompose(p, _original_calibration);
+    return calib;
+}
+
+
+rs2_intrinsics_double optimizer::get_new_z_intrinsics_from_new_calib(const rs2_intrinsics_double& orig, const calib & new_c, const calib & orig_c)
+{
+    rs2_intrinsics_double res;
+    res = orig;
+    res.fx = res.fx / new_c.k_mat.get_fx()*orig_c.k_mat.get_fx();
+    res.fy = res.fy / new_c.k_mat.get_fy()*orig_c.k_mat.get_fy();
+
+    return res;
+}
+
+void optimizer::zero_invalid_edges( z_frame_data & z_data, ir_frame_data const & ir_data )
+{
+    for( auto i = 0; i < ir_data.edges.size(); i++ )
+    {
+        if( ir_data.edges[i] <= _params.grad_ir_threshold || z_data.edges[i] <= _params.grad_z_threshold )
+        {
+            z_data.supressed_edges[i] = 0;
+            z_data.subpixels_x[i] = 0;
+            z_data.subpixels_y[i] = 0;
+            z_data.closest[i] = 0;
+        }
+    }
+}
+
+std::vector< direction > optimizer::get_direction( std::vector<double> gradient_x, std::vector<double> gradient_y )
+{
+    std::vector<direction> res( gradient_x.size(), deg_none );
+
+    std::map<int, direction> angle_dir_map = { {0, deg_0}, {45,deg_45} , {90,deg_90}, {135,deg_135} };
+
+    for( auto i = 0; i < gradient_x.size(); i++ )
+    {
+        int closest = -1;
+        auto angle = atan2( gradient_y[i], gradient_x[i] )* 180.f / M_PI;
+        angle = angle < 0 ? 180 + angle : angle;
+        auto dir = fmod( angle, 180 );
+
+        for( auto d : angle_dir_map )
+        {
+            closest = closest == -1 || abs( dir - d.first ) < abs( dir - closest ) ? d.first : closest;
+        }
+        res[i] = angle_dir_map[closest];
+    }
+    return res;
+}
+std::vector< direction > optimizer::get_direction2(std::vector<double> gradient_x, std::vector<double> gradient_y)
+{
+    std::vector<direction> res(gradient_x.size(), deg_none);
+    
+    std::map<int, direction> angle_dir_map = { {0, deg_0}, {45,deg_45} , {90,deg_90}, {135,deg_135} , { 180,deg_180 }, { 225,deg_225 }, { 270,deg_270 }, { 315,deg_315 } };
+
+
+
+    for (auto i = 0; i < gradient_x.size(); i++)
+    {
+        int closest = -1;
+        auto angle = atan2(gradient_y[i], gradient_x[i]) * 180.f / M_PI;
+        angle = angle < 0 ? 360 + angle : angle;
+        auto dir = fmod(angle, 360);
+
+        for (auto d : angle_dir_map)
+        {
+            closest = closest == -1 || abs(dir - d.first) < abs(dir - closest) ? d.first : closest;
+        }
+        res[i] = angle_dir_map[closest];
+    }
+    return res;
+}
+//std::vector< uint16_t > optimizer::get_closest_edges(
+//    z_frame_data const & z_data,
+//    ir_frame_data const & ir_data,
+//    size_t width, size_t height )
+//{
+//    std::vector< uint16_t > z_closest;
+//    z_closest.reserve( z_data.edges.size() );
+//
+//    for( auto i = 0; i < int(height); i++ )
+//    {
+//        for( auto j = 0; j < int(width); j++ )
+//        {
+//            auto idx = i * width + j;
+//
+//            auto edge = z_data.edges[idx];
+//
+//            //if (edge == 0)  continue;
+//
+//            auto edge_prev_idx = get_prev_index( z_data.valid_directions[idx], i, j, width, height );
+//
+//            auto edge_next_idx = get_next_index( z_data.valid_directions[idx], i, j, width, height );
+//
+//            auto edge_minus_idx = edge_prev_idx.second * width + edge_prev_idx.first;
+//
+//            auto edge_plus_idx = edge_next_idx.second * width + edge_next_idx.first;
+//
+//            auto z_edge_plus = z_data.edges[edge_plus_idx];
+//            auto z_edge = z_data.edges[idx];
+//            auto z_edge_minus = z_data.edges[edge_minus_idx];
+//
+//           
+//            if (z_data.supressed_edges[idx])
+//            {
+//                z_closest.push_back(std::min(z_data.frame[edge_minus_idx], z_data.frame[edge_plus_idx]));
+//            }
+//            else
+//            {
+//                z_closest.push_back(0);
+//            }
+//        }
+//    }
+//    return z_closest;
+//}
+
+/* Given pixel coordinates and depth in an image with no distortion or inverse distortion coefficients, compute the corresponding point in 3D space relative to the same camera */
+static void deproject_pixel_to_point(double point[3], const struct rs2_intrinsics_double * intrin, const double pixel[2], double depth)
+{
+    double x = (double)(pixel[0] - intrin->ppx) / intrin->fx;
+    double y = (double)(pixel[1] - intrin->ppy) / intrin->fy;
+
+    point[0] = depth * x;
+    point[1] = depth * y;
+    point[2] = depth;
+}
+
+/* Given a point in 3D space, compute the corresponding pixel coordinates in an image with no distortion or forward distortion coefficients produced by the same camera */
+static void project_point_to_pixel(double pixel[2], const struct rs2_intrinsics_double * intrin, const double point[3])
+{
+    double x = point[0] / point[2], y = point[1] / point[2];
+
+    if( intrin->model == RS2_DISTORTION_BROWN_CONRADY )
+    {
+        double r2 = x * x + y * y;
+        double f = 1 + intrin->coeffs[0] * r2 + intrin->coeffs[1] * r2*r2 + intrin->coeffs[4] * r2*r2*r2;
+
+        double xcd = x * f;
+        double ycd = y * f;
+
+        double dx = xcd + 2 * intrin->coeffs[2] * x*y + intrin->coeffs[3] * (r2 + 2 * x*x);
+        double dy = ycd + 2 * intrin->coeffs[3] * x*y + intrin->coeffs[2] * (r2 + 2 * y*y);
+
+        x = dx;
+        y = dy;
+    }
+
+    pixel[0] = x * (double)intrin->fx + (double)intrin->ppx;
+    pixel[1] = y * (double)intrin->fy + (double)intrin->ppy;
+}
+
+std::vector<double> optimizer::blur_edges(std::vector<double> const & edges, size_t image_width, size_t image_height)
+{
+    std::vector<double> res = edges;
+
+    for( auto i = 0; i < image_height; i++ )
+        for( auto j = 0; j < image_width; j++ )
+        {
+            if( i == 0 && j == 0 )
+                continue;
+            else if( i == 0 )
+                res[j] = std::max( res[j], res[j - 1] * _params.gamma );
+            else if( j == 0 )
+                res[i*image_width + j] = std::max(
+                    res[i*image_width + j],
+                    res[(i - 1)*image_width + j] * _params.gamma );
+            else
+                res[i*image_width + j] = std::max(
+                    res[i*image_width + j],
+                    std::max(
+                        res[ i     *image_width + j - 1] * _params.gamma,
+                        res[(i - 1)*image_width + j    ] * _params.gamma ) );
+        }
+
+
+    for( int i = int(image_height) - 1; i >= 0; i-- )  // note: must be signed because will go under 0!
+        for( int j = int(image_width) - 1; j >= 0; j-- )
+        {
+            if( i == image_height - 1 && j == image_width - 1 )
+                continue;
+            else if( i == image_height - 1 )
+                res[i*image_width + j] = std::max( res[i*image_width + j], res[i*image_width + j + 1] * _params.gamma );
+            else if( j == image_width - 1 )
+                res[i*image_width + j] = std::max( res[i*image_width + j], res[(i + 1)*image_width + j] * _params.gamma );
+            else
+                res[i*image_width + j] = std::max( res[i*image_width + j], (std::max( res[i*image_width + j + 1] * _params.gamma, res[(i + 1)*image_width + j] * _params.gamma )) );
+        }
+
+    for( auto i = 0; i < image_height; i++ )
+        for( auto j = 0; j < image_width; j++ )
+            res[i*image_width + j] = _params.alpha * edges[i*image_width + j] + (1 - _params.alpha) * res[i*image_width + j];
+    return res;
+}
+
+
+std::vector< byte > optimizer::get_luminance_from_yuy2( std::vector< yuy_t > const & yuy2_imagh )
+{
+    std::vector<byte> res( yuy2_imagh.size(), 0 );
+    auto yuy2 = (uint8_t*)yuy2_imagh.data();
+    for( auto i = 0; i < res.size(); i++ )
+        res[i] = yuy2[i * 2];
+
+    return res;
+}
+
+std::vector<uint8_t> optimizer::get_logic_edges( std::vector<double> edges )
+{
+    std::vector<uint8_t> logic_edges( edges.size(), 0 );
+    auto max = std::max_element( edges.begin(), edges.end() );
+    auto thresh = *max*_params.edge_thresh4_logic_lum;
+
+    for( auto i = 0; i < edges.size(); i++ )
+    {
+        logic_edges[i] = abs( edges[i] ) > thresh ? 1 : 0;
+    }
+    return logic_edges;
+}
+
+
+
+void optimizer::sum_per_section(
+    std::vector< double > & sum_weights_per_section,
+    std::vector< byte > const & section_map,
+    std::vector< double > const & weights,
+    size_t num_of_sections
+)
+{/*sumWeightsPerSection = zeros(params.numSectionsV*params.numSectionsH,1);
+for ix = 1:params.numSectionsV*params.numSectionsH
+    sumWeightsPerSection(ix) = sum(weights(sectionMap == ix-1));
+end*/
+    sum_weights_per_section.resize( num_of_sections );
+    auto p_sum = sum_weights_per_section.data();
+    for( byte i = 0; i < num_of_sections; ++i, ++p_sum )
+    {
+        *p_sum = 0;
+
+        auto p_section = section_map.data();
+        auto p_weight = weights.data();
+        for( size_t ii = 0; ii < section_map.size(); ++ii, ++p_section, ++p_weight )
+        {
+            if( *p_section == i )
+                *p_sum += *p_weight;
+        }
+    }
+}
+
+
+double get_max(double x, double y)
+{
+    return x > y ? x : y;
+}
+double get_min(double x, double y)
+{
+    return x < y ? x : y;
+}
+
+//std::vector<double> optimizer::calculate_weights(z_frame_data& z_data)
+//{
+//    std::vector<double> res;
+//
+//    for (auto i = 0; i < z_data.supressed_edges.size(); i++)
+//    {
+//        if (z_data.supressed_edges[i])
+//            z_data.weights.push_back(
+//                get_min(get_max(z_data.supressed_edges[i] - _params.grad_z_min, (double)0),
+//                    _params.grad_z_max - _params.grad_z_min));
+//    }
+//
+//    return res;
+//}
+
+void deproject_sub_pixel(
+    std::vector<double3>& points,
+    const rs2_intrinsics_double& intrin,
+    std::vector< byte > const & valid_edges,
+    const double* x,
+    const double* y,
+    const double* depth, double depth_units
+)
+{
+    auto ptr = (double*)points.data();
+    byte const * valid_edge = valid_edges.data();
+    for (size_t i = 0; i < valid_edges.size(); ++i)
+    {
+        if (!valid_edge[i])
+            continue;
+
+        const double pixel[] = { x[i] - 1, y[i] - 1 };
+        deproject_pixel_to_point(ptr, &intrin, pixel, depth[i] * depth_units);
+        ptr += 3;
+    }
+}
+
+std::vector<double3> optimizer::subedges2vertices(z_frame_data& z_data, const rs2_intrinsics_double& intrin, double depth_units)
+{
+    std::vector<double3> res(z_data.n_strong_edges);
+    deproject_sub_pixel(res, intrin, z_data.supressed_edges, z_data.subpixels_x.data(), z_data.subpixels_y.data(), z_data.closest.data(), depth_units);
+    z_data.vertices = res;
+    return res;
+}
+
+static p_matrix calc_p_gradients(const z_frame_data & z_data, 
+    const std::vector<double3>& new_vertices,
+    const yuy2_frame_data & yuy_data, 
+    std::vector<double> interp_IDT_x, 
+    std::vector<double> interp_IDT_y,
+    const calib & cal,
+    const p_matrix & p_mat,
+    const std::vector<double>& rc, 
+    const std::vector<double2>& xy,
+    data_collect * data = nullptr)
+{
+    auto coefs = calc_p_coefs(z_data, new_vertices, yuy_data, cal, p_mat, rc, xy);
+    auto w = z_data.weights;
+
+    if (data)
+        data->iteration_data_p.coeffs_p = coefs;
+
+    p_matrix sums = { 0 };
+    auto sum_of_valids = 0;
+
+    for (auto i = 0; i < coefs.x_coeffs.size(); i++)
+    {
+        if (interp_IDT_x[i] == std::numeric_limits<double>::max() || interp_IDT_y[i] == std::numeric_limits<double>::max())
+            continue;
+
+        sum_of_valids++;
+
+        for (auto j = 0; j < 12; j++)
+        {
+            sums.vals[j] += w[i] * (interp_IDT_x[i] * coefs.x_coeffs[i].vals[j] + interp_IDT_y[i] * coefs.y_coeffs[i].vals[j]);
+        }
+        
+    }
+
+    p_matrix averages = { 0 };
+    for (auto i = 0; i < 8; i++) //zero the last line of P grad?
+    {
+        averages.vals[i] = (double)sums.vals[i] / (double)sum_of_valids;
+    }
+
+    return averages;
+}
+
+static
+std::pair< std::vector<double2>, std::vector<double>> calc_rc(
+    const z_frame_data & z_data,
+    const std::vector<double3>& new_vertices,
+    const yuy2_frame_data & yuy_data,
+    const calib & cal,
+    const p_matrix & p_mat
+)
+{
+    auto v = new_vertices;
+
+    std::vector<double2> f1( z_data.vertices.size() );
+    std::vector<double> r2( z_data.vertices.size() );
+    std::vector<double> rc( z_data.vertices.size() );
+
+    auto yuy_intrin = cal.get_intrinsics();
+    auto yuy_extrin = cal.get_extrinsics();
+
+    auto fx = (double)yuy_intrin.fx;
+    auto fy = (double)yuy_intrin.fy;
+    auto ppx = (double)yuy_intrin.ppx;
+    auto ppy = (double)yuy_intrin.ppy;
+
+   /* double mat[3][4] = {
+        fx*(double)r[0] + ppx * (double)r[2], fx*(double)r[3] + ppx * (double)r[5], fx*(double)r[6] + ppx * (double)r[8], fx*(double)t[0] + ppx * (double)t[2],
+        fy*(double)r[1] + ppy * (double)r[2], fy*(double)r[4] + ppy * (double)r[5], fy*(double)r[7] + ppy * (double)r[8], fy*(double)t[1] + ppy * (double)t[2],
+        r[2], r[5], r[8], t[2] };
+*/
+    auto mat = p_mat.vals;
+    for( auto i = 0; i < z_data.vertices.size(); ++i )
+    {
+        double x = v[i].x;
+        double y = v[i].y;
+        double z = v[i].z;
+
+        double x1 = (double)mat[0] * (double)x + (double)mat[1] * (double)y + (double)mat[2] * (double)z + (double)mat[3];
+        double y1 = (double)mat[4] * (double)x + (double)mat[5] * (double)y + (double)mat[6] * (double)z + (double)mat[7];
+        double z1 = (double)mat[8] * (double)x + (double)mat[9] * (double)y + (double)mat[10] * (double)z + (double)mat[11];
+
+        auto x_in = x1 / z1;
+        auto y_in = y1 / z1;
+
+        auto x2 = ((x_in - ppx) / fx);
+        auto y2 = ((y_in - ppy) / fy);
+
+        f1[i].x = x2;
+        f1[i].y = y2;
+
+        auto r2 = (x2 * x2 + y2 * y2);
+
+        rc[i] = 1 + (double)yuy_intrin.coeffs[0] * r2 + (double)yuy_intrin.coeffs[1] * r2 * r2 + (double)yuy_intrin.coeffs[4] * r2 * r2 * r2;
+    }
+
+    return { f1,rc };
+}
+
+static p_matrix calc_gradients(
+    const z_frame_data& z_data,
+    const std::vector<double3>& new_vertices,
+    const yuy2_frame_data& yuy_data,
+    const std::vector<double2>& uv,
+    const calib & cal,
+    const p_matrix & p_mat,
+    data_collect * data = nullptr
+)
+{
+    p_matrix res;
+    auto interp_IDT_x = biliniar_interp( yuy_data.edges_IDTx, yuy_data.width, yuy_data.height, uv );      
+    auto interp_IDT_y = biliniar_interp( yuy_data.edges_IDTy, yuy_data.width, yuy_data.height, uv );
+
+    auto rc = calc_rc( z_data, new_vertices, yuy_data, cal, p_mat);
+
+    if (data)
+    {
+        data->iteration_data_p.d_vals_x = interp_IDT_x;
+        data->iteration_data_p.d_vals_y = interp_IDT_y;
+        data->iteration_data_p.xy = rc.first;
+        data->iteration_data_p.rc = rc.second;
+    }
+        
+    res = calc_p_gradients( z_data, new_vertices, yuy_data, interp_IDT_x, interp_IDT_y, cal, p_mat, rc.second, rc.first, data );
+    return res;
+}
+
+std::pair<double, p_matrix> calc_cost_and_grad(
+    const z_frame_data & z_data,
+    const std::vector<double3>& new_vertices,
+    const yuy2_frame_data & yuy_data,
+    const calib & cal,
+    const p_matrix & p_mat,
+    data_collect * data = nullptr
+)
+{
+    auto uvmap = get_texture_map(new_vertices, cal, p_mat);
+    if( data )
+        data->iteration_data_p.uvmap = uvmap;
+
+    auto cost = calc_cost(z_data, yuy_data, uvmap, data ? &data->iteration_data_p.d_vals : nullptr );
+    auto grad = calc_gradients(z_data, new_vertices, yuy_data, uvmap, cal, p_mat, data);
+    return { cost, grad };
+}
+
+params::params()
+{
+    normalize_mat.vals[0] = 0.353692440000000;
+    normalize_mat.vals[1] = 0.266197740000000;
+    normalize_mat.vals[2] = 1.00926010000000;
+    normalize_mat.vals[3] = 0.000673204490000000;
+    normalize_mat.vals[4] = 0.355085250000000;
+    normalize_mat.vals[5] = 0.266275050000000;
+    normalize_mat.vals[6] = 1.01145800000000;
+    normalize_mat.vals[7] = 0.000675013750000000;
+    normalize_mat.vals[8] = 414.205570000000;
+    normalize_mat.vals[9] = 313.341060000000;
+    normalize_mat.vals[10] = 1187.34590000000;
+    normalize_mat.vals[11] = 0.791570250000000;
+
+    // NOTE: until we know the resolution, the current state is just the default!
+    // We need to get the depth and rgb resolutions to make final decisions!
+}
+svm_model_linear::svm_model_linear()
+{
+}
+svm_model_gaussian::svm_model_gaussian()
+{
+}
+void params::set_depth_resolution( size_t width, size_t height )
+{
+    AC_LOG( DEBUG, "... depth resolution= " << width << "x" << height );
+    // Some parameters are resolution-dependent
+    bool const XGA = (width == 1024 && height == 768);
+    if( XGA )
+    {
+        AC_LOG( DEBUG, "... changing IR threshold: " << grad_ir_threshold << " -> " << 2.5 << "  (because of resolution)" );
+        grad_ir_threshold = 2.5;
+    }
+}
+
+void params::set_rgb_resolution( size_t width, size_t height )
+{
+    AC_LOG( DEBUG, "... RGB resolution= " << width << "x" << height );
+}
+
+calib const & optimizer::get_calibration() const
+{
+    return _final_calibration;
+}
+
+rs2_dsm_params const & optimizer::get_dsm_params() const
+{
+    return _final_dsm_params;
+}
+
+double optimizer::get_cost() const
+{
+    return _params_curr.cost;
+}
+
+static
+void write_to_file( void const * data, size_t cb,
+    std::string const & dir,
+    char const * filename
+)
+{
+    std::string path = dir + filename;
+    std::fstream f( path, std::ios::out | std::ios::binary );
+    if( !f )
+        throw std::runtime_error( "failed to open file:\n" + path );
+    f.write( (char const *) data, cb );
+    f.close();
+}
+
+template< typename T >
+void write_obj( std::fstream & f, T const & o )
+{
+    f.write( (char const *)&o, sizeof( o ) );
+}
+
+template< typename T >
+void write_vector_to_file( std::vector< T > const & v,
+    std::string const & dir,
+    char const * filename
+)
+{
+    write_to_file( v.data(), v.size() * sizeof( T ), dir, filename );
+}
+
+void write_matlab_camera_params_file(
+    rs2_intrinsics const & _intr_depth,
+    calib const & rgb_calibration,
+    float _depth_units,
+    std::string const & dir,
+    char const * filename
+)
+{
+    std::string path = dir + filename;
+    std::fstream f( path, std::ios::out | std::ios::binary );
+    if( !f )
+        throw std::runtime_error( "failed to open file:\n" + path );
+
+
+    //depth intrinsics
+    write_obj( f, (double)_intr_depth.width );
+    write_obj( f, (double)_intr_depth.height );
+    write_obj( f, (double)_depth_units );
+
+    double k_depth[9] = { _intr_depth.fx, 0, _intr_depth.ppx,
+                        0, _intr_depth.fy, _intr_depth.ppy,
+                        0, 0, 1 };
+    for( auto i = 0; i < 9; i++ )
+    {
+        write_obj( f, k_depth[i] );
+    }
+
+    //color intrinsics
+    rs2_intrinsics _intr_rgb = rgb_calibration.get_intrinsics();
+    
+    write_obj( f, (double)_intr_rgb.width );
+    write_obj( f, (double)_intr_rgb.height );
+
+    double k_rgb[9] = { _intr_rgb.fx, 0, _intr_rgb.ppx,
+                        0, _intr_rgb.fy, _intr_rgb.ppy,
+                        0, 0, 1 };
+
+
+    for( auto i = 0; i < 9; i++ )
+    {
+        write_obj( f, k_rgb[i] );
+    }
+
+    for( auto i = 0; i < 5; i++ )
+    {
+        write_obj( f, (double)_intr_rgb.coeffs[i] );
+    }
+
+    //extrinsics
+    rs2_extrinsics _extr = rgb_calibration.get_extrinsics();
+    for( auto i = 0; i < 9; i++ )
+    {
+        write_obj( f, (double)_extr.rotation[i] );
+    }
+    //extrinsics
+    for( auto i = 0; i < 3; i++ )
+    {
+        write_obj( f, (double)_extr.rotation[i] );
+    }
+
+    f.close();
+}
+
+void optimizer::write_data_to( std::string const & dir )
+{
+    // NOTE: it is expected that dir ends with a path separator or this won't work!
+    AC_LOG( DEBUG, "... writing data to: " << dir );
+    
+    try
+    {
+        write_vector_to_file( _yuy.orig_frame, dir, "rgb.raw" );
+        write_vector_to_file( _yuy.prev_frame, dir, "rgb_prev.raw" );
+        write_vector_to_file( _ir.ir_frame, dir, "ir.raw" );
+        write_vector_to_file( _z.frame, dir, "depth.raw" );
+
+        write_to_file( &_original_dsm_params, sizeof( _original_dsm_params ), dir, "dsm.params" );
+        write_to_file( &_original_calibration, sizeof( _original_calibration ), dir, "rgb.calib" );
+        auto & cal_info = _k_to_DSM->get_calibration_info();
+        auto & cal_regs = _k_to_DSM->get_calibration_registers();
+        write_to_file( &cal_info, sizeof( cal_info ), dir, "cal.info" );
+        write_to_file( &cal_regs, sizeof( cal_regs ), dir, "cal.registers" );
+        write_to_file( &_z.orig_intrinsics, sizeof( _z.orig_intrinsics), dir, "depth.intrinsics" );
+        write_to_file( &_z.depth_units, sizeof( _z.depth_units ), dir, "depth.units" );
+
+        // This file is meant for matlab -- it packages all the information needed
+        write_matlab_camera_params_file( _z.orig_intrinsics,
+                                         _original_calibration,
+                                         _z.depth_units,
+                                         dir,
+                                         "camera_params"
+        );
+    }
+    catch( std::exception const & err )
+    {
+        AC_LOG( ERROR, "Failed to write data: " << err.what() );
+    }
+    catch( ... )
+    {
+        AC_LOG( ERROR, "Failed to write data (unknown error)" );
+    }
+}
+
+optimization_params optimizer::back_tracking_line_search( optimization_params const & curr_params,
+                                                          const std::vector<double3>& new_vertices,
+                                                          data_collect * data ) const
+{
+    optimization_params new_params;
+
+    // was gradStruct.P ./ norm( gradStruct.P(:) )   -> vector norm
+    // now gradStruct.P ./ norm( gradStruct.P )      -> matrix 2-norm
+    auto grads_over_norm
+        = curr_params.calib_gradients.normalize( curr_params.calib_gradients.matrix_norm() );
+    //%grad = gradStruct.P ./ norm(gradStruct.P) ./ params.rgbPmatNormalizationMat;
+    auto grad = grads_over_norm / _params.normalize_mat;
+
+    //%unitGrad = grad ./ norm(grad);     <-   was ./ norm(grad(:)')
+    auto grad_norm = grad.matrix_norm();
+    auto unit_grad = grad.normalize( grad_norm );
+
+    //%t = -params.controlParam * grad(:)' * unitGrad(:);
+    // -> dot product of grad and unitGrad
+    auto t_vals = ( grad * -_params.control_param ) * unit_grad;
+    auto t = t_vals.sum();
+
+    //%stepSize = params.maxStepSize * norm(grad) / norm(unitGrad);
+    auto step_size = _params.max_step_size * grad_norm / unit_grad.matrix_norm();
+
+
+    auto movement = unit_grad * step_size;
+    new_params.curr_p_mat = curr_params.curr_p_mat + movement;
+    
+    calib old_calib = decompose( curr_params.curr_p_mat, _original_calibration );
+    auto uvmap_old = get_texture_map(new_vertices, old_calib, curr_params.curr_p_mat );
+    //curr_params.cost = calc_cost( z_data, yuy_data, uvmap_old );
+
+    calib new_calib = decompose( new_params.curr_p_mat, _original_calibration );
+    auto uvmap_new = get_texture_map(new_vertices, new_calib, new_params.curr_p_mat );
+    new_params.cost = calc_cost( _z, _yuy, uvmap_new );
+
+    auto diff = calc_cost_per_vertex_diff( _z, _yuy, uvmap_old, uvmap_new );
+
+    auto iter_count = 0;
+    while( diff >= step_size * t
+           && abs( step_size ) > _params.min_step_size
+           && iter_count++ < _params.max_back_track_iters )
+    {
+        AC_LOG( DEBUG, "    back tracking line search cost= " << AC_D_PREC << new_params.cost );
+        step_size = _params.tau * step_size;
+
+        new_params.curr_p_mat = curr_params.curr_p_mat + unit_grad * step_size;
+        
+        new_calib = decompose( new_params.curr_p_mat, _original_calibration );
+        uvmap_new = get_texture_map(new_vertices, new_calib, new_params.curr_p_mat);
+        new_params.cost = calc_cost( _z, _yuy, uvmap_new);
+        diff = calc_cost_per_vertex_diff( _z, _yuy, uvmap_old, uvmap_new );
+    }
+
+    if(diff >= step_size * t )
+    {
+        new_params = curr_params;
+    }
+
+    if (data)
+    {
+        data->iteration_data_p.grads_norma = curr_params.calib_gradients.get_norma();
+        data->iteration_data_p.grads_norm = grads_over_norm;
+        data->iteration_data_p.normalized_grads = grad;
+        data->iteration_data_p.unit_grad = unit_grad;
+        data->iteration_data_p.back_tracking_line_search_iters = iter_count;
+        data->iteration_data_p.t = t;
+    }
+    return new_params;
+}
+
+void optimizer::set_final_data(const std::vector<double3>& vertices,
+    const p_matrix& p_mat,
+    const p_matrix& p_mat_opt)
+{
+    _vertices_from_bin = vertices;
+    _p_mat_from_bin = p_mat;
+    _p_mat_from_bin_opt = p_mat_opt;
+}
+
+void optimizer::set_cycle_data(const std::vector<double3>& vertices, 
+    const rs2_intrinsics_double& k_depth,
+    const p_matrix& p_mat, 
+    const algo_calibration_registers& dsm_regs_cand,
+    const rs2_dsm_params_double& dsm_params_cand)
+{
+    _vertices_from_bin = vertices;
+    _k_dapth_from_bin = k_depth;
+    _p_mat_from_bin = p_mat;
+    _dsm_regs_cand_from_bin = dsm_regs_cand;
+    _dsm_params_cand_from_bin = dsm_params_cand;
+}
+
+size_t optimizer::optimize_p
+(
+    const optimization_params& params_curr,
+    const std::vector<double3>& new_vertices,
+    optimization_params& params_new,
+    calib& optimaized_calibration,
+    calib& new_rgb_calib_for_k_to_dsm,
+    rs2_intrinsics_double& new_z_k,
+    std::function<void(data_collect const&data)> cb,
+    data_collect* data 
+)
+{
+
+    size_t n_iterations = 0;
+    auto curr = params_curr;
+    while (1)
+    {
+
+        auto res = calc_cost_and_grad(_z, new_vertices, _yuy, new_rgb_calib_for_k_to_dsm, curr.curr_p_mat, data);
+        curr.cost = res.first;
+        curr.calib_gradients = res.second;
+        AC_LOG( DEBUG, std::setw( 3 ) << std::right << n_iterations << std::left
+                           << " cost= " << AC_D_PREC << curr.cost );
+
+        if (data)
+        {
+            data->type = iteration_data;
+            data->iteration_data_p.iteration = n_iterations;
+            data->iteration_data_p.params = curr;
+            data->iteration_data_p.c = new_rgb_calib_for_k_to_dsm;
+            data->iteration_data_p.iteration = n_iterations;
+        }
+
+        params_new = back_tracking_line_search(curr, new_vertices, data);
+        
+        if (data)
+            data->iteration_data_p.next_params = params_new;
+
+        if (cb)
+            cb(*data);
+
+        auto norm = (params_new.curr_p_mat - curr.curr_p_mat).get_norma();
+        if (norm < _params.min_rgb_mat_delta)
+        {
+            AC_LOG(DEBUG, "    {normal(new-curr)} " << norm << " < " << _params.min_rgb_mat_delta << " {min_rgb_mat_delta}  -->  stopping");
+            break;
+        }
+
+        auto delta = params_new.cost - curr.cost;
+        AC_LOG( DEBUG, "    delta= " << AC_D_PREC << delta );
+        delta = abs(delta);
+        if (delta < _params.min_cost_delta)
+        {
+            AC_LOG(DEBUG, "    delta < " << _params.min_cost_delta << "  -->  stopping");
+            break;
+        }
+
+        if (++n_iterations >= _params.max_optimization_iters)
+        {
+            AC_LOG(DEBUG, "    exceeding max iterations  -->  stopping");
+            break;
+        }
+
+        curr = params_new;
+        new_rgb_calib_for_k_to_dsm = decompose_p_mat(params_new.curr_p_mat);
+    }
+
+    AC_LOG( DEBUG,
+            "    cycle " << data->cycle_data_p.cycle << " finished after " << n_iterations << " iterations; cost "
+                         << AC_D_PREC << params_curr.cost << "  -->  " << params_new.cost );
+    new_rgb_calib_for_k_to_dsm = optimaized_calibration = decompose_p_mat(params_new.curr_p_mat);
+
+    auto orig_rgb_calib = decompose_p_mat(params_curr.curr_p_mat);
+    new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[1] = 0;
+
+    new_z_k = get_new_z_intrinsics_from_new_calib(_z.orig_intrinsics, new_rgb_calib_for_k_to_dsm, orig_rgb_calib);
+    new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[0] = _original_calibration.k_mat.get_fx();
+    new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[4] = _original_calibration.k_mat.get_fy();
+    params_new.curr_p_mat = new_rgb_calib_for_k_to_dsm.calc_p_mat();
+    new_rgb_calib_for_k_to_dsm = decompose_p_mat(params_new.curr_p_mat);
+
+    return n_iterations;
+}
+
+size_t optimizer::optimize( std::function< void( data_collect const & data ) > cb )
+{
+    optimization_params params_orig;
+    params_orig.curr_p_mat = _original_calibration.calc_p_mat();
+    _original_calibration = decompose(params_orig.curr_p_mat, _original_calibration);
+    _params_curr = params_orig;
+
+    data_collect data;
+
+    auto cycle = 1;
+    data.cycle_data_p.cycle = cycle;
+
+    auto res = calc_cost_and_grad(_z, _z.vertices, _yuy, decompose(_params_curr.curr_p_mat, _original_calibration), _params_curr.curr_p_mat, &data);
+    _params_curr.cost = res.first;
+    _params_curr.calib_gradients = res.second;
+    params_orig.cost = res.first;
+
+    optimization_params new_params;
+    calib new_calib = _original_calibration;
+    calib new_k_to_dsm_calib = _original_calibration;
+    rs2_intrinsics_double new_k_depth;
+    algo_calibration_registers new_dsm_regs = _k_to_DSM->get_calibration_registers();
+    auto new_vertices = _z.vertices;
+
+    double last_cost = _params_curr.cost;
+    
+    auto n_iterations = optimize_p(_params_curr, new_vertices, new_params, _optimaized_calibration, new_calib, new_k_depth, cb, &data);
+
+    _z.orig_vertices = _z.vertices;
+    rs2_dsm_params_double new_dsm_params = _z.orig_dsm_params;
+
+    while (cycle < _params.max_K2DSM_iters)
+    {
+        std::vector<double3> cand_vertices = _z.vertices;
+        auto dsm_regs_cand = new_dsm_regs;
+
+        optimization_params params_candidate = new_params;
+        calib calib_candidate = new_calib;
+        calib calib_k_to_dsm_candidate = new_calib;
+        calib optimaized_calib_candidate = _optimaized_calibration;
+        rs2_intrinsics_double k_depth_candidate = new_k_depth;
+
+        data.cycle_data_p.cycle = ++cycle;
+        data.cycle_data_p.new_calib = new_calib;
+        data.cycle_data_p.new_k_depth = new_k_depth;
+        data.cycle_data_p.new_params = new_params;
+        data.cycle_data_p.new_dsm_params = new_dsm_params;
+        data.cycle_data_p.new_dsm_regs = new_dsm_regs;
+        data.cycle_data_p.new_vertices = new_vertices;
+        data.cycle_data_p.optimaized_calib_candidate = optimaized_calib_candidate;
+
+        if (cb)
+        {
+            data.type = cycle_data;
+            cb(data);
+        }
+
+        if (get_cycle_data_from_bin)
+        {
+            new_params.curr_p_mat = _p_mat_from_bin;
+            new_calib = decompose(_p_mat_from_bin, _original_calibration);
+            new_k_depth = _k_dapth_from_bin;
+            new_dsm_regs = _dsm_regs_cand_from_bin;
+            new_dsm_params = _dsm_params_cand_from_bin;
+        }
+
+        auto dsm_candidate = _k_to_DSM->convert_new_k_to_DSM(_z.orig_intrinsics, new_k_depth, _z, cand_vertices, new_dsm_params, dsm_regs_cand, &data);
+        data.type = cycle_data;
+
+        //this calib is now candidate to be the optimaized we can confirm it only after running more optimize_p
+        calib_k_to_dsm_candidate = calib_candidate;
+
+        data.k2dsm_data_p.dsm_params_cand = dsm_candidate;
+        data.k2dsm_data_p.vertices = cand_vertices;
+        data.k2dsm_data_p.dsm_pre_process_data = _k_to_DSM->get_pre_process_data();
+
+        if (cb)
+        {
+            data.type = k_to_dsm_data;
+            cb(data);
+        }
+
+        optimize_p(new_params, cand_vertices, params_candidate, optimaized_calib_candidate, calib_candidate, k_depth_candidate, cb, &data);
+
+        if( params_candidate.cost < last_cost )
+        {
+            if (cycle == 2)
+            {// No change at all (probably very good starting point)
+                AC_LOG(DEBUG, "No change required (probably very good starting point)");
+                new_k_to_dsm_calib = new_calib;
+                _optimaized_calibration = _original_calibration;
+            }
+
+            AC_LOG( DEBUG, "    cost is a regression; stopping -- not using last cycle" );
+            break;
+        }
+
+        new_params = params_candidate;
+        _params_curr = new_params;
+        new_calib = calib_candidate;
+        new_k_to_dsm_calib = calib_k_to_dsm_candidate;
+        new_k_depth = k_depth_candidate;
+        new_dsm_params = dsm_candidate;
+        new_dsm_regs = dsm_regs_cand;
+        last_cost = new_params.cost;
+        new_vertices = cand_vertices;
+        _z.vertices = new_vertices;
+        _optimaized_calibration = optimaized_calib_candidate;
+        AC_LOG(INFO, "CYCLE " << data.cycle_data_p.cycle << ": cost = " << AC_D_PREC << new_params.cost);
+    }
+   
+    AC_LOG( INFO,
+            "Calibration converged; cost " << AC_D_PREC << params_orig.cost << "  -->  "
+                                           << new_params.cost );
+
+    _final_dsm_params = _z.orig_dsm_params;
+    clip_ac_scaling( _z.orig_dsm_params, new_dsm_params );
+    new_dsm_params.copy_to( _final_dsm_params );
+    _final_calibration = new_k_to_dsm_calib;
+
+    // The actual valid cycles - we starting from 1 and the last cycle is only for verification
+    return cycle - 2;
+}
diff --git a/src/algo/depth-to-rgb-calibration/optimizer.h b/src/algo/depth-to-rgb-calibration/optimizer.h
new file mode 100644
index 0000000..096e0bd
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/optimizer.h
@@ -0,0 +1,382 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <cstdint>
+#include <vector>
+#include <map>
+#include <types.h>
+
+#include "calibration.h"
+#include "coeffs.h"
+#include "frame-data.h"
+#include "k-to-dsm.h"
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    struct optimization_params
+    {
+        p_matrix curr_p_mat;
+        p_matrix calib_gradients;
+        double cost;
+        double step_size = 0;
+    };
+
+    struct params
+    {
+        params();
+
+        void set_depth_resolution(size_t width, size_t height);
+        void set_rgb_resolution(size_t width, size_t height);
+
+        double gamma = 0.9;
+        double alpha = (double)1 / (double)3;
+        double grad_ir_threshold = 3.5; // Ignore pixels with IR gradient less than this (resolution-dependent!)
+        int grad_z_threshold = 0; //Ignore pixels with Z grad of less than this
+        double grad_z_min = 25; // Ignore pixels with Z grad of less than this
+        double grad_z_max = 1000;
+        double edge_thresh4_logic_lum = 0.1;
+
+        double max_step_size = 1;
+        double min_step_size = 0.00001;
+        double control_param = 0.5;
+        int max_back_track_iters = 50;
+        int max_optimization_iters = 50;
+        double min_rgb_mat_delta = 0.00001;
+        double min_cost_delta = 1;
+        double tau = 0.5;
+        double min_weighted_edge_per_section = 19.5313;
+        size_t num_of_sections_for_edge_distribution_x = 2;
+        size_t num_of_sections_for_edge_distribution_y = 2;
+        p_matrix normalize_mat;  //% rgbPmatNormalizationMat
+
+        double edge_distribution_min_max_ratio = 0.005;
+        double grad_dir_ratio = 10;
+        double grad_dir_ratio_prep = 1.5;
+        size_t dilation_size = 3;
+        double gauss_sigma = 1;
+        size_t gause_kernel_size = 5;
+        double move_thresh_pix_val = 20;
+        double move_threshold_pix_num = 62.2080;
+
+        //smearing
+        double max_sub_mm_z = 4;
+        double constant_weights = 1000;
+
+        // output validation
+        double const max_xy_movement_per_calibration[3] = { 10, 2, 2 };
+        double const max_xy_movement_from_origin = 20;
+        double const max_scaling_step = 0.020000000000000;
+        double const max_K2DSM_iters = 10;
+        // TODO: the following should be 0.2% but was increased to 0.5% to account for
+        // manual trigger activation
+        double const max_global_los_scaling_step = 0.005;  // the difference (.5%) between starting and final scale
+    };
+    // svm
+    struct decision_params
+    {
+        double initial_cost;
+        bool is_valid;
+        double xy_movement;
+        double xy_movement_from_origin;
+        std::vector< double >  improvement_per_section;
+        double min_improvement_per_section;
+        double max_improvement_per_section;
+        bool is_valid_1;
+        double moving_pixels;
+        double min_max_ratio_depth;// edgeDistributionMinMaxRatioDepth;
+        std::vector< double > distribution_per_section_depth;// edgeWeightDistributionPerSectionDepth;
+        double min_max_ratio_rgb;// edgeDistributionMinMaxRatioRgb;
+        std::vector< double > distribution_per_section_rgb;// edgeWeightDistributionPerSectionRgb;
+        double dir_ratio_1; // dirRatio1;
+        double dir_ratio_2;
+        std::vector< double > edge_weights_per_dir;
+        double new_cost;
+    };
+    struct svm_features
+    {
+        double max_over_min_depth;
+        double max_over_min_rgb;
+        double max_over_min_perp;
+        double max_over_min_diag;
+        double initial_cost;
+        double final_cost;
+        double xy_movement;
+        double xy_movement_from_origin;
+        double positive_improvement_sum;
+        double negative_improvement_sum;
+    };
+    struct svm_model_linear
+    {
+        svm_model_linear();
+        std::vector< double > mu = { 0,0,0,0,0,0,0,0,0,0 };
+        std::vector< double > sigma = { 1,1,1,1,1,1,1,1,1,1 };
+        std::vector< double > beta = { -0.00598037736275758, -0.419810195765952, -0.0519142921084610, 0.0511261823872767, -3.260600000000000e-04, 0.00134513193142993, -0.0305126906030304, 0, 0.000390629893900041, -0.000589640043298588 };// { 0.036404266074054, 0.217416714219929, -1.448206804928638, -0.426383040511132, 0.482625970398315, -0.341211816013196, 1.476722279284806, -0.570440485581453, 0.174994874978338, -0.217118614894225 };
+        double bias = 14.782481183385837;
+    };
+    struct svm_model_gaussian
+    {
+        svm_model_gaussian();
+        std::vector< double > mu = { 26.451657421181550, 1.834669247710750, 3.491429858876404, 3.786071463994616, 1.267059679244040e+04, 1.739017433204909e+04, 7.950284312071314, 7.037505628020683, 1.669357700781532e+04, -4.000499638952811e+02 };
+        std::vector< double > sigma = {64.543314844188930, 0.399466249006394, 5.051691865199965, 4.838800439657138, 3.560637036816310e+03, 4.169466021585641e+03, 3.946730380178832, 2.688331347779885, 9.166971780432328e+03, 1.309539174549818e+03};
+        std::vector< double > alpha = { 0.853782362459551, 0.809419984641913, 0.853782362459551, 0.523660624979399, 1.11094229588706, 0.853782362459551, 0.853782362459551, 0.739635480910988, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.858846426133943, 1.11094229588706, 0.853782362459551, 1.11094229588706, 0.853782362459551, 0.565954460907804, 0.410526909886890, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 1.11094229588706, 0.147472046069076, 0.853782362459551, 1.11094229588706, 0.853782362459551, 0.474919097314781, 1.07387030895150, 1.11094229588706, 0.728324034495017, 0.811599038284503, 0.118602560912953, 1.00766686099462, 0.759793036827252, 0.804341226802145, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.912663846986493, 0.502945760137574, 0.741688370316241, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.720528402669790, 0.853782362459551, 0.853782362459551, 0.626880433540383, 0.853782362459551, 1.11094229588706, 1.11094229588706, 0.828188533980146, 0.853782362459551, 0.853782362459551, 1.08218326015022, 1.11094229588706, 1.11094229588706, 0.874637498781498, 0.853782362459551, 0.853782362459551, 0.638113857711959, 0.567946527216678, 0.756319722985775, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.858929103546975, 0.853782362459551, 0.0551892575127066, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 1.11094229588706, 1.11094229588706, 1.10609139305017, 0.904762930421056, 1.11094229588706, 0.877257559768069, 1.11094229588706, 0.164605124354074, 1.11094229588706, 1.11094229588706, 1.11094229588706, 1.11094229588706, 1.11094229588706, 0.163757887887552, 0.853782362459551, 0.853782362459551, 1.10487919283239, 0.853782362459551, 0.641471719725152, 1.11094229588706, 0.853782362459551, 0.582518093538500, 0.853782362459551, 0.590370095260419, 0.625770558050165, 0.849648792088831, 0.464867191830818, 0.371399214192577, 0.508643001909889, 0.508719179090522, 0.849956268470741, 0.395653653246930, 0.666814548675369, 0.617065518321757, 0.853782362459551, 0.797324899450533, 0.645341371666331, 0.643837379212830, 0.670038550795845, 0.841968985583819, 1.06151054576426, 0.734320857082393, 0.580669562338322, 0.434135177363688, 1.10848731131424, 0.665617404389425, 0.709773717912651, 0.825756139249980, 1.11094229588706, 0.690353773003999, 1.11094229588706, 0.219534940218192, 0.657932066278636, 0.476475742895029, 0.661076180573250, 0.657638691861222, 0.407781991490912, 0.735521726220470, 0.722224781567731, 0.741663155838191, 0.657750600427332, 0.853782362459551, 0.851047964636070, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.572911397588253, 0.657581429355579, 0.509194534549591, 0.488095502769136, 0.853180064239348, 1.11094229588706, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.574573645023846, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.313804046292503, 0.0818345445662691, 0.608815326606831, 1.11094229588706, 1.11094229588706, 0.813193890719519, 0.807412795095128, 1.11094229588706, 1.11094229588706, 1.11094229588706, 0.489360336829842, 0.932772552136191, 0.853782362459551, 1.00400067721180, 1.11094229588706, 0.853782362459551, 0.626502674030708, 1.11094229588706, 0.853782362459551, 1.11094229588706, 0.853782362459551, 1.11094229588706, 0.853782362459551, 1.11094229588706, 0.853782362459551, 0.853782362459551, 0.472192610210062, 0.0505120252117739, 0.853782362459551, 0.853782362459551, 0.473165559571867, 0.296883608413205, 0.815314527893011, 0.683661864430910, 0.659295345426884, 0.541872778451743, 0.515306135002716, 0.606229468786921, 0.481728358034791, 0.467598697870095, 0.550458139680351, 0.654416225571927, 0.167005758120683, 0.853782362459551, 0.339472108535104, 1.11094229588706, 0.135084020329085, 0.656894107435376, 0.853782362459551, 0.416327424192007, 0.853782362459551, 1.11094229588706, 0.853782362459551, 0.122200722533292, 1.11094229588706, 0.853782362459551, 1.11094229588706, 0.481820439865076, 1.10047904288990, 0.723810502326994, 0.853782362459551, 1.04408869091412, 0.442766463043284, 0.473432211087953, 0.621097330923599, 0.636524721655964, 0.658340995052940, 0.657854873791700, 0.770188713793156, 1.11094229588706, 0.853782362459551, 1.11094229588706, 1.11094229588706, 1.11094229588706, 1.11094229588706, 0.542621644264350, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.820277591673038, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.852910435896307, 0.277144002177960, 1.09737060681344, 0.816340094455241, 1.11094229588706, 0.387365127119839, 0.822911949368766, 0.583552640059492, 1.10698101307889, 0.199605742376812, 0.309716857446239, 1.11094229588706, 0.825553571525066, 0.316140379615421, 0.828377208677995, 0.830376808053154, 0.772655504859029, 1.11094229588706, 0.515252846432175, 0.516918757966514, 0.741182454077847, 0.383763427412591, 1.11094229588706, 0.853782362459551, 1.11026858485958, 0.0978599136880101, 0.156617362810719, 0.853782362459551, 0.290818738206244, 0.853782362459551, 0.853782362459551, 0.853782362459551, 1.10819605976630, 0.386039711890531, 0.290732589038562, 0.853782362459551, 0.674592403169784, 0.360752576373701, 0.853782362459551, 1.11094229588706, 0.853782362459551, 0.853782362459551, 0.936084924636588, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.424951759018112, 1.11094229588706, 0.985693515370822, 0.853782362459551, 0.316412633956148, 0.367991629921835, 0.853782362459551, 0.853782362459551, 0.0914759047151927, 0.953020231941869, 0.853782362459551, 0.616881479123683, 0.853782362459551, 0.853782362459551, 0.673529054889632, 0.540929179359247, 0.657743115458036, 0.621498920245097, 0.587012931684455, 1.11017036408162, 1.10745536715549, 0.659692571990333, 0.608207729800647, 0.212511065146229, 0.296070075276644, 0.853782362459551, 0.349119696103402, 0.841330883963117, 0.581304165917077, 1.11094229588706, 0.572646085149409, 0.798236813225304, 0.853782362459551, 0.853782362459551, 0.853782362459551, 0.655613482190814, 0.853782362459551, 0.346650809612394, 0.845449841690559, 0.742414233118956, 0.497349430092853, 1.02290125480437, 0.531325561408872, 0.408979355805631, 0.806101219345509, 0.393215113631691, 0.621176662488951, 1.11094229588706, 1.11094229588706, 1.11094229588706, 0.951142231548956 };
+        double bias = -0.342210526291181;
+        double kernel_param_scale = 1;
+        std::vector< double > support_vectors_labels = { 1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, -1, -1, 1, -1, 1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, -1, 1, 1, -1, 1, -1, 1, -1, -1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1, -1, -1, 1, 1, -1, -1, 1, 1, -1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, -1, 1, -1, 1, 1, 1, -1, -1, -1, 1, -1, 1, 1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 1, 1, -1, 1, 1, -1, -1, -1, -1 };
+        std::vector< double > support_vectors[10] = {
+            {-0.0562123043369483, -0.0324974207934130, -0.0455795300828793, -0.0583388591877621, -0.0274359457172453, -0.00286615800048622, -0.0850389364052901, -0.0513925026855241, -0.0631250403340051, -0.0615118136651025, -0.0879080977150691, -0.0251284074787236, -0.0444919493167321, -0.0537704917650131, -0.0771568631874931, 0.00567872580422870, -0.0448018187377292, -0.0330399671536552, -0.111479363523474, -0.133896656168909, -0.135858082969125, -0.126684814651919, -0.157647032033827, -0.151843688868152, -0.116643853844292, -0.151720854659326, -0.143974119155527, -0.112671168982125, -0.143856744663014, -0.100774023471855, -0.132079187607702, -0.152777227682572, -0.104146002431311, -0.151123062310040, -0.104146002431311, -0.188970085737752, -0.128300292246279, -0.301025529869738, -0.304239542177909, -0.305034243161145, -0.299932444643398, -0.309162765273118, -0.286860826025910, -0.300112601286068, -0.295385423649795, -0.293959644085562, -0.299459798400177, -0.307099545823721, -0.308862208872332, -0.296878678382869, -0.305849589458012, -0.307708045125148, 0.348160236158141, 0.505695227718318, 0.485976265962213, 0.417781529492118, 0.281844782481576, 0.578655377229695, 0.153405223155692, 0.413908161974968, 0.266351312228530, 0.366037317121122, 0.320748712014903, 0.344584819965545, 0.292911546948038, 0.203132425686729, 0.408743671952102, 0.351735652350737, 0.574007336286582, 0.463440309669521, 0.350543846953205, -0.380930061392109, -0.380062386221645, -0.380742525503985, -0.379892647099266, -0.380930061392109, -0.380742525503985, -0.380930061392109, -0.380742525503985, -0.380930061392109, -0.380742525503985, -0.380930061392109, -0.380742525503985, -0.380171120008432, -0.381322845769040, -0.380030087870659, -0.380013725018617, -0.380171120008432, -0.381322845769040, -0.380030087870659, -0.380013725018617, -0.380171120008432, -0.380030087870659, -0.380171120008432, -0.380030087870659, -0.380171120008432, -0.380030087870659, 2.14659456464675, 1.88984565945844, 2.67647118955455, 2.14659456464675, 1.88984565945844, 2.67647118955455, 2.14659456464675, 2.67647118955455, 2.14659456464675, 2.14659456464675, 0.111494574553853, 0.0957018330431097, 0.0861782670520956, 0.0444485231406666, 0.0957018330431097, 0.177101136398129, 0.0181361027093097, 0.108156423705904, -0.0534781621222321, 0.0181361027093097, -0.316313830554705, -0.312840904894096, -0.312128615753399, -0.316462110744288, -0.316313830554705, -0.165507874069173, -0.173384153709154, -0.159562868123635, -0.196173028758245, -0.165507874069173, -0.322441539624239, -0.322915422504161, -0.311887124731291, -0.316217742131253, -0.322441539624239, -0.322915422504161, -0.322441539624239, -0.322441539624239, -0.234632594250674, -0.223045597135125, -0.166699686224635, -0.250816057954379, -0.332888826834439, -0.336684399748136, -0.318683645095036, -0.323348098275387, -0.115452058153772, -0.196667821564477, -0.188717782031995, -0.196667821564477, -0.196667821564477, -0.196667821564477, -0.196667821564477, 0.0859630372597497, 0.144063535201371, 0.125557454159761, 0.165367055658050, -0.343522603467787, -0.339435693676029, -0.339590926933874, -0.343364526160185, -0.343522603467787, -0.339435693676029, -0.339590926933874, -0.343364526160185, -0.343522603467787, -0.339590926933874, -0.343364526160185, -0.343522603467787, 0.0839244591927724, 0.00107176645329464, 0.103902882262456, 0.00711852332056431, 0.0839244591927724, 0.00107176645329464, 0.0839244591927724, 0.00107176645329464, 0.0839244591927724, -0.241259035021247, -0.220955211947689, -0.214315153109716, -0.241259035021247, -0.246216945658042, -0.214315153109716, -0.241259035021247, -0.214315153109716, -0.241259035021247, -0.214315153109716, -0.241259035021247, -0.214315153109716, -0.352834155784050, -0.350861068039928, -0.352163553789278, -0.350419255694952, -0.352834155784050, -0.350861068039928, -0.352834155784050, -0.350861068039928, 3.16916030843535, 3.15366685256908, 1.38741378243466, 3.16916030843535, -0.304509281897474, -0.304227759057322, -0.303641035721330, -0.239953153011648, -0.263474284848948, -0.254606369813228, -0.250352095943331, -0.234771892835509, -0.196701270276139, -0.216661193267720, -0.234771892835509, -0.216661193267720, -0.284911885395958, -0.294840307002373, -0.283888209847379, -0.306353742751674, -0.284911885395958, -0.283888209847379, -0.306353742751674, -0.284911885395958, -0.306353742751674, -0.284911885395958, -0.306353742751674, -0.291261546452128, -0.290035563399750, -0.293477411041730, -0.289632551358936, -0.290035563399750, 1.68488891221884, 3.13301127330454, 4.47061304141983, 9.25808846387818, -0.316017435338466, -0.308026776231821, -0.316017435338466, -0.308026776231821, -0.308026776231821, -0.308026776231821, -0.308026776231821, -0.294834486496376, -0.282563195685673, -0.286209874450064, -0.287326283448068, -0.282563195685673, -0.286209874450064, -0.287326283448068, -0.286209874450064, -0.287326283448068, -0.286209874450064, -0.287326283448068, -0.286209874450064, -0.287326283448068, -0.232553859769381, -0.235088585408672, -0.237264348426925, -0.232553859769381, -0.237264348426925, -0.237264348426925, -0.226305330061371, -0.202043331539786, -0.223751406262257, -0.224440598627960, -0.226305330061371, -0.223751406262257, -0.223751406262257, -0.344219019334402, 0.816092873585745, 0.684630776400184, 1.48922878577253, 2.02687227747499, 0.816092873585745, 0.684630776400184, 2.02687227747499, -0.320571147349952, 0.00286172794913721, 0.0612882816690623, 0.166247412244897, 0.542424515955872, 0.00286172794913721, 0.0612882816690623, 0.166247412244897, 0.0612882816690623, 0.0612882816690623, 0.0612882816690623, -0.336391161237969, -0.334917444445115, -0.336391161237969, -0.203414977228364, -0.207884684767060, -0.207479529785634, -0.203414977228364, -0.207884684767060, -0.207479529785634, -0.203414977228364, -0.207884684767060, -0.203414977228364, -0.203414977228364, -0.348450014764882, -0.353504672038965, -0.349281142286866, -0.355600847558802, -0.348450014764882, -0.349281142286866, -0.348450014764882, -0.317463073034788, -0.306655564735309, -0.325507759932246, -0.340107376755598, -0.317463073034788, -0.306655564735309, -0.317463073034788, -0.317463073034788, -0.317463073034788, -0.306021748942754, -0.322826202652428, -0.316867177810017, -0.344534086320147, -0.238293147442116, -0.239399824825181, -0.266513398537719, -0.209962236118425, -0.238293147442116, -0.239399824825181, -0.365663617047502, -0.365663617047502, -0.369958582494668, -0.373376551681660, -0.371281602077414, -0.371281602077414, -0.288508583084618, -0.281952304078295, -0.288508583084618, -0.281952304078295, -0.288508583084618, -0.281952304078295, -0.281952304078295, -0.369644016342871, -0.365477017255581, -0.365571526062232, -0.366578448863611, -0.369644016342871, -0.365477017255581, -0.366578448863611, -0.373469392014868, -0.372385440940071, -0.378193807190106, -0.378193807190106, -0.378193807190106, -0.378193807190106},
+            {-1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21987837917425, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.21438737126708, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75854819606953, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.75292361167551, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.54465504221194, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, -1.55422294355045, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, 0.0753935137262907, -0.349904922225673, -0.349904922225673, -0.349904922225673, -0.349904922225673, -0.349904922225673, -0.361105755406697, -0.361105755406697, -0.361105755406697, -0.361105755406697, -0.361105755406697, -1.08179416439212, -1.08179416439212, -1.08179416439212, -1.08179416439212, -1.08179416439212, -0.808250847685785, -0.808250847685785, -0.808250847685785, -0.808250847685785, -0.808250847685785, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.655734692966619, -0.673259436879201, -0.673259436879201, -0.673259436879201, -0.673259436879201, 0.400937185066202, 0.400937185066202, 0.400937185066202, 0.400937185066202, 0.0765135259095146, 0.0883986307707854, 0.0883986307707854, 0.0883986307707854, 0.0883986307707854, 0.0883986307707854, 0.0883986307707854, 0.0565645180689857, 0.0565645180689857, 0.0565645180689857, 0.0565645180689857, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, -0.319942922031094, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.687663825936970, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.674502743323060, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.170803649772231, 0.168632359461486, 0.168632359461486, 0.168632359461486, 0.168632359461486, 0.694066342873892, 0.694066342873892, 0.694066342873892, 0.671739914720242, 0.671739914720242, 0.671739914720242, 0.671739914720242, 1.27959245254742, 1.27959245254742, 1.27959245254742, 1.27959245254742, 1.27959245254742, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 1.26773215910237, 0.750603628375997, 0.750603628375997, 0.750603628375997, 0.750603628375997, 0.750603628375997, 0.792591871839333, 0.792591871839333, 0.792591871839333, 0.792591871839333, 1.05052406413540, 1.05052406413540, 1.05052406413540, 1.05052406413540, 1.05052406413540, 1.05052406413540, 1.05052406413540, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.06305188874812, 1.82660906215719, 1.82660906215719, 1.82660906215719, 1.82660906215719, 1.82660906215719, 1.82660906215719, 1.83897317208506, 1.83897317208506, 1.83897317208506, 1.83897317208506, 1.83897317208506, 1.83897317208506, 1.83897317208506, 0.908065308383070, 0.305100482975081, 0.305100482975081, 0.305100482975081, 0.305100482975081, 0.305100482975081, 0.305100482975081, 0.305100482975081, -1.57631673024680, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.59206593323724, -1.31619450032808, -1.31619450032808, -1.31619450032808, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, -1.32035207258010, 1.25108244163170, 1.25108244163170, 1.25108244163170, 1.25108244163170, 1.25108244163170, 1.25108244163170, 1.25108244163170, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, 1.24621153720812, -0.0449581753031382, -0.0449581753031382, -0.0449581753031382, -0.0449581753031382, -0.00762733064969650, -0.00762733064969650, -0.00762733064969650, -0.00762733064969650, -0.00762733064969650, -0.00762733064969650, -0.00472169089691700, -0.00472169089691700, 0.00756552273551637, 0.00756552273551637, 0.00756552273551637, 0.00756552273551637, 1.08795057015157, 1.08795057015157, 1.08795057015157, 1.08795057015157, 1.08795057015157, 1.08795057015157, 1.08795057015157, 1.03255577362754, 1.03255577362754, 1.03255577362754, 1.03255577362754, 1.03255577362754, 1.03255577362754, 1.03255577362754, -0.0830525352135685, -0.0830525352135685, -0.0535324720554350, -0.0535324720554350, -0.0535324720554350, -0.0535324720554350},
+            {-0.455346387028116, -0.468730452447457, -0.458946616111499, -0.476899906663255, -0.464753110819491, -0.472558381909235, -0.458683594732494, -0.443589601993333, -0.456920931618443, -0.455094548337438, -0.444602745035972, -0.468652729674597, -0.452231325554993, -0.458328814416776, -0.445767853180217, -0.451197085825580, -0.454326502287152, -0.465124020329030, -0.260764224383015, -0.266405559173948, -0.237283623548776, -0.271224526747735, -0.320086926706107, -0.249353892709193, -0.241246422896001, -0.245486264273016, -0.302565346668632, -0.283785823994845, -0.282619053543948, -0.328295734278742, -0.192901851389046, -0.254243368687387, -0.246890340825031, -0.280570515333163, -0.241801562353596, -0.271151804063531, -0.265391502730347, -0.452564111538745, -0.457674730325576, -0.449601130600087, -0.459601852368803, -0.454147668587520, -0.448922932387875, -0.458722103240935, -0.452867579367921, -0.456628241998785, -0.451632969573302, -0.447699062579495, -0.462369460437271, -0.459401343485521, -0.466413022427727, -0.465419987935184, -0.397128159199368, -0.384082624902792, -0.388010078392084, -0.371513683409782, -0.379072858252143, -0.382957901342264, -0.393302433992645, -0.378607085351951, -0.366070031486966, -0.390324554627094, -0.358083966986187, -0.405159232035796, -0.408536058439525, -0.402568513401922, -0.404042604084960, -0.403442581306979, -0.390611323255539, -0.388608020455881, -0.388205147105909, -0.459160082893752, -0.455796005159578, -0.462978436464233, -0.445658157583295, -0.459160082893752, -0.462978436464233, -0.459160082893752, -0.462978436464233, -0.459160082893752, -0.462978436464233, -0.459160082893752, -0.462978436464233, -0.435269510046111, -0.445782568768696, -0.450602701433552, -0.434554257670807, -0.435269510046111, -0.445782568768696, -0.450602701433552, -0.434554257670807, -0.435269510046111, -0.450602701433552, -0.435269510046111, -0.450602701433552, -0.435269510046111, -0.450602701433552, 0.490148491024994, 0.343446367142837, 0.468909275761798, 0.490148491024994, 0.343446367142837, 0.468909275761798, 0.490148491024994, 0.468909275761798, 0.490148491024994, 0.490148491024994, 0.305926514756817, 0.233751200663184, 0.199649970507922, 0.272061525735601, 0.233751200663184, 0.680948630272350, 0.587582502956514, 0.734727273333442, 0.474490962034151, 0.587582502956514, 0.381427198255032, 0.368973816482603, 0.473185690834583, 0.385793727480614, 0.381427198255032, 1.48634759853398, 1.18501841085869, 1.33116184443119, 1.26176879539380, 1.48634759853398, 0.0946746382493046, 0.134641577528356, 0.0677739174046016, 1.14681149328697, 0.0946746382493046, 0.134641577528356, 0.0946746382493046, 0.0946746382493046, 0.565677155545849, 0.472752452057500, 0.243639627813908, 11.3120375885850, 0.144738215611596, 0.0946543722512796, 0.0381962154643959, 0.0566104928960270, -0.262241491515252, 0.0541423294345829, -0.00205263232167131, 0.0541423294345829, 0.0541423294345829, 0.0541423294345829, 0.0541423294345829, 1.99287556335306, 2.19898005477759, 1.79741730011656, 2.35324724326977, -0.424539130206231, -0.433289854935123, -0.455959077281552, -0.431026125077710, -0.424539130206231, -0.433289854935123, -0.455959077281552, -0.431026125077710, -0.424539130206231, -0.455959077281552, -0.431026125077710, -0.424539130206231, -0.369164007003499, -0.345404704861329, -0.375796199840768, -0.363529420904128, -0.369164007003499, -0.345404704861329, -0.369164007003499, -0.345404704861329, -0.369164007003499, -0.169002532488381, -0.0940874589394906, -0.129013257628514, -0.169002532488381, -0.160395859374761, -0.129013257628514, -0.169002532488381, -0.129013257628514, -0.169002532488381, -0.129013257628514, -0.169002532488381, -0.129013257628514, -0.0797565032844359, -0.0486139495704364, -0.114988552881947, -0.0382297239152158, -0.0797565032844359, -0.0486139495704364, -0.0797565032844359, -0.0486139495704364, -0.488111489300505, -0.484996041146409, -0.482629700627788, -0.488111489300505, -0.424767055623732, -0.412171508201987, -0.407336425627621, -0.355653273627718, -0.455095223917619, -0.425685840073863, -0.381838385327480, -0.399984964586631, -0.404866358181129, -0.398395540185751, -0.399984964586631, -0.398395540185751, -0.352857181852127, -0.421878327521780, -0.380796047776644, -0.425717543292975, -0.352857181852127, -0.380796047776644, -0.425717543292975, -0.352857181852127, -0.425717543292975, -0.352857181852127, -0.425717543292975, 0.0274677904397428, 0.0379257102791340, 0.0204218173894372, 0.0449387535706461, 0.0379257102791340, 0.400648885183352, 0.335284758670244, 0.232642212956276, 0.312437414197087, -0.288891976410425, -0.298741385904160, -0.288891976410425, -0.298741385904160, -0.298741385904160, -0.298741385904160, -0.298741385904160, -0.162903188437913, -0.243795084453742, -0.237401765918999, -0.222316693389635, -0.243795084453742, -0.237401765918999, -0.222316693389635, -0.237401765918999, -0.222316693389635, -0.237401765918999, -0.222316693389635, -0.237401765918999, -0.222316693389635, -0.262270711030727, -0.252991030710321, -0.269163567602038, -0.262270711030727, -0.269163567602038, -0.269163567602038, -0.320231968125509, -0.320196896169068, -0.329461375374193, -0.320645239981881, -0.320231968125509, -0.329461375374193, -0.329461375374193, -0.291021959523801, -0.130576576715280, -0.213673502951809, -0.210269432406720, -0.218579408813314, -0.130576576715280, -0.213673502951809, -0.218579408813314, -0.0303873363907555, 0.140117833220232, 0.141520771626209, 0.119929403047299, 0.146888048493643, 0.140117833220232, 0.141520771626209, 0.119929403047299, 0.141520771626209, 0.141520771626209, 0.141520771626209, 0.0749759872667360, 0.0414275773972281, 0.0749759872667360, 0.311823609207830, 0.239452003869262, 0.238379998257423, 0.311823609207830, 0.239452003869262, 0.238379998257423, 0.311823609207830, 0.239452003869262, 0.311823609207830, 0.311823609207830, -0.130700977433798, -0.167146193596160, -0.0615386598768579, -0.144889324695907, -0.130700977433798, -0.0615386598768579, -0.130700977433798, -0.401382708655795, -0.401280247512171, -0.359434869405504, -0.453125206740792, -0.401382708655795, -0.401280247512171, -0.401382708655795, -0.401382708655795, -0.401382708655795, -0.199922817196940, 0.120468538533776, 0.0252623460102056, 0.224394100493349, -0.178790540101980, -0.295233752499250, -0.479535261282215, -0.460194978857168, -0.178790540101980, -0.295233752499250, -0.425698191828129, -0.425698191828129, -0.388123069706955, -0.458102179795361, -0.489346851293502, -0.489346851293502, -0.406443557513611, -0.411844850201016, -0.406443557513611, -0.411844850201016, -0.406443557513611, -0.411844850201016, -0.411844850201016, -0.317037308416094, -0.307194671977445, -0.356310292961308, -0.327837839444650, -0.317037308416094, -0.307194671977445, -0.327837839444650, -0.401824072625035, -0.386891377953320, -0.300612907082113, -0.300612907082113, -0.300612907082113, -0.300612907082113},
+            {0.0146878036505866, -0.0715201014611666, -0.0154441781599043, -0.0641364210551600, -0.00266091291952416, -0.117182736233026, -0.0735867293423339, -0.0570537062929955, 0.00463733399775743, 0.0256346284929428, -0.0246765362312497, -0.0160655869691669, -0.0508538226494937, -0.0141936417733490, -0.0127266472030019, -0.0730303292553236, -0.0664265944324324, -0.0246765364704428, 1.48186516228254, 1.52037374551689, 1.09405796722225, 1.29245423786242, 1.23252202774826, 0.892241080465828, 1.42196291085630, 1.26696582467700, 1.45490914734366, 1.24285517020238, 0.977756714834265, 1.55284931972475, 1.44779575855285, 1.17290777010029, 1.17290777010029, 1.26696582467700, 1.17290777010029, 1.20470204429025, 1.35858632807581, 0.126876175563901, 0.257400040762596, 0.140519932285093, 0.162304082115068, 0.104331144506133, 0.230656835238993, 0.197141523090582, 0.143568169911863, 0.195074895209414, 0.162888700678495, 0.140519932285093, 0.235646063077548, 0.257762606449042, 0.143643156577770, 0.159942221229570, 2.13779485912842, 2.01611840787698, 1.80084468535214, 1.75315327406719, 1.57942028230350, 1.86443323373208, 1.66689658924460, 1.80497793701620, 1.98167461094824, 1.60156272331805, 1.78494754825716, 1.76110184261468, 2.19538270334008, 1.71282165202887, 1.83804398212289, 1.99889650941261, 2.30810785649804, 1.80879325389964, 1.78494754825716, 0.0146878057116800, 0.0424139932373443, 0.0897147937676463, 0.0551843062345696, 0.0146878057116800, 0.0897147937676463, 0.0146878057116800, 0.0897147937676463, 0.0146878057116800, 0.0897147937676463, 0.0146878057116800, 0.0897147937676463, -0.0438747173255158, -0.0539537632571007, -0.0416065374409651, -0.0322020706585786, -0.0438747173255158, -0.0539537632571007, -0.0416065374409651, -0.0322020706585786, -0.0438747173255158, -0.0416065374409651, -0.0438747173255158, -0.0416065374409651, -0.0438747173255158, -0.0416065374409651, -0.499485899868839, -0.446495101855180, -0.492335989415017, -0.499485899868839, -0.446495101855180, -0.492335989415017, -0.499485899868839, -0.492335989415017, -0.499485899868839, -0.499485899868839, -0.495346379428251, -0.493112187129704, -0.509708636158468, -0.507276715414884, -0.493112187129704, -0.563188707155963, -0.542444595595567, -0.569450891541650, -0.561562402655941, -0.542444595595567, -0.494633631062968, -0.467435901227490, -0.507936630468358, -0.490196086502091, -0.494633631062968, -0.574217584013908, -0.538202250696055, -0.537663264229382, -0.554305844666604, -0.574217584013908, -0.523589731735383, -0.544285831877649, -0.538021602696807, -0.517911723793302, -0.523589731735383, -0.544285831877649, -0.523589731735383, -0.523589731735383, 0.388648661426724, 0.0958765461173931, 0.457536235191985, 2.52416124374966, -0.160589900696309, -0.177760082459930, -0.136847488254109, -0.141402740079129, 8.36238608682430, -0.465685910978104, -0.474452343658915, -0.465685910978104, -0.465685910978104, -0.465685910978104, -0.465685910978104, 1.11196850169663, 0.312872585857810, 0.288448813741144, 1.24285484615520, -0.516361751884633, -0.523802230967843, -0.532464743079345, -0.501969164869399, -0.516361751884633, -0.523802230967843, -0.532464743079345, -0.501969164869399, -0.516361751884633, -0.532464743079345, -0.501969164869399, -0.516361751884633, -0.544912082031247, -0.503445327828003, -0.529687041658847, -0.539134965439934, -0.544912082031247, -0.503445327828003, -0.544912082031247, -0.503445327828003, -0.544912082031247, -0.349432362341764, -0.423499475892707, -0.447843210123798, -0.349432362341764, -0.398637786232781, -0.447843210123798, -0.349432362341764, -0.447843210123798, -0.349432362341764, -0.447843210123798, -0.349432362341764, -0.447843210123798, -0.385323359617264, -0.384779914380513, -0.394577263980320, -0.388063537087760, -0.385323359617264, -0.384779914380513, -0.385323359617264, -0.384779914380513, 2.34702486688598, 4.05937350301211, 3.65392084092929, 2.34702486688598, 1.07063619762551, 0.944670306552827, 1.38751911392757, 1.19154580075536, 0.971241248296592, 1.00598783060296, 1.36072950401619, 0.0951169728004483, 0.115779112618027, 0.137167821487774, 0.0951169728004483, 0.137167821487774, 0.0861426361794709, 0.263995288719754, 0.0603565854650902, 0.108985959231675, 0.0861426361794709, 0.0603565854650902, 0.108985959231675, 0.0861426361794709, 0.108985959231675, 0.0861426361794709, 0.108985959231675, 0.516583152575397, 0.575807514235328, 0.480122738905976, 0.557221045313747, 0.575807514235328, 0.735239725398820, 0.602759112289538, 0.606075485570604, 0.587438934636138, -0.558443506780906, -0.560356518538487, -0.558443506780906, -0.560356518538487, -0.560356518538487, -0.560356518538487, -0.560356518538487, -0.552654193154295, -0.566902213382612, -0.557629980210787, -0.557747237574831, -0.566902213382612, -0.557629980210787, -0.557747237574831, -0.557629980210787, -0.557747237574831, -0.557629980210787, -0.557747237574831, -0.557629980210787, -0.557747237574831, -0.512450842115765, -0.516180978743920, -0.521398499483264, -0.512450842115765, -0.521398499483264, -0.521398499483264, -0.529397098370384, -0.522796956226171, -0.524478028406689, -0.530356909115416, -0.529397098370384, -0.524478028406689, -0.524478028406689, -0.567360584888808, -0.548668214477132, -0.543611888049474, -0.543500251088595, -0.527913842886170, -0.548668214477132, -0.543611888049474, -0.527913842886170, -0.491899495847044, -0.498429827032548, -0.467405353370493, -0.480587170568557, -0.473139408679441, -0.498429827032548, -0.467405353370493, -0.480587170568557, -0.467405353370493, -0.467405353370493, -0.467405353370493, -0.474727674100595, -0.464117706265432, -0.474727674100595, -0.503922240823354, -0.468124063080712, -0.481911379760844, -0.503922240823354, -0.468124063080712, -0.481911379760844, -0.503922240823354, -0.468124063080712, -0.503922240823354, -0.503922240823354, -0.180821754511368, -0.201201001246597, -0.135707133264597, -0.220575637624468, -0.180821754511368, -0.135707133264597, -0.180821754511368, -0.525005475944051, -0.513778466463775, -0.531689241608024, -0.514876674700704, -0.525005475944051, -0.513778466463775, -0.525005475944051, -0.525005475944051, -0.525005475944051, 0.438749011119932, 0.664199307188112, 0.139593823463500, 0.664199277963077, -0.377549732273387, -0.378508279996288, -0.443301159193859, -0.359997042390898, -0.377549732273387, -0.378508279996288, -0.374699993643990, -0.374699993643990, -0.552527738764995, -0.529297869604807, -0.540649756477113, -0.540649756477113, -0.246344538911226, -0.250384714193122, -0.246344538911226, -0.250384714193122, -0.246344538911226, -0.250384714193122, -0.250384714193122, -0.525814870547797, -0.526240155150164, -0.551641502928304, -0.555111024192912, -0.525814870547797, -0.526240155150164, -0.555111024192912, -0.157390593752744, -0.147035345820185, -0.454777845783357, -0.454777845783357, -0.454777845783357, -0.454777845783357},
+            {0.746652481987945, 1.26105059165182, 1.05723073915883, -0.506749404680611, 0.593626735473724, 0.0404471064820669, -0.586908921744923, 0.216619551560428, 0.941567458493259, 0.570350583248558, -0.0421640764210375, 0.793993850384826, -0.360756941393818, 1.19821784373011, 0.765698900398831, -0.0821038220422749, 0.920111611243153, 1.11128203089680, 0.262402539232842, 1.40961457512035, 1.52394300203970, 0.236468747229413, 0.215359023962812, 1.80301766858827, -0.215580968676673, 1.59950828546875, 1.32858590837004, -0.175726794119504, 2.20342168186837, 0.137672291237078, 0.236637146695239, -0.121476385097831, -0.230369952383949, 1.67607299504352, 0.154427489554299, -0.162912527275333, 1.04546526638195, -0.302888686519197, 0.923935156769341, 1.55766184100970, 1.12351979012344, 1.55576720988604, -0.242445071735610, 1.95812619286061, -0.0513997174832906, 0.0401130502127249, 1.32379392878224, 0.619799139098112, 0.472650095115247, 0.904372843577969, 0.191766642773318, 1.06499357056068, 1.27139371975480, 0.380139272604670, -0.577744864168958, 0.342920247994823, 0.115990722878870, 1.06158718397182, 2.35291707345733, 1.22926313548044, 1.09932402322577, 1.48929220641682, -0.693320379640610, 1.90135747130601, 0.513422513013761, 0.571554063470129, 0.334299511822442, 2.72206460998923, 0.108139577750639, 1.63198798960715, 0.00248893437970992, 0.747092405022448, -0.193455089024266, -0.0207973656960025, 0.992509393970536, 0.747092405022448, -0.0207973656960025, 0.747092405022448, -0.0207973656960025, 0.747092405022448, -0.0207973656960025, 0.747092405022448, -0.0207973656960025, 0.782446144995354, -0.307117871801016, -0.270987409861955, 1.00970561238718, 0.782446144995354, -0.307117871801016, -0.270987409861955, 1.00970561238718, 0.782446144995354, -0.270987409861955, 0.782446144995354, -0.270987409861955, 0.782446144995354, -0.270987409861955, 0.690011294230760, -0.382125846248701, 0.896664316889851, 0.690011294230760, -0.382125846248701, 0.896664316889851, 0.690011294230760, 0.896664316889851, 0.690011294230760, 0.690011294230760, 2.35331475949226, 0.512110971897181, 1.15525732984078, 2.56691220311994, 0.512110971897181, 2.18300640069863, -0.328959885904351, 0.528212319519730, 2.99212524259019, -0.328959885904351, 2.26087113220827, 0.522210003054581, 1.39277024027806, 2.75354982477407, 2.26087113220827, 2.08211811616256, -0.0194932297676597, 1.29415288013456, 2.51331399919555, 2.08211811616256, 0.173841150448476, -0.836938520165749, -0.116177835781395, 0.412256671051930, 0.173841150448476, -0.836938520165749, 0.173841150448476, 0.173841150448476, -0.169183624646849, -1.12131585002422, -0.416042979703697, -0.110207059932810, 0.685796645059184, -0.687395680518830, -0.0466889206998595, 0.334394133672133, -1.55028427986226, 0.883907097421726, 0.0586298605315750, 0.883907097421726, 0.883907097421726, 0.883907097421726, 0.883907097421726, 0.279572702357546, -1.88650190423760, 0.632381925243329, 0.732198925881166, 0.197104686427017, -0.279385716121005, -0.532218041156286, 0.0643529739735787, 0.197104686427017, -0.279385716121005, -0.532218041156286, 0.0643529739735787, 0.197104686427017, -0.532218041156286, 0.0643529739735787, 0.197104686427017, 0.254700869200498, -0.912479668166473, -0.340760739025025, 0.171503579361775, 0.254700869200498, -0.912479668166473, 0.254700869200498, -0.912479668166473, 0.254700869200498, -1.89355356330251, -1.68156894224614, -1.57478077968220, -1.89355356330251, -1.59428330283521, -1.57478077968220, -1.89355356330251, -1.57478077968220, -1.89355356330251, -1.57478077968220, -1.89355356330251, -1.57478077968220, 0.163240760620832, -0.980696262202460, -0.426603875194079, -0.170607614918133, 0.163240760620832, -0.980696262202460, 0.163240760620832, -0.980696262202460, -1.60149047085309, -1.30306399044543, -1.42029621108536, -1.60149047085309, 0.421574866249710, -0.287728894867627, 1.08741264081401, 0.144112336606881, -0.00174793035657583, -0.484171808545769, 0.643494918656688, -0.568070122870895, -0.696040277853307, 0.0694093462080534, -0.568070122870895, 0.0694093462080534, 0.370638141830822, -0.249954755406262, -0.542076266562879, 0.552835393205272, 0.370638141830822, -0.542076266562879, 0.552835393205272, 0.370638141830822, 0.552835393205272, 0.370638141830822, 0.552835393205272, -1.16349580222016, -1.49178013873109, -1.31896155825835, -0.923147527486940, -1.49178013873109, -1.41195755773155, -1.45112112991909, -1.31141868837375, -1.16864048818101, -0.751241293631580, -0.940358830546292, -0.751241293631580, -0.940358830546292, -0.940358830546292, -0.940358830546292, -0.940358830546292, -0.922091602497640, -1.29422672108368, -1.12606860954099, -1.01736702861656, -1.29422672108368, -1.12606860954099, -1.01736702861656, -1.12606860954099, -1.01736702861656, -1.12606860954099, -1.01736702861656, -1.12606860954099, -1.01736702861656, -0.418835558467606, -0.876543660985182, -0.354298520186538, -0.418835558467606, -0.354298520186538, -0.354298520186538, -0.672166773777051, -0.953966549596707, -1.07839510473839, -0.573309430681438, -0.672166773777051, -1.07839510473839, -1.07839510473839, -0.771191693539798, 0.434625002052529, 0.155593943834686, -0.389453691408209, 0.585379001375486, 0.434625002052529, 0.155593943834686, 0.585379001375486, 0.526561236809189, 0.0625971215628006, -0.565507653474784, -0.470689703429145, 0.0187671837212449, 0.0625971215628006, -0.565507653474784, -0.470689703429145, -0.565507653474784, -0.565507653474784, -0.565507653474784, 0.591127895843202, 0.381829026853781, 0.591127895843202, 0.501692969113144, -0.597934698496828, 0.188777689388023, 0.501692969113144, -0.597934698496828, 0.188777689388023, 0.501692969113144, -0.597934698496828, 0.501692969113144, 0.501692969113144, 1.65583872958623, -0.767690410835019, -0.155182333554967, 0.858877561181861, 1.65583872958623, -0.155182333554967, 1.65583872958623, -0.0767729093105824, -0.954094906192809, -0.768386772795495, -0.0783746240995459, -0.0767729093105824, -0.954094906192809, -0.0767729093105824, -0.0767729093105824, -0.0767729093105824, 3.40431283021840, -0.372278317225116, 1.20243770396007, 2.51135299564400, 1.58684267092178, -1.07785342893219, 0.206855125204832, 0.367806068729651, 1.58684267092178, -1.07785342893219, 0.155450502595880, 0.155450502595880, -0.154571268392329, -0.925836433615535, 0.0570067529765944, 0.0570067529765944, 0.0313628603793186, 0.400553730975719, 0.0313628603793186, 0.400553730975719, 0.0313628603793186, 0.400553730975719, 0.400553730975719, -0.116810567976282, -0.785173237463049, -0.831455115409628, 0.449076364029460, -0.116810567976282, -0.785173237463049, 0.449076364029460, -0.692448213026071, 0.588093414263563, 0.643831717588340, 0.643831717588340, 0.643831717588340, 0.643831717588340},
+            {0.231214382539635, 0.759654352692475, 0.573760963020423, 0.284597735940930, 0.681006410683275, 0.693998931720632, 0.467617275145568, 0.717508293319345, 0.639963047968708, 0.674673165643432, 0.658695306541066, 0.764970156295444, 0.727483622692381, 0.720470209620153, 0.650473798871370, 0.640386981900739, 0.666988953244499, 0.615928101981335, 0.857823398292310, 1.21484275530793, 1.33168784724604, 0.432010103901961, 0.312681368088020, 1.28152732859875, 0.687038451835498, 1.28674476079208, 1.21859211132117, 0.697333254072230, 1.24484462994305, 1.21594310979008, -0.376909942688284, 1.32411465400942, 1.30971542181418, 1.32902151360945, 1.23135369376351, 1.22768397174856, 1.26381063772213, 1.25343573305183, 1.17205868707798, 1.25852856145961, 1.13521906260214, 1.04825779960757, 0.492336136647599, 1.21085356042929, -0.0269018907861091, 1.01638218383641, 1.30341168819723, 0.601727017911226, 1.25674194928639, 1.18452421842082, 1.14135978074025, 1.22096473603469, 1.64875529575885, 1.46768210515928, 1.80239785299724, 0.898522929508411, 1.25819644084325, 1.61515818031894, 1.64280710452247, 0.814056084401213, 1.47415400704319, 1.24616374370283, 1.38452828415317, 1.66789368772245, 1.61497549055817, 1.54818832994016, 1.59372070798141, 1.65136729090250, 1.62546516187306, 1.63762152592845, 1.50306021154901, 0.670922404324348, 0.308079928293169, 0.692966500354670, 0.391483425305660, 0.670922404324348, 0.692966500354670, 0.670922404324348, 0.692966500354670, 0.670922404324348, 0.692966500354670, 0.670922404324348, 0.692966500354670, 0.710263004781530, 0.400638056061107, 0.599996617972085, 0.782560838080664, 0.710263004781530, 0.400638056061107, 0.599996617972085, 0.782560838080664, 0.710263004781530, 0.599996617972085, 0.710263004781530, 0.599996617972085, 0.710263004781530, 0.599996617972085, -0.135628062381722, -0.0461330329359392, -0.204131101445074, -0.135628062381722, -0.0461330329359392, -0.204131101445074, -0.135628062381722, -0.204131101445074, -0.135628062381722, -0.135628062381722, 1.95582774061669, 1.77700491312152, 1.61274808078270, 1.71282600016488, 1.77700491312152, 1.82087715651623, 1.67711249411180, 1.95379192087238, 1.87992717154822, 1.67711249411180, 1.52810557244399, 1.21679706731283, 1.47422380390051, 1.46647494743238, 1.52810557244399, 1.36338358386815, 1.22931600027805, 1.00030314271269, 1.36673430145469, 1.36338358386815, -0.0249550737457550, 0.189644498565838, -0.415473174791648, 0.0650702244415299, -0.0249550737457550, 0.189644498565838, -0.0249550737457550, -0.0249550737457550, -0.309819938659154, -1.04053682254237, -0.235847917654961, -0.0181800942330890, -0.0502383997650206, -0.212297802186540, -0.116979185289919, -0.162076855387610, 0.361999640094659, 0.298307899833394, 0.140278914595514, 0.298307899833394, 0.298307899833394, 0.298307899833394, 0.298307899833394, 0.0892883286249521, 0.110087792105655, 0.144701412111872, 0.0825672191699474, -0.0167316923349238, -0.447086466803769, -0.146255453670104, -0.106280123403084, -0.0167316923349238, -0.447086466803769, -0.146255453670104, -0.106280123403084, -0.0167316923349238, -0.146255453670104, -0.106280123403084, -0.0167316923349238, -0.0105239879511963, -0.127146573129401, -0.652884842781702, -0.547496272584674, -0.0105239879511963, -0.127146573129401, -0.0105239879511963, -0.127146573129401, -0.0105239879511963, -1.48092548079475, -1.34808004486064, -1.55733992336978, -1.48092548079475, -1.55532401212504, -1.55733992336978, -1.48092548079475, -1.55733992336978, -1.48092548079475, -1.55733992336978, -1.48092548079475, -1.55733992336978, -0.316077297182987, -0.308690072754117, -0.509923312671711, -0.433073459500191, -0.316077297182987, -0.308690072754117, -0.316077297182987, -0.308690072754117, -1.35536023182711, -1.40097622556656, -1.46655388628126, -1.35536023182711, 0.946528645849249, 0.836730694323816, 0.737607446050449, 0.554257659970582, 0.848830377709846, 0.537410853416373, 0.686575637774894, -0.835848638187543, -0.713352577200754, -0.713536906485012, -0.835848638187543, -0.713536906485012, 0.172741479777548, -0.0822578251683793, 0.171854263349629, 0.270785921591835, 0.172741479777548, 0.171854263349629, 0.270785921591835, 0.172741479777548, 0.270785921591835, 0.172741479777548, 0.270785921591835, -1.66288729312809, -1.70604048836185, -1.68982349304699, -1.73050264732824, -1.70604048836185, -1.72633802343573, -2.01002126034521, -1.67226981764921, -1.68044424757286, -1.12321541595285, -1.48014483339394, -1.12321541595285, -1.48014483339394, -1.48014483339394, -1.48014483339394, -1.48014483339394, -1.61387350405606, -1.42062357246624, -1.59862804352024, -1.57040317813503, -1.42062357246624, -1.59862804352024, -1.57040317813503, -1.59862804352024, -1.57040317813503, -1.59862804352024, -1.57040317813503, -1.59862804352024, -1.57040317813503, -0.972115525436076, -0.963738028816805, -1.10196180446430, -0.972115525436076, -1.10196180446430, -1.10196180446430, -1.11210319414552, -1.15437081247485, -1.43282888800881, -1.30935965271949, -1.11210319414552, -1.43282888800881, -1.43282888800881, -1.47058219550612, -0.00135436726666069, -0.0248136062899834, -0.518701555676455, -0.447042199669429, -0.00135436726666069, -0.0248136062899834, -0.447042199669429, -0.157697453917382, -0.448459919056492, -0.168054089611604, -0.165041113864838, -0.456230089330041, -0.448459919056492, -0.168054089611604, -0.165041113864838, -0.168054089611604, -0.168054089611604, -0.168054089611604, -0.149464235365586, -0.157571913261266, -0.149464235365586, -0.0538584676398656, -0.289785195779601, -0.163392690100400, -0.0538584676398656, -0.289785195779601, -0.163392690100400, -0.0538584676398656, -0.289785195779601, -0.0538584676398656, -0.0538584676398656, 1.07655269606775, 1.05805324983155, 0.796634507753521, 0.598030595085087, 1.07655269606775, 0.796634507753521, 1.07655269606775, -0.688616852028498, -0.460867598641761, -0.531277871963968, -0.612379712208465, -0.688616852028498, -0.460867598641761, -0.688616852028498, -0.688616852028498, -0.688616852028498, 2.62180780512001, 2.51145288404189, 2.58724711830089, 2.22455173094889, 0.876213230672054, 0.691224857968713, -0.0346062459022550, 0.274573220863073, 0.876213230672054, 0.691224857968713, -0.381410668897071, -0.381410668897071, -0.558266302417037, -0.696284903410133, -0.703257796830294, -0.703257796830294, 0.0402150482718513, 0.0561741699628573, 0.0402150482718513, 0.0561741699628573, 0.0402150482718513, 0.0561741699628573, 0.0561741699628573, 0.574791520645250, 0.425960730644230, 0.129577042096975, 0.417413660452146, 0.574791520645250, 0.425960730644230, 0.417413660452146, 0.102643887007419, 0.0839088178233579, -0.0143604729272548, -0.0143604729272548, -0.0143604729272548, -0.0143604729272548},
+            {-0.748863403637009, -1.17957946825521, -0.788373516893258, 1.31311455691775, -0.535977856925875, 2.12984416587385, 2.17338417270776, 0.0830943823934754, -0.854878661524892, 0.304456176855422, 0.376996919255485, -0.787024701666123, 1.19558567983422, -0.726019567387843, -0.878296988673828, 0.678682327785494, -0.562736205299652, -0.957636779524893, 0.788661270836098, -0.641074171010679, -1.28495438928320, 0.318137880004040, 0.275808230653592, -0.993443087728918, 1.66143533649873, -0.593936437570384, -0.258908688745897, 1.71025341051400, -1.28033381515686, 1.29523635178962, -0.858120699128343, 0.935011105891908, 1.22088961780812, -1.08344225215906, 1.43870080479111, 0.984887064727023, -0.418781834191209, 1.44973465461495, -0.716019801183593, -0.757727840506846, -0.274559125692989, -1.23279345481362, 1.32581835694487, -1.26225511210061, -0.265459455640849, 1.43857539542119, -0.799201371557448, -0.511338298648682, 0.0605035396131036, -0.195051155802495, 0.242307497599998, -0.354178973306550, -0.534683047467867, 0.998992840022473, 1.24447672808786, 0.958676264777589, 0.182003471774160, -0.476697282711382, -1.06546455318109, -0.321979211443012, -0.633411755163303, -0.472050491019262, 2.06572300745341, -1.09237549503676, 0.332923862190279, 0.824008348775133, 0.663018963282930, -1.63422259557570, 1.11670584415779, -0.734522757614081, 1.34625597642015, -0.691610522539409, 0.759146815962733, 1.03860335326562, -1.16910126168017, -0.691610522539409, 1.03860335326562, -0.691610522539409, 1.03860335326562, -0.691610522539409, 1.03860335326562, -0.691610522539409, 1.03860335326562, -0.618218857025345, 1.45195529451773, 1.02255675319333, -0.841413585544158, -0.618218857025345, 1.45195529451773, 1.02255675319333, -0.841413585544158, -0.618218857025345, 1.02255675319333, -0.618218857025345, 1.02255675319333, -0.618218857025345, 1.02255675319333, -1.02275704467417, 1.16940822572881, -1.20008450432819, -1.02275704467417, 1.16940822572881, -1.20008450432819, -1.02275704467417, -1.20008450432819, -1.02275704467417, -1.02275704467417, -0.720946166365106, 0.757769729259143, 0.550292612648572, -1.19870475962254, 0.757769729259143, -1.10383522928156, 1.41403067949023, 0.922442380696744, -1.32695360065029, 1.41403067949023, -0.769249433708676, 0.495245148351054, 0.390828920338764, -1.09621189814630, -0.769249433708676, -1.18892929254667, 0.669192535521923, -0.271962136862170, -1.37520370795266, -1.18892929254667, -0.916310767588616, 2.06716364456989, -0.285511060726067, -1.07643316113618, -0.916310767588616, 2.06716364456989, -0.916310767588616, -0.916310767588616, -1.17832736805757, -0.584804388220423, -0.121767139371858, -1.03932950629037, -1.40275897367131, 1.06252368034906, 0.712248544344382, -0.180359653507658, 2.44723619184903, -0.994885778756078, 0.420919436749478, -0.994885778756078, -0.994885778756078, -0.994885778756078, -0.994885778756078, -1.54740711352197, 2.57545579485412, -1.10478679401902, -1.39940227952446, -0.834994268932898, 0.268635249640068, 0.986692814671913, -0.217682110250317, -0.834994268932898, 0.268635249640068, 0.986692814671913, -0.217682110250317, -0.834994268932898, 0.986692814671913, -0.217682110250317, -0.834994268932898, -0.329955271533458, 1.94767098723717, 0.0780780075967514, -1.02665011155489, -0.329955271533458, 1.94767098723717, -0.329955271533458, 1.94767098723717, -0.329955271533458, -0.109487411491573, 0.457016554542513, -0.156787403875798, -0.109487411491573, -0.0438357271577242, -0.156787403875798, -0.109487411491573, -0.156787403875798, -0.109487411491573, -0.156787403875798, -0.109487411491573, -0.156787403875798, -0.845603442518522, 1.83875065391607, 0.404512314943238, -0.401860388986373, -0.845603442518522, 1.83875065391607, -0.845603442518522, 1.83875065391607, 0.0726945868792075, 0.215489706634699, -0.502042661353760, 0.0726945868792075, -0.0672343609277610, 0.479925391023872, -1.09594265461945, -0.476435107053653, 0.404416868505632, 1.23647565861439, -0.736571473110903, 0.339413495037852, 1.30490592164706, -0.937430768683648, 0.339413495037852, -0.937430768683648, -0.434751835476868, 0.569042884088908, 1.07641343256800, -0.697844987189229, -0.434751835476868, 1.07641343256800, -0.697844987189229, -0.434751835476868, -0.697844987189229, -0.434751835476868, -0.697844987189229, -0.425652286243003, 1.97687179786747, 0.612587965290393, -1.21476181047567, 1.97687179786747, -0.401597850873819, -0.721725806696591, 0.571337464776273, -1.02290480542505, -0.104042615090100, -0.402537092147174, -0.104042615090100, -0.402537092147174, -0.402537092147174, -0.402537092147174, -0.402537092147174, -1.18933506072477, 0.827846745386210, -0.251027591819956, -0.517707234039079, 0.827846745386210, -0.251027591819956, -0.517707234039079, -0.251027591819956, -0.517707234039079, -0.251027591819956, -0.517707234039079, -0.251027591819956, -0.517707234039079, 0.0611716646763475, 1.67597895722442, -0.626164350092102, 0.0611716646763475, -0.626164350092102, -0.626164350092102, 0.0268979362964186, 1.07276786192454, 0.189058292514292, -1.06990818894304, 0.0268979362964186, 0.189058292514292, 0.189058292514292, -1.29680980338010, -0.724865632039011, 0.806298564322980, 0.281197209011806, -0.948832389337955, -0.724865632039011, 0.806298564322980, -0.948832389337955, -0.807317943302244, -0.803905431112132, 0.927079869381654, 0.728522766047627, -0.427754403417575, -0.803905431112132, 0.927079869381654, 0.728522766047627, 0.927079869381654, 0.927079869381654, 0.927079869381654, -0.798394909568813, 0.683790282835010, -0.798394909568813, -0.769688245685114, 0.986087515111903, -0.422213918941944, -0.769688245685114, 0.986087515111903, -0.422213918941944, -0.769688245685114, 0.986087515111903, -0.769688245685114, -0.769688245685114, -1.02651219749346, 2.11079209038143, 1.11110350072513, -1.03256930091492, -1.02651219749346, 1.11110350072513, -1.02651219749346, -0.734044558879847, 1.63477920038599, 1.30089837945035, -1.18552155267844, -0.734044558879847, 1.63477920038599, -0.734044558879847, -0.734044558879847, -0.734044558879847, -1.33260964780639, 2.13549797789185, -0.0690600458881005, -0.852526933793239, -1.30867917198782, 1.96076092247263, -0.838293332762362, -0.774049060519241, -1.30867917198782, 1.96076092247263, -0.491907095407903, -0.491907095407903, -0.838254066822840, 0.925599362234278, -0.820782898464703, -0.820782898464703, -0.778736930425014, -0.438678066974198, -0.778736930425014, -0.438678066974198, -0.778736930425014, -0.438678066974198, -0.438678066974198, -0.732695381197886, 0.503720792010490, 1.21397542954061, -0.823786199155863, -0.732695381197886, 0.503720792010490, -0.823786199155863, 1.65078834679289, -0.424743491175061, -1.01280161877701, -1.01280161877701, -1.01280161877701, -1.01280161877701},
+            {-0.759870342387174, -1.39220317548960, -0.817875009275250, 1.10189533390064, -0.447333773783130, 1.10198402035639, 1.10185489287682, 0.461524137822443, -0.915510992641892, 0.786504657777828, 0.893001482310819, -0.815894818091386, 1.10211492156507, -0.726333381774462, -0.949891361448735, 1.10197373272752, -0.486617616728089, -1.06636984657578, 1.10199537222272, -0.601625325673062, -1.54690374931343, 0.806590721020676, 0.744446702497179, -1.11893696948924, 1.10207093308302, -0.532422574763945, -0.0405694423067069, 1.10212840190634, -1.54012029968644, 1.10227597616870, -0.920270617348791, 1.10195812391131, 1.10202942782173, -1.25106444579178, 1.10194535306168, 1.10195883340296, -0.275278679553388, 1.10200424086830, -0.711652758009244, -0.772884192903130, -0.0635457971422700, -1.47032645354978, 1.10216919767598, -1.51357901538931, -0.0501866015676457, 1.10210002224050, -0.833771346975815, -0.411160519586955, 0.428358596086389, 0.0531795910775631, 0.695264386853659, -0.180435432678142, -0.445432868290702, 1.10197302323588, 1.10198827730626, 1.10196309035283, 0.606732245542107, -0.360304158404802, -1.22467144524865, -0.133163068545537, -0.590376158253512, -0.353482218856020, 1.10201240002223, -1.26417931018082, 0.828297972674534, 1.10198189188145, 1.10198969628956, -2.05966325038592, 1.10197054001511, -0.738816887285065, 1.10193861289105, -0.675817576582367, 1.10198437510221, 1.10201062629311, -1.37682015499489, -0.675817576582367, 1.10201062629311, -0.675817576582367, 1.10201062629311, -0.675817576582367, 1.10201062629311, -0.675817576582367, 1.10201062629311, -0.568071514633758, 1.10201559273463, 1.10200459561412, -0.895742959029344, -0.568071514633758, 1.10201559273463, 1.10200459561412, -0.895742959029344, -0.568071514633758, 1.10200459561412, -0.568071514633758, 1.10200459561412, -0.568071514633758, 1.10200459561412, -1.16197269294447, 1.10189675288393, -1.42230655128171, -1.16197269294447, 1.10189675288393, -1.42230655128171, -1.16197269294447, -1.42230655128171, -1.16197269294447, -1.16197269294447, -0.718885138475212, 1.10198756781462, 1.10198472984803, -1.42028095263250, 1.10198756781462, -1.28100330820848, 1.10203971545060, 1.10199856493513, -1.60856265292400, 1.10203971545060, -0.789799005861464, 1.06660131722672, 0.913308197455560, -1.26981152092579, -0.789799005861464, -1.40592962167746, 1.10199572696855, -0.0597331664098119, -1.67939847622920, -1.40592962167746, -1.00569926482802, 1.10144196873888, -0.0796242968229336, -1.24077442239110, -1.00569926482802, 1.10144196873888, -1.00569926482802, -1.00569926482802, -1.39036497132138, -0.519015843249042, 0.160767613762035, -1.18630266915407, -1.71985227089834, 1.10210782664861, 1.10200211239336, 0.0747481371146373, 1.10183963880644, -1.12105497942533, 0.957483985299388, -1.12105497942533, -1.12105497942533, -1.12105497942533, -1.12105497942533, -1.93220972767404, 1.10189923610470, -1.28240029725936, -1.71492431929844, -0.886318781496105, 0.733916072742071, 1.10199359849361, 0.0199551615348945, -0.886318781496105, 0.733916072742071, 1.10199359849361, 0.0199551615348945, -0.886318781496105, 1.10199359849361, 0.0199551615348945, -0.886318781496105, -0.144872696043313, 1.10276162320036, 0.454159614537416, -1.16768809158493, -0.144872696043313, 1.10276162320036, -0.144872696043313, 1.10276162320036, -0.144872696043313, 0.178795441739964, 1.01047804481081, 0.109354479010717, 0.178795441739964, 0.275178462859847, 0.109354479010717, 0.178795441739964, 0.109354479010717, 0.178795441739964, 0.109354479010717, 0.178795441739964, 0.109354479010717, -0.901894074226874, 1.10259524740938, 0.933396743919169, -0.250436361688960, -0.901894074226874, 1.10259524740938, -0.901894074226874, 1.10259524740938, 0.446256232347284, 0.655893276436248, -0.397513625149896, 0.446256232347284, 0.240827005837577, 1.04411043204990, -1.26941624539254, -0.359919259186870, 0.933256619319092, 1.10216387648864, -0.741824599745185, 0.837825381242260, 1.10199182476449, -1.03670546873960, 0.837825381242260, -1.03670546873960, -0.298724185739840, 1.10198260137310, 1.10197337798170, -0.684970373561028, -0.298724185739840, 1.10197337798170, -0.684970373561028, -0.298724185739840, -0.684970373561028, -0.298724185739840, -0.684970373561028, -0.285365167538127, 1.10228200684769, 1.10199679120601, -1.44385425600168, 1.10228200684769, -0.250050930352294, -0.720029725873051, 1.10200353137665, -1.16218962001523, 0.186788929369132, -0.251429827366210, 0.186788929369132, -0.251429827366210, -0.251429827366210, -0.251429827366210, -0.251429827366210, -1.40652532860070, 1.10199998391842, -0.0289992299173617, -0.420510732616103, 1.10199998391842, -0.0289992299173617, -0.420510732616103, -0.0289992299173617, -0.420510732616103, -0.0289992299173617, -0.420510732616103, -0.0289992299173617, -0.420510732616103, 0.429339468286923, 1.10202729934679, -0.579736266784927, 0.429339468286923, -0.579736266784927, -0.579736266784927, 0.379022320755696, 1.10202197815945, 0.617089404589778, -1.23119513224677, 0.379022320755696, 0.617089404589778, 0.617089404589778, -1.56430864362620, -0.724639293096830, 1.10200495035994, 0.752358243841239, -1.05344415039683, -0.724639293096830, 1.10200495035994, -1.05344415039683, -0.845687259169652, -0.840677361284643, 1.10202339714274, 1.10198934154373, -0.288451278825126, -0.840677361284643, 1.10202339714274, 1.10198934154373, 1.10202339714274, 1.10202339714274, 1.10202339714274, -0.832587382791625, 1.10202552561768, -0.832587382791625, -0.790443224275993, 1.10199005103538, -0.280317311850059, -0.790443224275993, 1.10199005103538, -0.280317311850059, -0.790443224275993, 1.10199005103538, -0.790443224275993, -0.790443224275993, -1.16748562040647, 1.10229548718896, 1.10199785544348, -1.17637803395106, -1.16748562040647, 1.10199785544348, -1.16748562040647, -0.738114845301391, 1.10223518039906, 1.10203865121313, -1.40092673002246, -0.738114845301391, 1.10223518039906, -0.738114845301391, -0.738114845301391, -0.738114845301391, -1.61686627708891, 1.10200246713918, 0.238146723772065, -0.912058428919757, -1.58173402451026, 1.10223092344918, -0.891162126217227, -0.796845322143280, -1.58173402451026, 1.10223092344918, -0.382633634232164, -0.382633634232164, -0.891104480020993, 1.10202871833008, -0.865455115409289, -0.865455115409289, -0.803727568481969, -0.304488273244501, -0.803727568481969, -0.304488273244501, -0.803727568481969, -0.304488273244501, -0.304488273244501, -0.736134121998792, 1.07904438171350, 1.10198579408550, -0.869864251243085, -0.736134121998792, 1.07904438171350, -0.869864251243085, 1.10218090428814, -0.284030968497906, -1.14735716503777, -1.14735716503777, -1.14735716503777, -1.14735716503777},
+            {0.00807748085553650, 0.625591585904198, -0.0411498578784241, -0.263186039816633, 0.813608410124607, -0.884603743626652, -0.763924344263941, 2.12463252818764, 0.533894140907224, -0.441318853539060, 2.18148873231194, 1.12016986811597, 1.43509908735797, 0.865145331074714, 0.253014001405086, 1.27152484444923, 0.946541485428841, -1.01447459841414, 1.21076152605558, 0.398497014096557, -0.132628489135916, 0.607275789298017, 0.836472847942274, 0.561921475058992, -0.0835119421687813, 0.118938492536001, 1.37376817422043, 0.370638211267020, -0.786434035366673, 0.913132654264581, -0.0567923769877430, 1.57477043269614, 0.254172627612780, 0.716501983234525, 0.373233295343833, 1.35604106540605, 0.0770310806118117, 0.874225568610481, 0.0128954312848458, -0.680530316068411, -0.289096292447115, -0.897384319643869, 0.457350665940084, -1.04533383404431, -0.398968487608656, -0.322870523380811, -0.297872278746290, -0.116961894123421, 0.784620596578893, -0.129038835890747, 0.423875998898999, 0.215792228973284, 0.0887641417797961, -0.219119253744783, 0.997888782008803, -0.0419422320723215, 0.722014086695218, 0.765881021464601, -0.911586545784448, -0.437460317198248, 0.573056899869385, -0.712547751784097, -0.393482910253674, -0.632145953537235, 0.600079650981565, 0.380330999436682, 0.785947114925546, -1.34298758071757, 0.368245535225754, -0.310945600701237, -0.345457981781413, 0.116496599382934, 0.526488563539253, 0.487541422400223, -0.742799443715990, 0.116496599382934, 0.487541422400223, 0.116496599382934, 0.487541422400223, 0.116496599382934, 0.487541422400223, 0.116496599382934, 0.487541422400223, -0.0688609028420118, 0.0112243931555806, 0.711233834721939, -0.173609724501656, -0.0688609028420118, 0.0112243931555806, 0.711233834721939, -0.173609724501656, -0.0688609028420118, 0.711233834721939, -0.0688609028420118, 0.711233834721939, -0.0688609028420118, 0.711233834721939, -1.27172365303134, -0.159416553457405, -1.38276632592370, -1.27172365303134, -0.159416553457405, -1.38276632592370, -1.27172365303134, -1.38276632592370, -1.27172365303134, -1.27172365303134, 3.58611825743335, 4.49302088355422, 2.05572303207701, 2.22707315252822, 4.49302088355422, 1.62064589436142, 3.26011092681418, 1.54795669451330, -0.582328968236560, 3.26011092681418, -0.352318229289400, 1.09205304830638, -0.214913640888278, -1.54042111920021, -0.352318229289400, 0.127566188316502, 3.75283302080943, -0.718962595083334, -1.43205822216795, 0.127566188316502, 0.173578648262692, -0.0374440863391778, -0.539019933931473, -0.342767765927891, 0.173578648262692, -0.0374440863391778, 0.173578648262692, 0.173578648262692, -0.116181238289476, -0.580254818524919, 0.0190141196689126, 0.250835877881501, -0.724008094756817, 0.136068391114962, -0.474621686811020, -1.06408704506836, -0.337966753855241, -0.753820454721026, 0.784362792659932, -0.753820454721026, -0.753820454721026, -0.753820454721026, -0.753820454721026, 0.120341286752893, -0.326993788126011, -1.08730569694824, -1.21311651286900, 0.197658173476916, 0.622621727369985, 0.696072833676134, 0.511687422674543, 0.197658173476916, 0.622621727369985, 0.696072833676134, 0.511687422674543, 0.197658173476916, 0.696072833676134, 0.511687422674543, 0.197658173476916, -0.148564819488414, -0.453757253445657, -0.324054077736041, -1.03321790209750, -0.148564819488414, -0.453757253445657, -0.148564819488414, -0.453757253445657, -0.148564819488414, -0.293310001625041, 0.409573847107187, -0.438984023583743, -0.293310001625041, -0.184442815625268, -0.438984023583743, -0.293310001625041, -0.438984023583743, -0.293310001625041, -0.438984023583743, -0.293310001625041, -0.438984023583743, -0.312821710129675, -0.371664389327065, -0.0713438102549139, -0.136098615109566, -0.312821710129675, -0.371664389327065, -0.312821710129675, -0.371664389327065, -0.312820964415860, -0.653454938866988, -0.404550901229066, -0.312820964415860, 1.08851559502827, 3.51133892829183, 0.132021082648365, 1.74262507290399, 2.08302681076696, 1.76487887763757, 1.10738471128532, 0.524552690475055, 0.0793670824031241, -0.689986393367027, 0.524552690475055, -0.689986393367027, 0.444424249606728, 0.999411103497213, 1.03749769089353, 0.351791040302253, 0.444424249606728, 1.03749769089353, 0.351791040302253, 0.444424249606728, 0.351791040302253, 0.444424249606728, 0.351791040302253, -0.644901920998551, -1.24178718498217, -0.622354518082879, -1.30473059771449, -1.24178718498217, -0.214949754743042, -1.13577959840251, -0.343239270120173, -0.929170051424126, -0.661701574887934, -0.969045286671415, -0.661701574887934, -0.969045286671415, -0.969045286671415, -0.969045286671415, -0.969045286671415, -1.39330938763849, -0.645425518627350, -0.815596239414594, -0.852732148227106, -0.645425518627350, -0.815596239414594, -0.852732148227106, -0.815596239414594, -0.852732148227106, -0.815596239414594, -0.852732148227106, -0.815596239414594, -0.852732148227106, -0.574410552824837, -0.494077573310061, -1.01297177201547, -0.574410552824837, -1.01297177201547, -1.01297177201547, -0.427832086538871, -1.13317055882430, -0.445738699321611, -1.32641547607236, -0.427832086538871, -0.445738699321611, -0.445738699321611, -0.872606912829185, -0.965547782347693, -1.02345970417320, -0.0129770030021522, -1.01231820712174, -0.965547782347693, -1.02345970417320, -1.01231820712174, -0.984493653862425, -0.174554863497120, 0.491643487566963, 0.00344595888002130, -0.857843057655234, -0.174554863497120, 0.491643487566963, 0.00344595888002130, 0.491643487566963, 0.491643487566963, 0.491643487566963, -1.08767083039131, -0.909821973836650, -1.08767083039131, -0.423484255404758, 0.268569591589664, -0.462321137429687, -0.423484255404758, 0.268569591589664, -0.462321137429687, -0.423484255404758, 0.268569591589664, -0.423484255404758, -0.423484255404758, -0.175634763632040, 0.520376480048978, 0.934084655737956, -0.503894256503587, -0.175634763632040, 0.934084655737956, -0.175634763632040, -0.850827382082055, -0.833197003002566, -0.370549653703921, -0.809503864075149, -0.850827382082055, -0.833197003002566, -0.850827382082055, -0.850827382082055, -0.850827382082055, 0.274370179766286, 0.966470367547794, 1.98882525877863, 0.163273948642405, -0.694900860470129, -0.232569480768028, -0.477888019852038, -0.438743584143621, -0.694900860470129, -0.232569480768028, -0.471195984074645, -0.471195984074645, -0.334774353012471, 0.444707833917585, -0.998300918007323, -0.998300918007323, 0.333759254129109, -0.0851540039897996, 0.333759254129109, -0.0851540039897996, 0.333759254129109, -0.0851540039897996, -0.0851540039897996, 1.47716885183278, 1.83109783830305, 0.829066418329942, 0.435020159214084, 1.47716885183278, 1.83109783830305, 0.435020159214084, 0.232843934132196, -0.207989581583821, -0.471219207733461, -0.471219207733461, -0.471219207733461, -0.471219207733461},
+            {0.305489115308679, 0.305489115308679, 0.182567836410798, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.301237233034322, 0.305489115308679, -0.305735801966496, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.0930184492086217, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.989359812055965, -0.805150547655912, 0.305489115308679, 0.305489115308679, 0.305489115308679, -4.10061639537301, -3.35876505001599, -5.48530480040745, 0.305489115308679, -3.56988080801826, -0.316696539838224, 0.305489115308679, -1.93047792003247, 0.305489115308679, 0.305489115308679, -4.85862770737041, -0.419727513118965, -2.10863726429585, -0.913624230513248, -1.58685211347130, 0.305489115308679, -0.0874047810555463, -0.564396873909662, -0.200474630243951, 0.305489115308679, -0.233470241410002, -1.90120317474321, -0.669819402936397, -0.673989710894159, -1.75204582506311, -0.339695362227079, 0.305489115308679, -0.718369681115585, -1.54602153786089, -1.71903982028676, -2.35924874141170, -0.576499603886324, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.559620567202887, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -4.16236693148931, -0.0381809689644984, -6.85920622263371, -2.69151857326129, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.440661642492699, 0.0230531958135220, 0.0170373229069763, 0.305489115308679, 0.0170373229069763, 0.0170373229069763, 0.0170373229069763, 0.0170373229069763, 0.305489115308679, -4.13188447664887, 0.212768982129600, 0.0818080184554714, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.00276448554629029, 0.305489115308679, 0.0474895057748349, -0.00276448554629029, -0.0162391021694579, 0.0474895057748349, -0.00276448554629029, 0.0474895057748349, -0.00276448554629029, 0.0474895057748349, -0.00276448554629029, 0.0474895057748349, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.513927459867575, -1.37689242322558, 0.305489115308679, -0.513927459867575, 0.305489115308679, -0.00476870452842700, 0.305489115308679, 0.305489115308679, 0.305489115308679, -1.29465314491025, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.195727873083928, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -1.46496908865993, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.457657432511492, 0.305489115308679, 0.305489115308679, 0.0452121865258278, 0.305489115308679, 0.305489115308679, 0.0452121865258278, 0.305489115308679, 0.0452121865258278, 0.305489115308679, 0.0452121865258278, 0.305489115308679, 0.0452121865258278, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.617504587073939, 0.0200521923177877, 0.305489115308679, -0.592446664644113, -0.617504587073939, 0.305489115308679, 0.305489115308679, 0.290972073172454, -7.00299189350891, -1.91041293884145, 0.305489115308679, 0.305489115308679, -7.00299189350891, -1.91041293884145, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.133014493274124, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.0806302313159857, 0.305489115308679, 0.305489115308679, 0.0806302313159857, 0.305489115308679, 0.305489115308679, 0.305489115308679, -0.133949511921237, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.138549929701295, 0.305489115308679, 0.305489115308679, 0.126175148140415, -0.840015284174348, -0.930821973506928, 0.305489115308679, 0.126175148140415, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679, 0.305489115308679}
+        };
+    };
+    // Data that's passed to a callback at each optimization iteration
+    enum data_type
+    {
+        k_to_dsm_data,
+        cycle_data,
+        iteration_data
+    };
+
+    struct k_to_dsm_inputs
+    {
+        rs2_intrinsics_double old_k;
+        rs2_intrinsics_double new_k;
+        z_frame_data z;
+        std::vector<double3> new_vertices;
+        rs2_dsm_params_double previous_dsm_params;
+        algo_calibration_registers new_dsm_regs;
+    };
+
+    struct convert_norm_vertices_to_los_data
+    {
+        double3 laser_incident;
+        std::vector<double3> fovex_indicent_direction;
+        std::vector<double3> mirror_normal_direction;
+        std::vector<double> ang_x;
+        std::vector<double> ang_y;
+        std::vector<double> dsm_x_corr;
+        std::vector<double> dsm_y_corr;
+        std::vector<double> dsm_x;
+        std::vector<double> dsm_y;
+    };
+
+    struct k2dsm_data_params
+    {
+        k_to_dsm_inputs inputs;
+        algo_calibration_registers dsm_regs_orig;
+        std::vector < uint8_t> relevant_pixels_image_rot;
+        convert_norm_vertices_to_los_data first_norm_vertices_to_los_data;
+        pre_process_data dsm_pre_process_data;
+
+        std::vector < double> errL2;
+        std::vector < std::vector < double>> sg_mat;
+        std::vector < double> sg_mat_tag_x_sg_mat;
+        std::vector <double> sg_mat_tag_x_err_l2;
+        std::vector <double> quad_coef;
+        double2 focal_scaling;
+        double2 opt_scaling;
+        double2 new_los_scaling;
+        rs2_dsm_params_double dsm_params_cand;
+        algo_calibration_registers dsm_regs_cand;
+        convert_norm_vertices_to_los_data second_norm_vertices_to_los_data;
+        std::vector< double2> los_orig;
+        std::vector< double2> dsm;
+        std::vector < double3> vertices;
+        rs2_intrinsics_double k_depth;
+    };
+    
+    struct iteration_data_params
+    {
+        size_t iteration;
+        optimization_params params;
+        calib c;
+        std::vector< double2 > uvmap;
+        std::vector< double > d_vals;
+        std::vector< double > d_vals_x;
+        std::vector< double > d_vals_y;
+        std::vector < double2> xy;
+        std::vector<double > rc;
+        coeffs<k_matrix> coeffs_k;
+        coeffs<rotation_in_angles> coeffs_r;
+        coeffs < p_matrix> coeffs_p;
+        p_matrix unit_grad;
+        p_matrix normalized_grads;
+        p_matrix grads_norm;
+        double grads_norma;
+        double cost;
+        int back_tracking_line_search_iters;
+        double t;
+        optimization_params next_params;
+    };
+
+    struct cycle_data_params
+    {
+        size_t cycle;
+        optimization_params new_params;
+        calib new_calib;
+        rs2_intrinsics_double new_k_depth;
+        algo_calibration_registers new_dsm_regs;
+        rs2_dsm_params_double new_dsm_params;
+        std::vector<double3> new_vertices;
+        calib optimaized_calib_candidate;
+    };
+
+    struct data_collect
+    {
+        data_type type;
+
+        cycle_data_params cycle_data_p;
+        k2dsm_data_params k2dsm_data_p;
+        iteration_data_params iteration_data_p;
+
+    };
+
+
+    class optimizer
+    {
+    public:
+        optimizer();
+
+        void set_yuy_data( std::vector< yuy_t > && yuy_data, std::vector< yuy_t > && prev_yuy_data,
+                           calib const & calibration );
+        void set_ir_data( std::vector< ir_t > && ir_data, size_t width, size_t height );
+        void set_z_data( std::vector< z_t > && z_data,
+                         rs2_intrinsics_double const & depth_intrinsics,
+                         rs2_dsm_params const & dms_params, algo_calibration_info const & cal_info,
+                         algo_calibration_registers const & cal_regs, float depth_units );
+
+        // Write dumps of all the pertinent data from the above to a directory of choice, so that
+        // a reproduction can be made
+        void write_data_to( std::string const & directory );
+
+        // (optional) Return whether the scene passed in is valid and can go thru optimization
+        bool is_scene_valid();
+
+        // Optimize the calibration, optionally calling the callback after each iteration
+        size_t optimize( std::function< void( data_collect const & data ) >
+                             iteration_callback = nullptr );
+
+        // (optional) Return whether the results of calibration are valid:
+        //      1. If pixel movement is acceptable
+        //      2. Movement from the camera's factory settings is within thresholds
+        //      3. No worsening of the fit in any image section
+        bool is_valid_results();
+
+        calib const & get_calibration() const;
+        rs2_dsm_params const & get_dsm_params() const;
+
+        double get_cost() const;
+        double calc_correction_in_pixels( std::vector< double2 > const & old_uvmap,
+                                          std::vector< double2 > const & new_uvmap ) const;
+        double calc_correction_in_pixels( calib const & from_calibration, calib const & to_calibration) const;
+        double calc_correction_in_pixels(calib const & to_calibration) const { return calc_correction_in_pixels( _original_calibration, to_calibration); }
+
+        // for debugging/unit-testing
+        z_frame_data    const & get_z_data() const   { return _z; }
+        yuy2_frame_data const & get_yuy_data() const { return _yuy; }
+        ir_frame_data   const & get_ir_data() const  { return _ir; }
+        decision_params const& get_decision_params() const { return _decision_params; };
+        std::vector< double >const& get_extracted_features() const { return _extracted_features; };
+        params const & get_params() const { return _params; }
+        void set_cycle_data(const std::vector<double3>& vertices,
+            const rs2_intrinsics_double& k_depth,
+            const p_matrix& p_mat,
+            const algo_calibration_registers& dsm_regs_cand,
+            const rs2_dsm_params_double& dsm_params_cand);
+
+        void set_final_data(const std::vector<double3>& vertices,
+            const p_matrix& p_mat,
+            const p_matrix& p_mat_opt = p_matrix());
+    private:
+
+        // 1 cycle of optimization
+        size_t optimize_p(const optimization_params& params_curr,
+            const std::vector<double3>& new_vertices,
+            optimization_params& params_new,
+            calib& optimaized_calibration,
+            calib& new_rgb_calib_for_k_to_dsm,
+            rs2_intrinsics_double& new_z_k,
+            std::function<void(data_collect const&data)> cb,
+            data_collect* data);
+
+        calib decompose_p_mat(p_matrix p);
+        rs2_intrinsics_double get_new_z_intrinsics_from_new_calib(const rs2_intrinsics_double& orig, const calib & new_c, const calib & orig_c);
+        void zero_invalid_edges( z_frame_data& z_data, ir_frame_data const & ir_data );
+        std::vector<direction> get_direction( std::vector<double> gradient_x, std::vector<double> gradient_y );
+        std::vector<direction> get_direction2(std::vector<double> gradient_x, std::vector<double> gradient_y);
+        std::vector<uint16_t> get_closest_edges( const z_frame_data& z_data, ir_frame_data const & ir_data, size_t width, size_t height );
+        std::vector<double> blur_edges( std::vector<double> const & edges, size_t image_width, size_t image_height );
+        std::vector< byte > get_luminance_from_yuy2( std::vector< yuy_t > const & yuy2_imagh );
+
+        std::vector<uint8_t> get_logic_edges( std::vector<double> edges );
+        std::vector <double3> subedges2vertices(z_frame_data& z_data, const rs2_intrinsics_double& intrin, double depth_units);
+        
+        optimization_params back_tracking_line_search( optimization_params const & opt_params,
+                                                       const std::vector<double3>& new_vertices,
+                                                       data_collect * data = nullptr ) const;
+       
+        // input validation
+        bool is_movement_in_images(yuy2_frame_data& yuy);
+        bool is_edge_distributed( z_frame_data & z_data, yuy2_frame_data & yuy_data );
+        void section_per_pixel( frame_data const &, size_t section_w, size_t section_h, byte * section_map );
+        void check_edge_distribution(std::vector<double>& sum_weights_per_section, double& min_max_ratio, bool& is_edge_distributed);
+        void sum_per_section(std::vector< double >& sum_weights_per_section, std::vector< byte > const& section_map, std::vector< double > const& weights, size_t num_of_sections);
+        void images_dilation(yuy2_frame_data& yuy);
+        void gaussian_filter(yuy2_frame_data& yuy);
+
+        // svm
+        bool valid_by_svm(svm_model model);
+        void collect_decision_params(z_frame_data& z_data, yuy2_frame_data& yuy_data);// , decision_params& decision_params);
+
+        // output validation
+        void clip_pixel_movement( size_t iteration_number = 0 );
+        std::vector< double > cost_per_section_diff( calib const & old_calib, calib const & new_calib );
+        void clip_ac_scaling( rs2_dsm_params_double const & ac_data_orig,
+                              rs2_dsm_params_double & ac_data_new ) const;
+
+    private:
+        params _params;
+        decision_params _decision_params;
+        svm_features _svm_features;
+        std::vector< double > _extracted_features;
+        svm_model_linear _svm_model_linear;
+        svm_model_gaussian _svm_model_gaussian;
+        yuy2_frame_data _yuy;
+        ir_frame_data _ir;
+        z_frame_data _z;
+        calib _original_calibration;         // starting state of auto-calibration
+        rs2_dsm_params _original_dsm_params;
+        calib _final_calibration;         // starting state of auto-calibration
+        calib _optimaized_calibration;         // the last result of optimize_p that gives the optimal cost but not used for calibration
+        rs2_dsm_params _final_dsm_params;
+        calib _factory_calibration;          // factory default calibration of the camera
+        optimization_params _params_curr;  // last-known setting
+
+        //cycle data from bin files
+        bool get_cycle_data_from_bin = false;
+        bool get_final_data_from_bin = false;
+        rs2_intrinsics_double _k_dapth_from_bin;
+        p_matrix _p_mat_from_bin;
+        p_matrix _p_mat_from_bin_opt;
+        std::vector<double3> _vertices_from_bin;
+        algo_calibration_registers _dsm_regs_cand_from_bin;
+        rs2_dsm_params_double _dsm_params_cand_from_bin;
+
+        std::shared_ptr<k_to_DSM> _k_to_DSM;
+    };
+
+}  // librealsense::algo::depth_to_rgb_calibration
+}  // librealsense::algo
+}  // librealsense
diff --git a/src/algo/depth-to-rgb-calibration/pinv_3x3.cpp b/src/algo/depth-to-rgb-calibration/pinv_3x3.cpp
new file mode 100644
index 0000000..810beff
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/pinv_3x3.cpp
@@ -0,0 +1,939 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+// Code generated by Matlab Coder
+
+#include "utils.h"
+#include <limits>
+#include <cmath>
+#include <cstring>
+
+
+namespace
+{
+
+    static inline bool rtIsNaN( double value ) { return (value != value); }
+    static inline bool rtIsInf( double value )
+    {
+        return (value == std::numeric_limits< double >::infinity()
+            || value == -std::numeric_limits< double >::infinity());
+    }
+
+    double b_xnrm2( int n, const double x[3], int ix0 )
+    {
+        double y;
+        double scale;
+        int kend;
+        int k;
+        double absxk;
+        double t;
+        y = 0.0;
+        if( n >= 1 )
+        {
+            if( n == 1 )
+            {
+                y = std::abs( x[ix0 - 1] );
+            }
+            else
+            {
+                scale = 3.3121686421112381E-170;
+                kend = ( ix0 + n ) - 1;
+                for( k = ix0; k <= kend; k++ )
+                {
+                    absxk = std::abs( x[k - 1] );
+                    if( absxk > scale )
+                    {
+                        t = scale / absxk;
+                        y = 1.0 + y * t * t;
+                        scale = absxk;
+                    }
+                    else
+                    {
+                        t = absxk / scale;
+                        y += t * t;
+                    }
+                }
+
+                y = scale * std::sqrt( y );
+            }
+        }
+
+        return y;
+    }
+
+    double xnrm2( int n, const double x[9], int ix0 )
+    {
+        double y;
+        double scale;
+        int kend;
+        int k;
+        double absxk;
+        double t;
+        y = 0.0;
+        if( n >= 1 )
+        {
+            if( n == 1 )
+            {
+                y = std::abs( x[ix0 - 1] );
+            }
+            else
+            {
+                scale = 3.3121686421112381E-170;
+                kend = ( ix0 + n ) - 1;
+                for( k = ix0; k <= kend; k++ )
+                {
+                    absxk = std::abs( x[k - 1] );
+                    if( absxk > scale )
+                    {
+                        t = scale / absxk;
+                        y = 1.0 + y * t * t;
+                        scale = absxk;
+                    }
+                    else
+                    {
+                        t = absxk / scale;
+                        y += t * t;
+                    }
+                }
+
+                y = scale * std::sqrt( y );
+            }
+        }
+
+        return y;
+    }
+
+    void b_xaxpy( int n, double a, const double x[9], int ix0, double y[3], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i3;
+        int k;
+        if( ( n < 1 ) || ( a == 0.0 ) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i3 = n - 1;
+            for( k = 0; k <= i3; k++ )
+            {
+                y[iy] += a * x[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    void c_xaxpy( int n, double a, const double x[3], int ix0, double y[9], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i4;
+        int k;
+        if( ( n < 1 ) || ( a == 0.0 ) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i4 = n - 1;
+            for( k = 0; k <= i4; k++ )
+            {
+                y[iy] += a * x[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    void xaxpy( int n, double a, int ix0, double y[9], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i2;
+        int k;
+        if( ( n < 1 ) || ( a == 0.0 ) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i2 = n - 1;
+            for( k = 0; k <= i2; k++ )
+            {
+                y[iy] += a * y[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    double xdotc( int n, const double x[9], int ix0, const double y[9], int iy0 )
+    {
+        double d;
+        int ix;
+        int iy;
+        int k;
+        d = 0.0;
+        if( n >= 1 )
+        {
+            ix = ix0;
+            iy = iy0;
+            for( k = 0; k < n; k++ )
+            {
+                d += x[ix - 1] * y[iy - 1];
+                ix++;
+                iy++;
+            }
+        }
+
+        return d;
+    }
+
+    void xrotg( double * a, double * b, double * c, double * s )
+    {
+        double roe;
+        double absa;
+        double absb;
+        double scale;
+        double ads;
+        double bds;
+        roe = *b;
+        absa = std::abs( *a );
+        absb = std::abs( *b );
+        if( absa > absb )
+        {
+            roe = *a;
+        }
+
+        scale = absa + absb;
+        if( scale == 0.0 )
+        {
+            *s = 0.0;
+            *c = 1.0;
+            *a = 0.0;
+            *b = 0.0;
+        }
+        else
+        {
+            ads = absa / scale;
+            bds = absb / scale;
+            scale *= std::sqrt( ads * ads + bds * bds );
+            if( roe < 0.0 )
+            {
+                scale = -scale;
+            }
+
+            *c = *a / scale;
+            *s = *b / scale;
+            if( absa > absb )
+            {
+                *b = *s;
+            }
+            else if( *c != 0.0 )
+            {
+                *b = 1.0 / *c;
+            }
+            else
+            {
+                *b = 1.0;
+            }
+
+            *a = scale;
+        }
+    }
+
+    void xrot( double x[9], int ix0, int iy0, double c, double s )
+    {
+        int ix;
+        int iy;
+        double temp;
+        ix = ix0 - 1;
+        iy = iy0 - 1;
+        temp = c * x[ix] + s * x[iy];
+        x[iy] = c * x[iy] - s * x[ix];
+        x[ix] = temp;
+        iy++;
+        ix++;
+        temp = c * x[ix] + s * x[iy];
+        x[iy] = c * x[iy] - s * x[ix];
+        x[ix] = temp;
+        iy++;
+        ix++;
+        temp = c * x[ix] + s * x[iy];
+        x[iy] = c * x[iy] - s * x[ix];
+        x[ix] = temp;
+    }
+
+    void b_sqrt( double * x ) { *x = std::sqrt( *x ); }
+
+    void xswap( double x[9], int ix0, int iy0 )
+    {
+        int ix;
+        int iy;
+        double temp;
+        ix = ix0 - 1;
+        iy = iy0 - 1;
+        temp = x[ix];
+        x[ix] = x[iy];
+        x[iy] = temp;
+        ix++;
+        iy++;
+        temp = x[ix];
+        x[ix] = x[iy];
+        x[iy] = temp;
+        ix++;
+        iy++;
+        temp = x[ix];
+        x[ix] = x[iy];
+        x[iy] = temp;
+    }
+
+
+
+    void svd_3x3( const double A[9], double U[9], double s[3], double V[9] )
+    {
+        double b_A[9];
+        double e[3];
+        double work[3];
+        double Vf[9];
+        bool apply_transform;
+        double nrm;
+        double b_s[3];
+        int kase;
+        int qp1;
+        int qjj;
+        double r;
+        int m;
+        int q;
+        int qq;
+        double snorm;
+        int exitg1;
+        bool exitg2;
+        double scale;
+        double sm;
+        double sqds;
+        double b;
+        memcpy( &b_A[0], &A[0], 9U * sizeof( double ) );
+        e[0] = 0.0;
+        work[0] = 0.0;
+        e[1] = 0.0;
+        work[1] = 0.0;
+        e[2] = 0.0;
+        work[2] = 0.0;
+        memset( &U[0], 0, 9U * sizeof( double ) );
+        memset( &Vf[0], 0, 9U * sizeof( double ) );
+        apply_transform = false;
+        nrm = xnrm2( 3, b_A, 1 );
+        if( nrm > 0.0 )
+        {
+            apply_transform = true;
+            if( b_A[0] < 0.0 )
+            {
+                nrm = -nrm;
+            }
+
+            if( std::abs( nrm ) >= 1.0020841800044864E-292 )
+            {
+                r = 1.0 / nrm;
+                for( qp1 = 1; qp1 < 4; qp1++ )
+                {
+                    b_A[qp1 - 1] *= r;
+                }
+            }
+            else
+            {
+                for( qp1 = 1; qp1 < 4; qp1++ )
+                {
+                    b_A[qp1 - 1] /= nrm;
+                }
+            }
+
+            b_A[0]++;
+            b_s[0] = -nrm;
+        }
+        else
+        {
+            b_s[0] = 0.0;
+        }
+
+        for( kase = 2; kase < 4; kase++ )
+        {
+            qjj = 3 * (kase - 1);
+            if( apply_transform )
+            {
+                xaxpy( 3, -(xdotc( 3, b_A, 1, b_A, qjj + 1 ) / b_A[0]), 1, b_A, qjj + 1 );
+            }
+
+            e[kase - 1] = b_A[qjj];
+        }
+
+        for( qp1 = 1; qp1 < 4; qp1++ )
+        {
+            U[qp1 - 1] = b_A[qp1 - 1];
+        }
+
+        nrm = b_xnrm2( 2, e, 2 );
+        if( nrm == 0.0 )
+        {
+            e[0] = 0.0;
+        }
+        else
+        {
+            if( e[1] < 0.0 )
+            {
+                e[0] = -nrm;
+            }
+            else
+            {
+                e[0] = nrm;
+            }
+
+            r = e[0];
+            if( std::abs( e[0] ) >= 1.0020841800044864E-292 )
+            {
+                r = 1.0 / e[0];
+                for( qp1 = 2; qp1 < 4; qp1++ )
+                {
+                    e[qp1 - 1] *= r;
+                }
+            }
+            else
+            {
+                for( qp1 = 2; qp1 < 4; qp1++ )
+                {
+                    e[qp1 - 1] /= r;
+                }
+            }
+
+            e[1]++;
+            e[0] = -e[0];
+            for( qp1 = 2; qp1 < 4; qp1++ )
+            {
+                work[qp1 - 1] = 0.0;
+            }
+
+            for( kase = 2; kase < 4; kase++ )
+            {
+                b_xaxpy( 2, e[kase - 1], b_A, 3 * (kase - 1) + 2, work, 2 );
+            }
+
+            for( kase = 2; kase < 4; kase++ )
+            {
+                c_xaxpy( 2, -e[kase - 1] / e[1], work, 2, b_A, 3 * (kase - 1) + 2 );
+            }
+        }
+
+        for( qp1 = 2; qp1 < 4; qp1++ )
+        {
+            Vf[qp1 - 1] = e[qp1 - 1];
+        }
+
+        apply_transform = false;
+        nrm = xnrm2( 2, b_A, 5 );
+        if( nrm > 0.0 )
+        {
+            apply_transform = true;
+            if( b_A[4] < 0.0 )
+            {
+                nrm = -nrm;
+            }
+
+            if( std::abs( nrm ) >= 1.0020841800044864E-292 )
+            {
+                r = 1.0 / nrm;
+                for( qp1 = 5; qp1 < 7; qp1++ )
+                {
+                    b_A[qp1 - 1] *= r;
+                }
+            }
+            else
+            {
+                for( qp1 = 5; qp1 < 7; qp1++ )
+                {
+                    b_A[qp1 - 1] /= nrm;
+                }
+            }
+
+            b_A[4]++;
+            b_s[1] = -nrm;
+        }
+        else
+        {
+            b_s[1] = 0.0;
+        }
+
+        for( kase = 3; kase < 4; kase++ )
+        {
+            if( apply_transform )
+            {
+                xaxpy( 2, -(xdotc( 2, b_A, 5, b_A, 8 ) / b_A[4]), 5, b_A, 8 );
+            }
+        }
+
+        for( qp1 = 2; qp1 < 4; qp1++ )
+        {
+            U[qp1 + 2] = b_A[qp1 + 2];
+        }
+
+        m = 1;
+        b_s[2] = b_A[8];
+        e[1] = b_A[7];
+        e[2] = 0.0;
+        U[6] = 0.0;
+        U[7] = 0.0;
+        U[8] = 1.0;
+        for( q = 1; q >= 0; q-- )
+        {
+            qp1 = q + 2;
+            qq = q + 3 * q;
+            if( b_s[q] != 0.0 )
+            {
+                for( kase = qp1; kase < 4; kase++ )
+                {
+                    qjj = (q + 3 * (kase - 1)) + 1;
+                    xaxpy( 3 - q, -(xdotc( 3 - q, U, qq + 1, U, qjj ) / U[qq]), qq + 1, U, qjj );
+                }
+
+                for( qp1 = q + 1; qp1 < 4; qp1++ )
+                {
+                    kase = (qp1 + 3 * q) - 1;
+                    U[kase] = -U[kase];
+                }
+
+                U[qq]++;
+                if( 0 <= q - 1 )
+                {
+                    U[3 * q] = 0.0;
+                }
+            }
+            else
+            {
+                U[3 * q] = 0.0;
+                U[1 + 3 * q] = 0.0;
+                U[2 + 3 * q] = 0.0;
+                U[qq] = 1.0;
+            }
+        }
+
+        for( q = 2; q >= 0; q-- )
+        {
+            if( (q + 1 <= 1) && (e[0] != 0.0) )
+            {
+                xaxpy( 2, -(xdotc( 2, Vf, 2, Vf, 5 ) / Vf[1]), 2, Vf, 5 );
+                xaxpy( 2, -(xdotc( 2, Vf, 2, Vf, 8 ) / Vf[1]), 2, Vf, 8 );
+            }
+
+            Vf[3 * q] = 0.0;
+            Vf[1 + 3 * q] = 0.0;
+            Vf[2 + 3 * q] = 0.0;
+            Vf[q + 3 * q] = 1.0;
+        }
+
+        qq = 0;
+        snorm = 0.0;
+        for( q = 0; q < 3; q++ )
+        {
+            if( b_s[q] != 0.0 )
+            {
+                nrm = std::abs( b_s[q] );
+                r = b_s[q] / nrm;
+                b_s[q] = nrm;
+                if( q + 1 < 3 )
+                {
+                    e[q] /= r;
+                }
+
+                kase = 3 * q;
+                qjj = kase + 3;
+                for( qp1 = kase + 1; qp1 <= qjj; qp1++ )
+                {
+                    U[qp1 - 1] *= r;
+                }
+            }
+
+            if( (q + 1 < 3) && (e[q] != 0.0) )
+            {
+                nrm = std::abs( e[q] );
+                r = nrm / e[q];
+                e[q] = nrm;
+                b_s[q + 1] *= r;
+                kase = 3 * (q + 1);
+                qjj = kase + 3;
+                for( qp1 = kase + 1; qp1 <= qjj; qp1++ )
+                {
+                    Vf[qp1 - 1] *= r;
+                }
+            }
+
+            nrm = std::abs( b_s[q] );
+            r = std::abs( e[q] );
+            if( (nrm > r) || rtIsNaN( r ) )
+            {
+                r = nrm;
+            }
+
+            if( (!(snorm > r)) && (!rtIsNaN( r )) )
+            {
+                snorm = r;
+            }
+        }
+
+        while( (m + 2 > 0) && (qq < 75) )
+        {
+            qp1 = m;
+            do
+            {
+                exitg1 = 0;
+                q = qp1 + 1;
+                if( qp1 + 1 == 0 )
+                {
+                    exitg1 = 1;
+                }
+                else
+                {
+                    nrm = std::abs( e[qp1] );
+                    if( (nrm <= 2.2204460492503131E-16
+                        * (std::abs( b_s[qp1] ) + std::abs( b_s[qp1 + 1] )))
+                        || (nrm <= 1.0020841800044864E-292)
+                        || ((qq > 20) && (nrm <= 2.2204460492503131E-16 * snorm)) )
+                    {
+                        e[qp1] = 0.0;
+                        exitg1 = 1;
+                    }
+                    else
+                    {
+                        qp1--;
+                    }
+                }
+            } while( exitg1 == 0 );
+
+            if( qp1 + 1 == m + 1 )
+            {
+                kase = 4;
+            }
+            else
+            {
+                qjj = m + 2;
+                kase = m + 2;
+                exitg2 = false;
+                while( (!exitg2) && (kase >= qp1 + 1) )
+                {
+                    qjj = kase;
+                    if( kase == qp1 + 1 )
+                    {
+                        exitg2 = true;
+                    }
+                    else
+                    {
+                        nrm = 0.0;
+                        if( kase < m + 2 )
+                        {
+                            nrm = std::abs( e[kase - 1] );
+                        }
+
+                        if( kase > qp1 + 2 )
+                        {
+                            nrm += std::abs( e[kase - 2] );
+                        }
+
+                        r = std::abs( b_s[kase - 1] );
+                        if( (r <= 2.2204460492503131E-16 * nrm) || (r <= 1.0020841800044864E-292) )
+                        {
+                            b_s[kase - 1] = 0.0;
+                            exitg2 = true;
+                        }
+                        else
+                        {
+                            kase--;
+                        }
+                    }
+                }
+
+                if( qjj == qp1 + 1 )
+                {
+                    kase = 3;
+                }
+                else if( qjj == m + 2 )
+                {
+                    kase = 1;
+                }
+                else
+                {
+                    kase = 2;
+                    q = qjj;
+                }
+            }
+
+            switch( kase )
+            {
+            case 1:
+                r = e[m];
+                e[m] = 0.0;
+                qjj = m + 1;
+                for( qp1 = qjj; qp1 >= q + 1; qp1-- )
+                {
+                    xrotg( &b_s[qp1 - 1], &r, &sm, &sqds );
+                    if( qp1 > q + 1 )
+                    {
+                        r = -sqds * e[0];
+                        e[0] *= sm;
+                    }
+
+                    xrot( Vf, 1 + 3 * (qp1 - 1), 1 + 3 * (m + 1), sm, sqds );
+                }
+                break;
+
+            case 2:
+                r = e[q - 1];
+                e[q - 1] = 0.0;
+                for( qp1 = q + 1; qp1 <= m + 2; qp1++ )
+                {
+                    xrotg( &b_s[qp1 - 1], &r, &sm, &sqds );
+                    b = e[qp1 - 1];
+                    r = -sqds * b;
+                    e[qp1 - 1] = b * sm;
+                    xrot( U, 1 + 3 * (qp1 - 1), 1 + 3 * (q - 1), sm, sqds );
+                }
+                break;
+
+            case 3:
+                kase = m + 1;
+                scale = std::abs( b_s[m + 1] );
+                r = std::abs( b_s[m] );
+                if( (!(scale > r)) && (!rtIsNaN( r )) )
+                {
+                    scale = r;
+                }
+
+                r = std::abs( e[m] );
+                if( (!(scale > r)) && (!rtIsNaN( r )) )
+                {
+                    scale = r;
+                }
+
+                r = std::abs( b_s[q] );
+                if( (!(scale > r)) && (!rtIsNaN( r )) )
+                {
+                    scale = r;
+                }
+
+                r = std::abs( e[q] );
+                if( (!(scale > r)) && (!rtIsNaN( r )) )
+                {
+                    scale = r;
+                }
+
+                sm = b_s[m + 1] / scale;
+                nrm = b_s[m] / scale;
+                r = e[m] / scale;
+                sqds = b_s[q] / scale;
+                b = ((nrm + sm) * (nrm - sm) + r * r) / 2.0;
+                nrm = sm * r;
+                nrm *= nrm;
+                if( (b != 0.0) || (nrm != 0.0) )
+                {
+                    r = b * b + nrm;
+                    b_sqrt( &r );
+                    if( b < 0.0 )
+                    {
+                        r = -r;
+                    }
+
+                    r = nrm / (b + r);
+                }
+                else
+                {
+                    r = 0.0;
+                }
+
+                r += (sqds + sm) * (sqds - sm);
+                nrm = sqds * (e[q] / scale);
+                for( qp1 = q + 1; qp1 <= kase; qp1++ )
+                {
+                    xrotg( &r, &nrm, &sm, &sqds );
+                    if( qp1 > q + 1 )
+                    {
+                        e[0] = r;
+                    }
+
+                    b = e[qp1 - 1];
+                    nrm = b_s[qp1 - 1];
+                    e[qp1 - 1] = sm * b - sqds * nrm;
+                    r = sqds * b_s[qp1];
+                    b_s[qp1] *= sm;
+                    xrot( Vf, 1 + 3 * (qp1 - 1), 1 + 3 * qp1, sm, sqds );
+                    b_s[qp1 - 1] = sm * nrm + sqds * b;
+                    xrotg( &b_s[qp1 - 1], &r, &sm, &sqds );
+                    b = e[qp1 - 1];
+                    r = sm * b + sqds * b_s[qp1];
+                    b_s[qp1] = -sqds * b + sm * b_s[qp1];
+                    nrm = sqds * e[qp1];
+                    e[qp1] *= sm;
+                    xrot( U, 1 + 3 * (qp1 - 1), 1 + 3 * qp1, sm, sqds );
+                }
+
+                e[m] = r;
+                qq++;
+                break;
+
+            default:
+                if( b_s[q] < 0.0 )
+                {
+                    b_s[q] = -b_s[q];
+                    kase = 3 * q;
+                    qjj = kase + 3;
+                    for( qp1 = kase + 1; qp1 <= qjj; qp1++ )
+                    {
+                        Vf[qp1 - 1] = -Vf[qp1 - 1];
+                    }
+                }
+
+                qp1 = q + 1;
+                while( (q + 1 < 3) && (b_s[q] < b_s[qp1]) )
+                {
+                    nrm = b_s[q];
+                    b_s[q] = b_s[qp1];
+                    b_s[qp1] = nrm;
+                    xswap( Vf, 1 + 3 * q, 1 + 3 * (q + 1) );
+                    xswap( U, 1 + 3 * q, 1 + 3 * (q + 1) );
+                    q = qp1;
+                    qp1++;
+                }
+
+                qq = 0;
+                m--;
+                break;
+            }
+        }
+
+        for( qp1 = 0; qp1 < 3; qp1++ )
+        {
+            s[qp1] = b_s[qp1];
+            V[3 * qp1] = Vf[3 * qp1];
+            kase = 1 + 3 * qp1;
+            V[kase] = Vf[kase];
+            kase = 2 + 3 * qp1;
+            V[kase] = Vf[kase];
+        }
+    }
+
+}  // anon namespace
+
+
+void librealsense::algo::depth_to_rgb_calibration::pinv_3x3( const double m[9], double n[9] )
+{
+    int br;
+    double U[9];
+    double s[3];
+    double V[9];
+    int i0;
+    double absxk;
+    int vcol;
+    int r;
+    int j;
+    int ar;
+    int ib;
+    int ia;
+    int i1;
+    int ic;
+    bool p = true;
+    for( br = 0; br < 9; br++ )
+    {
+        n[br] = 0.0;
+        if( p && ((!rtIsInf( m[br] )) && (!rtIsNaN( m[br] ))) )
+            p = true;
+        else
+            p = false;
+    }
+
+    if( !p )
+    {
+        for( i0 = 0; i0 < 9; i0++ )
+            n[i0] = std::numeric_limits< double >::quiet_NaN();
+    }
+    else
+    {
+        svd_3x3( m, U, s, V );
+        absxk = std::abs( s[0] );
+        if( (!rtIsInf( absxk )) && (!rtIsNaN( absxk )) )
+        {
+            if( absxk <= 2.2250738585072014E-308 )
+            {
+                absxk = 4.94065645841247E-324;
+            }
+            else
+            {
+                frexp( absxk, &vcol );
+                absxk = std::ldexp( 1.0, vcol - 53 );
+            }
+        }
+        else
+        {
+            absxk = std::numeric_limits< double >::quiet_NaN();
+        }
+
+        absxk *= 3.0;
+        r = -1;
+        br = 0;
+        while( (br < 3) && (s[br] > absxk) )
+        {
+            r++;
+            br++;
+        }
+
+        if( r + 1 > 0 )
+        {
+            vcol = 1;
+            for( j = 0; j <= r; j++ )
+            {
+                absxk = 1.0 / s[j];
+                i0 = vcol + 2;
+                for( br = vcol; br <= i0; br++ )
+                {
+                    V[br - 1] *= absxk;
+                }
+
+                vcol += 3;
+            }
+
+            for( vcol = 0; vcol <= 6; vcol += 3 )
+            {
+                i0 = vcol + 1;
+                j = vcol + 3;
+                if( i0 <= j )
+                {
+                    memset( &n[i0 + -1],
+                        0,
+                        (unsigned int)(((j - i0) + 1)
+                            * static_cast<int>(sizeof( double ))) );
+                }
+            }
+
+            br = 0;
+            for( vcol = 0; vcol <= 6; vcol += 3 )
+            {
+                ar = -1;
+                br++;
+                i0 = br + 3 * r;
+                for( ib = br; ib <= i0; ib += 3 )
+                {
+                    ia = ar;
+                    j = vcol + 1;
+                    i1 = vcol + 3;
+                    for( ic = j; ic <= i1; ic++ )
+                    {
+                        ia++;
+                        n[ic - 1] += U[ib - 1] * V[ia];
+                    }
+
+                    ar += 3;
+                }
+            }
+        }
+    }
+}
diff --git a/src/algo/depth-to-rgb-calibration/rotation-in-angles.cpp b/src/algo/depth-to-rgb-calibration/rotation-in-angles.cpp
new file mode 100644
index 0000000..3145d14
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/rotation-in-angles.cpp
@@ -0,0 +1,117 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "calibration-types.h"
+#include <cmath>
+#include <cstdlib>
+#include <stdexcept>
+#include <sstream>
+#include <iomanip>
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    matrix_3x3 extract_rotation_from_angles( const rotation_in_angles & rot_angles )
+    {
+        matrix_3x3 res;
+
+        auto sin_a = sin( rot_angles.alpha );
+        auto sin_b = sin( rot_angles.beta );
+        auto sin_g = sin( rot_angles.gamma );
+
+        auto cos_a = cos( rot_angles.alpha );
+        auto cos_b = cos( rot_angles.beta );
+        auto cos_g = cos( rot_angles.gamma );
+
+        //% function [R] = calcRmatRromAngs(xAlpha,yBeta,zGamma)
+        //%     R = [cos( yBeta )*cos( zGamma ), -cos( yBeta )*sin( zGamma ), sin( yBeta ); ...
+        //%          cos( xAlpha )*sin( zGamma ) + cos( zGamma )*sin( xAlpha )*sin( yBeta ), cos( xAlpha )*cos( zGamma ) - sin( xAlpha )*sin( yBeta )*sin( zGamma ), -cos( yBeta )*sin( xAlpha ); ...
+        //%          sin( xAlpha )*sin( zGamma ) - cos( xAlpha )*cos( zGamma )*sin( yBeta ), cos( zGamma )*sin( xAlpha ) + cos( xAlpha )*sin( yBeta )*sin( zGamma ), cos( xAlpha )*cos( yBeta )];
+        //% end
+        // -> note the transposing of the coordinates
+
+        res.rot[0] = cos_b * cos_g;
+        res.rot[3] = -cos_b * sin_g;
+        res.rot[6] = sin_b;
+        res.rot[1] = cos_a * sin_g + cos_g * sin_a*sin_b;
+        res.rot[4] = cos_a * cos_g - sin_a * sin_b*sin_g;
+        res.rot[7] = -cos_b * sin_a;
+        res.rot[2] = sin_a * sin_g - cos_a * cos_g*sin_b;
+        res.rot[5] = cos_g * sin_a + cos_a * sin_b*sin_g;
+        res.rot[8] = cos_a * cos_b;
+
+        return res;
+    }
+
+#if 0
+    double determinant( double const r[9] )
+    {
+        // |A| = aei + bfg + cdh - ceg - bdi - afh
+        return r[0] * r[4] * r[8]  // aei
+            + r[1] * r[5] * r[6]   // bfg
+            + r[2] * r[3] * r[7]   // cdh
+            - r[2] * r[4] * r[6]   // ceg
+            - r[1] * r[3] * r[8]   // bdi
+            - r[0] * r[5] * r[7];  // afh
+    }
+
+    rotation inverse( rotation const & r )
+    {
+
+    }
+
+    inline double3 operator*( const rotation & a, const rotation & b ) { return { dot( a.x,b ), dot( a.y,b ), dot( a.z,b ) }; }
+    inline rotation operator*( const rotation & a, const rotation & b )
+    {
+        return{ a*b.x, a*b.y, a*b.z };
+    }
+#endif
+
+    rotation_in_angles extract_angles_from_rotation( const double r[9] )
+    {
+        rotation_in_angles res;
+        //% function [xAlpha,yBeta,zGamma] = extractAnglesFromRotMat(R)
+        //%     xAlpha = atan2(-R(2,3),R(3,3));
+        //%     yBeta = asin(R(1,3));
+        //%     zGamma = atan2(-R(1,2),R(1,1));
+        // -> we transpose the coordinates!
+        res.alpha = atan2( -r[7], r[8] );
+        res.beta = asin( r[6] );
+        res.gamma = atan2( -r[3], r[0] );
+        // -> additional code is in the original function that catches some corner
+        //    case, but since these have never occurred we were told not to use it 
+
+#if 0
+        // TODO Sanity-check: can be removed
+        rotation rot = extract_rotation_from_angles( res );
+        double const epsilon = 1e-8;
+        if( determinant( rot * inverse(r) - I ) > epsilon )
+        {
+            std::ostringstream ss;
+            ss << std::setprecision( 15 );
+            ss << "angles_from_rotation != rotation_from_angles!";
+            ss << "\n    " << r[0] << "  " << r[1] << "  " << r[2]
+                << "\n    " << r[3] << "  " << r[4] << "  " << r[5]
+                << "\n    " << r[6] << "  " << r[7] << "  " << r[8];
+            ss << "\nvs:"
+                << "\n    " << rot.rot[0] << "  " << rot.rot[1] << "  " << rot.rot[2]
+                << "\n    " << rot.rot[3] << "  " << rot.rot[4] << "  " << rot.rot[5]
+                << "\n    " << rot.rot[6] << "  " << rot.rot[7] << "  " << rot.rot[8];
+            ss << "\nangles:"
+                << "\n    alpha= " << res.alpha
+                << "\n    beta = " << res.beta
+                << "\n    gamma= " << res.gamma;
+            ss << "\nsum= " << sum;
+            throw std::runtime_error( ss.str() );
+        }
+#endif
+        return res;
+    }
+
+
+}
+}
+}
diff --git a/src/algo/depth-to-rgb-calibration/svd_3x4.cpp b/src/algo/depth-to-rgb-calibration/svd_3x4.cpp
new file mode 100644
index 0000000..fca9423
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/svd_3x4.cpp
@@ -0,0 +1,792 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+// Code generated by Matlab Coder
+
+#include "utils.h"
+#include <limits>
+#include <cmath>
+#include <cstring>
+
+
+namespace
+{
+
+    double b_xnrm2( int n, const double x[4], int ix0 )
+    {
+        double y;
+        double scale;
+        int kend;
+        int k;
+        double absxk;
+        double t;
+        y = 0.0;
+        if( n >= 1 )
+        {
+            if( n == 1 )
+            {
+                y = std::abs( x[ix0 - 1] );
+            }
+            else
+            {
+                scale = 3.3121686421112381E-170;
+                kend = (ix0 + n) - 1;
+                for( k = ix0; k <= kend; k++ )
+                {
+                    absxk = std::abs( x[k - 1] );
+                    if( absxk > scale )
+                    {
+                        t = scale / absxk;
+                        y = 1.0 + y * t * t;
+                        scale = absxk;
+                    }
+                    else
+                    {
+                        t = absxk / scale;
+                        y += t * t;
+                    }
+                }
+
+                y = scale * std::sqrt( y );
+            }
+        }
+
+        return y;
+    }
+
+    double xnrm2( int n, const double x[12], int ix0 )
+    {
+        double y;
+        double scale;
+        int kend;
+        int k;
+        double absxk;
+        double t;
+        y = 0.0;
+        if( n >= 1 )
+        {
+            if( n == 1 )
+            {
+                y = std::abs( x[ix0 - 1] );
+            }
+            else
+            {
+                scale = 3.3121686421112381E-170;
+                kend = (ix0 + n) - 1;
+                for( k = ix0; k <= kend; k++ )
+                {
+                    absxk = std::abs( x[k - 1] );
+                    if( absxk > scale )
+                    {
+                        t = scale / absxk;
+                        y = 1.0 + y * t * t;
+                        scale = absxk;
+                    }
+                    else
+                    {
+                        t = absxk / scale;
+                        y += t * t;
+                    }
+                }
+
+                y = scale * std::sqrt( y );
+            }
+        }
+
+        return y;
+    }
+
+    void b_xaxpy( int n, double a, const double x[12], int ix0, double y[3], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i1;
+        int k;
+        if( (n < 1) || (a == 0.0) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i1 = n - 1;
+            for( k = 0; k <= i1; k++ )
+            {
+                y[iy] += a * x[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    void c_xaxpy( int n, double a, const double x[3], int ix0, double y[12], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i2;
+        int k;
+        if( (n < 1) || (a == 0.0) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i2 = n - 1;
+            for( k = 0; k <= i2; k++ )
+            {
+                y[iy] += a * x[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    void xaxpy( int n, double a, int ix0, double y[12], int iy0 )
+    {
+        int ix;
+        int iy;
+        int i0;
+        int k;
+        if( (n < 1) || (a == 0.0) )
+        {
+        }
+        else
+        {
+            ix = ix0 - 1;
+            iy = iy0 - 1;
+            i0 = n - 1;
+            for( k = 0; k <= i0; k++ )
+            {
+                y[iy] += a * y[ix];
+                ix++;
+                iy++;
+            }
+        }
+    }
+
+    double xdotc( int n, const double x[12], int ix0, const double y[12], int iy0 )
+    {
+        double d;
+        int ix;
+        int iy;
+        int k;
+        d = 0.0;
+        if( n >= 1 )
+        {
+            ix = ix0;
+            iy = iy0;
+            for( k = 0; k < n; k++ )
+            {
+                d += x[ix - 1] * y[iy - 1];
+                ix++;
+                iy++;
+            }
+        }
+
+        return d;
+    }
+
+    void xrotg( double * a, double * b, double * c, double * s )
+    {
+        double roe;
+        double absa;
+        double absb;
+        double scale;
+        double ads;
+        double bds;
+        roe = *b;
+        absa = std::abs( *a );
+        absb = std::abs( *b );
+        if( absa > absb )
+        {
+            roe = *a;
+        }
+
+        scale = absa + absb;
+        if( scale == 0.0 )
+        {
+            *s = 0.0;
+            *c = 1.0;
+            *a = 0.0;
+            *b = 0.0;
+        }
+        else
+        {
+            ads = absa / scale;
+            bds = absb / scale;
+            scale *= std::sqrt( ads * ads + bds * bds );
+            if( roe < 0.0 )
+            {
+                scale = -scale;
+            }
+
+            *c = *a / scale;
+            *s = *b / scale;
+            if( absa > absb )
+            {
+                *b = *s;
+            }
+            else if( *c != 0.0 )
+            {
+                *b = 1.0 / *c;
+            }
+            else
+            {
+                *b = 1.0;
+            }
+
+            *a = scale;
+        }
+    }
+
+
+    // Test if value is not a number
+    inline bool rtIsNaN( double value ) { return (value != value); }
+
+}  // anon namespace
+
+
+void librealsense::algo::depth_to_rgb_calibration::svd_3x4( const double A[12], double U[3] )
+{
+    double b_A[12];
+    double e[4];
+    double work[3];
+    bool apply_transform;
+    double s[4];
+    int k;
+    int qjj;
+    double r;
+    int m;
+    int iter;
+    double snorm;
+    double b;
+    int exitg1;
+    int q;
+    int qs;
+    bool exitg2;
+    double scale;
+    double sm;
+    double sqds;
+    memcpy( &b_A[0], &A[0], 12U * sizeof( double ) );
+    e[0] = 0.0;
+    e[1] = 0.0;
+    e[2] = 0.0;
+    e[3] = 0.0;
+    work[0] = 0.0;
+    work[1] = 0.0;
+    work[2] = 0.0;
+    apply_transform = false;
+    double nrm = xnrm2( 3, b_A, 1 );
+    if( nrm > 0.0 )
+    {
+        apply_transform = true;
+        if( b_A[0] < 0.0 )
+        {
+            nrm = -nrm;
+        }
+
+        if( std::abs( nrm ) >= 1.0020841800044864E-292 )
+        {
+            r = 1.0 / nrm;
+            for( k = 1; k < 4; k++ )
+            {
+                b_A[k - 1] *= r;
+            }
+        }
+        else
+        {
+            for( k = 1; k < 4; k++ )
+            {
+                b_A[k - 1] /= nrm;
+            }
+        }
+
+        b_A[0]++;
+        s[0] = -nrm;
+    }
+    else
+    {
+        s[0] = 0.0;
+    }
+
+    for( k = 2; k < 5; k++ )
+    {
+        qjj = 3 * ( k - 1 );
+        if( apply_transform )
+        {
+            xaxpy( 3, -( xdotc( 3, b_A, 1, b_A, qjj + 1 ) / b_A[0] ), 1, b_A, qjj + 1 );
+        }
+
+        e[k - 1] = b_A[qjj];
+    }
+
+    nrm = b_xnrm2( 3, e, 2 );
+    if( nrm == 0.0 )
+    {
+        e[0] = 0.0;
+    }
+    else
+    {
+        if( e[1] < 0.0 )
+        {
+            e[0] = -nrm;
+        }
+        else
+        {
+            e[0] = nrm;
+        }
+
+        r = e[0];
+        if( std::abs( e[0] ) >= 1.0020841800044864E-292 )
+        {
+            r = 1.0 / e[0];
+            for( k = 2; k < 5; k++ )
+            {
+                e[k - 1] *= r;
+            }
+        }
+        else
+        {
+            for( k = 2; k < 5; k++ )
+            {
+                e[k - 1] /= r;
+            }
+        }
+
+        e[1]++;
+        e[0] = -e[0];
+        for( qjj = 2; qjj < 4; qjj++ )
+        {
+            work[qjj - 1] = 0.0;
+        }
+
+        for( k = 2; k < 5; k++ )
+        {
+            b_xaxpy( 2, e[k - 1], b_A, 3 * ( k - 1 ) + 2, work, 2 );
+        }
+
+        for( k = 2; k < 5; k++ )
+        {
+            c_xaxpy( 2, -e[k - 1] / e[1], work, 2, b_A, 3 * ( k - 1 ) + 2 );
+        }
+    }
+
+    apply_transform = false;
+    nrm = xnrm2( 2, b_A, 5 );
+    if( nrm > 0.0 )
+    {
+        apply_transform = true;
+        if( b_A[4] < 0.0 )
+        {
+            nrm = -nrm;
+        }
+
+        if( std::abs( nrm ) >= 1.0020841800044864E-292 )
+        {
+            r = 1.0 / nrm;
+            for( k = 5; k < 7; k++ )
+            {
+                b_A[k - 1] *= r;
+            }
+        }
+        else
+        {
+            for( k = 5; k < 7; k++ )
+            {
+                b_A[k - 1] /= nrm;
+            }
+        }
+
+        b_A[4]++;
+        s[1] = -nrm;
+    }
+    else
+    {
+        s[1] = 0.0;
+    }
+
+    for( k = 3; k < 5; k++ )
+    {
+        qjj = 1 + 3 * ( k - 1 );
+        if( apply_transform )
+        {
+            xaxpy( 2, -( xdotc( 2, b_A, 5, b_A, qjj + 1 ) / b_A[4] ), 5, b_A, qjj + 1 );
+        }
+
+        e[k - 1] = b_A[qjj];
+    }
+
+    nrm = b_xnrm2( 2, e, 3 );
+    if( nrm == 0.0 )
+    {
+        e[1] = 0.0;
+    }
+    else
+    {
+        if( e[2] < 0.0 )
+        {
+            e[1] = -nrm;
+        }
+        else
+        {
+            e[1] = nrm;
+        }
+
+        r = e[1];
+        if( std::abs( e[1] ) >= 1.0020841800044864E-292 )
+        {
+            r = 1.0 / e[1];
+            for( k = 3; k < 5; k++ )
+            {
+                e[k - 1] *= r;
+            }
+        }
+        else
+        {
+            for( k = 3; k < 5; k++ )
+            {
+                e[k - 1] /= r;
+            }
+        }
+
+        e[2]++;
+        e[1] = -e[1];
+        for( qjj = 3; qjj < 4; qjj++ )
+        {
+            work[2] = 0.0;
+        }
+
+        for( k = 3; k < 5; k++ )
+        {
+            b_xaxpy( 1, e[k - 1], b_A, 3 * ( k - 1 ) + 3, work, 3 );
+        }
+
+        for( k = 3; k < 5; k++ )
+        {
+            c_xaxpy( 1, -e[k - 1] / e[2], work, 3, b_A, 3 * ( k - 1 ) + 3 );
+        }
+    }
+
+    m = 2;
+    s[2] = b_A[8];
+    s[3] = 0.0;
+    e[2] = b_A[11];
+    e[3] = 0.0;
+    iter = 0;
+    snorm = 0.0;
+    nrm = s[0];
+    if( s[0] != 0.0 )
+    {
+        nrm = std::abs( s[0] );
+        r = s[0] / nrm;
+        s[0] = nrm;
+        e[0] /= r;
+    }
+
+    if( e[0] != 0.0 )
+    {
+        b = std::abs( e[0] );
+        r = b / e[0];
+        e[0] = b;
+        s[1] *= r;
+    }
+
+    nrm = std::abs( nrm );
+    r = std::abs( e[0] );
+    if( ( nrm > r ) || rtIsNaN( r ) )
+    {
+        r = nrm;
+    }
+
+    if( ! rtIsNaN( r ) )
+    {
+        snorm = r;
+    }
+
+    nrm = s[1];
+    if( s[1] != 0.0 )
+    {
+        nrm = std::abs( s[1] );
+        r = s[1] / nrm;
+        s[1] = nrm;
+        e[1] /= r;
+    }
+
+    if( e[1] != 0.0 )
+    {
+        b = std::abs( e[1] );
+        r = b / e[1];
+        e[1] = b;
+        s[2] = b_A[8] * r;
+    }
+
+    nrm = std::abs( nrm );
+    r = std::abs( e[1] );
+    if( ( nrm > r ) || rtIsNaN( r ) )
+    {
+        r = nrm;
+    }
+
+    if( ( ! ( snorm > r ) ) && ( ! rtIsNaN( r ) ) )
+    {
+        snorm = r;
+    }
+
+    nrm = s[2];
+    if( s[2] != 0.0 )
+    {
+        nrm = std::abs( s[2] );
+        r = s[2] / nrm;
+        s[2] = nrm;
+        e[2] = b_A[11] / r;
+    }
+
+    if( e[2] != 0.0 )
+    {
+        b = std::abs( e[2] );
+        r = b / e[2];
+        e[2] = b;
+        s[3] = 0.0 * r;
+    }
+
+    nrm = std::abs( nrm );
+    r = std::abs( e[2] );
+    if( ( nrm > r ) || rtIsNaN( r ) )
+    {
+        r = nrm;
+    }
+
+    if( ( ! ( snorm > r ) ) && ( ! rtIsNaN( r ) ) )
+    {
+        snorm = r;
+    }
+
+    if( s[3] != 0.0 )
+    {
+        s[3] = std::numeric_limits< double >::quiet_NaN();  // rtNaN;
+    }
+
+    if( ! ( snorm > 0.0 ) )
+    {
+        snorm = 0.0;
+    }
+
+    while( ( m + 2 > 0 ) && ( iter < 75 ) )
+    {
+        qjj = m;
+        do
+        {
+            exitg1 = 0;
+            q = qjj + 1;
+            if( qjj + 1 == 0 )
+            {
+                exitg1 = 1;
+            }
+            else
+            {
+                nrm = std::abs( e[qjj] );
+                if( ( nrm
+                      <= 2.2204460492503131E-16 * ( std::abs( s[qjj] ) + std::abs( s[qjj + 1] ) ) )
+                    || ( nrm <= 1.0020841800044864E-292 )
+                    || ( ( iter > 20 ) && ( nrm <= 2.2204460492503131E-16 * snorm ) ) )
+                {
+                    e[qjj] = 0.0;
+                    exitg1 = 1;
+                }
+                else
+                {
+                    qjj--;
+                }
+            }
+        } while( exitg1 == 0 );
+
+        if( qjj + 1 == m + 1 )
+        {
+            qjj = 4;
+        }
+        else
+        {
+            qs = m + 2;
+            k = m + 2;
+            exitg2 = false;
+            while( ( ! exitg2 ) && ( k >= qjj + 1 ) )
+            {
+                qs = k;
+                if( k == qjj + 1 )
+                {
+                    exitg2 = true;
+                }
+                else
+                {
+                    nrm = 0.0;
+                    if( k < m + 2 )
+                    {
+                        nrm = std::abs( e[k - 1] );
+                    }
+
+                    if( k > qjj + 2 )
+                    {
+                        nrm += std::abs( e[k - 2] );
+                    }
+
+                    r = std::abs( s[k - 1] );
+                    if( ( r <= 2.2204460492503131E-16 * nrm ) || ( r <= 1.0020841800044864E-292 ) )
+                    {
+                        s[k - 1] = 0.0;
+                        exitg2 = true;
+                    }
+                    else
+                    {
+                        k--;
+                    }
+                }
+            }
+
+            if( qs == qjj + 1 )
+            {
+                qjj = 3;
+            }
+            else if( qs == m + 2 )
+            {
+                qjj = 1;
+            }
+            else
+            {
+                qjj = 2;
+                q = qs;
+            }
+        }
+
+        switch( qjj )
+        {
+        case 1:
+            r = e[m];
+            e[m] = 0.0;
+            qjj = m + 1;
+            for( k = qjj; k >= q + 1; k-- )
+            {
+                xrotg( &s[k - 1], &r, &sm, &sqds );
+                if( k > q + 1 )
+                {
+                    r = -sqds * e[k - 2];
+                    e[k - 2] *= sm;
+                }
+            }
+            break;
+
+        case 2:
+            r = e[q - 1];
+            e[q - 1] = 0.0;
+            for( k = q + 1; k <= m + 2; k++ )
+            {
+                xrotg( &s[k - 1], &r, &sm, &sqds );
+                b = e[k - 1];
+                r = -sqds * b;
+                e[k - 1] = b * sm;
+            }
+            break;
+
+        case 3:
+            qjj = m + 1;
+            scale = std::abs( s[m + 1] );
+            r = std::abs( s[m] );
+            if( ( ! ( scale > r ) ) && ( ! rtIsNaN( r ) ) )
+            {
+                scale = r;
+            }
+
+            r = std::abs( e[m] );
+            if( ( ! ( scale > r ) ) && ( ! rtIsNaN( r ) ) )
+            {
+                scale = r;
+            }
+
+            r = std::abs( s[q] );
+            if( ( ! ( scale > r ) ) && ( ! rtIsNaN( r ) ) )
+            {
+                scale = r;
+            }
+
+            r = std::abs( e[q] );
+            if( ( ! ( scale > r ) ) && ( ! rtIsNaN( r ) ) )
+            {
+                scale = r;
+            }
+
+            sm = s[m + 1] / scale;
+            nrm = s[m] / scale;
+            r = e[m] / scale;
+            sqds = s[q] / scale;
+            b = ( ( nrm + sm ) * ( nrm - sm ) + r * r ) / 2.0;
+            nrm = sm * r;
+            nrm *= nrm;
+            if( ( b != 0.0 ) || ( nrm != 0.0 ) )
+            {
+                r = std::sqrt( b * b + nrm );
+                if( b < 0.0 )
+                {
+                    r = -r;
+                }
+
+                r = nrm / ( b + r );
+            }
+            else
+            {
+                r = 0.0;
+            }
+
+            r += ( sqds + sm ) * ( sqds - sm );
+            nrm = sqds * ( e[q] / scale );
+            for( k = q + 1; k <= qjj; k++ )
+            {
+                xrotg( &r, &nrm, &sm, &sqds );
+                if( k > q + 1 )
+                {
+                    e[k - 2] = r;
+                }
+
+                b = e[k - 1];
+                nrm = s[k - 1];
+                e[k - 1] = sm * b - sqds * nrm;
+                r = sqds * s[k];
+                s[k] *= sm;
+                s[k - 1] = sm * nrm + sqds * b;
+                xrotg( &s[k - 1], &r, &sm, &sqds );
+                b = e[k - 1];
+                r = sm * b + sqds * s[k];
+                s[k] = -sqds * b + sm * s[k];
+                nrm = sqds * e[k];
+                e[k] *= sm;
+            }
+
+            e[m] = r;
+            iter++;
+            break;
+
+        default:
+            if( s[q] < 0.0 )
+            {
+                s[q] = -s[q];
+            }
+
+            qjj = q + 1;
+            while( ( q + 1 < 4 ) && ( s[q] < s[qjj] ) )
+            {
+                nrm = s[q];
+                s[q] = s[qjj];
+                s[qjj] = nrm;
+                q = qjj;
+                qjj++;
+            }
+
+            iter = 0;
+            m--;
+            break;
+        }
+    }
+
+    U[0] = s[0];
+    U[1] = s[1];
+    U[2] = s[2];
+}
diff --git a/src/algo/depth-to-rgb-calibration/utils.cpp b/src/algo/depth-to-rgb-calibration/utils.cpp
new file mode 100644
index 0000000..b77c141
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/utils.cpp
@@ -0,0 +1,364 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "calibration.h"
+#include "debug.h"
+#include "utils.h"
+#include <math.h>
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+    double get_norma(const std::vector<double3>& vec)
+    {
+        double sum = 0;
+        std::for_each( vec.begin(), vec.end(), [&]( double3 const & v ) { sum += v.get_norm(); } );
+        return std::sqrt(sum);
+    }
+
+    double rad_to_deg(double rad)
+    {
+        return rad * 180. / M_PI;
+    }
+
+    double deg_to_rad(double deg)
+    {
+        return deg * M_PI / 180.;
+    }
+
+    void direct_inv_6x6(const double A[36], const double B[6], double C[6])
+    {
+        double b_A[36];
+        int i0;
+        int j;
+        signed char ipiv[6];
+        int iy;
+        int b;
+        int jj;
+        int jy;
+        int jp1j;
+        int n;
+        int k;
+        double smax;
+        int ix;
+        double s;
+
+        /* INV_MY Summary of this function goes here */
+        /*    Detailed explanation goes here */
+        memcpy(&b_A[0], &A[0], 36U * sizeof(double));
+        for (i0 = 0; i0 < 6; i0++) {
+            ipiv[i0] = (signed char)(1 + i0);
+        }
+
+        for (j = 0; j < 5; j++) {
+            b = j * 7;
+            jj = j * 7;
+            jp1j = b + 2;
+            n = 6 - j;
+            jy = 0;
+            ix = b;
+            smax = std::abs(b_A[b]);
+            for (k = 2; k <= n; k++) {
+                ix++;
+                s = std::abs(b_A[ix]);
+                if (s > smax) {
+                    jy = k - 1;
+                    smax = s;
+                }
+            }
+
+            if (b_A[jj + jy] != 0.0) {
+                if (jy != 0) {
+                    iy = j + jy;
+                    ipiv[j] = (signed char)(iy + 1);
+                    ix = j;
+                    for (k = 0; k < 6; k++) {
+                        smax = b_A[ix];
+                        b_A[ix] = b_A[iy];
+                        b_A[iy] = smax;
+                        ix += 6;
+                        iy += 6;
+                    }
+                }
+
+                i0 = (jj - j) + 6;
+                for (iy = jp1j; iy <= i0; iy++) {
+                    b_A[iy - 1] /= b_A[jj];
+                }
+            }
+
+            n = 4 - j;
+            jy = b + 6;
+            iy = jj;
+            for (b = 0; b <= n; b++) {
+                smax = b_A[jy];
+                if (b_A[jy] != 0.0) {
+                    ix = jj + 1;
+                    i0 = iy + 8;
+                    jp1j = (iy - j) + 12;
+                    for (k = i0; k <= jp1j; k++) {
+                        b_A[k - 1] += b_A[ix] * -smax;
+                        ix++;
+                    }
+                }
+
+                jy += 6;
+                iy += 6;
+            }
+        }
+
+        for (iy = 0; iy < 6; iy++) {
+            C[iy] = B[iy];
+        }
+
+        for (jy = 0; jy < 5; jy++) {
+            if (ipiv[jy] != jy + 1) {
+                smax = C[jy];
+                iy = ipiv[jy] - 1;
+                C[jy] = C[iy];
+                C[iy] = smax;
+            }
+        }
+
+        for (k = 0; k < 6; k++) {
+            jy = 6 * k;
+            if (C[k] != 0.0) {
+                i0 = k + 2;
+                for (iy = i0; iy < 7; iy++) {
+                    C[iy - 1] -= C[k] * b_A[(iy + jy) - 1];
+                }
+            }
+        }
+
+        for (k = 5; k >= 0; k--) {
+            jy = 6 * k;
+            if (C[k] != 0.0) {
+                C[k] /= b_A[k + jy];
+                for (iy = 0; iy < k; iy++) {
+                    C[iy] -= C[k] * b_A[iy + jy];
+                }
+            }
+        }
+    }
+
+    void direct_inv_2x2(const double A[4], const double B[2], double C[2])
+    {
+        int r1;
+        int r2;
+        double a21;
+        double C_tmp;
+
+        /* INV_MY Summary of this function goes here */
+        /*    Detailed explanation goes here */
+        if (std::abs(A[1]) > std::abs(A[0])) {
+            r1 = 1;
+            r2 = 0;
+        }
+        else {
+            r1 = 0;
+            r2 = 1;
+        }
+
+        a21 = A[r2] / A[r1];
+        C_tmp = A[2 + r1];
+        C[1] = (B[r2] - B[r1] * a21) / (A[2 + r2] - a21 * C_tmp);
+        C[0] = (B[r1] - C[1] * C_tmp) / A[r1];
+    }
+
+    void ndgrid_my(const double vec1[5], const double vec2[5], double yScalingGrid
+        [25], double xScalingGrid[25])
+    {
+        int k;
+        int b_k;
+
+        /* NDGRID_MY Summary of this function goes here */
+        /*    Detailed explanation goes here */
+        for (k = 0; k < 5; k++) {
+            for (b_k = 0; b_k < 5; b_k++) {
+                yScalingGrid[b_k + 5 * k] = vec1[b_k];
+            }
+        }
+
+        for (k = 0; k < 5; k++) {
+            for (b_k = 0; b_k < 5; b_k++) {
+                xScalingGrid[b_k + 5 * k] = vec2[k];
+            }
+        }
+
+        /*  search around last estimated scaling */
+    }
+
+    void inv(const double x[9], double y[9])
+    {
+        double b_x[9];
+        int p1;
+        int p2;
+        int p3;
+        double absx11;
+        double absx21;
+        double absx31;
+        int itmp;
+        memcpy(&b_x[0], &x[0], 9U * sizeof(double));
+        p1 = 0;
+        p2 = 3;
+        p3 = 6;
+        absx11 = std::abs(x[0]);
+        absx21 = std::abs(x[1]);
+        absx31 = std::abs(x[2]);
+        if ((absx21 > absx11) && (absx21 > absx31)) {
+            p1 = 3;
+            p2 = 0;
+            b_x[0] = x[1];
+            b_x[1] = x[0];
+            b_x[3] = x[4];
+            b_x[4] = x[3];
+            b_x[6] = x[7];
+            b_x[7] = x[6];
+        }
+        else {
+            if (absx31 > absx11) {
+                p1 = 6;
+                p3 = 0;
+                b_x[0] = x[2];
+                b_x[2] = x[0];
+                b_x[3] = x[5];
+                b_x[5] = x[3];
+                b_x[6] = x[8];
+                b_x[8] = x[6];
+            }
+        }
+    
+        b_x[1] /= b_x[0];
+        b_x[2] /= b_x[0];
+        b_x[4] -= b_x[1] * b_x[3];
+        b_x[5] -= b_x[2] * b_x[3];
+        b_x[7] -= b_x[1] * b_x[6];
+        b_x[8] -= b_x[2] * b_x[6];
+        if (std::abs(b_x[5]) > std::abs(b_x[4])) {
+            itmp = p2;
+            p2 = p3;
+            p3 = itmp;
+            absx11 = b_x[1];
+            b_x[1] = b_x[2];
+            b_x[2] = absx11;
+            absx11 = b_x[4];
+            b_x[4] = b_x[5];
+            b_x[5] = absx11;
+            absx11 = b_x[7];
+            b_x[7] = b_x[8];
+            b_x[8] = absx11;
+        }
+    
+        b_x[5] /= b_x[4];
+        b_x[8] -= b_x[5] * b_x[7];
+        absx11 = (b_x[5] * b_x[1] - b_x[2]) / b_x[8];
+        absx21 = -(b_x[1] + b_x[7] * absx11) / b_x[4];
+        y[p1] = ((1.0 - b_x[3] * absx21) - b_x[6] * absx11) / b_x[0];
+        y[p1 + 1] = absx21;
+        y[p1 + 2] = absx11;
+        absx11 = -b_x[5] / b_x[8];
+        absx21 = (1.0 - b_x[7] * absx11) / b_x[4];
+        y[p2] = -(b_x[3] * absx21 + b_x[6] * absx11) / b_x[0];
+        y[p2 + 1] = absx21;
+        y[p2 + 2] = absx11;
+        absx11 = 1.0 / b_x[8];
+        absx21 = -b_x[7] * absx11 / b_x[4];
+        y[p3] = -(b_x[3] * absx21 + b_x[6] * absx11) / b_x[0];
+        y[p3 + 1] = absx21;
+        y[p3 + 2] = absx11;
+    }
+
+    void transpose(const double x[9], double y[9])
+    {
+        for (auto i = 0; i < 3; i++)
+            for (auto j = 0; j < 3; j++)
+                y[i * 3 + j] = x[j * 3 + i];
+    }
+
+    void rotate_180(const uint8_t* A, uint8_t* B, uint32_t w, uint32_t h)
+    {
+        /* ROT Summary of this function goes here */
+        /*    Detailed explanation goes here */
+        for (int j = 0; j < int(w); j++) {
+            for (int i = 0; i < int(h); i++) {
+                B[i + h * j] = A[(h * (w - 1 - j) - i) + h - 1];
+            }
+        }
+    }
+    
+    std::vector< double > interp1( const std::vector< double > & ind,
+                                   const std::vector< double > & vals,
+                                   const std::vector< double > & intrp )
+    {
+        std::vector<double> res(intrp.size(), 0);
+
+        for (auto i = 0; i < intrp.size(); i++)
+        {
+            auto value = intrp[i];
+            auto it = std::lower_bound(ind.begin(), ind.end(), value);
+            if (it == ind.begin())
+            {
+                if (*it == ind.front())
+                    res[i] = ind.front();
+                else
+                    res[i] = std::numeric_limits<double>::max();
+            }
+            else if (it == ind.end())
+            {
+                if (*it == ind.back())
+                    res[i] = ind.back();
+                else
+                    res[i] = std::numeric_limits<double>::max();
+            }
+            else
+            {
+                auto val1 = *(--it);
+                auto ind1 = std::distance(ind.begin(), it);
+                auto val2= *(++it);
+                auto ind2 = std::distance(ind.begin(), it);
+
+                auto target_val1 = vals[ind1];
+                auto target_val2 = vals[ind2];
+
+                res[i] = ((val2 - value) / (val2 - val1))*target_val1 + ((value - val1) / (val2 - val1))*target_val2;
+            }
+        }
+        return res;
+    }
+
+
+    double3x3 cholesky3x3( double3x3 const & mat )
+    {
+        double3x3 res = { 0 };
+
+        for( auto i = 0; i < 3; i++ )
+        {
+            for( auto j = 0; j <= i; j++ )
+            {
+                double sum = 0;
+
+                if( i == j )
+                {
+                    for( auto l = 0; l < i; l++ )
+                    {
+                        sum += res.mat[i][l] * res.mat[i][l];
+                    }
+                    res.mat[i][i] = sqrt( mat.mat[i][j] - sum );
+                }
+                else
+                {
+                    for( auto l = 0; l < j; l++ )
+                    {
+                        sum += res.mat[i][l] * res.mat[j][l];
+                    }
+                    res.mat[i][j] = ( mat.mat[i][j] - sum ) / res.mat[j][j];
+                }
+            }
+        }
+        return res;
+    }
+
+}
+}
+}
\ No newline at end of file
diff --git a/src/algo/depth-to-rgb-calibration/utils.h b/src/algo/depth-to-rgb-calibration/utils.h
new file mode 100644
index 0000000..fef3bea
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/utils.h
@@ -0,0 +1,34 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "calibration-types.h"
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+    void ndgrid_my(const double vec1[5], const double vec2[5], double yScalingGrid[25], double xScalingGrid[25]); //auto generated code
+    void inv(const double x[9], double y[9]); //auto generated code
+    void transpose(const double x[9], double y[9]);
+    void rotate_180(const uint8_t* A, uint8_t* B, uint32_t w, uint32_t h); //auto generated code
+    std::vector< double > interp1( const std::vector< double > & ind,
+                                   const std::vector< double > & vals,
+                                   const std::vector< double > & intrp );
+    double get_norma(const std::vector<double3>& vec);
+    double rad_to_deg(double rad); 
+    double deg_to_rad(double deg);
+    std::vector<double> direct_inv(std::vector<double> A, uint32_t s);
+    void direct_inv_2x2(const double A[4], const double B[2], double C[2]);
+    void direct_inv_6x6(const double A[36], const double B[6], double C[6]);
+    void pinv_3x3( const double in[9], double out[9] );  // in pinv_3x3.cpp
+    void svd_3x4( const double in[12], double out[3] );  // in svd_3x4.cpp
+
+    double3x3 cholesky3x3( double3x3 const & mat );
+
+}
+}
+}
+
diff --git a/src/algo/depth-to-rgb-calibration/uvmap.cpp b/src/algo/depth-to-rgb-calibration/uvmap.cpp
new file mode 100644
index 0000000..292edd5
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/uvmap.cpp
@@ -0,0 +1,150 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "uvmap.h"
+#include <limits>
+#include "debug.h"
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    static void transform_point_to_uv( double pixel[2], const p_matrix & pmat, const double point[3] )
+    {
+        auto p = pmat.vals;
+        // pmat * point
+        double x = p[0] * point[0] + p[1] * point[1] + p[2] * point[2] + p[3];
+        double y = p[4] * point[0] + p[5] * point[1] + p[6] * point[2] + p[7];
+        double z = p[8] * point[0] + p[9] * point[1] + p[10] * point[2] + p[11];
+
+        pixel[0] = x / z;
+        pixel[1] = y / z;
+    }
+
+
+    /* Given a point in 3D space, compute the corresponding pixel coordinates in an image with no distortion or forward distortion coefficients produced by the same camera */
+    static void distort_pixel( double pixel[2], const rs2_intrinsics_double * intrin, const double point[2] )
+    {
+        double x = (point[0] - intrin->ppx) / intrin->fx;
+        double y = (point[1] - intrin->ppy) / intrin->fy;
+
+        if( intrin->model == RS2_DISTORTION_BROWN_CONRADY )
+        {
+            double r2 = x * x + y * y;
+            double r2c = 1 + intrin->coeffs[0] * r2 + intrin->coeffs[1] * r2*r2 + intrin->coeffs[4] * r2*r2*r2;
+
+            double xcd = x * r2c;
+            double ycd = y * r2c;
+
+            double dx = xcd + 2 * intrin->coeffs[2] * x*y + intrin->coeffs[3] * (r2 + 2 * x*x);
+            double dy = ycd + 2 * intrin->coeffs[3] * x*y + intrin->coeffs[2] * (r2 + 2 * y*y);
+
+            x = dx;
+            y = dy;
+        }
+
+        pixel[0] = x * (double)intrin->fx + (double)intrin->ppx;
+        pixel[1] = y * (double)intrin->fy + (double)intrin->ppy;
+    }
+
+
+    uvmap_t get_texture_map(
+        std::vector< double3 > const & points,
+        const calib & cal,
+        const p_matrix & p_mat
+    )
+    {
+        auto intrinsics = cal.get_intrinsics();
+
+        std::vector< double2 > uv_map( points.size() );
+
+        for( auto i = 0; i < points.size(); ++i )
+        {
+            double2 uv;
+            transform_point_to_uv( &uv.x, p_mat, &points[i].x );
+
+            double2 uvmap;
+            distort_pixel( &uvmap.x, &intrinsics, &uv.x );
+            uv_map[i] = uvmap;
+        }
+
+        return uv_map;
+    }
+
+
+    std::vector< double > biliniar_interp(
+        std::vector< double > const & vals,
+        size_t width,
+        size_t height,
+        uvmap_t const & uv
+    )
+    {
+        std::vector< double > res( uv.size() );
+
+        for( auto i = 0; i < uv.size(); i++ )
+        {
+            auto x = uv[i].x;
+            auto x1 = floor( x );
+            auto x2 = ceil( x );
+            auto y = uv[i].y;
+            auto y1 = floor( y );
+            auto y2 = ceil( y );
+
+            if( x1 < 0 || x1 >= width || x2 < 0 || x2 >= width ||
+                y1 < 0 || y1 >= height || y2 < 0 || y2 >= height )
+            {
+                res[i] = std::numeric_limits<double>::max();
+                continue;
+            }
+
+            // x1 y1    x2 y1
+            // x1 y2    x2 y2
+
+            // top_l    top_r
+            // bot_l    bot_r
+
+            auto top_l = vals[int( y1*width + x1 )];
+            auto top_r = vals[int( y1*width + x2 )];
+            auto bot_l = vals[int( y2*width + x1 )];
+            auto bot_r = vals[int( y2*width + x2 )];
+
+            double interp_x_top, interp_x_bot;
+            if( x1 == x2 )
+            {
+                interp_x_top = top_l;
+                interp_x_bot = bot_l;
+            }
+            else
+            {
+                interp_x_top = ((double)(x2 - x) / (double)(x2 - x1))*(double)top_l + ((double)(x - x1) / (double)(x2 - x1))*(double)top_r;
+                interp_x_bot = ((double)(x2 - x) / (double)(x2 - x1))*(double)bot_l + ((double)(x - x1) / (double)(x2 - x1))*(double)bot_r;
+            }
+
+            if( y1 == y2 )
+            {
+                res[i] = interp_x_bot;
+                continue;
+            }
+
+            auto interp_y_x = ((double)(y2 - y) / (double)(y2 - y1))*(double)interp_x_top + ((double)(y - y1) / (double)(y2 - y1))*(double)interp_x_bot;
+            res[i] = interp_y_x;
+        }
+
+#if 0
+        std::ofstream f;
+        f.open( "interp_y_x" );
+        f.precision( 16 );
+        for( auto i = 0; i < res.size(); i++ )
+        {
+            f << res[i] << std::endl;
+        }
+        f.close();
+#endif
+        return res;
+    }
+
+
+}
+}
+}
\ No newline at end of file
diff --git a/src/algo/depth-to-rgb-calibration/uvmap.h b/src/algo/depth-to-rgb-calibration/uvmap.h
new file mode 100644
index 0000000..0ffe50c
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/uvmap.h
@@ -0,0 +1,45 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "calibration.h"
+
+
+namespace librealsense {
+namespace algo {
+namespace depth_to_rgb_calibration {
+
+
+    /*
+    A UV-map is simply a collection of 2D points on the RGB frame.
+
+    In our case, the point may not fall neatly on (integer) coordinates but,
+    rather, in-between! In this case, bilinear interpolation can be used to
+    actually transform any another WxH (per-coordinate) value matrix into a
+    per-UV-pixel vector of interpolated values.
+    */
+    typedef std::vector< double2 > uvmap_t;
+
+
+    // Map 3D points to a UV-map given a calibration
+    uvmap_t get_texture_map(
+        std::vector< double3 > const & vertices,
+        calib const & calibration,
+        p_matrix const & p_mat
+    );
+
+
+    // Interpolate WxH values (unit unspecified) according to a (N-sized)
+    // vector of (x,y) pixels to an (N-sized) output vector of values
+    std::vector< double > biliniar_interp(
+        std::vector< double > const & values,
+        size_t width,
+        size_t height,
+        uvmap_t const & uvmap
+    );
+
+
+}
+}
+}
diff --git a/src/algo/depth-to-rgb-calibration/valid-results.cpp b/src/algo/depth-to-rgb-calibration/valid-results.cpp
new file mode 100644
index 0000000..8281817
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/valid-results.cpp
@@ -0,0 +1,397 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "optimizer.h"
+#include "cost.h"
+#include "debug.h"
+
+using namespace librealsense::algo::depth_to_rgb_calibration;
+
+
+// Return the average pixel movement from the calibration
+double optimizer::calc_correction_in_pixels( calib const & from_calibration, calib const & to_calibration) const
+{
+    //%    [uvMap,~,~] = OnlineCalibration.aux.projectVToRGB(frame.vertices,params.rgbPmat,params.Krgb,params.rgbDistort);
+    //% [uvMapNew,~,~] = OnlineCalibration.aux.projectVToRGB(frame.vertices,newParams.rgbPmat,newParams.Krgb,newParams.rgbDistort);
+    auto old_uvmap = get_texture_map( _z.orig_vertices, from_calibration, from_calibration.calc_p_mat());
+    auto new_uvmap = get_texture_map( _z.vertices, to_calibration, to_calibration.calc_p_mat());
+
+    return calc_correction_in_pixels( old_uvmap, new_uvmap );
+}
+
+
+double optimizer::calc_correction_in_pixels( uvmap_t const & old_uvmap, uvmap_t const & new_uvmap ) const
+{
+    // uvmap is Nx[x,y]
+
+    if( old_uvmap.size() != new_uvmap.size() )
+        throw std::runtime_error( to_string()
+                                  << "did not expect different uvmap sizes (" << old_uvmap.size()
+                                  << " vs " << new_uvmap.size() << ")" );
+
+    //% xyMovement = mean(sqrt(sum((uvMap-uvMapNew).^2,2)));
+    // note: "the mean of a vector containing NaN values is also NaN"
+    // note: .^ = element-wise power
+    // note: "if A is a matrix, then sum(A,2) is a column vector containing the sum of each row"
+    // -> so average of sqrt( dx^2 + dy^2 )
+
+    size_t const n_pixels = old_uvmap.size();
+    if( !n_pixels )
+        throw std::runtime_error( "no pixels found in uvmap" );
+    double sum = 0;
+    for( auto i = 0; i < n_pixels; i++ )
+    {
+        double2 const & o = old_uvmap[i];
+        double2 const & n = new_uvmap[i];
+        double dx = o.x - n.x, dy = o.y - n.y;
+        double movement = sqrt( dx * dx + dy * dy );
+        sum += movement;
+    }
+    return sum / n_pixels;
+}
+
+// Movement of pixels should clipped by a certain number of pixels
+// This function actually changes the calibration if it exceeds this number of pixels!
+void optimizer::clip_pixel_movement( size_t iteration_number )
+{
+    double xy_movement = calc_correction_in_pixels(_final_calibration);
+
+    // Clip any (average) movement of pixels if it's too big
+    AC_LOG( INFO, "    average pixel movement= " << xy_movement );
+
+    size_t n_max_movements = sizeof( _params.max_xy_movement_per_calibration ) / sizeof( _params.max_xy_movement_per_calibration[0] );
+    double const max_movement = _params.max_xy_movement_per_calibration[std::min( n_max_movements - 1, iteration_number )];
+
+    if( xy_movement > max_movement )
+    {
+        AC_LOG( WARNING, "Pixel movement too big: clipping at limit for iteration (" << iteration_number << ")= " << max_movement );
+
+        //% mulFactor = maxMovementInThisIteration/xyMovement;
+        double const mul_factor = max_movement / xy_movement;
+
+        //% if ~strcmp( params.derivVar, 'P' )
+        // -> assuming params.derivVar == 'KrgbRT'!!
+        //%     optParams = { 'xAlpha'; 'yBeta'; 'zGamma'; 'Trgb'; 'Kdepth'; 'Krgb' };
+        // -> note we don't do Kdepth at this time!
+        //%     for fn = 1:numel( optParams )
+        //%         diff = newParams.(optParams{ fn }) - params.(optParams{ fn });
+        //%         newParams.(optParams{ fn }) = params.(optParams{ fn }) + diff * mulFactor;
+        //%     end
+        calib const & old_calib = _original_calibration;
+        calib & new_calib = _final_calibration;
+        new_calib = old_calib + (new_calib - old_calib) * mul_factor;
+
+    }
+}
+
+std::vector< double > optimizer::cost_per_section_diff(calib const & old_calib, calib const & new_calib)
+{
+    // We require here that the section_map is initialized and ready
+    if (_z.section_map.size() != _z.weights.size())
+        throw std::runtime_error("section_map has not been initialized");
+
+    auto uvmap_old = get_texture_map(_z.orig_vertices, old_calib, old_calib.calc_p_mat());
+    auto uvmap_new = get_texture_map(_z.vertices, new_calib, new_calib.calc_p_mat());
+
+    size_t const n_sections_x = _params.num_of_sections_for_edge_distribution_x;
+    size_t const n_sections_y = _params.num_of_sections_for_edge_distribution_y;
+    size_t const n_sections = n_sections_x * n_sections_y;
+
+    std::vector< double > cost_per_section_diff(n_sections, 0.);
+    std::vector< size_t > N_per_section(n_sections, 0);
+
+    //old
+    auto d_vals_old = biliniar_interp(_yuy.edges_IDT, _yuy.width, _yuy.height, uvmap_old);
+
+    auto cost_per_vertex_old = calc_cost_per_vertex(d_vals_old, _z, _yuy,
+        [&](size_t i, double d_val, double weight, double vertex_cost) {});
+
+    //new
+    auto d_vals_new = biliniar_interp(_yuy.edges_IDT, _yuy.width, _yuy.height, uvmap_new);
+
+    auto cost_per_vertex_new = calc_cost_per_vertex(d_vals_new, _z, _yuy,
+        [&](size_t i, double d_val, double weight, double vertex_cost) {});
+
+
+    for (auto i = 0; i < cost_per_vertex_new.size(); i++)
+    {
+        if (d_vals_old[i] != std::numeric_limits<double>::max() && d_vals_new[i] != std::numeric_limits<double>::max())
+        {
+            byte section = _z.section_map[i];
+            cost_per_section_diff[section] += (cost_per_vertex_new[i] - cost_per_vertex_old[i]);
+            ++N_per_section[section];
+        }
+    }
+
+    for (size_t x = 0; x < n_sections; ++x)
+    {
+
+        double & cost = cost_per_section_diff[x];
+        size_t N = N_per_section[x];
+        if (N)
+            cost /= N;
+    }
+
+    return cost_per_section_diff;
+}
+
+
+void optimizer::clip_ac_scaling( rs2_dsm_params_double const & ac_data_in,
+                                 rs2_dsm_params_double & ac_data_new ) const
+{
+    if( abs( ac_data_in.h_scale - ac_data_new.h_scale ) > _params.max_global_los_scaling_step )
+    {
+        double const new_h_scale = ac_data_in.h_scale
+                                 + ( ac_data_new.h_scale - ac_data_in.h_scale )
+                                       / abs( ac_data_new.h_scale - ac_data_in.h_scale )
+                                       * _params.max_global_los_scaling_step;
+        AC_LOG( DEBUG,
+                "    H scale delta ("
+                    << AC_D_PREC << abs( ac_data_in.h_scale - ac_data_new.h_scale )
+                    << " > max global LoS scaling per step (" << _params.max_global_los_scaling_step
+                    << "); clipping to " << new_h_scale );
+        ac_data_new.h_scale = new_h_scale;
+    }
+    if( abs( ac_data_in.v_scale - ac_data_new.v_scale ) > _params.max_global_los_scaling_step )
+    {
+        double const new_v_scale = ac_data_in.v_scale
+                                 + ( ac_data_new.v_scale - ac_data_in.v_scale )
+                                       / abs( ac_data_new.v_scale - ac_data_in.v_scale )
+                                       * _params.max_global_los_scaling_step;
+        AC_LOG( DEBUG,
+                "    V scale delta ("
+                    << AC_D_PREC << abs( ac_data_in.v_scale - ac_data_new.v_scale )
+                    << " > max global LoS scaling per step (" << _params.max_global_los_scaling_step
+                    << "); clipping to " << new_v_scale );
+        ac_data_new.v_scale = new_v_scale;
+    }
+}
+
+std::vector< double > extract_features(decision_params& decision_params)
+{
+    svm_features features;
+    std::vector< double > res;
+    auto max_elem = *std::max_element(decision_params.distribution_per_section_depth.begin(), decision_params.distribution_per_section_depth.end());
+    auto min_elem = *std::min_element(decision_params.distribution_per_section_depth.begin(), decision_params.distribution_per_section_depth.end());
+    features.max_over_min_depth = max_elem / (min_elem + 1e-3);
+    res.push_back(features.max_over_min_depth);
+
+    max_elem = *std::max_element(decision_params.distribution_per_section_rgb.begin(), decision_params.distribution_per_section_rgb.end());
+    min_elem = *std::min_element(decision_params.distribution_per_section_rgb.begin(), decision_params.distribution_per_section_rgb.end());
+    features.max_over_min_rgb = max_elem / (min_elem + 1e-3);
+    res.push_back(features.max_over_min_rgb);
+
+    std::vector<double>::iterator it = decision_params.edge_weights_per_dir.begin();
+    max_elem = std::max(*it, *(it + 2));
+    min_elem = std::min(*it, *(it + 2));
+    features.max_over_min_perp = max_elem / (min_elem + 1e-3);
+    res.push_back(features.max_over_min_perp);
+
+    max_elem = std::max(*(it + 1), *(it + 3));
+    min_elem = std::min(*(it + 1), *(it + 3));
+    features.max_over_min_diag = max_elem / (min_elem + 1e-3);
+    res.push_back(features.max_over_min_diag);
+
+    features.initial_cost = decision_params.initial_cost;
+    features.final_cost = decision_params.new_cost;
+    res.push_back(features.initial_cost);
+    res.push_back(features.final_cost);
+
+    features.xy_movement = decision_params.xy_movement;
+    if (features.xy_movement > 100) { features.xy_movement = 100; }
+    features.xy_movement_from_origin = decision_params.xy_movement_from_origin;
+    if (features.xy_movement_from_origin > 100) { features.xy_movement_from_origin = 100; }
+    res.push_back(features.xy_movement);
+    res.push_back(features.xy_movement_from_origin);
+
+    std::vector<double>::iterator  iter = decision_params.improvement_per_section.begin();
+    features.positive_improvement_sum = 0;
+    features.negative_improvement_sum = 0;
+    for (int i = 0; i < decision_params.improvement_per_section.size(); i++)
+    {
+        if (*(iter + i) > 0)
+        {
+            features.positive_improvement_sum += *(iter + i);
+        }
+        else
+        {
+            features.negative_improvement_sum += *(iter + i);
+        }
+    }
+    res.push_back(features.positive_improvement_sum);
+    res.push_back(features.negative_improvement_sum);
+
+    return res;
+}
+void optimizer::collect_decision_params(z_frame_data& z_data, yuy2_frame_data& yuy_data)
+{
+     auto uvmap = get_texture_map(_z.orig_vertices,
+        _original_calibration,
+        _original_calibration.calc_p_mat());
+
+    _decision_params.initial_cost = calc_cost(z_data, yuy_data, uvmap); //1.560848046875000e+04;
+    //_decision_params.is_valid = 0;
+    _decision_params.xy_movement = calc_correction_in_pixels(_optimaized_calibration); //2.376f; // 
+    _decision_params.xy_movement_from_origin = calc_correction_in_pixels(_optimaized_calibration); //2.376f;
+    _decision_params.improvement_per_section = _z.cost_diff_per_section; // { -4.4229550, 828.93903, 1424.0482, 2536.4409 }; 
+    _decision_params.min_improvement_per_section = *std::min_element(_z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end());// -4.422955036163330;
+    _decision_params.max_improvement_per_section = *std::max_element(_z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end()); //2.536440917968750e+03;// 
+    //_decision_params.is_valid_1 = 1;
+    //_decision_params.moving_pixels = 0;
+    _decision_params.min_max_ratio_depth = z_data.min_max_ratio; // 0.762463343108504;
+    _decision_params.distribution_per_section_depth = z_data.sum_weights_per_section; //{ 980000, 780000, 1023000, 816000 };
+    _decision_params.min_max_ratio_rgb = yuy_data.min_max_ratio; // 0.618130692181835;
+    _decision_params.distribution_per_section_rgb = yuy_data.sum_weights_per_section; //{3025208, 2.899468500000000e+06, 4471484, 2.763961500000000e+06};
+    _decision_params.dir_ratio_1 = z_data.dir_ratio1;// 2.072327044025157;
+    //_decision_params.dir_ratio_2 = z_data.dir_ratio2;
+    _decision_params.edge_weights_per_dir = z_data.sum_weights_per_direction;// { 636000, 898000, 1318000, 747000 };
+    std::vector<double2> new_uvmap = get_texture_map(_z.vertices, _optimaized_calibration, _optimaized_calibration.calc_p_mat());
+    _decision_params.new_cost = calc_cost(z_data, yuy_data, new_uvmap);// 1.677282421875000e+04; 
+
+}
+bool svm_rbf_predictor(std::vector< double >& features, svm_model_gaussian& svm_model)
+{
+    bool res = true;
+    std::vector< double > x_norm;
+    // Applying the model
+    for (auto i = 0; i < features.size(); i++)
+    {
+        x_norm.push_back((*(features.begin() + i) - *(svm_model.mu.begin() + i)) / (*(svm_model.sigma.begin() + i)));
+    }
+
+    // Extracting model parameters
+    auto mu = svm_model.mu;
+    auto sigma = svm_model.sigma;
+    auto x_sv = svm_model.support_vectors;
+    auto y_sv = svm_model.support_vectors_labels;
+    auto alpha = svm_model.alpha;
+    auto bias = svm_model.bias;
+    auto gamma = 1 / (svm_model.kernel_param_scale * svm_model.kernel_param_scale);
+    int n_samples = 1;// size(featuresMat, 1);
+    //labels = zeros(nSamples, 1);
+   /* innerProduct = exp(-gamma * sum((xNorm(iSample, :) - xSV). ^ 2, 2));
+    score = sum(alpha.*ySV.*innerProduct, 1) + bias;
+    labels(iSample) = score > 0; % dealing with the theoretical possibility of score = 0*/
+    std::vector< double > inner_product;
+    double score = 0;
+
+    for (auto i = 0; i < y_sv.size(); i++)
+    {
+        double sum_raw = 0;
+        for (auto k = 0; k < x_norm.size(); k++)
+        {
+            double res1 = *(x_norm.begin() + k) - *(x_sv[k].begin() + i);
+            sum_raw += res1 * res1;
+        }
+        double final_sum = exp(-gamma * sum_raw);
+        inner_product.push_back(final_sum);
+        score += *(alpha.begin() + i) * *(y_sv.begin() + i) * final_sum;
+        //score = sum(alpha .* ySV .* innerProduct, 1) + bias;
+    }
+    score += bias;
+
+    if (score < 0)
+    {
+        res = false;
+    }
+    return res;
+}
+bool optimizer::valid_by_svm(svm_model model)
+{
+    bool is_valid = true;
+
+    collect_decision_params(_z, _yuy);
+    _extracted_features = extract_features(_decision_params);
+
+    double res = 0;
+    switch (model)
+    {
+    case linear:
+        for (auto i = 0; i < _svm_model_linear.mu.size(); i++)
+        {
+            // isValid = (featuresMat-SVMModel.Mu)./SVMModel.Sigma*SVMModel.Beta+SVMModel.Bias > 0;
+            auto res1 = (*(_extracted_features.begin() + i) - *(_svm_model_linear.mu.begin() + i)) / (*(_svm_model_linear.sigma.begin() + i));// **(_svm_model_linear.beta.begin() + i) + _svm_model_linear.bias);
+            res += res1 * *(_svm_model_linear.beta.begin() + i);
+        }
+        res += _svm_model_linear.bias;
+        if (res < 0)
+        {
+            AC_LOG( INFO, "Calibration invalid according to SVM linear model" );
+            is_valid = false;
+        }
+        break;
+
+    case gaussian:
+        is_valid = svm_rbf_predictor(_extracted_features, _svm_model_gaussian);
+        break;
+    default:
+        AC_LOG(DEBUG, "ERROR : Unknown SVM kernel " << model);
+        break;
+    }
+
+    return is_valid;
+}
+
+
+bool optimizer::is_valid_results()
+{
+    if( get_final_data_from_bin )
+    {
+        _z.vertices = _vertices_from_bin;
+        _final_calibration = decompose_p_mat( _p_mat_from_bin );
+        _optimaized_calibration = decompose_p_mat( _p_mat_from_bin_opt );
+    }
+
+
+    bool res = true;
+    // Clip any (average) movement of pixels if it's too big
+    clip_pixel_movement();
+
+    // Based on (possibly new, clipped) calibration values, see if we've strayed too
+    // far away from the camera's original factory calibration -- which we may not have
+    if( _factory_calibration.width  &&  _factory_calibration.height )
+    {
+        double xy_movement = calc_correction_in_pixels(_final_calibration);
+        AC_LOG( DEBUG, "... average pixel movement from factory calibration= " << xy_movement );
+        if( xy_movement > _params.max_xy_movement_from_origin )
+        {
+            AC_LOG( ERROR, "Calibration has moved too far from the original factory calibration (" << xy_movement << " pixels)" );
+            return false;
+        }
+    }
+    else
+    {
+        AC_LOG( DEBUG, "... no factory calibration available; skipping distance check" );
+    }
+
+    /* %% Check and see that the score didn't increased by a lot in one image section and decreased in the others
+     % [c1, costVecOld] = OnlineCalibration.aux.calculateCost( frame.vertices, frame.weights, frame.rgbIDT, params );
+     % [c2, costVecNew] = OnlineCalibration.aux.calculateCost( frame.vertices, frame.weights, frame.rgbIDT, newParams );
+     % scoreDiffPerVertex = costVecNew - costVecOld;
+     % for i = 0:(params.numSectionsH*params.numSectionsV) - 1
+     %     scoreDiffPersection( i + 1 ) = nanmean( scoreDiffPerVertex( frame.sectionMapDepth == i ) );
+     % end*/
+    _z.cost_diff_per_section
+        = cost_per_section_diff( _original_calibration, _optimaized_calibration );
+    //% validOutputStruct.minImprovementPerSection = min( scoreDiffPersection );
+    //% validOutputStruct.maxImprovementPerSection = max( scoreDiffPersection );
+    double min_cost_diff
+        = *std::min_element( _z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end() );
+    double max_cost_diff
+        = *std::max_element( _z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end() );
+    AC_LOG( DEBUG, "... min cost diff= " << min_cost_diff << "  max= " << max_cost_diff );
+    if( min_cost_diff < 0. )
+    {
+        AC_LOG( ERROR,
+                "Some image sections were hurt by the optimization; invalidating calibration!" );
+        for( size_t x = 0; x < _z.cost_diff_per_section.size(); ++x )
+            AC_LOG( DEBUG,
+                    "... cost diff in section " << x << "= " << _z.cost_diff_per_section[x] );
+        // return false;
+        res = false;
+    }
+
+    bool res_svm = valid_by_svm( linear );  //(gaussian);
+    return ( res && res_svm );
+}
+
diff --git a/src/algo/depth-to-rgb-calibration/valid-scene.cpp b/src/algo/depth-to-rgb-calibration/valid-scene.cpp
new file mode 100644
index 0000000..2ac5084
--- /dev/null
+++ b/src/algo/depth-to-rgb-calibration/valid-scene.cpp
@@ -0,0 +1,683 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "optimizer.h"
+#include <librealsense2/rsutil.h>
+#include <algorithm>
+#include <array>
+#include "coeffs.h"
+#include "cost.h"
+#include "debug.h"
+#include <math.h>
+
+
+#define GAUSS_CONV_ROWS 4
+#define GAUSS_CONV_COLUMNS 4
+#define GAUSS_CONV_CORNERS 16
+
+using namespace librealsense::algo::depth_to_rgb_calibration;
+using librealsense::to_string;
+
+template<class T>
+std::vector<double> gauss_convolution(std::vector<T> const& image,
+    size_t image_width, size_t image_height,
+    size_t mask_width, size_t mask_height,
+    std::function< double(std::vector<T> const& sub_image) > convolution_operation
+    )
+{
+    // boundaries handling 
+    // Extend - The nearest border pixels are conceptually extended as far as necessary to provide values for the convolution.
+    // Corner pixels are extended in 90 wedges.Other edge pixels are extended in lines.
+    // https://en.wikipedia.org/wiki/Kernel_(image_processing)
+    // handling order:
+    // 1. rows: 0,1 and image_height-1, image_height-2
+    // 2. columns: 0,1 and image_width-1, image_width-2
+    // 3. corners: 4 pixels in each corner
+    // 4. rest of the pixels
+
+    // 1. rows handling :
+    std::vector<double> res(image.size(), 0);
+    std::vector<T> sub_image(mask_width * mask_height, 0);
+    size_t ind = 0;
+    size_t row_bound[GAUSS_CONV_ROWS] = { 0, 1, image_height - 1,image_height - 2 };
+    size_t lines[GAUSS_CONV_ROWS] = { 2, 1, 2 , 1 };
+    size_t first_rows[GAUSS_CONV_ROWS] = { 1,1,0,0 };
+    size_t last_rows[GAUSS_CONV_ROWS] = { 0,0,1,1 };
+    
+    for (auto row = 0; row < GAUSS_CONV_ROWS; row++) {
+        for (auto jj = 0; jj < image_width - mask_width + 1; jj++)
+        {
+            ind = first_rows[row] * mask_width * lines[row]; // skip first 1/2 rows in sub-image for padding - start from 2nd/3rd line
+            for (auto l = first_rows[row] * lines[row]; l < mask_height - last_rows[row] * lines[row]; l++)
+            {
+                for (auto k = 0; k < mask_width; k++)
+                {
+                    auto p = (l - first_rows[row] * lines[row] + last_rows[row] * (-2 + row_bound[row])) * image_width + jj + k;
+                    sub_image[ind++] = (image[p]);
+                }
+            }
+            // fill first 2 lines to same values as 3rd line
+            ind = first_rows[row] * mask_width * lines[row] + last_rows[row] * (mask_width * (mask_height - lines[row]));
+            auto ind_pad = last_rows[row] * (mask_width * (mask_height - lines[row] - 1)); // previous line
+            for (auto k = 0; k < mask_width * lines[row]; k++)
+            {
+                auto idx1 = last_rows[row] * ind;
+                auto idx2 = last_rows[row] * ind_pad + first_rows[row] * ind;
+                sub_image[k + idx1] = sub_image[k % mask_width + idx2];
+            }
+            auto mid = jj + mask_width / 2 + row_bound[row] * image_width;
+            res[mid] = convolution_operation(sub_image);
+        }
+    }
+
+    // 2. columns handling :
+    size_t column_boundaries[GAUSS_CONV_COLUMNS] = { 0,1, image_width - 1 ,image_width - 2 };
+    size_t columns[GAUSS_CONV_COLUMNS] = { 2, 1, 2, 1 };
+    size_t left_column[GAUSS_CONV_COLUMNS] = { 1,1,0,0 };
+    size_t right_column[GAUSS_CONV_COLUMNS] = { 0,0,1,1 };
+    for (auto col = 0; col < GAUSS_CONV_COLUMNS; col++) {
+        for (size_t ii = 0; ii < image_height - mask_height + 1; ii++)
+        {
+            ind = 0; 
+            for (auto l = 0; l < mask_height; l++)
+            {
+                ind += left_column[col] * columns[col];
+                for (auto k = left_column[col] * columns[col]; k < mask_width - right_column[col] * columns[col]; k++)
+                {
+                    size_t p = (ii + l) * image_width + k - left_column[col] * columns[col] + right_column[col] * (column_boundaries[col] - 2);
+                    sub_image[ind++] = (image[p]);
+                }
+                ind += right_column[col] * columns[col];
+            }
+            // fill first 2 columns to same values as 3rd column
+            ind = columns[col];
+            for (auto l = 0; l < mask_height; l++)
+            {
+                ind = left_column[col] * columns[col] + right_column[col] * (mask_height - columns[col] - 1) + l * mask_width;
+                for (auto k = 1; k <= columns[col]; k++)
+                {
+                    auto idx = left_column[col] * (ind - k) + right_column[col] * (ind + k);
+                    sub_image[idx] = sub_image[ind];
+                }
+            }
+            auto mid = (ii + mask_height / 2) * image_width + column_boundaries[col];
+            res[mid] = convolution_operation(sub_image);
+        }
+    }
+
+    // 3. corners handling
+    size_t corners_arr[GAUSS_CONV_CORNERS] = { 0,1,image_width, image_width + 1,  image_width - 1, image_width - 2, 2 * image_width - 1, 2 * image_width - 2,
+        (image_height - 2) * image_width,(image_height - 2) * image_width,  // left corners - line before the last
+        (image_height - 1) * image_width,(image_height - 1) * image_width,
+        (image_height - 2) * image_width,(image_height - 2) * image_width,  // right corners - last row
+        (image_height - 1) * image_width,(image_height - 1) * image_width };
+
+    size_t corners_arr_col[GAUSS_CONV_CORNERS] = { 0,0,0,0,0,0,0,0,0,1,0,1,image_width - 1,image_width - 2,image_width - 1,image_width - 2 };
+    size_t left_col[GAUSS_CONV_CORNERS] = { 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0 };
+    size_t right_col[GAUSS_CONV_CORNERS] = { 0,0,0,0,1,1 ,1,1,0,0,0,0,1,1,1,1 };
+    size_t up_rows[GAUSS_CONV_CORNERS] = { 1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0 };
+    size_t down_rows[GAUSS_CONV_CORNERS] = { 0,0,0,0,0,0 ,0,0,1,1,1,1,1,1,1,1 };
+    size_t corner_columns[GAUSS_CONV_CORNERS] = { 2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1 };
+    size_t corner_rows[GAUSS_CONV_CORNERS] = { 2, 2,1,1 ,2,2,1,1,1,1,2,2,1,1,2,2 };
+    for (auto corner = 0; corner < GAUSS_CONV_CORNERS; corner++) {
+        ind = up_rows[corner] * corner_rows[corner] * mask_width; // starting point in sub-image
+        for (auto l = up_rows[corner] * corner_rows[corner]; l < mask_height - down_rows[corner] * corner_rows[corner]; l++)
+        {
+            ind += left_col[corner] * corner_columns[corner];
+            for (auto k = left_col[corner] * corner_columns[corner]; k < mask_width - right_col[corner] * corner_columns[corner]; k++)
+            {
+                auto up_row_i = (l - corner_rows[corner] + right_col[corner] * (corner_rows[corner] - 2)) * image_width;
+                auto up_col_i = k - left_col[corner] * corner_columns[corner] + right_col[corner] * (corners_arr[corner] - 2);
+                auto down_row_i = (l - 2) * image_width + corners_arr[corner];
+                auto down_col_i = k - left_col[corner] * corner_columns[corner] + right_col[corner] * (corners_arr_col[corner] - 2);
+                auto col_i = down_rows[corner] * down_col_i + up_rows[corner] * up_col_i;
+                auto row_i = down_rows[corner] * down_row_i + up_rows[corner] * up_row_i;
+                auto p = row_i + col_i;
+                sub_image[ind++] = (image[p]);
+            }
+            ind += right_col[corner] * corner_columns[corner];
+        }
+        // fill first 2 columns to same values as 3rd column
+        // and first 2 rows to same values as 3rd row
+        // 3.1. rows
+        auto l_init = down_rows[corner] * (mask_height - corner_rows[corner]); // pad last rows
+        auto l_limit = up_rows[corner] * corner_rows[corner] + down_rows[corner] * mask_height;
+        for (auto l = l_init; l < l_limit; l++)
+        {
+            ind = up_rows[corner] * (corner_rows[corner] * mask_width) + down_rows[corner] * (mask_height - corner_rows[corner] - 1) * mask_width; // start with padding first 2 rows
+            auto ind2 = l * mask_width;
+            for (auto k = 0; k < mask_width; k++)
+            {
+                sub_image[k + ind2] = sub_image[ind++];
+            }
+        }
+        // 3.2. columns
+        for (auto l = 0; l < mask_height; l++)
+        {
+            ind = l * mask_width + left_col[corner] * corner_columns[corner] + right_col[corner] * (mask_width - 1 - corner_columns[corner]);
+            auto ind2 = l * mask_width + right_col[corner] * (mask_width - corner_columns[corner]);
+            for (auto k = 0; k < corner_columns[corner]; k++)
+            {
+                sub_image[k + ind2] = sub_image[ind];
+            }
+        }
+        auto mid = corners_arr[corner] + corners_arr_col[corner];
+        res[mid] = convolution_operation(sub_image);
+    }
+
+    // 4. rest of the pixel in the middle
+    for (size_t i = 0; i < image_height - mask_height + 1; i++)
+    {
+        for (size_t j = 0; j < image_width - mask_width + 1; j++)
+        {
+            ind = 0;
+            for (size_t l = 0; l < mask_height; l++)
+            {
+                for (size_t k = 0; k < mask_width; k++)
+                {
+                    size_t p = (i + l) * image_width + j + k;
+                    sub_image[ind++] = (image[p]);
+                }
+
+            }
+            auto mid = (i + mask_height / 2) * image_width + j + mask_width / 2;
+            res[mid] = convolution_operation(sub_image);
+        }
+    }
+    return res;
+}
+template<class T>
+std::vector<uint8_t> dilation_convolution(std::vector<T> const& image,
+    size_t image_width, size_t image_height,
+    size_t mask_width, size_t mask_height,
+    std::function< uint8_t(std::vector<T> const& sub_image) > convolution_operation
+    )
+{
+    // poundaries handling 
+    // Extend boundary rows and columns to zeros
+
+    // 1. rows
+    std::vector<uint8_t> res(image.size(), 0);
+    std::vector<T> sub_image(mask_width * mask_height, 0);
+    auto ind = 0;
+    size_t rows[2] = { 0, image_height - 1 };
+
+    for (auto rows_i = 0; rows_i < 2; rows_i++) {
+        for (auto jj = 0; jj < image_width - mask_width + 1; jj++)
+        {
+            ind = 0;
+            for (auto l = 0; l < mask_height; l++)
+            {
+                for (auto k = 0; k < mask_width; k++)
+                {
+                    size_t p = (l + rows[rows_i]) * image_width + jj + k;
+                    if (rows_i != 0)
+                    {
+                        p = p - 2 * image_width;
+                    }
+                    sub_image[ind] = (image[p]);
+                    bool cond1 = (l == 2) && (rows_i == 0);
+                    bool cond2 = (l == 0) && (rows_i == 1);
+                    if (cond1 || cond2) {
+                        sub_image[ind] = 0;
+                    }
+                    ind++;
+                }
+            }
+            size_t mid = jj + mask_width / 2 + rows[rows_i] * image_width;
+            res[mid] = convolution_operation(sub_image);
+        }
+    }
+
+    // 2. columns
+    size_t columns[2] = { 0, image_width - 1 };
+    for (size_t columns_i = 0; columns_i < 2; columns_i++) {
+        for (size_t ii = 0; ii < image_height - mask_height + 1; ii++)
+        {
+            ind = 0;
+            for (size_t l = 0; l < mask_height; l++)
+            {
+                for (size_t k = 0; k < mask_width; k++)
+                {
+                    size_t p = (ii + l) * image_width + k + columns[columns_i];
+                    if (columns_i != 0)
+                    {
+                        p = p - 2;
+                    }
+                    sub_image[ind] = (image[p]);
+                    bool cond1 = (k == 2) && (columns_i == 0);
+                    bool cond2 = (k == 0) && (columns_i == 1);
+                    if (cond1 || cond2) {
+                        sub_image[ind] = 0;
+                    }
+                    ind++;
+                }
+                auto mid = (ii + mask_height / 2) * image_width + columns[columns_i];
+                res[mid] = convolution_operation(sub_image);
+            }
+        }
+    }
+    // 3. rest of the pixels
+    for (size_t i = 0; i < image_height - mask_height + 1; i++)
+    {
+        for (size_t j = 0; j < image_width - mask_width + 1; j++)
+        {
+            ind = 0;
+            for (size_t l = 0; l < mask_height; l++)
+            {
+                for (size_t k = 0; k < mask_width; k++)
+                {
+                    size_t p = (i + l) * image_width + j + k;
+                    sub_image[ind++] = (image[p]);
+                }
+
+            }
+            size_t mid = (i + mask_height / 2) * image_width + j + mask_width / 2;
+            res[mid] = convolution_operation(sub_image);
+        }
+    }
+    return res;
+}
+void optimizer::check_edge_distribution(
+    std::vector<double>& sum_weights_per_section,
+    double& min_max_ratio,
+    bool& is_edge_distributed
+    )
+{
+    /*minMaxRatio = min(sumWeightsPerSection)/max(sumWeightsPerSection);
+      if minMaxRatio < params.edgeDistributMinMaxRatio
+          isDistributed = false;
+          fprintf('isEdgeDistributed: Ratio between min and max is too small: %0.5f, threshold is %0.5f\n',minMaxRatio, params.edgeDistributMinMaxRatio);
+          return;
+      end*/
+    is_edge_distributed = true;
+
+    double z_max = *std::max_element(sum_weights_per_section.begin(), sum_weights_per_section.end());
+    double z_min = *std::min_element(sum_weights_per_section.begin(), sum_weights_per_section.end());
+    min_max_ratio = z_min / z_max;
+    if (min_max_ratio < _params.edge_distribution_min_max_ratio)
+    {
+        is_edge_distributed = false;
+        AC_LOG(ERROR, "Edge distribution ratio ({min}" << z_min << "/" << z_max << "{max} = " << min_max_ratio << ") is too small; threshold= " << _params.edge_distribution_min_max_ratio);
+        return;
+    }
+    /*if any(sumWeightsPerSection< params.minWeightedEdgePerSection)
+    isDistributed = false;
+    printVals = num2str(sumWeightsPerSection(1));
+    for k = 2:numel(sumWeightsPerSection)
+        printVals = [printVals,',',num2str(sumWeightsPerSection(k))];
+    end
+    disp(['isEdgeDistributed: weighted edge per section is too low: ' printVals ', threshold is ' num2str(params.minWeightedEdgePerSection)]);
+    return;
+end*/
+    for (auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it)
+    {
+        if (*it < _params.min_weighted_edge_per_section)
+        {
+            is_edge_distributed = false;
+            break;
+        }
+    }
+    if (!is_edge_distributed) {
+        AC_LOG(DEBUG, "check_edge_distribution: weighted edge per section is too low:  ");
+        for (auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it)
+        {
+            AC_LOG(DEBUG, "    " << *it);
+        }
+        AC_LOG(DEBUG, "threshold is: " << _params.min_weighted_edge_per_section);
+        return;
+    }
+    
+}
+bool optimizer::is_edge_distributed(z_frame_data& z, yuy2_frame_data& yuy)
+{
+    size_t num_of_sections = _params.num_of_sections_for_edge_distribution_x * _params.num_of_sections_for_edge_distribution_y;
+
+    // depth frame
+    AC_LOG(DEBUG, "... checking Z edge distribution");
+    sum_per_section(z.sum_weights_per_section, z.section_map, z.weights, num_of_sections);
+    //for debug 
+    auto it = z.sum_weights_per_section.begin();
+    AC_LOG(DEBUG, "    sum_per_section(z), section #0  " << *(it));
+    AC_LOG(DEBUG, "    sum_per_section(z), section #1  " << *(it + 2));
+    AC_LOG(DEBUG, "    sum_per_section(z), section #2  " << *(it + 1));
+    AC_LOG(DEBUG, "    sum_per_section(z), section #3  " << *(it + 3));
+    check_edge_distribution(z.sum_weights_per_section, z.min_max_ratio, z.is_edge_distributed);
+    // yuy frame
+    AC_LOG(DEBUG, "... checking YUY edge distribution");
+    sum_per_section(yuy.sum_weights_per_section, yuy.section_map, yuy.edges_IDT, num_of_sections);
+    //for debug 
+    it = yuy.sum_weights_per_section.begin();
+    AC_LOG(DEBUG, "    sum_per_section(yuy), section #0  " << *(it));
+    AC_LOG(DEBUG, "    sum_per_section(yuy), section #1  " << *(it + 2));
+    AC_LOG(DEBUG, "    sum_per_section(yuy), section #2  " << *(it + 1));
+    AC_LOG(DEBUG, "    sum_per_section(yuy), section #3  " << *(it + 3));
+    check_edge_distribution(yuy.sum_weights_per_section, yuy.min_max_ratio, yuy.is_edge_distributed);
+
+    return  (z.is_edge_distributed && yuy.is_edge_distributed);
+}
+
+//%function[isBalanced, dirRatio1, perpRatio, dirRatio2, weightsPerDir] = isGradDirBalanced( frame, params )
+static bool is_grad_dir_balanced( std::vector< double > const & weights,
+                                  std::vector< double > const & directions,
+                                  params const & _params,
+                                  std::vector< double > * p_weights_per_dir,
+                                  double * p_dir_ratio1 )
+{
+    //%weightsPerDir = sum( frame.weights .* (frame.dirPerPixel == [1:4]) );
+    std::vector< double > weights_per_dir( 4, 0. );  // 4 = deg_non is number of directions
+    for (auto dir = 0; dir < 4; ++dir)
+    {
+        for( auto ii = 0; ii < directions.size(); ++ii )
+        {
+            if( directions[ii] == dir + 1 )  // avoid direction 0
+                weights_per_dir[dir] += weights[ii];
+        }
+    }
+    if( p_weights_per_dir )
+        *p_weights_per_dir = weights_per_dir;
+
+    /*
+    [maxVal,maxIx] = max(weightsPerDir);
+    ixMatch = mod(maxIx+2,4);
+    if ixMatch == 0
+        ixMatch = 4;
+    end
+    if weightsPerDir(ixMatch) < 1e-3 %Don't devide by zero...
+        dirRatio1 = 1e6;
+    else
+        dirRatio1 = maxVal/weightsPerDir(ixMatch);
+    end
+    */
+    //%[maxVal, maxIx] = max( weightsPerDir );
+    auto max_val = max_element( weights_per_dir.begin(), weights_per_dir.end() );
+    auto max_ix = distance( weights_per_dir.begin(), max_val );
+    //%ixMatch = mod( maxIx + 2, 4 );
+    //%if ixMatch == 0
+    //%    ixMatch = 4;
+    //%end
+    auto ix_match = (max_ix + 1) % 3;
+
+    double dir_ratio1;
+    //%if weightsPerDir( ixMatch ) < 1e-3 %Don't devide by zero...
+    if (weights_per_dir.at(ix_match) < 1e-3) //%Don't devide by zero...
+        dir_ratio1 = 1e6;
+    else
+        //%dirRatio1 = maxVal / weightsPerDir( ixMatch );
+        dir_ratio1 = *max_val / weights_per_dir.at( ix_match );
+    if( p_dir_ratio1 )
+        *p_dir_ratio1 = dir_ratio1;
+
+    //%if dirRatio1 > params.gradDirRatio
+    if( dir_ratio1 > _params.grad_dir_ratio )
+    {
+        //%ixCheck = true(size(weightsPerDir));
+        //%ixCheck([maxIx,ixMatch]) = false;
+        //%[maxValPerp,~] = max(weightsPerDir(ixCheck));
+        double max_val_perp = DBL_MIN;
+        double min_val_perp = DBL_MAX;
+        for (auto i = 0; i < 4; ++i)
+        {
+            if ((i != max_ix) && (i != ix_match))
+            {
+                if( max_val_perp < weights_per_dir[i] )
+                    max_val_perp = weights_per_dir[i];
+                if( min_val_perp > weights_per_dir[i] )
+                    min_val_perp = weights_per_dir[i];
+            }
+        }
+
+        //%perpRatio = maxVal/maxValPerp;
+        auto perp_ratio = *max_val / max_val_perp;
+        if( perp_ratio > _params.grad_dir_ratio_prep )
+        {
+            AC_LOG( DEBUG,
+                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                                                                << _params.grad_dir_ratio );
+            return false;
+        }
+        if( min_val_perp < 1e-3 )  // % Don't devide by zero...
+        {
+            AC_LOG( DEBUG,
+                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                                                                << _params.grad_dir_ratio );
+            return false;
+        }
+
+        //%dirRatio2 = maxValPerp / min( weightsPerDir( ixCheck ));
+        double dir_ratio2 = max_val_perp / min_val_perp;
+        //%if dirRatio2 > params.gradDirRatio
+        if( dir_ratio2 > _params.grad_dir_ratio )
+        {
+            AC_LOG( DEBUG,
+                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                                                                << _params.grad_dir_ratio );
+            return false;
+        }
+    }
+    return true;
+}
+
+void optimizer::section_per_pixel(
+    frame_data const& f,
+    size_t const section_w,
+    size_t const section_h,
+    byte* const section_map
+    )
+{
+    //% [gridX,gridY] = meshgrid(0:res(2)-1,0:res(1)-1);
+    //% gridX = floor(gridX/res(2)*params.numSectionsH);
+    //% gridY = floor(gridY/res(1)*params.numSectionsV);
+
+    // res(2) is width; res(1) is height
+    //    -->  section_x = x * section_w / width
+    //    -->  section_y = y * section_h / height
+
+    // We need to align the pixel-map orientation the same as the image data
+    // In Matlab, it's always height-oriented (data + x*h + y) whereas our frame
+    // data is width-oriented (data + y*w + x)
+    //    -->  we iterate over cols within rows
+
+    assert(section_w * section_h <= 256);
+
+    byte* section = section_map;
+    for (size_t row = 0; row < f.height; row++)
+    {
+        size_t const section_y = row * section_h / f.height;  // note not a floating point division!
+        for (size_t col = 0; col < f.width; col++)
+        {
+            size_t const section_x = col * section_w / f.width;  // note not a floating point division!
+            //% sectionMap = gridY + gridX*params.numSectionsH;   TODO BUGBUGBUG!!!
+            *section++ = byte(section_y + section_x * section_h);
+        }
+    }
+}
+
+template<class T>
+uint8_t dilation_calc(std::vector<T> const& sub_image, std::vector<uint8_t> const& mask)
+{
+    uint8_t res = 0;
+
+    for (auto i = 0; i < sub_image.size(); i++)
+    {
+        res = res || (uint8_t)(sub_image[i] * mask[i]);
+    }
+
+    return res;
+}
+void optimizer::images_dilation(yuy2_frame_data& yuy)
+{
+    auto area = yuy.height * yuy.width;
+    std::vector<uint8_t> dilation_mask = { 1, 1, 1,
+                                              1,  1,  1,
+                                              1,  1,  1 };
+
+    yuy.dilated_image = dilation_convolution<uint8_t>(yuy.prev_logic_edges, yuy.width, yuy.height, _params.dilation_size, _params.dilation_size, [&](std::vector<uint8_t> const& sub_image)
+        {return dilation_calc(sub_image, dilation_mask); });
+
+}
+template<class T>
+double gaussian_calc(std::vector<T> const& sub_image, std::vector<double> const& mask)
+{
+    double res = 0;
+
+    for (auto i = 0; i < sub_image.size(); i++)
+    {
+        res = res + (double)(sub_image[i] * mask[i]);
+    }
+
+    return res;
+}
+
+void optimizer::gaussian_filter(yuy2_frame_data& yuy)
+{
+    auto area = yuy.height * yuy.width;
+
+    /* diffIm = abs(im1-im2);
+diffIm = imgaussfilt(im1-im2,params.moveGaussSigma);*/
+    // use this matlab function to get gauss kernel with sigma=1: disp17(fspecial('gaussian',5,1))
+    std::vector<double>  gaussian_kernel = { 0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651, 0.0029690167439504968,
+        0.013306209891013651, 0.059634295436180138, 0.098320331348845769, 0.059634295436180138, 0.013306209891013651,
+        0.021938231279714643, 0.098320331348845769, 0.16210282163712664, 0.098320331348845769, 0.021938231279714643,
+        0.013306209891013651, 0.059634295436180138, 0.098320331348845769, 0.059634295436180138, 0.013306209891013651,
+        0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651, 0.0029690167439504968
+    };
+
+    std::vector<uint8_t>::iterator yuy_iter = yuy.lum_frame.begin();
+    std::vector<uint8_t>::iterator yuy_prev_iter = yuy.prev_lum_frame.begin();
+    for (auto i = 0; i < area; i++, yuy_iter++, yuy_prev_iter++)
+    {
+        yuy.yuy_diff.push_back((double)(*yuy_prev_iter) - (double)(*yuy_iter)); // used for testing only
+    }
+    yuy.gaussian_filtered_image = gauss_convolution<double>(yuy.yuy_diff, yuy.width, yuy.height, _params.gause_kernel_size, _params.gause_kernel_size, [&](std::vector<double> const& sub_image)
+        {return gaussian_calc(sub_image, gaussian_kernel); });
+    return;
+}
+void abs_values(std::vector< double >& vec_in)
+{
+    //std::vector< double > abs_vec_in = vec_in;
+    for (double& val : vec_in)
+    {
+        if (val < 0)
+        {
+            val *= -1;
+        }
+    }
+}
+void gaussian_dilation_mask(std::vector< double >& gauss_diff, std::vector< uint8_t >& dilation_mask)
+{
+    auto gauss_it = gauss_diff.begin();
+    auto dilation_it = dilation_mask.begin();
+    for (auto i = 0; i < gauss_diff.size(); i++, gauss_it++, dilation_it++)
+    {
+        if (*dilation_it)
+        {
+            *gauss_it = 0;
+        }
+    }
+}
+void move_suspected_mask(std::vector< uint8_t >& move_suspect, std::vector< double >& gauss_diff_masked, double movement_threshold)
+{
+    for (auto it = gauss_diff_masked.begin(); it != gauss_diff_masked.end(); ++it)
+    {
+        if (*it > movement_threshold)
+        {
+            move_suspect.push_back(1);
+        }
+        else
+        {
+            move_suspect.push_back(0);
+        }
+    }
+}
+bool optimizer::is_movement_in_images(yuy2_frame_data& yuy)
+{
+    /*function [isMovement,movingPixels] = isMovementInImages(im1,im2, params)
+isMovement = false;
+
+[edgeIm1,~,~] = OnlineCalibration.aux.edgeSobelXY(uint8(im1));
+logicEdges = abs(edgeIm1) > params.edgeThresh4logicIm*max(edgeIm1(:));
+SE = strel('square', params.seSize);
+dilatedIm = imdilate(logicEdges,SE);
+diffIm = imgaussfilt(double(im1)-double(im2),params.moveGaussSigma);
+*/
+    yuy.prev_logic_edges = get_logic_edges(yuy.prev_edges);
+    images_dilation(yuy);
+    gaussian_filter(yuy);
+    /*
+%
+IDiffMasked = abs(diffIm);
+IDiffMasked(dilatedIm) = 0;
+% figure; imagesc(IDiffMasked); title('IDiffMasked');impixelinfo; colorbar;
+ixMoveSuspect = IDiffMasked > params.moveThreshPixVal;
+if sum(ixMoveSuspect(:)) > params.moveThreshPixNum
+    isMovement = true;
+end
+movingPixels = sum(ixMoveSuspect(:));
+disp(['isMovementInImages: # of pixels above threshold ' num2str(sum(ixMoveSuspect(:))) ', allowed #: ' num2str(params.moveThreshPixNum)]);
+end*/
+    yuy.gaussian_diff_masked = yuy.gaussian_filtered_image;
+    abs_values(yuy.gaussian_diff_masked);
+    gaussian_dilation_mask(yuy.gaussian_diff_masked, yuy.dilated_image);
+    move_suspected_mask(yuy.move_suspect, yuy.gaussian_diff_masked, _params.move_thresh_pix_val);
+    auto sum_move_suspect = 0;
+    for (auto it = yuy.move_suspect.begin(); it != yuy.move_suspect.end(); ++it)
+    {
+        sum_move_suspect += *it;
+    }
+    if (sum_move_suspect > _params.move_threshold_pix_num)
+    {
+        AC_LOG(DEBUG, "is_movement_in_images:  # of pixels above threshold " << sum_move_suspect << " allowed #:" << _params.move_threshold_pix_num);
+        return true;
+    }
+
+    return false;
+}
+bool optimizer::is_scene_valid()
+{
+    std::vector< byte > section_map_depth(_z.width * _z.height);
+    std::vector< byte > section_map_rgb(_yuy.width * _yuy.height);
+
+    size_t const section_w = _params.num_of_sections_for_edge_distribution_x;  //% params.numSectionsH
+    size_t const section_h = _params.num_of_sections_for_edge_distribution_y;  //% params.numSectionsH
+
+    // Get a map for each pixel to its corresponding section
+    section_per_pixel(_z, section_w, section_h, section_map_depth.data());
+    section_per_pixel(_yuy, section_w, section_h, section_map_rgb.data());
+
+    // remove pixels in section map that were removed in weights
+    AC_LOG(DEBUG, "... " << _z.supressed_edges.size() << " total edges");
+    for (auto i = 0; i < _z.supressed_edges.size(); i++)
+    {
+        if (_z.supressed_edges[i])
+        {
+            _z.section_map.push_back(section_map_depth[i]);
+        }
+    }
+    _z.section_map = _z.section_map_depth_inside; // NOHA :: taken from preprocessDepth
+    AC_LOG(DEBUG, "... " << _z.section_map.size() << " not suppressed");
+
+    // remove pixels in section map where edges_IDT > 0
+    int i = 0;
+    AC_LOG(DEBUG, "... " << _z.supressed_edges.size() << " total edges IDT");
+
+    for (auto it = _yuy.edges_IDT.begin(); it != _yuy.edges_IDT.end(); ++it, ++i)
+    {
+        if (*it > 0)
+        {
+            _yuy.section_map.push_back(section_map_rgb[i]);
+        }
+    }
+    AC_LOG(DEBUG, "... " << _yuy.section_map.size() << " not suppressed");
+
+    bool res_movement = is_movement_in_images(_yuy);
+    bool res_edges = is_edge_distributed(_z, _yuy);
+    bool res_gradient = is_grad_dir_balanced( _z.weights,
+                                              _z.directions,
+                                              _params,
+                                              &_z.sum_weights_per_direction,
+                                              &_z.dir_ratio1 );
+
+    //return((!res_movement) && res_edges && res_gradient);
+    return(!res_movement);
+}
diff --git a/src/android/jni/debug_protocol.cpp b/src/android/jni/debug_protocol.cpp
dissimilarity index 70%
index 9437e0e..926dbd2 100644
--- a/src/android/jni/debug_protocol.cpp
+++ b/src/android/jni/debug_protocol.cpp
@@ -1,202 +1,126 @@
-// License: Apache 2.0. See LICENSE file in root directory.
-// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
-
-#include <jni.h>
-#include <memory>
-#include <vector>
-#include "error.h"
-#include <iostream>
-#include <fstream>
-#include <string>
-
-#include "../../../include/librealsense2/rs.h"
-#include "../../../include/librealsense2/hpp/rs_device.hpp"
-#include "../../api.h"
-#include "../../../common/parser.hpp"
-
-using std::string;
-using std::hex;
-
-std::vector<uint8_t> send_and_receive_raw_data(JNIEnv *env, rs2_device * dev, const std::vector<uint8_t>& input)
-{
-    std::vector<uint8_t> results;
-
-    rs2_error *e = NULL;
-    std::shared_ptr<const rs2_raw_data_buffer> list(
-            rs2_send_and_receive_raw_data(dev, (void*)input.data(), (uint32_t)input.size(), &e),
-            rs2_delete_raw_data);
-    handle_error(env, e);
-
-    auto size = rs2_get_raw_data_size(list.get(), &e);
-    handle_error(env, e);
-
-    auto start = rs2_get_raw_data(list.get(), &e);
-
-    results.insert(results.begin(), start, start + size);
-
-    return results;
-}
-
-std::string hex_mode(JNIEnv *env, rs2_device * dev, const std::string& line)
-{
-    std::vector<uint8_t> raw_data;
-    std::stringstream ss(line);
-    std::string word;
-    while (ss >> word)
-    {
-        std::stringstream converter;
-        int temp;
-        converter << std::hex << word;
-        converter >> temp;
-        raw_data.push_back(temp);
-    }
-    if (raw_data.empty())
-        throw std::runtime_error("Wrong input!");
-
-    auto result = send_and_receive_raw_data(env, dev, raw_data);
-
-    std::stringstream rv;
-    for (auto& elem : result)
-        rv << std::setfill('0') << std::setw(2) << std::hex << static_cast<int>(elem) << " ";
-
-    return rv.str();
-}
-
-std::vector<uint8_t> build_raw_command_data(const command& command, const std::vector<std::string>& params)
-{
-    if (params.size() > command.parameters.size() && !command.is_cmd_write_data)
-        throw std::runtime_error("Input string was not in a correct format!");
-
-    std::vector<parameter> vec_parameters;
-    for (auto param_index = 0; param_index < params.size(); ++param_index)
-    {
-        auto is_there_write_data = param_index >= int(command.parameters.size());
-        auto name = (is_there_write_data) ? "" : command.parameters[param_index].name;
-        auto is_reverse_bytes = (is_there_write_data) ? false : command.parameters[param_index].is_reverse_bytes;
-        auto is_decimal = (is_there_write_data) ? false : command.parameters[param_index].is_decimal;
-        auto format_length = (is_there_write_data) ? -1 : command.parameters[param_index].format_length;
-        vec_parameters.push_back(parameter(name, params[param_index], is_decimal, is_reverse_bytes, format_length));
-    }
-
-    std::vector<uint8_t> raw_data;
-    encode_raw_data_command(command, vec_parameters, raw_data);
-    return raw_data;
-}
-
-std::string xml_mode(const std::string& line, const commands_xml& cmd_xml, std::map<std::string,
-xml_parser_function>& format_type_to_lambda, JNIEnv *env, jlong handle)
-{
-    try {
-        std::vector<string> tokens;
-        std::stringstream ss(line);
-        std::string word;
-        while (ss >> word) {
-            std::stringstream converter;
-            converter << hex << word;
-            tokens.push_back(word);
-        }
-
-        if (tokens.empty())
-            throw std::runtime_error("Wrong input!");
-
-        auto command_str = tokens.front();
-        auto it = cmd_xml.commands.find(command_str);
-        if (it == cmd_xml.commands.end())
-            throw std::runtime_error("Command not found!");
-
-        auto command = it->second;
-        std::vector<std::string> params;
-        for (auto i = 1; i < tokens.size(); ++i)
-            params.push_back(tokens[i]);
-
-        auto raw_data = build_raw_command_data(command, params);
-
-        auto result = send_and_receive_raw_data(env, reinterpret_cast<rs2_device *>(handle),
-                                                raw_data);
-
-        unsigned returned_opcode = *result.data();
-        // check returned opcode
-        if (command.op_code != returned_opcode) {
-            std::stringstream msg;
-            msg << "OpCodes do not match! Sent 0x" << hex << command.op_code << " but received 0x"
-                << hex << (returned_opcode) << "!";
-            throw std::runtime_error(msg.str());
-        }
-
-        if(!command.is_read_command)
-            return "Executed Successfully";
-
-        std::string rv;
-        decode_string_from_raw_data(command, cmd_xml.custom_formatters, result.data(),
-                                    result.size(), rv, format_type_to_lambda);
-        return rv;
-    }catch(std::exception& e){
-        return e.what();
-    }
-}
-
-extern "C"
-JNIEXPORT jbyteArray JNICALL
-Java_com_intel_realsense_librealsense_DebugProtocol_nSendAndReceiveRawData(JNIEnv *env, jclass type,
-                                                                           jlong handle,
-                                                                           jbyteArray buffer_) {
-    jbyte *buffer = env->GetByteArrayElements(buffer_, NULL);
-    jsize length = env->GetArrayLength(buffer_);
-    std::vector<uint8_t> buff(reinterpret_cast<uint8_t*>(buffer), reinterpret_cast<uint8_t*>(buffer) + length);
-    auto ret = send_and_receive_raw_data(env, reinterpret_cast<rs2_device *>(handle), buff);
-    env->ReleaseByteArrayElements(buffer_, buffer, 0);
-    jbyteArray rv = env->NewByteArray(ret.size());
-    env->SetByteArrayRegion (rv, 0, ret.size(), reinterpret_cast<const jbyte *>(ret.data()));
-    return rv;
-}
-
-extern "C"
-JNIEXPORT jbyteArray JNICALL
-Java_com_intel_realsense_librealsense_DebugProtocol_nSendAndReceiveData(JNIEnv *env, jclass clazz,
-                                                                        jlong handle,
-                                                                        jstring filePath,
-                                                                        jstring command) {
-    const char *file_path = env->GetStringUTFChars(filePath, 0);
-    const char *line = env->GetStringUTFChars(command, 0);
-
-    std::map<string, xml_parser_function> format_type_to_lambda;
-    commands_xml cmd_xml;
-
-    std::string result = "failed to open commands file";
-    bool sts = parse_xml_from_file(file_path, cmd_xml);
-    if(sts){
-        update_format_type_to_lambda(format_type_to_lambda);
-
-        result = xml_mode(line, cmd_xml, format_type_to_lambda, env, handle);
-    }
-
-    env->ReleaseStringUTFChars(command, line);
-    env->ReleaseStringUTFChars(filePath, file_path);
-
-    jbyteArray rv = env->NewByteArray(result.size());
-    env->SetByteArrayRegion(rv, 0, result.size(),
-                            reinterpret_cast<const jbyte *>(result.c_str()));
-    return rv;
-}
-
-extern "C"
-JNIEXPORT jobjectArray JNICALL
-Java_com_intel_realsense_librealsense_DebugProtocol_nGetCommands(JNIEnv *env, jclass clazz,
-                                                                 jstring filePath) {
-    const char *file_path = env->GetStringUTFChars(filePath, 0);
-
-    jobjectArray rv;
-    commands_xml cmd_xml;
-    bool sts = parse_xml_from_file(file_path, cmd_xml);
-    if(sts)
-    {
-        rv = (jobjectArray)env->NewObjectArray(cmd_xml.commands.size(), env->FindClass("java/lang/String"),env->NewStringUTF(""));
-        int i = 0;
-        for(auto&& c : cmd_xml.commands)
-            env->SetObjectArrayElement(rv, i++, env->NewStringUTF(c.first.c_str()));
-    }
-    env->ReleaseStringUTFChars(filePath, file_path);
-
-    return(rv);
-}
-
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+
+#include <jni.h>
+#include "error.h"
+#include <fstream>
+#include "../../../include/librealsense2/h/rs_internal.h"
+#include "../../../common/parser.hpp"   //needed for auto completion in nGetCommands
+
+
+extern "C"
+JNIEXPORT jbyteArray JNICALL
+Java_com_intel_realsense_librealsense_DebugProtocol_nSendAndReceiveRawData(JNIEnv *env, jclass type,
+                                                                           jlong handle,
+                                                                           jbyteArray buffer_) {
+    jbyte *buffer = env->GetByteArrayElements(buffer_, NULL);
+    jsize length = env->GetArrayLength(buffer_);
+
+    rs2_error* e = NULL;
+    std::shared_ptr<const rs2_raw_data_buffer> response_bytes(
+            rs2_send_and_receive_raw_data(reinterpret_cast<rs2_device*>(handle), (void*)buffer, (int)length, &e),
+            rs2_delete_raw_data);
+
+    int response_size = rs2_get_raw_data_size(response_bytes.get(), &e);
+    handle_error(env, e);
+
+    const unsigned char* response_start = rs2_get_raw_data(response_bytes.get(), &e);
+    handle_error(env, e);
+
+    env->ReleaseByteArrayElements(buffer_, buffer, 0);
+    jbyteArray rv = env->NewByteArray(response_size);
+    env->SetByteArrayRegion (rv, 0, response_size, reinterpret_cast<const jbyte *>(response_start));
+
+    return rv;
+}
+
+extern "C"
+JNIEXPORT jbyteArray JNICALL
+Java_com_intel_realsense_librealsense_DebugProtocol_nSendAndReceiveData(JNIEnv *env, jclass clazz,
+                                                                        jlong handle,
+                                                                        jstring filePath,
+                                                                        jstring command) {
+    const char *file_path = env->GetStringUTFChars(filePath, 0);
+    const char *line = env->GetStringUTFChars(command, 0);
+
+    std::ifstream f(file_path);
+    std::string xml_content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
+
+    rs2_error* e = NULL;
+
+    //creating terminal parser
+    std::shared_ptr<rs2_terminal_parser> terminal_parser = std::shared_ptr<rs2_terminal_parser>(
+            rs2_create_terminal_parser(xml_content.c_str(), &e),
+            rs2_delete_terminal_parser);
+    handle_error(env, e);
+
+    //using parser to get bytes command from the string command
+    int line_length = strlen(line);
+    std::shared_ptr<const rs2_raw_data_buffer> command_buffer(
+            rs2_terminal_parse_command(terminal_parser.get(), line, line_length, &e),
+            rs2_delete_raw_data);
+    handle_error(env, e);
+
+    int command_size = rs2_get_raw_data_size(command_buffer.get(), &e);
+    handle_error(env, e);
+
+    const unsigned char* command_start = rs2_get_raw_data(command_buffer.get(), &e);
+    handle_error(env, e);
+
+    //calling send_receive to get the bytes response
+    std::shared_ptr<const rs2_raw_data_buffer> response_bytes(
+            rs2_send_and_receive_raw_data(reinterpret_cast<rs2_device*>(handle), (void*)command_start, command_size, &e),
+            rs2_delete_raw_data);
+
+    int response_size = rs2_get_raw_data_size(response_bytes.get(), &e);
+    handle_error(env, e);
+
+    const unsigned char* response_start = rs2_get_raw_data(response_bytes.get(), &e);
+    handle_error(env, e);
+
+    //using parser to get response string from response bytes and string command
+    std::shared_ptr<const rs2_raw_data_buffer> response_buffer(
+            rs2_terminal_parse_response(terminal_parser.get(), line, line_length,
+                                       (void*)response_start, response_size, &e),
+            rs2_delete_raw_data);
+    handle_error(env, e);
+
+    int response_buffer_size = rs2_get_raw_data_size(response_buffer.get(), &e);
+    handle_error(env, e);
+
+    const unsigned char* response_buffer_start = rs2_get_raw_data(response_buffer.get(), &e);
+    handle_error(env, e);
+
+    //releasing jni resources
+    env->ReleaseStringUTFChars(command, line);
+    env->ReleaseStringUTFChars(filePath, file_path);
+
+    //assigning return value
+    jbyteArray rv = env->NewByteArray(response_buffer_size);
+    env->SetByteArrayRegion(rv, 0, response_buffer_size,
+                            reinterpret_cast<const jbyte *>(response_buffer_start));
+
+    return rv;
+}
+
+extern "C"
+JNIEXPORT jobjectArray JNICALL
+Java_com_intel_realsense_librealsense_DebugProtocol_nGetCommands(JNIEnv *env, jclass clazz,
+                                                                 jstring filePath) {
+    const char *file_path = env->GetStringUTFChars(filePath, 0);
+
+    jobjectArray rv;
+    commands_xml cmd_xml;
+    bool sts = parse_xml_from_file(file_path, cmd_xml);
+    if(sts)
+    {
+        rv = (jobjectArray)env->NewObjectArray(cmd_xml.commands.size(), env->FindClass("java/lang/String"),env->NewStringUTF(""));
+        int i = 0;
+        for(auto&& c : cmd_xml.commands)
+            env->SetObjectArrayElement(rv, i++, env->NewStringUTF(c.first.c_str()));
+    }
+    env->ReleaseStringUTFChars(filePath, file_path);
+
+    return(rv);
+}
+
diff --git a/src/android/jni/fw_logger.cpp b/src/android/jni/fw_logger.cpp
dissimilarity index 77%
index 485d1f5..08d9054 100644
--- a/src/android/jni/fw_logger.cpp
+++ b/src/android/jni/fw_logger.cpp
@@ -1,28 +1,201 @@
-// License: Apache 2.0. See LICENSE file in root directory.
-// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
-
-#include <jni.h>
-#include <memory>
-
-#include "error.h"
-#include "../../../include/librealsense2/rs.h"
-#include "../fw-logger/rs-fw-logger.h"
-
-std::shared_ptr<android_fw_logger> g_fw_logger;
-#define TAG "rs_fw_log"
-
-extern "C"
-JNIEXPORT void JNICALL
-Java_com_intel_realsense_librealsense_FwLogger_nStartReadingFwLogs(JNIEnv *env, jclass clazz,
-        jstring file_path) {
-    const char *filePath = env->GetStringUTFChars(file_path, 0);
-    g_fw_logger = std::make_shared<android_fw_logger>(filePath);
-
-    env->ReleaseStringUTFChars(file_path, filePath);
-}
-
-extern "C"
-JNIEXPORT void JNICALL
-Java_com_intel_realsense_librealsense_FwLogger_nStopReadingFwLogs(JNIEnv *env, jclass clazz) {
-    g_fw_logger.reset();
-}
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+
+#include <jni.h>
+#include "error.h"
+#include "../../../include/librealsense2/h/rs_internal.h"
+
+// Fw Logger methods
+
+extern "C"
+JNIEXPORT jlong JNICALL
+Java_com_intel_realsense_librealsense_FwLogger_nGetFwLog(JNIEnv *env, jobject instance,
+                                                        jlong fw_logger_handle) {
+    rs2_error* e = NULL;
+    rs2_firmware_log_message* log_msg = rs2_create_fw_log_message(reinterpret_cast<rs2_device*>(fw_logger_handle), &e);
+    handle_error(env, e);
+
+    int result = rs2_get_fw_log(reinterpret_cast<rs2_device*>(fw_logger_handle), log_msg, &e);
+    handle_error(env, e);
+
+    bool result_bool = (result != 0);
+    jclass clazz = env->GetObjectClass(instance);
+    jfieldID resultField = env->GetFieldID(clazz, "mFwLogPullingStatus", "Z");
+    env->SetBooleanField(instance, resultField, result_bool);
+
+    return (jlong)log_msg;
+}
+
+extern "C"
+JNIEXPORT jlong JNICALL
+Java_com_intel_realsense_librealsense_FwLogger_nGetFlashLog(JNIEnv *env, jobject instance,
+                                                            jlong fw_logger_handle) {
+    rs2_error* e = NULL;
+    rs2_firmware_log_message* log_msg = rs2_create_fw_log_message(reinterpret_cast<rs2_device*>(fw_logger_handle), &e);
+    handle_error(env, e);
+
+    int result = rs2_get_flash_log(reinterpret_cast<rs2_device*>(fw_logger_handle), log_msg, &e);
+    handle_error(env, e);
+
+    bool result_bool = (result != 0);
+    jclass clazz = env->GetObjectClass(instance);
+    jfieldID resultField = env->GetFieldID(clazz, "mFwLogPullingStatus", "Z");
+    env->SetBooleanField(instance, resultField, result_bool);
+
+    return (jlong)log_msg;
+}
+
+extern "C"
+JNIEXPORT jboolean JNICALL
+Java_com_intel_realsense_librealsense_FwLogger_nInitParser(JNIEnv *env, jclass clazz,
+                                                               jlong fw_logger_handle,
+                                                               jstring xml_content) {
+    const char* xml_content_arr = env->GetStringUTFChars(xml_content, 0);
+
+    rs2_error* e = NULL;
+    int result = rs2_init_fw_log_parser(reinterpret_cast<rs2_device*>(fw_logger_handle), xml_content_arr, &e);
+    handle_error(env, e);
+
+    env->ReleaseStringUTFChars(xml_content, xml_content_arr);
+
+    bool resultBool = (result != 0);
+    return (jboolean)resultBool;
+}
+
+extern "C"
+JNIEXPORT jlong JNICALL
+Java_com_intel_realsense_librealsense_FwLogger_nParseFwLog(JNIEnv *env, jclass clazz,
+                                                            jlong fw_logger_handle, jlong fw_log_msg_handle) {
+    rs2_error* e = NULL;
+    rs2_firmware_log_parsed_message* parsed_msg = rs2_create_fw_log_parsed_message(reinterpret_cast<rs2_device*>(fw_logger_handle), &e);
+    handle_error(env, e);
+
+    int result = rs2_parse_firmware_log(reinterpret_cast<rs2_device*>(fw_logger_handle),
+                                   reinterpret_cast<rs2_firmware_log_message*>(fw_log_msg_handle),
+                                        parsed_msg, &e);
+    handle_error(env, e);
+
+    return (jlong)parsed_msg;
+}
+
+// Fw Log Msg methods
+
+extern "C" JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_FwLogMsg_nRelease(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_delete_fw_log_message(reinterpret_cast<rs2_firmware_log_message*>(handle));
+}
+
+extern "C" JNIEXPORT jint JNICALL
+Java_com_intel_realsense_librealsense_FwLogMsg_nGetSeverity(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    rs2_log_severity severity = rs2_fw_log_message_severity(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+    return (jint)severity;
+}
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_intel_realsense_librealsense_FwLogMsg_nGetSeverityStr(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    rs2_log_severity severity = rs2_fw_log_message_severity(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+
+    const char* severity_string = rs2_log_severity_to_string(severity);
+    return env->NewStringUTF(severity_string);
+}
+
+extern "C" JNIEXPORT jlong JNICALL
+Java_com_intel_realsense_librealsense_FwLogMsg_nGetTimestamp(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    unsigned int timestamp = rs2_fw_log_message_timestamp(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+    return (jlong)(unsigned long long)timestamp;
+}
+
+extern "C" JNIEXPORT jint JNICALL
+Java_com_intel_realsense_librealsense_FwLogMsg_nGetSize(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    int size = rs2_fw_log_message_size(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+    return (jint)size;
+}
+
+extern "C" JNIEXPORT jbyteArray JNICALL
+    Java_com_intel_realsense_librealsense_FwLogMsg_nGetData(JNIEnv *env, jclass clazz,
+                                                            jlong handle,jbyteArray input_buffer) {
+    jbyte *buffer = env->GetByteArrayElements(input_buffer, NULL);
+
+    rs2_error* e = NULL;
+    int size = rs2_fw_log_message_size(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+
+    const unsigned char* message_data = rs2_fw_log_message_data(reinterpret_cast<rs2_firmware_log_message*>(handle), &e);
+    handle_error(env, e);
+
+    env->ReleaseByteArrayElements(input_buffer, buffer, 0);
+    jbyteArray rv = env->NewByteArray(size);
+    env->SetByteArrayRegion (rv, 0, size, reinterpret_cast<const jbyte *>(message_data));
+    return rv;
+}
+
+
+//Parsed Fw Log Msg methods
+
+extern "C" JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nRelease(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_delete_fw_log_parsed_message(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle));
+}
+
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetMessage(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    const char* message = rs2_get_fw_log_parsed_message(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+
+    return env->NewStringUTF(message);
+}
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetFileName(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    const char* file_name = rs2_get_fw_log_parsed_file_name(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+
+    return env->NewStringUTF(file_name);
+}
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetThreadName(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    const char* thread_name = rs2_get_fw_log_parsed_thread_name(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+
+    return env->NewStringUTF(thread_name);
+}
+
+extern "C" JNIEXPORT jstring JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetSeverity(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    rs2_log_severity severity = rs2_get_fw_log_parsed_severity(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+
+    const char* severity_string = rs2_log_severity_to_string(severity);
+    return env->NewStringUTF(severity_string);
+}
+
+extern "C" JNIEXPORT jint JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetLine(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    int line = rs2_get_fw_log_parsed_line(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+    return (jint)line;
+}
+
+extern "C" JNIEXPORT jlong JNICALL
+Java_com_intel_realsense_librealsense_FwLogParsedMsg_nGetTimestamp(JNIEnv *env, jclass clazz, jlong handle) {
+    rs2_error* e = NULL;
+    unsigned int timestamp = rs2_get_fw_log_parsed_timestamp(reinterpret_cast<rs2_firmware_log_parsed_message*>(handle), &e);
+    handle_error(env, e);
+    return (jlong)(unsigned long long)timestamp;
+}
+
diff --git a/src/android/jni/stream_profile.cpp b/src/android/jni/stream_profile.cpp
index 155e972..774b490 100644
--- a/src/android/jni/stream_profile.cpp
+++ b/src/android/jni/stream_profile.cpp
@@ -2,6 +2,7 @@
 // Copyright(c) 2019 Intel Corporation. All Rights Reserved.
 
 #include <jni.h>
+#include <cstring>      //for memcpy
 #include "error.h"
 #include "../../../include/librealsense2/rs.h"
 
@@ -70,3 +71,162 @@ Java_com_intel_realsense_librealsense_StreamProfile_nIsProfileExtendableTo(JNIEn
     handle_error(env, e);
     return rv;
 }
+
+extern "C"
+JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_StreamProfile_nGetExtrinsicTo(JNIEnv *env, jclass type,
+                                                                         jlong handle, jlong otherHandle,
+                                                                         jobject extrinsic) {
+    rs2_error* e = nullptr;
+    rs2_extrinsics extr;
+    rs2_get_extrinsics(reinterpret_cast<const rs2_stream_profile *>(handle),
+            reinterpret_cast<const rs2_stream_profile *>(otherHandle),&extr, &e);
+    handle_error(env, e);
+
+    if (e != nullptr)
+    {
+        return;
+    }
+
+    jclass clazz = env->GetObjectClass(extrinsic);
+
+    //retrieving the array members
+    //mRotation
+    jfieldID rotation_field = env->GetFieldID(clazz, "mRotation", "[F");
+    jfloatArray rotationArray = env->NewFloatArray(9);
+    if (rotationArray != NULL)
+    {
+        env->SetFloatArrayRegion(rotationArray, 0, 9, reinterpret_cast<jfloat*>(&extr.rotation));
+    }
+    env->SetObjectField(extrinsic, rotation_field, rotationArray);
+
+    //mTranslation
+    jfieldID translation_field = env->GetFieldID(clazz, "mTranslation", "[F");
+    jfloatArray translationArray = env->NewFloatArray(3);
+    if (translationArray != NULL)
+    {
+        env->SetFloatArrayRegion(translationArray, 0, 3, reinterpret_cast<jfloat*>(&extr.translation));
+    }
+    env->SetObjectField(extrinsic, translation_field, translationArray);
+}
+
+extern "C"
+JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_StreamProfile_nRegisterExtrinsic(JNIEnv *env, jclass type,
+                                                                       jlong fromHandle, jlong toHandle,
+                                                                       jobject extrinsic)
+{
+    rs2_error* e = nullptr;
+    rs2_extrinsics extr;
+
+    //fill c++ extrinsic from java extrinsic data
+    jclass clazz = env->GetObjectClass(extrinsic);
+    //fill rotation
+    jfieldID rotation_field = env->GetFieldID(clazz, "mRotation", "[F");
+    jobject rotationObject = env->GetObjectField(extrinsic, rotation_field);
+    jfloatArray* rotationArray = reinterpret_cast<jfloatArray *>(&rotationObject);
+    jfloat * rotation = env->GetFloatArrayElements(*rotationArray, NULL);
+    memcpy(extr.rotation, rotation, 9 * sizeof(float));
+    env->ReleaseFloatArrayElements(*rotationArray, rotation, 0);
+    //fill translation
+    jfieldID translation_field = env->GetFieldID(clazz, "mTranslation", "[F");
+    jobject translationObject = env->GetObjectField(extrinsic, translation_field);
+    jfloatArray* translationArray = reinterpret_cast<jfloatArray *>(&translationObject);
+    jfloat * translation = env->GetFloatArrayElements(*translationArray, NULL);
+    memcpy(extr.translation, translation, 9 * sizeof(float));
+    env->ReleaseFloatArrayElements(*translationArray, translation, 0);
+
+    //calling the api method
+    rs2_register_extrinsics(reinterpret_cast<const rs2_stream_profile *>(fromHandle),
+                       reinterpret_cast<const rs2_stream_profile *>(toHandle), extr, &e);
+    handle_error(env, e);
+}
+
+extern "C"
+JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_VideoStreamProfile_nGetIntrinsic(JNIEnv *env, jclass type,
+                                                                   jlong handle, jobject intrinsic) {
+    rs2_error* e = nullptr;
+    rs2_intrinsics intr;
+    rs2_get_video_stream_intrinsics(reinterpret_cast<const rs2_stream_profile *>(handle), &intr, &e);
+    handle_error(env, e);
+
+    if (e != nullptr)
+    {
+        return;
+    }
+
+    jclass clazz = env->GetObjectClass(intrinsic);
+
+    //retrieving all the built-in types members
+    jfieldID width_field = env->GetFieldID(clazz, "mWidth", "I");
+    jfieldID height_field = env->GetFieldID(clazz, "mHeight", "I");
+    jfieldID ppx_field = env->GetFieldID(clazz, "mPpx", "F");
+    jfieldID ppy_field = env->GetFieldID(clazz, "mPpy", "F");
+    jfieldID fx_field = env->GetFieldID(clazz, "mFx", "F");
+    jfieldID fy_field = env->GetFieldID(clazz, "mFy", "F");
+    jfieldID model_field = env->GetFieldID(clazz, "mModelValue", "I");
+
+
+    env->SetIntField(intrinsic, width_field, intr.width);
+    env->SetIntField(intrinsic, height_field, intr.height);
+    env->SetFloatField(intrinsic, ppx_field, intr.ppx);
+    env->SetFloatField(intrinsic, ppy_field, intr.ppy);
+    env->SetFloatField(intrinsic, fx_field, intr.fx);
+    env->SetFloatField(intrinsic, fy_field, intr.fy);
+    env->SetIntField(intrinsic, model_field, intr.model);
+
+    //retrieving the array member
+    jfieldID coeff_field = env->GetFieldID(clazz, "mCoeffs", "[F");
+    jfloatArray coeffsArray = env->NewFloatArray(5);
+    if (coeffsArray != NULL)
+    {
+        env->SetFloatArrayRegion(coeffsArray, 0, 5, reinterpret_cast<jfloat*>(&intr.coeffs));
+    }
+    env->SetObjectField(intrinsic, coeff_field, coeffsArray);
+}
+
+extern "C"
+JNIEXPORT void JNICALL
+Java_com_intel_realsense_librealsense_MotionStreamProfile_nGetIntrinsic(JNIEnv *env, jclass type,
+                                                                        jlong handle, jobject intrinsic) {
+    rs2_error* e = nullptr;
+    rs2_motion_device_intrinsic intr;
+    rs2_get_motion_intrinsics(reinterpret_cast<const rs2_stream_profile *>(handle), &intr, &e);
+    handle_error(env, e);
+
+    if (e != nullptr)
+    {
+        return;
+    }
+
+    jclass clazz = env->GetObjectClass(intrinsic);
+
+    //retrieving the array members
+    //mData
+    jfieldID data_field = env->GetFieldID(clazz, "mData", "[F");
+    jfloatArray dataArray = env->NewFloatArray(12);
+    if (dataArray != NULL)
+    {
+        env->SetFloatArrayRegion(dataArray, 0, 12, reinterpret_cast<jfloat*>(&intr.data));
+    }
+    env->SetObjectField(intrinsic, data_field, dataArray);
+
+    //mNoiseVariances
+    jfieldID noise_field = env->GetFieldID(clazz, "mNoiseVariances", "[F");
+    jfloatArray noiseArray = env->NewFloatArray(3);
+    if (noiseArray != NULL)
+    {
+        env->SetFloatArrayRegion(noiseArray, 0, 3, reinterpret_cast<jfloat*>(&intr.noise_variances));
+    }
+    env->SetObjectField(intrinsic, noise_field, noiseArray);
+
+    //mBiasVariances
+    jfieldID bias_field = env->GetFieldID(clazz, "mBiasVariances", "[F");
+    jfloatArray biasArray = env->NewFloatArray(3);
+    if (biasArray != NULL)
+    {
+        env->SetFloatArrayRegion(biasArray, 0, 3, reinterpret_cast<jfloat*>(&intr.bias_variances));
+    }
+    env->SetObjectField(intrinsic, bias_field, biasArray);
+}
diff --git a/src/archive.h b/src/archive.h
index f4159d6..147ab76 100644
--- a/src/archive.h
+++ b/src/archive.h
@@ -98,11 +98,10 @@ namespace librealsense
         std::vector<byte> data;
         frame_additional_data additional_data;
         std::shared_ptr<metadata_parser_map> metadata_parsers = nullptr;
-        explicit frame() : ref_count(0), _kept(false), owner(nullptr), on_release() {}
+        explicit frame() : ref_count(0), owner(nullptr), on_release(),_kept(false) {}
         frame(const frame& r) = delete;
         frame(frame&& r)
-            : ref_count(r.ref_count.exchange(0)), _kept(r._kept.exchange(false)),
-            owner(r.owner), on_release()
+            : ref_count(r.ref_count.exchange(0)), owner(r.owner), on_release(), _kept(r._kept.exchange(false))
         {
             *this = std::move(r);
             if (owner) metadata_parsers = owner->get_md_parsers();
diff --git a/src/calibrated-sensor.h b/src/calibrated-sensor.h
new file mode 100644
index 0000000..b3fbe20
--- /dev/null
+++ b/src/calibrated-sensor.h
@@ -0,0 +1,24 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "types.h"
+#include "core/streaming.h"
+
+namespace librealsense
+{
+    class calibrated_sensor
+    {
+    public:
+        virtual void override_intrinsics( rs2_intrinsics const & ) = 0;
+        virtual void override_extrinsics( rs2_extrinsics const & ) = 0;
+
+        virtual rs2_dsm_params get_dsm_params() const = 0;
+        virtual void override_dsm_params( rs2_dsm_params const & ) = 0;
+
+        virtual void reset_calibration() = 0;
+    };
+    MAP_EXTENSION(RS2_EXTENSION_CALIBRATED_SENSOR, calibrated_sensor );
+}
+
diff --git a/src/concurrency.h b/src/concurrency.h
index 7dbf55d..e1bab21 100644
--- a/src/concurrency.h
+++ b/src/concurrency.h
@@ -28,7 +28,7 @@ class single_consumer_queue
     std::atomic<bool> _was_flushed;
 public:
     explicit single_consumer_queue<T>(unsigned int cap = QUEUE_MAX_SIZE)
-        : _queue(), _mutex(), _deq_cv(), _enq_cv(), _cap(cap), _need_to_flush(false), _was_flushed(false), _accepting(true)
+        : _queue(), _mutex(), _deq_cv(), _enq_cv(), _cap(cap), _accepting(true), _need_to_flush(false), _was_flushed(false)
     {}
 
     void enqueue(T&& item)
@@ -273,7 +273,7 @@ public:
 
         //wait
         std::unique_lock<std::mutex> lk(_blocking_invoke_mutex);
-        _blocking_invoke_cv.wait(lk, [&](){ return done || exit_condition(); });
+        while(_blocking_invoke_cv.wait_for(lk, std::chrono::milliseconds(10), [&](){ return !done && !exit_condition(); }));
     }
 
     void start()
@@ -409,7 +409,7 @@ class watchdog
 {
 public:
     watchdog(std::function<void()> operation, uint64_t timeout_ms) :
-            _operation(std::move(operation)), _timeout_ms(timeout_ms)
+            _timeout_ms(timeout_ms), _operation(std::move(operation))
     {
         _watcher = std::make_shared<active_object<>>([this](dispatcher::cancellable_timer cancellable_timer)
         {
@@ -440,7 +440,6 @@ private:
     uint64_t _timeout_ms;
     bool _kicked = false;
     bool _running = false;
-    bool _blocker = true;
     std::function<void()> _operation;
     std::shared_ptr<active_object<>> _watcher;
-};
\ No newline at end of file
+};
diff --git a/src/context.cpp b/src/context.cpp
index 8bdecb0..d5f697b 100644
--- a/src/context.cpp
+++ b/src/context.cpp
@@ -324,8 +324,11 @@ namespace librealsense
             std::copy(begin(ds5_devices), end(ds5_devices), std::back_inserter(list));
         }
 
-        auto l500_devices = l500_info::pick_l500_devices(ctx, devices);
-        std::copy(begin(l500_devices), end(l500_devices), std::back_inserter(list));
+        if( mask & RS2_PRODUCT_LINE_L500 )
+        {
+            auto l500_devices = l500_info::pick_l500_devices(ctx, devices);
+            std::copy(begin(l500_devices), end(l500_devices), std::back_inserter(list));
+        }
 
         if (mask & RS2_PRODUCT_LINE_SR300)
         {
@@ -359,6 +362,7 @@ namespace librealsense
                 list.push_back(dev);
         }
 
+        LOG_INFO( "Found " << list.size() << " RealSense devices (mask " << mask << ")" );
         return list;
     }
 
diff --git a/src/core/serialization.h b/src/core/serialization.h
index 698e5a0..69768ef 100644
--- a/src/core/serialization.h
+++ b/src/core/serialization.h
@@ -139,7 +139,7 @@ namespace librealsense
         public:
             serialized_option(device_serializer::nanoseconds time, sensor_identifier id, rs2_option opt_id, std::shared_ptr<librealsense::option> o) :
                 serialized_data(time),
-                sensor_id(id), option_id(opt_id), option(o)
+                sensor_id(id), option(o), option_id(opt_id)
             {}
             sensor_identifier sensor_id;
             std::shared_ptr<librealsense::option> option;
diff --git a/src/depth-to-rgb-calibration.cpp b/src/depth-to-rgb-calibration.cpp
new file mode 100644
index 0000000..7a5c43c
--- /dev/null
+++ b/src/depth-to-rgb-calibration.cpp
@@ -0,0 +1,173 @@
+//// License: Apache 2.0. See LICENSE file in root directory.
+//// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "depth-to-rgb-calibration.h"
+#include <librealsense2/rs.hpp>
+#include "core/streaming.h"
+#include "calibrated-sensor.h"
+#include "context.h"
+#include "api.h"  // VALIDATE_INTERFACE_NO_THROW
+#include "algo/depth-to-rgb-calibration/debug.h"
+
+#ifndef _WIN32
+#include <sys/stat.h>  // mkdir
+#endif
+
+
+using namespace librealsense;
+namespace impl = librealsense::algo::depth_to_rgb_calibration;
+
+depth_to_rgb_calibration::depth_to_rgb_calibration(
+    rs2::frame depth,
+    rs2::frame ir,
+    rs2::frame yuy,
+    rs2::frame prev_yuy,
+    algo::depth_to_rgb_calibration::algo_calibration_info const & cal_info,
+    algo::depth_to_rgb_calibration::algo_calibration_registers const & cal_regs
+)
+    : _intr( yuy.get_profile().as< rs2::video_stream_profile >().get_intrinsics() )
+    , _extr(to_raw_extrinsics( depth.get_profile().get_extrinsics_to( yuy.get_profile() )))
+    , _from( depth.get_profile().get()->profile )
+    , _to( yuy.get_profile().get()->profile )
+{
+    AC_LOG( DEBUG, "... setting yuy data" );
+    auto color_profile = yuy.get_profile().as< rs2::video_stream_profile >();
+    auto yuy_data = (impl::yuy_t const *) yuy.get_data();
+    auto prev_yuy_data = (impl::yuy_t const *) prev_yuy.get_data();
+    impl::calib calibration( _intr, _extr );
+    _algo.set_yuy_data(
+        std::vector< impl::yuy_t >( yuy_data, yuy_data + yuy.get_data_size() / sizeof( impl::yuy_t )),
+        std::vector< impl::yuy_t >( prev_yuy_data, prev_yuy_data + yuy.get_data_size() / sizeof( impl::yuy_t ) ),
+        calibration
+    );
+
+    AC_LOG( DEBUG, "... setting ir data" );
+    auto ir_profile = ir.get_profile().as< rs2::video_stream_profile >();
+    auto ir_data = (impl::ir_t const *) ir.get_data();
+    _algo.set_ir_data(
+        std::vector< impl::ir_t >( ir_data, ir_data + ir.get_data_size() / sizeof( impl::ir_t )),
+        ir_profile.width(), ir_profile.height()
+    );
+
+    auto si = ((frame_interface *) depth.get() )->get_sensor();
+    auto cs = VALIDATE_INTERFACE_NO_THROW( si, librealsense::calibrated_sensor );
+    if( !cs )
+    {
+        // We can only calibrate depth sensors that supply this interface!
+        throw librealsense::not_implemented_exception( "the depth frame supplied is not from a calibrated_sensor" );
+    }
+    _dsm_params = cs->get_dsm_params();
+
+    AC_LOG( DEBUG, "... setting z data" );
+    auto z_profile = depth.get_profile().as< rs2::video_stream_profile >();
+    auto z_data = (impl::z_t const *) depth.get_data();
+    _algo.set_z_data(
+        std::vector< impl::z_t >( z_data, z_data + depth.get_data_size() / sizeof( impl::z_t ) ),
+        z_profile.get_intrinsics(), _dsm_params, cal_info, cal_regs,
+        depth.as< rs2::depth_frame >().get_units() * 1000.f   // same scaling as for extrinsics!
+    );
+
+    debug_calibration( "old" );
+
+    // If the user has this env var defined, then we write out logs and frames to it
+    // NOTE: The var should end with a directory separator \ or /
+    auto dir_ = getenv( "RS2_DEBUG_DIR" );
+    if( dir_ )
+    {
+        std::string dir( dir_ );
+        dir += std::to_string( depth.get_frame_number() );
+        
+#ifdef _WIN32
+        dir += "\\";
+        auto status = _mkdir( dir.c_str() );
+#else
+        dir += "/";
+        auto status = mkdir( dir.c_str(), 0700 );
+#endif
+        if( status == 0 )
+            _algo.write_data_to( dir );
+        else
+            AC_LOG( WARNING, "Failed (" << status << ") to write AC frame data to: " << dir );
+    }
+}
+
+
+rs2_calibration_status depth_to_rgb_calibration::optimize(
+    std::function<void( rs2_calibration_status )> call_back
+)
+{
+#define DISABLE_RS2_CALIBRATION_CHECKS "RS2_AC_DISABLE_RETRIES"
+
+    try
+    {
+        AC_LOG( DEBUG, "... checking scene validity" );
+        if( !_algo.is_scene_valid() )
+        {
+            AC_LOG( ERROR, "Calibration scene was found invalid!" );
+            call_back( RS2_CALIBRATION_SCENE_INVALID );
+            if( !getenv( DISABLE_RS2_CALIBRATION_CHECKS ) )
+            {
+                // Default behavior is to stop AC and trigger a retry
+                return RS2_CALIBRATION_RETRY;
+            }
+            if( getenv( "RS2_AC_INVALID_SCENE_FAIL" ) )
+            {
+                // Here we don't want a retry, but we also do not want the calibration
+                // to possibly be successful -- fail it
+                AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is on but so is RS2_AC_INVALID_SCENE_FAIL: fail!" );
+                return RS2_CALIBRATION_FAILED;
+            }
+            AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is on; continuing" );
+        }
+
+        AC_LOG( DEBUG, "... optimizing" );
+        _algo.optimize();
+
+        AC_LOG( DEBUG, "... checking result validity" );
+        if( !_algo.is_valid_results() )
+        {
+            // Error would have printed inside
+            call_back( RS2_CALIBRATION_BAD_RESULT );
+            if( !getenv( DISABLE_RS2_CALIBRATION_CHECKS ) )
+            {
+                // Default behavior is to stop and trigger a retry
+                AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is off; will retry if possible" );
+                return RS2_CALIBRATION_RETRY;
+            }
+            if( !getenv( "RS2_AC_FORCE_BAD_RESULT" ) )
+            {
+                // This is mostly for validation use, where we don't want the retries and instead want
+                // to fail on bad results (we don't want to write bad results to the camera!)
+                AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is on; no retries" );
+                return RS2_CALIBRATION_FAILED;
+            }
+            // Allow forcing of results... be careful! This may damage the camera in AC2!
+            AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is on but so is RS2_AC_FORCE_BAD_RESULT: results will be used!" );
+        }
+
+        // AC_LOG( INFO, "Calibration finished; original cost= " << original_cost << "  optimized
+        // cost= " << params_curr.cost );
+
+        AC_LOG( DEBUG, "... optimization successful!" );
+        _intr = _algo.get_calibration().get_intrinsics();
+        _intr.model = RS2_DISTORTION_INVERSE_BROWN_CONRADY; //restore LRS model 
+        _extr = from_raw_extrinsics( _algo.get_calibration().get_extrinsics() );
+        _dsm_params = _algo.get_dsm_params();
+        debug_calibration( "new" );
+        return RS2_CALIBRATION_SUCCESSFUL;
+    }
+    catch( std::exception const & e )
+    {
+        AC_LOG( ERROR, "Calibration threw error: " << e.what() );
+        return RS2_CALIBRATION_FAILED;
+    }
+}
+
+
+void depth_to_rgb_calibration::debug_calibration( char const * prefix )
+{
+    AC_LOG( DEBUG, AC_F_PREC << prefix << _intr );
+    AC_LOG( DEBUG, AC_F_PREC << prefix << " extr" << _extr );
+    AC_LOG( DEBUG, AC_F_PREC << prefix << " dsm" << _dsm_params );
+}
+
diff --git a/src/depth-to-rgb-calibration.h b/src/depth-to-rgb-calibration.h
new file mode 100644
index 0000000..a0901a4
--- /dev/null
+++ b/src/depth-to-rgb-calibration.h
@@ -0,0 +1,52 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "algo/depth-to-rgb-calibration/optimizer.h"
+#include "types.h"
+
+
+namespace librealsense
+{
+    /*
+        Wrapper around the algo version, taking actual frames and translating to algo
+        vectors. Also translates the various stages in algo to actual RS2_CALIBRATION_
+        return values.
+    */
+    class depth_to_rgb_calibration
+    {
+        // inputs
+        stream_profile_interface* const _from;
+        stream_profile_interface* const _to;
+
+        // input/output
+        rs2_extrinsics _extr;
+        rs2_intrinsics _intr;
+        rs2_dsm_params _dsm_params;
+
+        algo::depth_to_rgb_calibration::optimizer _algo;
+
+    public:
+        depth_to_rgb_calibration(
+            rs2::frame depth,
+            rs2::frame ir,
+            rs2::frame yuy,
+            rs2::frame prev_yuy,
+            algo::depth_to_rgb_calibration::algo_calibration_info const & cal_info,
+            algo::depth_to_rgb_calibration::algo_calibration_registers const & cal_regs
+        );
+
+        rs2_extrinsics const & get_extrinsics() const { return _extr; }
+        rs2_intrinsics const & get_intrinsics() const { return _intr; }
+        stream_profile_interface * get_from_profile() const { return _from; }
+        stream_profile_interface * get_to_profile() const { return _to; }
+        rs2_dsm_params const & get_dsm_params() const { return _dsm_params; }
+
+        rs2_calibration_status optimize( std::function<void( rs2_calibration_status )> call_back = nullptr );
+
+    private:
+        void debug_calibration( char const * prefix );
+    };
+}  // librealsense
+
diff --git a/src/device-calibration.h b/src/device-calibration.h
new file mode 100644
index 0000000..ea69b97
--- /dev/null
+++ b/src/device-calibration.h
@@ -0,0 +1,21 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "types.h"
+#include "core/streaming.h"
+
+namespace librealsense
+{
+    // This extension should allow generic calibrations using the same interface
+    // by adding to rs2_calibration_type instead of adding new function calls
+    class device_calibration
+    {
+    public:
+        virtual void register_calibration_change_callback( calibration_change_callback_ptr ) = 0;
+        virtual void trigger_device_calibration( rs2_calibration_type ) = 0;
+    };
+    MAP_EXTENSION(RS2_EXTENSION_DEVICE_CALIBRATION, device_calibration );
+}
+
diff --git a/src/ds5/advanced_mode/presets.h b/src/ds5/advanced_mode/presets.h
index eed2cbe..63d3ae9 100644
--- a/src/ds5/advanced_mode/presets.h
+++ b/src/ds5/advanced_mode/presets.h
@@ -6,91 +6,91 @@
 
 namespace librealsense
 {
-    typedef struct
+    typedef struct laser_power_control
     {
         float laser_power;
         bool was_set = false;
     }laser_power_control;
 
-    typedef struct
+    typedef struct laser_state_control
     {
         int laser_state;
         bool was_set = false;
     }laser_state_control;
 
-    typedef struct
+    typedef struct exposure_control
     {
         float exposure;
         bool was_set = false;
     }exposure_control;
 
-    typedef struct
+    typedef struct auto_exposure_control
     {
         int auto_exposure;
         bool was_set = false;
     }auto_exposure_control;
-
-    typedef struct
+ 
+    typedef struct gain_control
     {
         float gain;
         bool was_set = false;
     }gain_control;
 
-    typedef struct
+    typedef struct backlight_compensation_control
     {
         int backlight_compensation;
         bool was_set = false;
     }backlight_compensation_control;
 
-    typedef struct
+    typedef struct brightness_control
     {
         float brightness;
         bool was_set = false;
     }brightness_control;
 
-    typedef struct
+    typedef struct contrast_control
     {
         float contrast;
         bool was_set = false;
     }contrast_control;
 
-    typedef struct
+    typedef struct gamma_control
     {
         float gamma;
         bool was_set = false;
     }gamma_control;
 
-    typedef struct
+    typedef struct hue_control
     {
         float hue;
         bool was_set = false;
     }hue_control;
 
-    typedef struct
+    typedef struct saturation_control
     {
         float saturation;
         bool was_set = false;
     }saturation_control;
 
-    typedef struct
+    typedef struct sharpness_control
     {
         float sharpness;
         bool was_set = false;
     }sharpness_control;
 
-    typedef struct
+    typedef struct white_balance_control
     {
         float white_balance;
         bool was_set = false;
     }white_balance_control;
 
-    typedef struct
+    typedef struct auto_white_balance_control
     {
         int auto_white_balance;
         bool was_set = false;
     }auto_white_balance_control;
 
-    typedef struct
+    typedef struct power_line_frequency_control
     {
         int power_line_frequency;
         bool was_set = false;
diff --git a/src/ds5/ds5-auto-calibration.cpp b/src/ds5/ds5-auto-calibration.cpp
index de0acd0..9598baf 100644
--- a/src/ds5/ds5-auto-calibration.cpp
+++ b/src/ds5/ds5-auto-calibration.cpp
@@ -213,7 +213,7 @@ namespace librealsense
                 LOG_WARNING(ex.what());
             }
             if (progress_callback)
-                progress_callback->on_update_progress(count++ * (2 * speed)); //curently this number does not reflect the actual progress
+                progress_callback->on_update_progress(count++ * (2.f * speed)); //curently this number does not reflect the actual progress
 
             now = std::chrono::high_resolution_clock::now();
 
@@ -310,7 +310,7 @@ namespace librealsense
             }
 
             if (progress_callback)
-                progress_callback->on_update_progress(count++ * (2 * speed)); //curently this number does not reflect the actual progress
+                progress_callback->on_update_progress(count++ * (2.f * speed)); //curently this number does not reflect the actual progress
 
             now = std::chrono::high_resolution_clock::now();
 
@@ -356,7 +356,7 @@ namespace librealsense
                 adv->set_all(old_preset_values);
             }
             else
-                advanced_mode->_preset_opt->set(old_preset);
+                advanced_mode->_preset_opt->set(static_cast<float>(old_preset));
         });
 
         return recover_preset;
diff --git a/src/ds5/ds5-device.cpp b/src/ds5/ds5-device.cpp
index bdde330..756a7c5 100644
--- a/src/ds5/ds5-device.cpp
+++ b/src/ds5/ds5-device.cpp
@@ -945,6 +945,16 @@ namespace librealsense
 #endif
     }
 
+    command ds5_device::get_firmware_logs_command() const
+    {
+        return command{ ds::GLD, 0x1f4 };
+    }
+
+    command ds5_device::get_flash_logs_command() const
+    {
+        return command{ ds::FRB, 0x17a000, 0x3f8 };
+    }
+
     std::shared_ptr<synthetic_sensor> ds5u_device::create_ds5u_depth_device(std::shared_ptr<context> ctx,
         const std::vector<platform::uvc_device_info>& all_device_infos)
     {
diff --git a/src/ds5/ds5-device.h b/src/ds5/ds5-device.h
index b4bb61d..edb821d 100644
--- a/src/ds5/ds5-device.h
+++ b/src/ds5/ds5-device.h
@@ -75,6 +75,10 @@ namespace librealsense
 
         ds::d400_caps  parse_device_capabilities(const uint16_t pid) const;
 
+        //TODO - add these to device class as pure virtual methods
+        command get_firmware_logs_command() const;
+        command get_flash_logs_command() const;
+
         void init(std::shared_ptr<context> ctx,
             const platform::backend_device_group& group);
 
diff --git a/src/ds5/ds5-factory.cpp b/src/ds5/ds5-factory.cpp
index f039dc4..90d84d9 100644
--- a/src/ds5/ds5-factory.cpp
+++ b/src/ds5/ds5-factory.cpp
@@ -22,10 +22,14 @@
 #include "ds5-motion.h"
 #include "sync.h"
 
+#include "../firmware_logger_device.h"
+
 namespace librealsense
 {
     // PSR
-    class rs400_device : public ds5_nonmonochrome, public ds5_advanced_mode_base
+    class rs400_device : public ds5_nonmonochrome, 
+        public ds5_advanced_mode_base,
+        public firmware_logger_device
     {
     public:
         rs400_device(std::shared_ptr<context> ctx,
@@ -34,7 +38,10 @@ namespace librealsense
             : device(ctx, group, register_device_notifications),
               ds5_device(ctx, group),
               ds5_nonmonochrome(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                  get_firmware_logs_command(),
+                  get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -60,7 +67,8 @@ namespace librealsense
 
     // DS5U_S
     class rs405u_device : public ds5u_device,
-        public ds5_advanced_mode_base
+        public ds5_advanced_mode_base,
+        public firmware_logger_device
     {
     public:
         rs405u_device(std::shared_ptr<context> ctx,
@@ -68,7 +76,10 @@ namespace librealsense
             bool register_device_notifications)
             : device(ctx, group, register_device_notifications),
             ds5u_device(ctx, group),
-            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -107,7 +118,9 @@ namespace librealsense
 
     // ASR (D460)
     class rs410_device : public ds5_nonmonochrome,
-                         public ds5_active, public ds5_advanced_mode_base
+                         public ds5_active, 
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs410_device(std::shared_ptr<context> ctx,
@@ -117,7 +130,10 @@ namespace librealsense
               ds5_device(ctx, group),
               ds5_nonmonochrome(ctx, group),
               ds5_active(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())  {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -142,7 +158,8 @@ namespace librealsense
     class rs415_device : public ds5_nonmonochrome,
                          public ds5_active,
                          public ds5_color,
-                         public ds5_advanced_mode_base
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs415_device(std::shared_ptr<context> ctx,
@@ -153,7 +170,10 @@ namespace librealsense
               ds5_nonmonochrome(ctx, group),
               ds5_active(ctx, group),
               ds5_color(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())  {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -178,7 +198,9 @@ namespace librealsense
     };
 
     class rs416_device : public ds5_nonmonochrome,
-        public ds5_active, public ds5_advanced_mode_base
+        public ds5_active, 
+        public ds5_advanced_mode_base,
+        public firmware_logger_device
     {
     public:
         rs416_device(std::shared_ptr<context> ctx,
@@ -188,7 +210,10 @@ namespace librealsense
             ds5_device(ctx, group),
             ds5_nonmonochrome(ctx, group),
             ds5_active(ctx, group),
-            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -227,7 +252,8 @@ namespace librealsense
         public ds5_nonmonochrome,
         public ds5_active,
         public ds5_color,
-        public ds5_advanced_mode_base
+        public ds5_advanced_mode_base,
+        public firmware_logger_device
 
     {
     public:
@@ -239,7 +265,10 @@ namespace librealsense
             ds5_nonmonochrome(ctx, group),
             ds5_active(ctx, group),
             ds5_color(ctx, group),
-            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -277,7 +306,9 @@ namespace librealsense
     };
 
     // PWGT
-    class rs420_mm_device : public ds5_motion, public ds5_advanced_mode_base
+    class rs420_mm_device : public ds5_motion, 
+                            public ds5_advanced_mode_base,
+                            public firmware_logger_device
     {
     public:
         rs420_mm_device(std::shared_ptr<context> ctx,
@@ -286,7 +317,10 @@ namespace librealsense
             : device(ctx, group, register_device_notifications),
               ds5_device(ctx, group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())  {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -319,7 +353,9 @@ namespace librealsense
     };
 
     // PWG
-    class rs420_device : public ds5_device, public ds5_advanced_mode_base
+    class rs420_device : public ds5_device, 
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs420_device(std::shared_ptr<context> ctx,
@@ -327,7 +363,10 @@ namespace librealsense
                      bool register_device_notifications)
             : device(ctx, group, register_device_notifications),
               ds5_device(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -352,7 +391,9 @@ namespace librealsense
     };
 
     // AWG
-    class rs430_device : public ds5_active, public ds5_advanced_mode_base
+    class rs430_device : public ds5_active, 
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs430_device(std::shared_ptr<context> ctx,
@@ -361,7 +402,10 @@ namespace librealsense
             : device(ctx, group, register_device_notifications),
               ds5_device(ctx, group),
               ds5_active(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())  {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -385,7 +429,10 @@ namespace librealsense
         };
     };
 
-    class rs430i_device : public ds5_active, public ds5_advanced_mode_base, public ds5_motion
+    class rs430i_device : public ds5_active, 
+                          public ds5_advanced_mode_base, 
+                          public ds5_motion,
+                          public firmware_logger_device
     {
     public:
         rs430i_device(std::shared_ptr<context> ctx,
@@ -395,7 +442,10 @@ namespace librealsense
               ds5_device(ctx, group),
               ds5_active(ctx, group),
               ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
-              ds5_motion(ctx, group)
+              ds5_motion(ctx, group),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) 
         {}
 
         std::vector<tagged_profile> get_profiles_tags() const override
@@ -425,7 +475,8 @@ namespace librealsense
     // AWGT
     class rs430_mm_device : public ds5_active,
                             public ds5_motion,
-                            public ds5_advanced_mode_base
+                            public ds5_advanced_mode_base,
+                            public firmware_logger_device
     {
     public:
         rs430_mm_device(std::shared_ptr<context> ctx,
@@ -435,7 +486,10 @@ namespace librealsense
               ds5_device(ctx, group),
               ds5_active(ctx, group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())  {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -471,7 +525,8 @@ namespace librealsense
     // AWGC
     class rs435_device : public ds5_active,
                          public ds5_color,
-                         public ds5_advanced_mode_base
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs435_device(std::shared_ptr<context> ctx,
@@ -481,7 +536,10 @@ namespace librealsense
               ds5_device(ctx, group),
               ds5_active(ctx, group),
               ds5_color(ctx,  group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()), 
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -509,7 +567,8 @@ namespace librealsense
     class rs430_rgb_mm_device : public ds5_active,
                                 public ds5_color,
                                 public ds5_motion,
-                                public ds5_advanced_mode_base
+                                public ds5_advanced_mode_base,
+                                public firmware_logger_device
     {
     public:
         rs430_rgb_mm_device(std::shared_ptr<context> ctx,
@@ -520,7 +579,10 @@ namespace librealsense
               ds5_active(ctx, group),
               ds5_color(ctx,  group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -548,7 +610,8 @@ namespace librealsense
     class rs435i_device  :      public ds5_active,
                                 public ds5_color,
                                 public ds5_motion,
-                                public ds5_advanced_mode_base
+                                public ds5_advanced_mode_base,
+                                public firmware_logger_device
     {
     public:
         rs435i_device(std::shared_ptr<context> ctx,
@@ -559,7 +622,10 @@ namespace librealsense
               ds5_active(ctx, group),
               ds5_color(ctx,  group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) 
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) 
         {
             check_and_restore_rgb_stream_extrinsic();
         }
@@ -763,7 +829,8 @@ namespace librealsense
                          public ds5_nonmonochrome,
                          public ds5_color,
                          public ds5_motion,
-                         public ds5_advanced_mode_base
+                         public ds5_advanced_mode_base,
+                         public firmware_logger_device
     {
     public:
         rs465_device(std::shared_ptr<context> ctx,
@@ -775,7 +842,10 @@ namespace librealsense
             ds5_color(ctx, group),
             ds5_motion(ctx, group),
             ds5_nonmonochrome(ctx, group),
-            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+            ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -800,7 +870,8 @@ namespace librealsense
     };
 
     class rs400_imu_device  :      public ds5_motion,
-                                public ds5_advanced_mode_base
+                                public ds5_advanced_mode_base,
+                                public firmware_logger_device
     {
     public:
         rs400_imu_device(std::shared_ptr<context> ctx,
@@ -809,7 +880,10 @@ namespace librealsense
             : device(ctx, group, register_device_notifications),
               ds5_device(ctx, group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()) {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -824,9 +898,10 @@ namespace librealsense
     };
 
     class rs405_device  :      public ds5_active,
-                                public ds5_color,
-                                public ds5_motion,
-                                public ds5_advanced_mode_base
+                               public ds5_color,
+                               public ds5_motion,
+                               public ds5_advanced_mode_base,
+                               public firmware_logger_device
     {
     public:
         rs405_device(std::shared_ptr<context> ctx,
@@ -837,8 +912,10 @@ namespace librealsense
               ds5_active(ctx, group),
               ds5_color(ctx,  group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())
-        {}
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
 
@@ -867,9 +944,10 @@ namespace librealsense
     };
 
     class rs455_device  :      public ds5_active,
-                                public ds5_color,
-                                public ds5_motion,
-                                public ds5_advanced_mode_base
+                               public ds5_color,
+                               public ds5_motion,
+                               public ds5_advanced_mode_base,
+                               public firmware_logger_device
     {
     public:
         rs455_device(std::shared_ptr<context> ctx,
@@ -880,7 +958,10 @@ namespace librealsense
               ds5_active(ctx, group),
               ds5_color(ctx,  group),
               ds5_motion(ctx, group),
-              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor())
+              ds5_advanced_mode_base(ds5_device::_hw_monitor, get_depth_sensor()),
+              firmware_logger_device(ctx, group, ds5_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command()) 
         {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
diff --git a/src/ds5/ds5-motion.cpp b/src/ds5/ds5-motion.cpp
index 96fca6e..7e6d339 100644
--- a/src/ds5/ds5-motion.cpp
+++ b/src/ds5/ds5-motion.cpp
@@ -24,6 +24,8 @@
 #include "proc/motion-transform.h"
 #include "proc/auto-exposure-processor.h"
 
+#include "../l500/l500-private.h"
+
 namespace librealsense
 {
     const std::map<uint32_t, rs2_format> fisheye_fourcc_to_rs2_format = {
@@ -220,13 +222,12 @@ namespace librealsense
         //  Motion intrinsic calibration presents is a prerequisite for motion correction.
         try
         {
-            // Writing to log to dereference underlying structure
-            LOG_INFO("Accel Sensitivity:" << (**_accel_intrinsic).sensitivity);
-            LOG_INFO("Gyro Sensitivity:" << (**_gyro_intrinsic).sensitivity);
-
-            mm_correct_opt = std::make_shared<enable_motion_correction>(hid_ep.get(),
-                option_range{ 0, 1, 1, 1 });
-            hid_ep->register_option(RS2_OPTION_ENABLE_MOTION_CORRECTION, mm_correct_opt);
+            if (_mm_calib)
+            {
+                mm_correct_opt = std::make_shared<enable_motion_correction>(hid_ep.get(),
+                    option_range{ 0, 1, 1, 1 });
+                hid_ep->register_option(RS2_OPTION_ENABLE_MOTION_CORRECTION, mm_correct_opt);
+            }
         }
         catch (...) {}
 
@@ -242,10 +243,8 @@ namespace librealsense
             [&, mm_correct_opt]() { return std::make_shared<gyroscope_transform>(_mm_calib, mm_correct_opt);
         });
 
-        uint16_t pid = static_cast<uint16_t>(strtoul(all_hid_infos.front().pid.data(), nullptr, 16));
-
         if ((camera_fw_version >= firmware_version(custom_sensor_fw_ver)) &&
-                (!val_in_range(pid, { ds::RS400_IMU_PID, ds::RS435I_PID, ds::RS430I_PID, ds::RS465_PID, ds::RS405_PID, ds::RS455_PID })))
+                (!val_in_range(_pid, { ds::RS400_IMU_PID, ds::RS435I_PID, ds::RS430I_PID, ds::RS465_PID, ds::RS405_PID, ds::RS455_PID })))
         {
             hid_ep->register_option(RS2_OPTION_MOTION_MODULE_TEMPERATURE,
                                     std::make_shared<motion_module_temperature_option>(*raw_hid_ep));
@@ -320,12 +319,22 @@ namespace librealsense
     {
         using namespace ds;
 
-        _mm_calib = std::make_shared<mm_calib_handler>(_hw_monitor,_device_capabilities);
+        std::vector<platform::hid_device_info> hid_infos = group.hid_devices;
+
+        if (!hid_infos.empty())
+        {
+            // product id
+            _pid = static_cast<uint16_t>(strtoul(hid_infos.front().pid.data(), nullptr, 16));
+
+            // motion correction
+            _mm_calib = std::make_shared<mm_calib_handler>(_hw_monitor, _pid);
 
-        _accel_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_ACCEL); });
-        _gyro_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_GYRO); });
-        // D435i to use predefined values extrinsics
-        _depth_to_imu = std::make_shared<lazy<rs2_extrinsics>>([this]() { return _mm_calib->get_extrinsic(RS2_STREAM_ACCEL); });
+            _accel_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_ACCEL); });
+            _gyro_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_GYRO); });
+
+            // use predefined extrinsics
+            _depth_to_imu = std::make_shared<lazy<rs2_extrinsics>>([this]() { return _mm_calib->get_extrinsic(RS2_STREAM_ACCEL); });
+        }
 
         initialize_fisheye_sensor(ctx,group);
 
@@ -441,10 +450,15 @@ namespace librealsense
         _fisheye_device_idx = add_sensor(fisheye_ep);
     }
 
-    mm_calib_handler::mm_calib_handler(std::shared_ptr<hw_monitor> hw_monitor, ds::d400_caps dev_cap) :
-        _hw_monitor(hw_monitor), _dev_cap(dev_cap)
+    mm_calib_handler::mm_calib_handler(std::shared_ptr<hw_monitor> hw_monitor, uint16_t pid) :
+        _hw_monitor(hw_monitor), _pid(pid)
     {
-        _imu_eeprom_raw = [this]() { return get_imu_eeprom_raw(); };
+        _imu_eeprom_raw = [this]() {
+            if (_pid == L515_PID)
+                return get_imu_eeprom_raw_l515();
+            else
+                return get_imu_eeprom_raw();
+        };
 
         _calib_parser = [this]() {
 
@@ -452,6 +466,8 @@ namespace librealsense
             uint16_t calib_id = ds::dm_v2_eeprom_id; //assume DM V2 IMU as default platform
             bool valid = false;
 
+            if (_pid == L515_PID) calib_id = ds::l500_eeprom_id;
+
             try
             {
                 raw = *_imu_eeprom_raw;
@@ -460,16 +476,19 @@ namespace librealsense
             }
             catch(const std::exception&)
             {
-                LOG_WARNING("IMU Calibration is not available, see the previous message");
+                // in case calibration table errors (invalid table, empty table, or corrupted table), data is invalid and default intrinsic and extrinsic will be used
+                LOG_WARNING("IMU Calibration is not available, default intrinsic and extrinsic will be used.");
             }
 
             std::shared_ptr<mm_calib_parser> prs = nullptr;
             switch (calib_id)
             {
                 case ds::dm_v2_eeprom_id: // DM V2 id
-                    prs = std::make_shared<dm_v2_imu_calib_parser>(raw, _dev_cap, valid); break;
+                    prs = std::make_shared<dm_v2_imu_calib_parser>(raw, _pid, valid); break;
                 case ds::tm1_eeprom_id: // TM1 id
                     prs = std::make_shared<tm1_imu_calib_parser>(raw); break;
+                case ds::l500_eeprom_id: // L515
+                    prs = std::make_shared<l500_imu_calib_parser>(raw, valid); break;
                 default:
                     throw recoverable_exception(to_string() << "Motion Intrinsics unresolved - "
                                 << ((valid)? "device is not calibrated" : "invalid calib type "),
@@ -487,6 +506,14 @@ namespace librealsense
         return _hw_monitor->send(cmd);
     }
 
+    std::vector<uint8_t> mm_calib_handler::get_imu_eeprom_raw_l515() const
+    {
+       // read imu calibration table on L515
+       // READ_TABLE 0x243 0
+       command cmd(ivcam2::READ_TABLE, ivcam2::L515_IMU_TABLE, 0);
+       return _hw_monitor->send(cmd);
+    }
+
     ds::imu_intrinsic mm_calib_handler::get_intrinsic(rs2_stream stream)
     {
         return (*_calib_parser)->get_intrinsic(stream);
diff --git a/src/ds5/ds5-motion.h b/src/ds5/ds5-motion.h
index dc767de..11589e5 100644
--- a/src/ds5/ds5-motion.h
+++ b/src/ds5/ds5-motion.h
@@ -111,35 +111,92 @@ namespace librealsense
     class dm_v2_imu_calib_parser : public mm_calib_parser
     {
     public:
-        dm_v2_imu_calib_parser(const std::vector<uint8_t>& raw_data, ds::d400_caps capabilities, bool valid = true)
+        dm_v2_imu_calib_parser(const std::vector<uint8_t>& raw_data, uint16_t pid, bool valid = true)
         {
+            // product id to identify platform specific parameters, imu models and physical location
+            _pid = pid;
+
             _calib_table.module_info.dm_v2_calib_table.extrinsic_valid = 0;
             _calib_table.module_info.dm_v2_calib_table.intrinsic_valid = 0;
+
+            _valid_intrinsic = false;
+            _valid_extrinsic = false;
+
             // default parser to be applied when no FW calibration is available
             if (valid)
-                _calib_table = *(ds::check_calib<ds::dm_v2_eeprom>(raw_data));
+            {
+                try
+                {
+                    _calib_table = *(ds::check_calib<ds::dm_v2_eeprom>(raw_data));
+                    _valid_intrinsic = (_calib_table.module_info.dm_v2_calib_table.intrinsic_valid == 1) ? true : false;
+                    _valid_extrinsic = (_calib_table.module_info.dm_v2_calib_table.extrinsic_valid == 1) ? true : false;
+                }
+                catch (...)
+                {
+                    _valid_intrinsic = false;
+                    _valid_extrinsic = false;
+                }
+            }
 
-            if (capabilities && ds::d400_caps::CAP_BMI_055)
+            // TODO - review possibly refactor into a map if necessary
+            //
+            // predefined platform specific extrinsic, IMU assembly transformation based on mechanical drawing (meters)
+            rs2_extrinsics _def_extr;
+
+            if (_pid == ds::RS435I_PID)
             {
-                // D435i specific - BMI055 assembly transformation based on mechanical drawing (mm)
+                // D435i specific - Bosch BMI055
                 _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, { -0.00552f, 0.0051f, 0.01174f} };
-                _imu_2_depth_rot = { {-1,0,0},{0,1,0},{0,0,-1} };        //Reference spec : Bosch BMI055
+                _imu_2_depth_rot = { {-1,0,0},{0,1,0},{0,0,-1} };
             }
-            else // BMI_055 and unmapped configurations
+            else if (_pid == ds::RS455_PID)
             {
-                if (capabilities && ds::d400_caps::CAP_BMI_085)
-                {    // BMI085 assembly transformation for designated SKUs, based on mechanical drawing (mm)
-                    _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, { -0.10125f, -0.00375f, -0.0013f} };
-                    _imu_2_depth_rot = { {1,0,0},{0,1,0},{0,0,1} };       //Reference spec : Bosch BMI085
-                }
-                else
-                {
-                    _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 }, { 0.f, 0.f, 0.f} };
-                    _imu_2_depth_rot = { {1,0,0},{0,1,0},{0,0,1} };
-                    LOG_ERROR("Undefined IMU sensor type, use default intrinsic/extrinsic data");
-                }
+                // D455 specific - Bosch BMI055
+                _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ -0.03022f, 0.0074f, 0.01602f } };
+                _imu_2_depth_rot = { { -1,0,0 },{ 0,1,0 },{ 0,0,-1 } };
+            }
+            else if (_pid == ds::RS405_PID)
+            {
+                // D405 specific - Bosch BMI055
+                // TODO - verify with mechanical drawing
+                _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ -0.00552f, 0.0051f, 0.01174f } };
+                _imu_2_depth_rot = { { -1,0,0 },{ 0,1,0 },{ 0,0,-1 } };
+            }
+            else if (_pid == ds::RS465_PID)
+            {
+                // D465 specific - Bosch BMI085
+                // TODO - verify with mechanical drawing
+                _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ -0.10125f, -0.00375f, -0.0013f } };
+                _imu_2_depth_rot = { { 1,0,0 },{ 0,1,0 },{ 0,0,1 } };
+            }
+            else // unmapped configurations
+            {
+                // IMU on new devices is oriented such that FW output is consistent with D435i
+                // use same rotation matrix as D435i so that librealsense output from unsupported
+                // devices will still be correctly aligned with depth coordinate system.
+                _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ 0.f, 0.f, 0.f } };
+                _imu_2_depth_rot = { { -1,0,0 },{ 0,1,0 },{ 0,0,-1 } };
+                LOG_ERROR("Undefined platform with IMU, use default intrinsic/extrinsic data, PID: " << _pid);
+            }
+
+            // default intrinsic in case no valid calibration data is available
+            // scale = 1 and offset = 0
+            _def_intr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ 0.0, 0.0, 0.0 } };
+
+            // handling extrinsic
+            if (_valid_extrinsic)
+            {
+                // extrinsic from calibration table, by user custom calibration, The extrinsic is stored as array of floats / little-endian
+                librealsense::copy(&_extr, &_calib_table.module_info.dm_v2_calib_table.depth_to_imu, sizeof(rs2_extrinsics));
+            }
+            else
+            {
+                LOG_INFO("IMU extrinsic table not found; using CAD values");
+                // default extrinsic based on mechanical drawing
+                _extr = _def_extr;
             }
         }
+
         dm_v2_imu_calib_parser(const dm_v2_imu_calib_parser&);
         virtual ~dm_v2_imu_calib_parser() {}
 
@@ -150,35 +207,36 @@ namespace librealsense
             if (!(RS2_STREAM_ACCEL == stream) && !(RS2_STREAM_GYRO == stream))
                 throw std::runtime_error(to_string() << "Depth Module V2 does not support extrinsic for : " << rs2_stream_to_string(stream) << " !");
 
-            rs2_extrinsics extr;
-            if (1 == _calib_table.module_info.dm_v2_calib_table.extrinsic_valid)
-            {
-                // The extrinsic is stored as array of floats / little-endian
-                librealsense::copy(&extr, &_calib_table.module_info.dm_v2_calib_table.depth_to_imu, sizeof(rs2_extrinsics));
-            }
-            else
-            {
-                LOG_INFO("IMU extrinsic table not found; using CAD values");
-                // D435i specific - BMI055 assembly transformation based on mechanical drawing (mm)
-                extr = _def_extr;
-            }
-            return extr;
+            return _extr;
         }
 
         ds::imu_intrinsic get_intrinsic(rs2_stream stream)
         {
-            if (1!=_calib_table.module_info.dm_v2_calib_table.intrinsic_valid)
-                throw std::runtime_error(to_string() << "Depth Module V2 intrinsic invalidated : " << rs2_stream_to_string(stream) << " !");
-
             ds::dm_v2_imu_intrinsic in_intr;
             switch (stream)
             {
                 case RS2_STREAM_ACCEL:
-                    in_intr = _calib_table.module_info.dm_v2_calib_table.accel_intrinsic;
+                    if (_valid_intrinsic)
+                    {
+                        in_intr = _calib_table.module_info.dm_v2_calib_table.accel_intrinsic;
+                    }
+                    else
+                    {
+                        LOG_INFO("Depth Module V2 IMU " << rs2_stream_to_string(stream) << "no valid intrinsic available, use default values.");
+                        in_intr = _def_intr;
+                    }
                     break;
                 case RS2_STREAM_GYRO:
-                    in_intr = _calib_table.module_info.dm_v2_calib_table.gyro_intrinsic;
-                    in_intr.bias = in_intr.bias * static_cast<float>(d2r);        // The gyro bias is calculated in Deg/sec
+                    if (_valid_intrinsic)
+                    {
+                        in_intr = _calib_table.module_info.dm_v2_calib_table.gyro_intrinsic;
+                        in_intr.bias = in_intr.bias * static_cast<float>(d2r);        // The gyro bias is calculated in Deg/sec
+                    }
+                    else
+                    {
+                        LOG_INFO("Depth Module V2 IMU " << rs2_stream_to_string(stream) << "intrinsic not valid, use default values.");
+                        in_intr = _def_intr;
+                    }
                     break;
                 default:
                     throw std::runtime_error(to_string() << "Depth Module V2 does not provide intrinsic for stream type : " << rs2_stream_to_string(stream) << " !");
@@ -189,28 +247,159 @@ namespace librealsense
 
     private:
         ds::dm_v2_eeprom    _calib_table;
-        rs2_extrinsics      _def_extr;
+        rs2_extrinsics      _extr;
+        float3x3            _imu_2_depth_rot;
+        ds::dm_v2_imu_intrinsic _def_intr;
+        bool                _valid_intrinsic;
+        bool                _valid_extrinsic;
+        uint16_t            _pid;
+    };
+
+    class l500_imu_calib_parser : public mm_calib_parser
+    {
+    public:
+        l500_imu_calib_parser(const std::vector<uint8_t>& raw_data, bool valid = true)
+        {
+            // default parser to be applied when no FW calibration is available
+            _valid_intrinsic = false;
+            _valid_extrinsic = false;
+
+            // in case calibration table is provided but with incorrect header and CRC, both intrinsic and extrinsic will use default values
+            // calibration table has flags to indicate if it contains valid intrinsic and extrinsic, use this as further indication if the data is valid
+            // currently, the imu calibration script only calibrates intrinsic so only the intrinsic_valid field is set during calibration, extrinsic
+            // will use default values derived from mechanical CAD drawing, however, if the calibration script in the future or user calibration provide
+            // valid extrinsic, the extrinsic_valid field should be set in the table and detected here so the values from the table can be used.
+            if (valid)
+            {
+                try
+                {
+                    imu_calib_table = *(ds::check_calib<ds::dm_v2_calibration_table>(raw_data));
+                    _valid_intrinsic = (imu_calib_table.intrinsic_valid == 1) ? true : false;
+                    _valid_extrinsic = (imu_calib_table.extrinsic_valid == 1) ? true : false;
+                }
+                catch (...)
+                {
+                    _valid_intrinsic = false;
+                    _valid_extrinsic = false;
+                }
+            }
+
+            // L515 specific
+            // Bosch BMI085 assembly transformation based on mechanical drawing (meters)
+            // device thickness 26 mm from front glass to back surface
+            // depth ground zero is 4.5mm from front glass into the device
+            // IMU reference in z direction is at 20.93mm from back surface
+            //
+            // IMU offset in Z direction = 4.5 mm - (26 mm - 20.93 mm) = 4.5 mm - 5.07mm = - 0.57mm
+            // IMU offset in x and Y direction (12.45mm, -16.42mm) from center
+            //
+            // coordinate system as reference, looking from back of the camera towards front,
+            // the positive x-axis points to the right, the positive y-axis points down, and the
+            // positive z-axis points forward.
+            // origin in the center but z-direction 4.5mm from front glass into the device
+            // the matrix below is such that output of motion data is consistent with convention
+            // that positive direction aligned with gravity leads to -1g and opposite direction
+            // leads to +1g, for example, positive z_aixs points forward away from front glass of
+            // the device, 1) if place the device flat on a table, facing up, positive z-axis points
+            // up, z-axis acceleration is around +1g; 2) facing down, positive z-axis points down,
+            // z-axis accleration would be around -1g
+            rs2_extrinsics _def_extr;
+            _def_extr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ -0.01245f, 0.01642f, 0.00057f } };
+            _imu_2_depth_rot = { { -1, 0, 0 },{ 0, 1, 0 },{ 0, 0, -1 } };
+
+            // default intrinsic in case no valid calibration data is available
+            // scale = 1 and offset = 0
+            _def_intr = { { 1, 0, 0, 0, 1, 0, 0, 0, 1 },{ 0.0, 0.0, 0.0 } };
+
+
+            // handling extrinsic
+            if (_valid_extrinsic)
+            {
+                // only in case valid extrinsic is available in calibration data by calibration script in future or user custom calibration
+                librealsense::copy(&_extr, &imu_calib_table.depth_to_imu, sizeof(rs2_extrinsics));
+            }
+            else
+            {
+                // L515 - BMI085 assembly transformation based on mechanical drawing
+                LOG_INFO("IMU extrinsic using CAD values");
+                _extr = _def_extr;
+            }
+        }
+
+        virtual ~l500_imu_calib_parser() {}
+
+        float3x3 imu_to_depth_alignment() { return _imu_2_depth_rot; }
+
+        ds::imu_intrinsic get_intrinsic(rs2_stream stream)
+        {
+            ds::dm_v2_imu_intrinsic in_intr;
+            switch (stream)
+            {
+            case RS2_STREAM_ACCEL:
+                if (_valid_intrinsic)
+                {
+                    in_intr = imu_calib_table.accel_intrinsic;
+                }
+                else
+                {
+                    LOG_INFO("L515 IMU " << rs2_stream_to_string(stream) << "no valid intrinsic available, use default values.");
+                    in_intr = _def_intr;
+                }
+                break;
+            case RS2_STREAM_GYRO:
+                if (_valid_intrinsic)
+                {
+                    in_intr = imu_calib_table.gyro_intrinsic;
+                    in_intr.bias = in_intr.bias * static_cast<float>(d2r);        // The gyro bias is calculated in Deg/sec
+                }
+                else
+                {
+                    LOG_INFO("L515 IMU " << rs2_stream_to_string(stream) << "no valid intrinsic available, use default values.");
+                    in_intr = _def_intr;
+                }
+                break;
+            default:
+                throw std::runtime_error(to_string() << "L515 does not provide intrinsic for stream type : " << rs2_stream_to_string(stream) << " !");
+            }
+
+            return{ in_intr.sensitivity, in_intr.bias,{ 0,0,0 },{ 0,0,0 } };
+        }
+
+        rs2_extrinsics get_extrinsic_to(rs2_stream stream)
+        {
+            if (!(RS2_STREAM_ACCEL == stream) && !(RS2_STREAM_GYRO == stream))
+                throw std::runtime_error(to_string() << "L515 does not support extrinsic for : " << rs2_stream_to_string(stream) << " !");
+
+            return _extr;
+        }
+
+    private:
+        ds::dm_v2_calibration_table  imu_calib_table;
+        rs2_extrinsics      _extr;
         float3x3            _imu_2_depth_rot;
+        ds::dm_v2_imu_intrinsic _def_intr;
+        bool                _valid_intrinsic;
+        bool                _valid_extrinsic;
     };
 
     class mm_calib_handler
     {
     public:
-        mm_calib_handler(std::shared_ptr<hw_monitor> hw_monitor, ds::d400_caps dev_cap);
+        mm_calib_handler(std::shared_ptr<hw_monitor> hw_monitor, uint16_t pid);
         ~mm_calib_handler() {}
 
         ds::imu_intrinsic get_intrinsic(rs2_stream);
         rs2_extrinsics get_extrinsic(rs2_stream);       // The extrinsic defined as Depth->Stream rigid-body transfom.
         const std::vector<uint8_t> get_fisheye_calib_raw();
         float3x3 imu_to_depth_alignment() { return (*_calib_parser)->imu_to_depth_alignment(); }
-
     private:
         std::shared_ptr<hw_monitor> _hw_monitor;
-        ds::d400_caps                   _dev_cap;
         lazy< std::shared_ptr<mm_calib_parser>> _calib_parser;
         lazy<std::vector<uint8_t>>      _imu_eeprom_raw;
         std::vector<uint8_t>            get_imu_eeprom_raw() const;
+        std::vector<uint8_t>            get_imu_eeprom_raw_l515() const;
         lazy<std::vector<uint8_t>>      _fisheye_calibration_table_raw;
+        uint16_t _pid;
     };
 
     class ds5_motion : public virtual ds5_device
@@ -244,6 +433,8 @@ namespace librealsense
         lazy<std::vector<uint8_t>>              _fisheye_calibration_table_raw;
         std::shared_ptr<lazy<rs2_extrinsics>>   _depth_to_imu;                  // Mechanical installation pose
 
+        uint16_t _pid;    // product PID
+
         // Bandwidth parameters required for HID sensors
         // The Acceleration configuration will be resolved according to the IMU sensor type at run-time
         std::vector<std::pair<std::string, stream_profile>> sensor_name_and_hid_profiles =
diff --git a/src/ds5/ds5-options.h b/src/ds5/ds5-options.h
index 6cd0e81..6325e7f 100644
--- a/src/ds5/ds5-options.h
+++ b/src/ds5/ds5-options.h
@@ -54,26 +54,6 @@ namespace librealsense
         hid_sensor& _ep;
     };
 
-    class enable_motion_correction : public option_base
-    {
-    public:
-        void set(float value) override;
-
-        float query() const override;
-
-        bool is_enabled() const override { return true; }
-
-        const char* get_description() const override
-        {
-            return "Enable/Disable Automatic Motion Data Correction";
-        }
-
-        enable_motion_correction(sensor_base* mm_ep, const option_range& opt_range);
-
-    private:
-        std::atomic<bool>   _is_active;
-    };
-
     class enable_auto_exposure_option : public option_base
     {
     public:
diff --git a/src/ds5/ds5-private.h b/src/ds5/ds5-private.h
index 05a89e5..9f51c29 100644
--- a/src/ds5/ds5-private.h
+++ b/src/ds5/ds5-private.h
@@ -333,7 +333,6 @@ namespace librealsense
             uint32_t                param;          // This field content is defined ny table type
             uint32_t                crc32;          // crc of all the actual table data excluding header/CRC
         };
-#pragma pack(pop)
 
         enum ds5_rect_resolutions : unsigned short
         {
@@ -380,6 +379,7 @@ namespace librealsense
             float  ppx;
             float  ppy;
         };
+#pragma pack(pop)
 
         template<class T>
         const T* check_calib(const std::vector<uint8_t>& raw_data)
@@ -561,7 +561,8 @@ namespace librealsense
         enum imu_eeprom_id : uint16_t
         {
             dm_v2_eeprom_id     = 0x0101,   // The pack alignment is Big-endian
-            tm1_eeprom_id       = 0x0002
+            tm1_eeprom_id       = 0x0002,
+            l500_eeprom_id      = 0x0105
         };
 
         struct depth_table_control
diff --git a/src/environment.cpp b/src/environment.cpp
index 5b57149..106de21 100644
--- a/src/environment.cpp
+++ b/src/environment.cpp
@@ -52,6 +52,33 @@ namespace librealsense
         register_extrinsics(from, to, lazy_extr);
     }
 
+    void extrinsics_graph::override_extrinsics( const stream_interface& from, const stream_interface& to, rs2_extrinsics const & extr )
+    {
+        std::lock_guard<std::mutex> lock( _mutex );
+
+        // First, trim any dead stream, to make sure we are not keep gaining memory
+        cleanup_extrinsics();
+
+        // The extrinsics must already exist!
+        auto from_idx = find_stream_profile( from, false );  // do not add if not there
+        auto from_it = _extrinsics.find( from_idx );
+        if( from_it == _extrinsics.end() )
+            throw std::runtime_error( "override_extrinsics called for invalid <from> stream" );
+        auto& from_map = from_it->second;
+
+        auto to_idx = find_stream_profile( to, false );  // do not add if not there
+        auto to_it = from_map.find( to_idx );
+        if( to_it == from_map.end() )
+            throw std::runtime_error( "override_extrinsics called for invalid <to> stream" );
+        auto& weak_ptr = to_it->second;
+        auto sp = weak_ptr.lock();
+        if( !sp )
+            throw std::runtime_error( "override_extrinsics called for out-of-date stream" );
+        
+        auto & lazy_extr = *sp;
+        lazy_extr = [=]() { return extr; };
+    }
+
     void extrinsics_graph::cleanup_extrinsics()
     {
         if (_locks_count.load()) return;
@@ -85,16 +112,18 @@ namespace librealsense
             LOG_INFO("Found " << invalid_ids.size() << " unreachable streams, " << std::dec << counter << " extrinsics deleted");
     }
 
-    int extrinsics_graph::find_stream_profile(const stream_interface& p)
+    int extrinsics_graph::find_stream_profile(const stream_interface& p, bool add_if_not_there)
     {
         auto sp = p.shared_from_this();
         auto max = 0;
         for (auto&& kvp : _streams)
         {
-            max = std::max(max, kvp.first);
             if (kvp.second.lock().get() == sp.get())
                 return kvp.first;
+            max = std::max( max, kvp.first );
         }
+        if( !add_if_not_there )
+            return -1;
         _streams[max + 1] = sp;
         return max + 1;
 
diff --git a/src/environment.h b/src/environment.h
index 7cae0c3..4d1eaa7 100644
--- a/src/environment.h
+++ b/src/environment.h
@@ -16,6 +16,7 @@ namespace librealsense
         void register_same_extrinsics(const stream_interface& from, const stream_interface& to);
         void register_extrinsics(const stream_interface& from, const stream_interface& to, std::weak_ptr<lazy<rs2_extrinsics>> extr);
         void register_extrinsics(const stream_interface& from, const stream_interface& to, rs2_extrinsics extr);
+        void override_extrinsics(const stream_interface& from, const stream_interface& to, rs2_extrinsics const & extr);
         bool try_fetch_extrinsics(const stream_interface& from, const stream_interface& to, rs2_extrinsics* extr);
 
         struct extrinsics_lock
@@ -53,7 +54,7 @@ namespace librealsense
         std::shared_ptr<lazy<rs2_extrinsics>> fetch_edge(int from, int to);
         bool try_fetch_extrinsics(int from, int to, std::set<int>& visited, rs2_extrinsics* extr);
         void cleanup_extrinsics();
-        int find_stream_profile(const stream_interface& p);
+        int find_stream_profile(const stream_interface& p, bool add_if_not_there = true);
 
         std::atomic<int> _locks_count;
         std::map<int, std::map<int, std::weak_ptr<lazy<rs2_extrinsics>>>> _extrinsics;
diff --git a/src/firmware_logger_device.cpp b/src/firmware_logger_device.cpp
new file mode 100644
index 0000000..63564c5
--- /dev/null
+++ b/src/firmware_logger_device.cpp
@@ -0,0 +1,133 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "firmware_logger_device.h"
+#include <string>
+
+namespace librealsense
+{
+    firmware_logger_device::firmware_logger_device(std::shared_ptr<context> ctx, 
+        const platform::backend_device_group group,
+        std::shared_ptr<hw_monitor> hardware_monitor,
+        const command& fw_logs_command, const command& flash_logs_command) :
+        device(ctx, group),
+        _hw_monitor(hardware_monitor),
+        _fw_logs(),
+        _flash_logs(),
+        _flash_logs_initialized(false),
+        _parser(nullptr), 
+        _fw_logs_command(fw_logs_command),
+        _flash_logs_command(flash_logs_command) { }
+
+    bool firmware_logger_device::get_fw_log(fw_logs::fw_logs_binary_data& binary_data)
+    {
+        bool result = false;
+        if (_fw_logs.empty())
+        {
+            get_fw_logs_from_hw_monitor();
+        }
+
+        if (!_fw_logs.empty())
+        {
+            fw_logs::fw_logs_binary_data data;
+            data = _fw_logs.front();
+            _fw_logs.pop();
+            binary_data = data;
+            result = true;
+        }
+        return result;
+    }
+
+
+    void firmware_logger_device::get_fw_logs_from_hw_monitor()
+    {
+        auto res = _hw_monitor->send(_fw_logs_command);
+        if (res.empty())
+        {
+            return;
+        }
+
+        auto beginOfLogIterator = res.begin();
+        // convert bytes to fw_logs_binary_data
+        for (int i = 0; i < res.size() / fw_logs::BINARY_DATA_SIZE; ++i)
+        {
+            if (*beginOfLogIterator == 0)
+                break;
+            auto endOfLogIterator = beginOfLogIterator + fw_logs::BINARY_DATA_SIZE;
+            std::vector<uint8_t> resultsForOneLog;
+            resultsForOneLog.insert(resultsForOneLog.begin(), beginOfLogIterator, endOfLogIterator);
+            fw_logs::fw_logs_binary_data binary_data{ resultsForOneLog };
+            _fw_logs.push(binary_data);
+            beginOfLogIterator = endOfLogIterator;
+        }
+    }
+
+    void firmware_logger_device::get_flash_logs_from_hw_monitor()
+    {
+        auto res = _hw_monitor->send(_flash_logs_command);
+
+        if (res.empty())
+        {
+            LOG_INFO("Getting Flash logs failed!");
+            return;
+        }
+
+        //erasing header
+        int size_of_flash_logs_header = 27;
+        res.erase(res.begin(), res.begin() + size_of_flash_logs_header);
+
+        auto beginOfLogIterator = res.begin();
+        // convert bytes to flash_logs_binary_data
+        for (int i = 0; i < res.size() / fw_logs::BINARY_DATA_SIZE && *beginOfLogIterator == 160; ++i)
+        {
+            auto endOfLogIterator = beginOfLogIterator + fw_logs::BINARY_DATA_SIZE;
+            std::vector<uint8_t> resultsForOneLog;
+            resultsForOneLog.insert(resultsForOneLog.begin(), beginOfLogIterator, endOfLogIterator);
+            fw_logs::fw_logs_binary_data binary_data{ resultsForOneLog };
+            _flash_logs.push(binary_data);
+            beginOfLogIterator = endOfLogIterator;
+        }
+
+        _flash_logs_initialized = true;
+    }
+
+    bool firmware_logger_device::get_flash_log(fw_logs::fw_logs_binary_data& binary_data)
+    {
+        bool result = false;
+        if (!_flash_logs_initialized)
+        {
+            get_flash_logs_from_hw_monitor();
+        }
+
+        if (!_flash_logs.empty())
+        {
+            fw_logs::fw_logs_binary_data data;
+            data = _flash_logs.front();
+            _flash_logs.pop();
+            binary_data = data;
+            result = true;
+        }
+        return result;
+    }
+
+    bool firmware_logger_device::init_parser(std::string xml_content)
+    {
+        _parser = new fw_logs::fw_logs_parser(xml_content);
+
+        return (_parser != nullptr);
+    }
+
+    bool firmware_logger_device::parse_log(const fw_logs::fw_logs_binary_data* fw_log_msg, 
+        fw_logs::fw_log_data* parsed_msg)
+    {
+        bool result = false;
+        if (_parser && parsed_msg && fw_log_msg)
+        {
+            *parsed_msg = _parser->parse_fw_log(fw_log_msg);
+            result = true;
+        }
+            
+        return result;
+    }
+
+}
diff --git a/src/firmware_logger_device.h b/src/firmware_logger_device.h
new file mode 100644
index 0000000..2d948b3
--- /dev/null
+++ b/src/firmware_logger_device.h
@@ -0,0 +1,62 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "core/extension.h"
+#include "device.h"
+#include <vector>
+#include "fw-logs/fw-log-data.h"
+#include "fw-logs/fw-logs-parser.h"
+
+namespace librealsense
+{
+    class firmware_logger_extensions
+    {
+    public:
+        virtual bool get_fw_log(fw_logs::fw_logs_binary_data& binary_data) = 0;
+        virtual bool get_flash_log(fw_logs::fw_logs_binary_data& binary_data) = 0;
+        virtual bool init_parser(std::string xml_content) = 0;
+        virtual bool parse_log(const fw_logs::fw_logs_binary_data* fw_log_msg, fw_logs::fw_log_data* parsed_msg) = 0;
+        virtual ~firmware_logger_extensions() = default;
+    };
+    MAP_EXTENSION(RS2_EXTENSION_FW_LOGGER, librealsense::firmware_logger_extensions);
+
+    class firmware_logger_device : public virtual device, public firmware_logger_extensions
+    {
+    public:
+        firmware_logger_device(std::shared_ptr<context> ctx, const platform::backend_device_group group, 
+            std::shared_ptr<hw_monitor> hardware_monitor,
+            const command& fw_logs_command, const command& flash_logs_command);
+
+        bool get_fw_log(fw_logs::fw_logs_binary_data& binary_data) override;
+        bool get_flash_log(fw_logs::fw_logs_binary_data& binary_data) override;
+
+        bool init_parser(std::string xml_content) override;
+        bool parse_log(const fw_logs::fw_logs_binary_data* fw_log_msg, fw_logs::fw_log_data* parsed_msg) override;
+
+        // Temporal solution for HW_Monitor injection
+        void assign_hw_monitor(std::shared_ptr<hw_monitor> hardware_monitor)
+            { _hw_monitor = hardware_monitor; }
+
+    private:
+
+        void get_fw_logs_from_hw_monitor();
+        void get_flash_logs_from_hw_monitor();
+
+        command _fw_logs_command;
+        command _flash_logs_command;
+
+        std::shared_ptr<hw_monitor> _hw_monitor;
+
+        std::queue<fw_logs::fw_logs_binary_data> _fw_logs;
+        std::queue<fw_logs::fw_logs_binary_data> _flash_logs;
+
+        bool _flash_logs_initialized;
+
+        fw_logs::fw_logs_parser* _parser;
+        uint16_t _device_pid;
+
+    };
+
+}
diff --git a/src/frame-archive.h b/src/frame-archive.h
index 7168e5f..89276e8 100644
--- a/src/frame-archive.h
+++ b/src/frame-archive.h
@@ -166,7 +166,7 @@ namespace librealsense
             std::shared_ptr<platform::time_service> ts,
             std::shared_ptr<metadata_parser_map> parsers)
             : max_frame_queue_size(in_max_frame_queue_size),
-            mutex(), recycle_frames(true), _time_service(ts),
+            recycle_frames(true), mutex(), _time_service(ts),
             _metadata_parsers(parsers)
         {
             published_frames_count = 0;
diff --git a/src/frame-validator.cpp b/src/frame-validator.cpp
index b5c8be2..e35e2c2 100644
--- a/src/frame-validator.cpp
+++ b/src/frame-validator.cpp
@@ -66,10 +66,7 @@ namespace librealsense
         //after the validation all streams will be passeded to user callback directly
         if (stream->get_stream_type() != RS2_STREAM_INFRARED)
             return false;
-
-        //start to validate only from the second frame
-        if(_ir_frame_num++ < 2)
-            return false;
+        // TODO review the above statement and check with PLM
 
         auto w = vf->get_width();
         auto h = vf->get_height();
diff --git a/src/fw-logs/CMakeLists.txt b/src/fw-logs/CMakeLists.txt
new file mode 100644
index 0000000..87b9391
--- /dev/null
+++ b/src/fw-logs/CMakeLists.txt
@@ -0,0 +1,15 @@
+# License: Apache 2.0. See LICENSE file in root directory.
+# Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+target_sources(${LRS_TARGET}
+    PRIVATE
+        "${CMAKE_CURRENT_LIST_DIR}/fw-log-data.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-log-data.h"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-formating-options.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-formating-options.h"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-parser.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-parser.h"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-xml-helper.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-logs-xml-helper.h"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-string-formatter.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/fw-string-formatter.h"
+)
diff --git a/src/fw-logs/fw-log-data.cpp b/src/fw-logs/fw-log-data.cpp
new file mode 100644
index 0000000..60560d5
--- /dev/null
+++ b/src/fw-logs/fw-log-data.cpp
@@ -0,0 +1,107 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+#include "fw-log-data.h"
+#include <sstream>
+#include <iomanip>
+#include <locale>
+#include <string>
+
+using namespace std;
+
+# define SET_WIDTH_AND_FILL(num, element) \
+setfill(' ') << setw(num) << left << element \
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        fw_log_data::fw_log_data(void)
+        {
+            _magic_number = 0;
+            _severity = 0;
+            _file_id = 0;
+            _group_id = 0;
+            _event_id = 0;
+            _line = 0;
+            _sequence = 0;
+            _p1 = 0;
+            _p2 = 0;
+            _p3 = 0;
+            _timestamp = 0;
+            _delta = 0;
+            _message = "";
+            _file_name = "";
+        }
+
+
+        fw_log_data::~fw_log_data(void)
+        {
+        }
+
+
+        rs2_log_severity fw_log_data::get_severity() const
+        {
+            return fw_logs_severity_to_log_severity(_severity);
+        }
+
+        const std::string& fw_log_data::get_message() const
+        {
+            return _message;
+        }
+
+        const std::string& fw_log_data::get_file_name() const
+        {
+            return _file_name;
+        }
+
+        const std::string& fw_log_data::get_thread_name() const
+        {
+            return _thread_name;
+        }
+
+        uint32_t fw_log_data::get_line() const
+        {
+            return _line;
+        }
+
+        uint32_t fw_log_data::get_timestamp() const
+        {
+            return _timestamp;
+        }
+
+        rs2_log_severity fw_logs_binary_data::get_severity() const
+        {
+            const fw_log_binary* log_binary = reinterpret_cast<const fw_log_binary*>(logs_buffer.data());
+            return fw_logs_severity_to_log_severity(static_cast<int32_t>(log_binary->dword1.bits.severity));
+        }
+
+        uint32_t fw_logs_binary_data::get_timestamp() const
+        {
+            const fw_log_binary* log_binary = reinterpret_cast<const fw_log_binary*>(logs_buffer.data());
+            return static_cast<uint32_t>(log_binary->dword5.timestamp);
+        }
+
+        rs2_log_severity fw_logs_severity_to_log_severity(int32_t severity)
+        {
+            rs2_log_severity result = RS2_LOG_SEVERITY_NONE;
+            switch (severity)
+            {
+            case 1:
+                result = RS2_LOG_SEVERITY_DEBUG;
+                break;
+            case 2:
+                result = RS2_LOG_SEVERITY_WARN;
+                break;
+            case 3:
+                result = RS2_LOG_SEVERITY_ERROR;
+                break;
+            case 4:
+                result = RS2_LOG_SEVERITY_FATAL;
+                break;
+            default:
+                break;
+            }
+            return result;
+        }
+    }
+}
diff --git a/src/fw-logs/fw-log-data.h b/src/fw-logs/fw-log-data.h
new file mode 100644
index 0000000..62774dc
--- /dev/null
+++ b/src/fw-logs/fw-log-data.h
@@ -0,0 +1,107 @@
+/* License: Apache 2.0. See LICENSE file in root directory. */
+/* Copyright(c) 2019 Intel Corporation. All Rights Reserved. */
+#pragma once
+#include <stdint.h>
+#include <string>
+#include <vector>
+#include "../types.h"       //for rs2_firmware_log_message
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        struct fw_logs_binary_data
+        {
+            std::vector<uint8_t> logs_buffer;
+            rs2_log_severity get_severity() const;
+            uint32_t get_timestamp() const;
+        };
+
+        rs2_log_severity fw_logs_severity_to_log_severity(int32_t severity);
+
+        static const int BINARY_DATA_SIZE = 20;
+
+        typedef union
+        {
+            uint32_t value;
+            struct
+            {
+                uint32_t magic_number : 8;
+                uint32_t severity : 5;
+                uint32_t thread_id : 3;
+                uint32_t file_id : 11;
+                uint32_t group_id : 5;
+            } bits;
+        } fw_log_header_dword1;
+
+        typedef union
+        {
+            uint32_t value;
+            struct
+            {
+                uint32_t event_id : 16;
+                uint32_t line_id : 12;
+                uint32_t seq_id : 4;
+            } bits;
+        } fw_log_header_dword2;
+
+        struct fw_log_header_dword3
+        {
+            uint16_t p1;
+            uint16_t p2;
+        };
+
+        struct fw_log_header_dword4
+        {
+            uint32_t p3;
+        };
+
+        struct fw_log_header_dword5
+        {
+            uint32_t timestamp;
+        };
+
+        struct fw_log_binary
+        {
+            fw_log_header_dword1 dword1;
+            fw_log_header_dword2 dword2;
+            fw_log_header_dword3 dword3;
+            fw_log_header_dword4 dword4;
+            fw_log_header_dword5 dword5;
+        };
+
+
+        class fw_log_data
+        {
+        public:
+            fw_log_data(void);
+            ~fw_log_data(void);
+
+            uint32_t _magic_number;
+            uint32_t _severity;
+            uint32_t _file_id;
+            uint32_t _group_id;
+            uint32_t _event_id;
+            uint32_t _line;
+            uint32_t _sequence;
+            uint32_t _p1;
+            uint32_t _p2;
+            uint32_t _p3;
+            uint64_t _timestamp;
+            double _delta;
+
+            uint32_t _thread_id;
+
+            std::string _message;
+            std::string _file_name;
+            std::string _thread_name;
+
+            rs2_log_severity get_severity() const;
+            const std::string& get_message() const;
+            const std::string& get_file_name() const;
+            const std::string& get_thread_name() const;
+            uint32_t get_line() const;
+            uint32_t get_timestamp() const;
+        };
+    }
+}
diff --git a/src/fw-logs/fw-logs-formating-options.cpp b/src/fw-logs/fw-logs-formating-options.cpp
new file mode 100644
index 0000000..0b8a947
--- /dev/null
+++ b/src/fw-logs/fw-logs-formating-options.cpp
@@ -0,0 +1,95 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+#include "fw-logs-formating-options.h"
+#include "fw-logs-xml-helper.h"
+#include <sstream>
+
+
+using namespace std;
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        fw_log_event::fw_log_event()
+            : num_of_params(0),
+            line("")
+        {}
+
+        fw_log_event::fw_log_event(int input_num_of_params, const string& input_line)
+            : num_of_params(input_num_of_params),
+            line(input_line)
+        {}
+
+
+        fw_logs_formating_options::fw_logs_formating_options(const string& xml_content)
+            : _xml_content(xml_content)
+        {}
+
+
+        fw_logs_formating_options::~fw_logs_formating_options(void)
+        {
+        }
+
+        bool fw_logs_formating_options::get_event_data(int id, fw_log_event* log_event_data) const
+        {
+            auto event_it = _fw_logs_event_list.find(id);
+            if (event_it != _fw_logs_event_list.end())
+            {
+                *log_event_data = event_it->second;
+                return true;
+            }
+            else
+            {
+                stringstream ss;
+                ss << "*** Unrecognized Log Id: ";
+                ss << id;
+                ss << "! P1 = 0x{0:x}, P2 = 0x{1:x}, P3 = 0x{2:x}";
+                log_event_data->line = ss.str();
+                log_event_data->num_of_params = 3;
+                return false;
+            }
+        }
+
+        bool fw_logs_formating_options::get_file_name(int id, string* file_name) const
+        {
+            auto file_it = _fw_logs_file_names_list.find(id);
+            if (file_it != _fw_logs_file_names_list.end())
+            {
+                *file_name = file_it->second;
+                return true;
+            }
+            else
+            {
+                *file_name = "Unknown";
+                return false;
+            }
+        }
+
+        bool fw_logs_formating_options::get_thread_name(uint32_t thread_id, string* thread_name) const
+        {
+            auto file_it = _fw_logs_thread_names_list.find(thread_id);
+            if (file_it != _fw_logs_thread_names_list.end())
+            {
+                *thread_name = file_it->second;
+                return true;
+            }
+            else
+            {
+                *thread_name = "Unknown";
+                return false;
+            }
+        }
+
+        std::unordered_map<string, std::vector<kvp>> fw_logs_formating_options::get_enums() const
+        {
+            return _fw_logs_enum_names_list;
+        }
+
+        bool fw_logs_formating_options::initialize_from_xml()
+        {
+            fw_logs_xml_helper fw_logs_xml(_xml_content);
+            return fw_logs_xml.build_log_meta_data(this);
+        }
+    }
+}
+
diff --git a/src/fw-logs/fw-logs-formating-options.h b/src/fw-logs/fw-logs-formating-options.h
new file mode 100644
index 0000000..3578fcb
--- /dev/null
+++ b/src/fw-logs/fw-logs-formating-options.h
@@ -0,0 +1,54 @@
+/* License: Apache 2.0. See LICENSE file in root directory. */
+/* Copyright(c) 2019 Intel Corporation. All Rights Reserved. */
+#pragma once
+#include <unordered_map>
+#include <string>
+#include <stdint.h>
+#include <vector>
+
+#ifdef ANDROID
+#include "../../common/android_helpers.h"
+#endif
+
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        struct fw_log_event
+        {
+            size_t num_of_params;
+            std::string line;
+
+            fw_log_event();
+            fw_log_event(int input_num_of_params, const std::string& input_line);
+        };
+
+        typedef std::pair<int, std::string> kvp;     // XML key/value pair
+
+        class fw_logs_xml_helper;
+
+        class fw_logs_formating_options
+        {
+        public:
+            fw_logs_formating_options(const std::string& xml_content);
+            ~fw_logs_formating_options(void);
+
+
+            bool get_event_data(int id, fw_log_event* log_event_data) const;
+            bool get_file_name(int id, std::string* file_name) const;
+            bool get_thread_name(uint32_t thread_id, std::string* thread_name) const;
+            std::unordered_map<std::string, std::vector<kvp>> get_enums() const;
+            bool initialize_from_xml();
+
+        private:
+            friend fw_logs_xml_helper;
+            std::unordered_map<int, fw_log_event> _fw_logs_event_list;
+            std::unordered_map<int, std::string> _fw_logs_file_names_list;
+            std::unordered_map<int, std::string> _fw_logs_thread_names_list;
+            std::unordered_map<std::string, std::vector<std::pair<int, std::string>>> _fw_logs_enum_names_list;
+
+            std::string _xml_content;
+        };
+    }
+}
diff --git a/src/fw-logs/fw-logs-parser.cpp b/src/fw-logs/fw-logs-parser.cpp
new file mode 100644
index 0000000..bd76b1d
--- /dev/null
+++ b/src/fw-logs/fw-logs-parser.cpp
@@ -0,0 +1,90 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+#include "fw-logs-parser.h"
+#include <regex>
+#include <sstream>
+#include "fw-string-formatter.h"
+#include "stdint.h"
+
+using namespace std;
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        fw_logs_parser::fw_logs_parser(string xml_content)
+            : _fw_logs_formating_options(xml_content),
+            _last_timestamp(0),
+            _timestamp_factor(0.00001)
+        {
+            _fw_logs_formating_options.initialize_from_xml();
+        }
+
+
+        fw_logs_parser::~fw_logs_parser(void)
+        {
+        }
+
+        fw_log_data fw_logs_parser::parse_fw_log(const fw_logs_binary_data* fw_log_msg) 
+        {
+            fw_log_data log_data;
+
+            if (!fw_log_msg || fw_log_msg->logs_buffer.size() == 0)
+                return log_data;
+
+            log_data = fill_log_data(fw_log_msg);
+
+            //message
+            fw_string_formatter reg_exp(_fw_logs_formating_options.get_enums());
+            fw_log_event log_event_data;
+            _fw_logs_formating_options.get_event_data(log_data._event_id, &log_event_data);
+
+            uint32_t params[3] = { log_data._p1, log_data._p2, log_data._p3 };
+            reg_exp.generate_message(log_event_data.line, log_event_data.num_of_params, params, &log_data._message);
+
+            //file_name
+            _fw_logs_formating_options.get_file_name(log_data._file_id, &log_data._file_name);
+
+            //thread_name
+            _fw_logs_formating_options.get_thread_name(log_data._thread_id, &log_data._thread_name);
+
+            return log_data;
+        }
+
+        fw_log_data fw_logs_parser::fill_log_data(const fw_logs_binary_data* fw_log_msg)
+        {
+            fw_log_data log_data;
+
+            auto* log_binary = reinterpret_cast<const fw_logs::fw_log_binary*>(fw_log_msg->logs_buffer.data());
+
+            //parse first DWORD
+            log_data._magic_number = static_cast<uint32_t>(log_binary->dword1.bits.magic_number);
+            log_data._severity = static_cast<uint32_t>(log_binary->dword1.bits.severity);
+            log_data._thread_id = static_cast<uint32_t>(log_binary->dword1.bits.thread_id);
+            log_data._file_id = static_cast<uint32_t>(log_binary->dword1.bits.file_id);
+            log_data._group_id = static_cast<uint32_t>(log_binary->dword1.bits.group_id);
+
+            //parse second DWORD
+            log_data._event_id = static_cast<uint32_t>(log_binary->dword2.bits.event_id);
+            log_data._line = static_cast<uint32_t>(log_binary->dword2.bits.line_id);
+            log_data._sequence = static_cast<uint32_t>(log_binary->dword2.bits.seq_id);
+
+            //parse third DWORD
+            log_data._p1 = static_cast<uint32_t>(log_binary->dword3.p1);
+            log_data._p2 = static_cast<uint32_t>(log_binary->dword3.p2);
+
+            //parse forth DWORD
+            log_data._p3 = static_cast<uint32_t>(log_binary->dword4.p3);
+
+            //parse fifth DWORD
+            log_data._timestamp = log_binary->dword5.timestamp;
+
+            log_data._delta = (_last_timestamp == 0) ? 
+                0 :(log_data._timestamp - _last_timestamp) * _timestamp_factor;
+            
+            _last_timestamp = log_data._timestamp;
+
+            return log_data;
+        }
+    }
+}
diff --git a/src/fw-logs/fw-logs-parser.h b/src/fw-logs/fw-logs-parser.h
new file mode 100644
index 0000000..a06af30
--- /dev/null
+++ b/src/fw-logs/fw-logs-parser.h
@@ -0,0 +1,31 @@
+/* License: Apache 2.0. See LICENSE file in root directory. */
+/* Copyright(c) 2019 Intel Corporation. All Rights Reserved. */
+#pragma once
+#include <string>
+#include <vector>
+#include <memory>
+#include "fw-logs-formating-options.h"
+#include "fw-log-data.h"
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        class fw_logs_parser : public std::enable_shared_from_this<fw_logs_parser>
+        {
+        public:
+            explicit fw_logs_parser(std::string xml_content);
+            ~fw_logs_parser(void);
+
+            fw_log_data parse_fw_log(const fw_logs_binary_data* fw_log_msg);
+            
+
+        private:
+            fw_log_data fill_log_data(const fw_logs_binary_data* fw_log_msg);
+
+            fw_logs_formating_options _fw_logs_formating_options;
+            uint64_t _last_timestamp;
+            const double _timestamp_factor;
+        };
+    }
+}
diff --git a/src/fw-logs/fw-logs-xml-helper.cpp b/src/fw-logs/fw-logs-xml-helper.cpp
new file mode 100644
index 0000000..e5f19f1
--- /dev/null
+++ b/src/fw-logs/fw-logs-xml-helper.cpp
@@ -0,0 +1,309 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+#include "fw-logs-xml-helper.h"
+#include <string.h>
+#include <fstream>
+#include <iostream>
+#include <memory>
+
+using namespace std;
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        fw_logs_xml_helper::fw_logs_xml_helper(string xml_content)
+            : _init_done(false),
+            _xml_content(xml_content)
+        {}
+
+
+        fw_logs_xml_helper::~fw_logs_xml_helper(void)
+        {
+            // TODO: Add cleanup code
+        }
+
+        bool fw_logs_xml_helper::get_root_node(xml_node<>** node)
+        {
+            if (_init_done)
+            {
+                *node = _xml_doc.first_node();
+                return true;
+            }
+
+            return false;
+        }
+
+        bool fw_logs_xml_helper::try_load_external_xml()
+        {
+            try
+            {
+                if (_xml_content.empty())
+                    return false;
+
+                _document_buffer.resize(_xml_content.size() + 2);
+                memcpy(_document_buffer.data(), _xml_content.data(), _xml_content.size());
+                _document_buffer[_xml_content.size()] = '\0';
+                _document_buffer[_xml_content.size() + 1] = '\0';
+                _xml_doc.parse<0>(_document_buffer.data());
+
+                return true;
+            }
+            catch (...)
+            {
+                _document_buffer.clear();
+                throw;
+            }
+
+            return false;
+        }
+
+        bool fw_logs_xml_helper::init()
+        {
+            _init_done = try_load_external_xml();
+            return _init_done;
+        }
+
+        bool fw_logs_xml_helper::build_log_meta_data(fw_logs_formating_options* log_meta_data)
+        {
+            xml_node<>* xml_root_node_list;
+
+            if (!init())
+                return false;
+
+            if (!get_root_node(&xml_root_node_list))
+            {
+                return false;
+            }
+
+            string root_name(xml_root_node_list->name(), xml_root_node_list->name() + xml_root_node_list->name_size());
+
+            // check if Format is the first root name.
+            if (root_name.compare("Format") != 0)
+                return false;
+
+            xml_node<>* events_node = xml_root_node_list->first_node();
+
+
+            if (!build_meta_data_structure(events_node, log_meta_data))
+                return false;
+
+            return true;
+        }
+
+
+        bool fw_logs_xml_helper::build_meta_data_structure(xml_node<>* xml_node_list_of_events, fw_logs_formating_options* logs_formating_options)
+        {
+            node_type res = none;
+            int id{};
+            int num_of_params{};
+            string line;
+
+            // loop through all elements in the Format.
+            for (xml_node<>* node = xml_node_list_of_events; node; node = node->next_sibling())
+            {
+                line.clear();
+                res = get_next_node(node, &id, &num_of_params, &line);
+                if (res == event)
+                {
+                    fw_log_event log_event(num_of_params, line);
+                    logs_formating_options->_fw_logs_event_list.insert(pair<int, fw_log_event>(id, log_event));
+                }
+                else if (res == file)
+                {
+                    logs_formating_options->_fw_logs_file_names_list.insert(kvp(id, line));
+                }
+                else if (res == thread)
+                {
+                    logs_formating_options->_fw_logs_thread_names_list.insert(kvp(id, line));
+                }
+                else if (res == enums)
+                {
+                    for (xml_node<>* enum_node = node->first_node(); enum_node; enum_node = enum_node->next_sibling())
+                    {
+                        for (xml_attribute<>* attribute = enum_node->first_attribute(); attribute; attribute = attribute->next_attribute())
+                        {
+                            string attr(attribute->name(), attribute->name() + attribute->name_size());
+                            if (attr.compare("Name") == 0)
+                            {
+                                string name_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                                vector<kvp> xml_kvp;
+
+                                for (xml_node<>* enum_value_node = enum_node->first_node(); enum_value_node; enum_value_node = enum_value_node->next_sibling())
+                                {
+                                    int key = 0;
+                                    string value_str;
+                                    for (xml_attribute<>* attribute = enum_value_node->first_attribute(); attribute; attribute = attribute->next_attribute())
+                                    {
+                                        string attr(attribute->name(), attribute->name() + attribute->name_size());
+                                        if (attr.compare("Value") == 0)
+                                        {
+                                            value_str = std::string(attribute->value(), attribute->value() + attribute->value_size());
+                                        }
+                                        if (attr.compare("Key") == 0)
+                                        {
+                                            try
+                                            {
+                                                auto key_str = std::string(attribute->value());
+                                                key = std::stoi(key_str);
+                                            }
+                                            catch (...) {}
+                                        }
+                                    }
+                                    xml_kvp.push_back(std::make_pair(key, value_str));
+                                }
+                                logs_formating_options->_fw_logs_enum_names_list.insert(pair<string, vector<kvp>>(name_attr_str, xml_kvp));
+                            }
+                        }
+                    }
+                }
+                else
+                    return false;
+            }
+
+            return true;
+        }
+
+        fw_logs_xml_helper::node_type fw_logs_xml_helper::get_next_node(xml_node<>* node, int* id, int* num_of_params, string* line)
+        {
+
+            string tag(node->name(), node->name() + node->name_size());
+
+            if (tag.compare("Event") == 0)
+            {
+                if (get_event_node(node, id, num_of_params, line))
+                    return event;
+            }
+            else if (tag.compare("File") == 0)
+            {
+                if (get_file_node(node, id, line))
+                    return file;
+            }
+            else if (tag.compare("Thread") == 0)
+            {
+                if (get_thread_node(node, id, line))
+                    return thread;
+            }
+            else if (tag.compare("Enums") == 0)
+            {
+                return enums;
+            }
+            return none;
+        }
+
+        bool fw_logs_xml_helper::get_enum_name_node(xml_node<>* node_file, int* thread_id, string* enum_name)
+        {
+            for (xml_attribute<>* attribute = node_file->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                string attr(attribute->name(), attribute->name() + attribute->name_size());
+
+                if (attr.compare("Name") == 0)
+                {
+                    string name_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *enum_name = name_attr_str;
+                    continue;
+                }
+                else
+                    return false;
+            }
+
+            return true;
+        }
+        bool fw_logs_xml_helper::get_enum_value_node(xml_node<>* node_file, int* thread_id, string* enum_name)
+        {
+            for (xml_attribute<>* attribute = node_file->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                string attr(attribute->name(), attribute->name() + attribute->name_size());
+
+                if (attr.compare("Value") == 0)
+                {
+                    string name_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *enum_name = name_attr_str;
+                    continue;
+                }
+                else
+                    return false;
+            }
+
+            return true;
+        }
+        bool fw_logs_xml_helper::get_thread_node(xml_node<>* node_file, int* thread_id, string* thread_name)
+        {
+            for (xml_attribute<>* attribute = node_file->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                string attr(attribute->name(), attribute->name() + attribute->name_size());
+
+                if (attr.compare("id") == 0)
+                {
+                    string id_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *thread_id = stoi(id_attr_str);
+                    continue;
+                }
+                else if (attr.compare("Name") == 0)
+                {
+                    string name_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *thread_name = name_attr_str;
+                    continue;
+                }
+                else
+                    return false;
+            }
+
+            return true;
+        }
+
+        bool fw_logs_xml_helper::get_file_node(xml_node<>* node_file, int* file_id, string* file_name)
+        {
+            for (xml_attribute<>* attribute = node_file->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                string attr(attribute->name(), attribute->name() + attribute->name_size());
+
+                if (attr.compare("id") == 0)
+                {
+                    string id_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *file_id = stoi(id_attr_str);
+                    continue;
+                }
+                else if (attr.compare("Name") == 0)
+                {
+                    string name_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *file_name = name_attr_str;
+                    continue;
+                }
+                else
+                    return false;
+            }
+            return true;
+        }
+
+        bool fw_logs_xml_helper::get_event_node(xml_node<>* node_event, int* event_id, int* num_of_params, string* line)
+        {
+            for (xml_attribute<>* attribute = node_event->first_attribute(); attribute; attribute = attribute->next_attribute())
+            {
+                string attr(attribute->name(), attribute->name() + attribute->name_size());
+
+                if (attr.compare("id") == 0)
+                {
+                    string id_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *event_id = stoi(id_attr_str);
+                    continue;
+                }
+                else if (attr.compare("numberOfArguments") == 0)
+                {
+                    string num_of_args_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *num_of_params = stoi(num_of_args_attr_str);
+                    continue;
+                }
+                else if (attr.compare("format") == 0)
+                {
+                    string format_attr_str(attribute->value(), attribute->value() + attribute->value_size());
+                    *line = format_attr_str;
+                    continue;
+                }
+                else
+                    return false;
+            }
+            return true;
+        }
+    }
+}
diff --git a/src/fw-logs/fw-logs-xml-helper.h b/src/fw-logs/fw-logs-xml-helper.h
new file mode 100644
index 0000000..39b6c96
--- /dev/null
+++ b/src/fw-logs/fw-logs-xml-helper.h
@@ -0,0 +1,48 @@
+/* License: Apache 2.0. See LICENSE file in root directory. */
+/* Copyright(c) 2019 Intel Corporation. All Rights Reserved. */
+#pragma once
+#include "../../third-party/rapidxml/rapidxml_utils.hpp"
+#include "fw-logs-formating-options.h"
+
+using namespace rapidxml;
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        class fw_logs_xml_helper
+        {
+        public:
+            enum node_type
+            {
+                event,
+                file,
+                thread,
+                enums,
+                none
+            };
+
+            fw_logs_xml_helper(std::string xml_content);
+            ~fw_logs_xml_helper(void);
+
+            bool build_log_meta_data(fw_logs_formating_options* logs_formating_options);
+
+        private:
+            bool init();
+            bool build_meta_data_structure(xml_node<>* xml_node_list_of_events, fw_logs_formating_options* logs_formating_options);
+            node_type get_next_node(xml_node<>* xml_node_list_of_events, int* id, int* num_of_params, std::string* line);
+            bool get_thread_node(xml_node<>* node_file, int* thread_id, std::string* thread_name);
+            bool get_event_node(xml_node<>* node_event, int* event_id, int* num_of_params, std::string* line);
+            bool get_enum_name_node(xml_node<>* node_file, int* thread_id, std::string* thread_name);
+            bool get_enum_value_node(xml_node<>* node_file, int* thread_id, std::string* enum_name);
+            bool get_file_node(xml_node<>* node_file, int* file_id, std::string* file_name);
+            bool get_root_node(xml_node<>** node);
+            bool try_load_external_xml();
+
+            bool _init_done;
+            std::string _xml_content;
+            xml_document<> _xml_doc;
+            std::vector<char> _document_buffer;
+        };
+    }
+}
diff --git a/src/fw-logs/fw-string-formatter.cpp b/src/fw-logs/fw-string-formatter.cpp
new file mode 100644
index 0000000..722a25d
--- /dev/null
+++ b/src/fw-logs/fw-string-formatter.cpp
@@ -0,0 +1,138 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2019 Intel Corporation. All Rights Reserved.
+#include "fw-string-formatter.h"
+#include "fw-logs-formating-options.h"
+#include <regex>
+#include <sstream>
+#include <iomanip>
+#include <iostream>
+
+using namespace std;
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        fw_string_formatter::fw_string_formatter(std::unordered_map<std::string, std::vector<kvp>> enums)
+            :_enums(enums)
+        {
+        }
+
+
+        fw_string_formatter::~fw_string_formatter(void)
+        {
+        }
+
+        bool fw_string_formatter::generate_message(const string& source, size_t num_of_params, const uint32_t* params, string* dest)
+        {
+            map<string, string> exp_replace_map;
+            map<string, int> enum_replace_map;
+
+            if (params == nullptr && num_of_params > 0) return false;
+
+            for (size_t i = 0; i < num_of_params; i++)
+            {
+                string regular_exp[4];
+                string replacement[4];
+                stringstream st_regular_exp[4];
+                stringstream st_replacement[4];
+
+                st_regular_exp[0] << "\\{\\b(" << i << ")\\}";
+                regular_exp[0] = st_regular_exp[0].str();
+
+                st_replacement[0] << params[i];
+                replacement[0] = st_replacement[0].str();
+
+                exp_replace_map[regular_exp[0]] = replacement[0];
+
+
+                st_regular_exp[1] << "\\{\\b(" << i << "):x\\}";
+                regular_exp[1] = st_regular_exp[1].str();
+
+                st_replacement[1] << hex << setw(2) << setfill('0') << params[i];
+                replacement[1] = st_replacement[1].str();
+
+                exp_replace_map[regular_exp[1]] = replacement[1];
+
+                st_regular_exp[2] << "\\{\\b(" << i << "):f\\}";
+                regular_exp[2] = st_regular_exp[2].str();
+                st_replacement[2] << params[i];
+                replacement[2] = st_replacement[2].str();
+                exp_replace_map[regular_exp[2]] = replacement[2];
+
+
+                st_regular_exp[3] << "\\{\\b(" << i << "),[a-zA-Z]+\\}";
+                regular_exp[3] = st_regular_exp[3].str();
+
+                enum_replace_map[regular_exp[3]] = params[i];
+            }
+
+            return replace_params(source, exp_replace_map, enum_replace_map, dest);
+        }
+
+        bool fw_string_formatter::replace_params(const string& source, const map<string, string>& exp_replace_map, const map<string, int>& enum_replace_map, string* dest)
+        {
+            string source_temp(source);
+
+            for (auto exp_replace_it = exp_replace_map.begin(); exp_replace_it != exp_replace_map.end(); exp_replace_it++)
+            {
+                string destTemp;
+                regex e(exp_replace_it->first);
+                auto res = regex_replace(back_inserter(destTemp), source_temp.begin(), source_temp.end(), e, exp_replace_it->second);
+                source_temp = destTemp;
+            }
+
+            for (auto exp_replace_it = enum_replace_map.begin(); exp_replace_it != enum_replace_map.end(); exp_replace_it++)
+            {
+                string destTemp;
+                regex e(exp_replace_it->first);
+                std::smatch m;
+                std::regex_search(source_temp, m, std::regex(e));
+
+                string enum_name;
+
+                string st_regular_exp = "[a-zA-Z]+";
+                regex e1(st_regular_exp);
+
+                for (size_t exp = 0; exp < m.size(); exp++)
+                {
+                    string str = m[exp];
+
+                    std::smatch m1;
+
+                    regex e2 = e1;
+                    std::regex_search(str, m1, std::regex(e2));
+
+                    for (size_t exp = 0; exp < m1.size(); exp++)
+                    {
+                        enum_name = m1[exp];
+                        if (_enums.size() > 0 && _enums.find(enum_name) != _enums.end())
+                        {
+                            auto vec = _enums[enum_name];
+                            regex e3 = e;
+                            // Verify user's input is within the enumerated range
+                            int val = exp_replace_it->second;
+                            auto it = std::find_if(vec.begin(), vec.end(), [val](kvp& entry) { return entry.first == val; });
+                            if (it != vec.end())
+                            {
+                                regex_replace(back_inserter(destTemp), source_temp.begin(), source_temp.end(), e3, it->second);
+                            }
+                            else
+                            {
+                                stringstream s;
+                                s << "Protocol Error recognized!\nImproper log message received: " << source_temp
+                                    << ", invalid parameter: " << exp_replace_it->second << ".\n The range of supported values is \n";
+                                for_each(vec.begin(), vec.end(), [&s](kvp& entry) { s << entry.first << ":" << entry.second << " ,"; });
+                                std::cout << s.str().c_str() << std::endl;;
+                            }
+                            source_temp = destTemp;
+                        }
+                    }
+                }
+            }
+
+            *dest = source_temp;
+            return true;
+        }
+    }
+}
diff --git a/src/fw-logs/fw-string-formatter.h b/src/fw-logs/fw-string-formatter.h
new file mode 100644
index 0000000..7759e5b
--- /dev/null
+++ b/src/fw-logs/fw-string-formatter.h
@@ -0,0 +1,28 @@
+/* License: Apache 2.0. See LICENSE file in root directory. */
+/* Copyright(c) 2019 Intel Corporation. All Rights Reserved. */
+#pragma once
+#include <string>
+#include <map>
+#include <stdint.h>
+#include <vector>
+#include <unordered_map>
+
+namespace librealsense
+{
+    namespace fw_logs
+    {
+        class fw_string_formatter
+        {
+        public:
+            fw_string_formatter(std::unordered_map<std::string, std::vector<std::pair<int, std::string>>> enums);
+            ~fw_string_formatter(void);
+
+            bool generate_message(const std::string& source, size_t num_of_params, const uint32_t* params, std::string* dest);
+
+        private:
+            bool replace_params(const std::string& source, const std::map<std::string, std::string>& exp_replace_map, const std::map<std::string, int>& enum_replace_map, std::string* dest);
+
+            std::unordered_map<std::string, std::vector<std::pair<int, std::string>>> _enums;
+        };
+    }
+}
diff --git a/src/gl/align-gl.cpp b/src/gl/align-gl.cpp
index c6c3287..32aed31 100644
--- a/src/gl/align-gl.cpp
+++ b/src/gl/align-gl.cpp
@@ -9,7 +9,9 @@
 #include "align-gl.h"
 #include "option.h"
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif // NOMINMAX
 
 #include <glad/glad.h>
 
@@ -96,10 +98,10 @@ void build_opengl_projection_for_intrinsics(matrix4& frustum,
     
     // These parameters define the final viewport that is rendered into by
     // the camera.
-    double L = 0;
-    double R = img_width;
-    double B = 0;
-    double T = img_height;
+    int L = 0;
+    int R = img_width;
+    int B = 0;
+    int T = img_height;
     
     // near and far clipping planes, these only matter for the mapping from
     // world-space z-coordinate into the depth coordinate for OpenGL
@@ -117,21 +119,21 @@ void build_opengl_projection_for_intrinsics(matrix4& frustum,
     // [-1, 1].  OpenGL then maps coordinates in NDC to the current
     // viewport
     matrix4 ortho;
-    ortho(0,0) =  2.0/(R-L); ortho(0,3) = -(R+L)/(R-L);
-    ortho(1,1) =  2.0/(T-B); ortho(1,3) = -(T+B)/(T-B);
-    ortho(2,2) = -2.0/(F-N); ortho(2,3) = -(F+N)/(F-N);
-    ortho(3,3) =  1.0;
-    
+    ortho(0,0) =  2.f/(R-L);        ortho(0,3) = float(-(R+L)/(R-L));
+    ortho(1,1) =  2.f/(T-B);        ortho(1,3) = float(-(T+B)/(T-B));
+    ortho(2,2) = -2.f/float(F-N);   ortho(2,3) = float(-(F+N)/(F-N));
+    ortho(3,3) =  1.f;
+
     // construct a projection matrix, this is identical to the 
     // projection matrix computed for the intrinsicx, except an
     // additional row is inserted to map the z-coordinate to
-    // OpenGL. 
+    // OpenGL.
     matrix4 tproj;
-    tproj(0,0) = alpha; tproj(0,1) = skew; tproj(0,2) = u0;
-                        tproj(1,1) = beta; tproj(1,2) = v0;
-                                           tproj(2,2) = -(N+F); tproj(2,3) = -N*F;
-                                           tproj(3,2) = 1.0;
-    
+    tproj(0,0) = float(alpha);  tproj(0,1) = float(skew);  tproj(0,2) = 0.f;
+    tproj(1,1) = float(beta);   tproj(1,2) = float(v0);
+    tproj(2,2) = float(-(N+F)); tproj(2,3) = float(-N*F);
+    tproj(3,2) = 1.f;
+
     // resulting OpenGL frustum is the product of the orthographic
     // mapping to normalized device coordinates and the augmented
     // camera intrinsic matrix
diff --git a/src/gl/colorizer-gl.cpp b/src/gl/colorizer-gl.cpp
index 4f571c9..cc5892c 100644
--- a/src/gl/colorizer-gl.cpp
+++ b/src/gl/colorizer-gl.cpp
@@ -11,7 +11,9 @@
 #include "colorizer-gl.h"
 #include "option.h"
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif // NOMINMAX
 
 #include <glad/glad.h>
 
@@ -181,7 +183,7 @@ namespace librealsense
 
         void colorizer::populate_floating_histogram(float* f, int* hist)
         {
-            float total = hist[MAX_DEPTH-1];
+            float total = float(hist[MAX_DEPTH-1]);
             for (int i = 0; i < MAX_DEPTH; i++)
                 f[i] = hist[i] / total;
         }
diff --git a/src/gl/pc-shader.cpp b/src/gl/pc-shader.cpp
index 9c7223d..51d4121 100644
--- a/src/gl/pc-shader.cpp
+++ b/src/gl/pc-shader.cpp
@@ -451,8 +451,6 @@ namespace librealsense
                     }
                     _durations.push_back(now);
 
-                    const auto fps = _durations.size();
-
                     //scoped_timer t("pointcloud_renderer.gl");
 
                     GLint curr_tex;
@@ -552,9 +550,9 @@ namespace librealsense
                                 ox = (xy.x / wh.x) * 2 - 1;
                                 oy = (xy.y / wh.y) * 2 - 1;
 
-                                auto p = frustum(left/(0.5*wh.x), right/(0.5*wh.x), 
-                                    bottom/(0.5*wh.y), top/(0.5*wh.y), near_plane, far_plae, 
-                                    ox * (0.5*wh.x), oy * (0.5*wh.y));
+                                auto p = frustum(left/(0.5f*wh.x), right/(0.5f*wh.x),
+                                    bottom / (0.5f * wh.y), top / (0.5f * wh.y), near_plane, far_plae,
+                                    ox * (0.5f * wh.x), oy * (0.5f * wh.y));
 
                                 auto fbo_width = 3;
                                 auto fbo_height = 3;
@@ -621,7 +619,6 @@ namespace librealsense
                                     if (rgba.a > 0)
                                     {
                                         std::vector<rs2::float3> pos_floats(size);
-                                        rs2::float2 w_pos;
                                         for (int i = 0; i < size; i++)
                                         {
                                             auto pos = pos_halfs[i];
@@ -764,4 +761,4 @@ namespace librealsense
             return f;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/gl/synthetic-stream-gl.cpp b/src/gl/synthetic-stream-gl.cpp
index 3b4e9dc..e6442f3 100644
--- a/src/gl/synthetic-stream-gl.cpp
+++ b/src/gl/synthetic-stream-gl.cpp
@@ -8,7 +8,9 @@
 
 #include <GLFW/glfw3.h>
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif // NOMINMAX
 
 #include <glad/glad.h>
 
diff --git a/src/gl/upload.cpp b/src/gl/upload.cpp
index c8dcdf5..f2b1f16 100644
--- a/src/gl/upload.cpp
+++ b/src/gl/upload.cpp
@@ -12,7 +12,9 @@
 #include "option.h"
 #include "context.h"
 
+#ifndef NOMINMAX
 #define NOMINMAX
+#endif // NOMINMAX
 
 #include <glad/glad.h>
 
diff --git a/src/hw-monitor.cpp b/src/hw-monitor.cpp
index 381446f..22a6dc0 100644
--- a/src/hw-monitor.cpp
+++ b/src/hw-monitor.cpp
@@ -117,7 +117,7 @@ namespace librealsense
         return _locked_transfer->send_receive(data);
     }
 
-    std::vector<uint8_t> hw_monitor::send(command cmd) const
+    std::vector<uint8_t> hw_monitor::send( command cmd, hwmon_response * p_response ) const
     {
         hwmon_cmd newCommand(cmd);
         auto opCodeXmit = static_cast<uint32_t>(newCommand.cmd);
@@ -139,7 +139,9 @@ namespace librealsense
         send_hw_monitor_command(details);
 
         // Error/exit conditions
-        if (newCommand.oneDirection)
+        if( p_response )
+            *p_response = hwm_Success;
+        if( newCommand.oneDirection )
             return std::vector<uint8_t>();
 
         librealsense::copy(newCommand.receivedOpcode, details.receivedOpcode.data(), 4);
@@ -152,14 +154,34 @@ namespace librealsense
         if (opCodeAsUint32 != opCodeXmit)
         {
             auto err_type = static_cast<hwmon_response>(opCodeAsUint32);
-            throw invalid_value_exception(to_string() << "hwmon command 0x" << std::hex << opCodeXmit << " failed.\nError type: "
-                << hwmon_error2str(err_type) << " (" << std::dec <<(int)err_type  << ").");
+            std::string err = hwmon_error_string( cmd, err_type );
+            LOG_DEBUG( err );
+            if( p_response )
+            {
+                *p_response = err_type;
+                return std::vector<uint8_t>();
+            }
+            throw invalid_value_exception( err );
         }
 
         return std::vector<uint8_t>(newCommand.receivedCommandData,
             newCommand.receivedCommandData + newCommand.receivedCommandDataLength);
     }
 
+    std::string hwmon_error_string( command const & cmd, hwmon_response e )
+    {
+        auto str = hwmon_error2str( e );
+        to_string err;
+        err << "hwmon command 0x" << std::hex << unsigned(cmd.cmd) << '(';
+        err << ' ' << cmd.param1;
+        err << ' ' << cmd.param2;
+        err << ' ' << cmd.param3;
+        err << ' ' << cmd.param4 << std::dec;
+        err << " ) failed (response " << e << "= " << ( str.empty() ? "unknown" : str ) << ")";
+        return err;
+    }
+
+
     void hw_monitor::get_gvd(size_t sz, unsigned char* gvd, uint8_t gvd_cmd) const
     {
         command command(gvd_cmd);
diff --git a/src/hw-monitor.h b/src/hw-monitor.h
index b3af270..e5e8f46 100644
--- a/src/hw-monitor.h
+++ b/src/hw-monitor.h
@@ -252,6 +252,8 @@ namespace librealsense
         }
     };
 
+    std::string hwmon_error_string( command const &, hwmon_response e );
+
     class hw_monitor
     {
         struct hwmon_cmd
@@ -320,7 +322,7 @@ namespace librealsense
         {}
 
         std::vector<uint8_t> send(std::vector<uint8_t> data) const;
-        std::vector<uint8_t> send(command cmd) const;
+        std::vector<uint8_t> send( command cmd, hwmon_response * = nullptr ) const;
         void get_gvd(size_t sz, unsigned char* gvd, uint8_t gvd_cmd) const;
         static std::string get_firmware_version_string(const std::vector<uint8_t>& buff, size_t index, size_t length = 4);
         static std::string get_module_serial_string(const std::vector<uint8_t>& buff, size_t index, size_t length = 6);
diff --git a/src/ivcam/sr300.cpp b/src/ivcam/sr300.cpp
index 8329308..ebbb564 100644
--- a/src/ivcam/sr300.cpp
+++ b/src/ivcam/sr300.cpp
@@ -381,7 +381,7 @@ namespace librealsense
         return flash;
     }
 
-    void sr300_camera::update_flash(const std::vector<uint8_t>& image, update_progress_callback_ptr callback, int update_mode)
+    void sr300_camera::update_flash(const std::vector<uint8_t>&, update_progress_callback_ptr, int)
     {
         throw std::runtime_error("update_flash is not supported by SR300");
     }
@@ -422,6 +422,7 @@ namespace librealsense
         const platform::backend_device_group& group,
         bool register_device_notifications)
         : device(ctx, group, register_device_notifications),
+        firmware_logger_device(ctx, group, nullptr, get_firmware_logs_command(), get_flash_logs_command()),
         _depth_device_idx(add_sensor(create_depth_device(ctx, depth))),
         _depth_stream(new stream(RS2_STREAM_DEPTH)),
         _ir_stream(new stream(RS2_STREAM_INFRARED)),
@@ -432,6 +433,8 @@ namespace librealsense
         using namespace ivcam;
         static auto device_name = "Intel RealSense SR300";
 
+        // Temporal solution for HW Monitor injection - to be refactored
+        this->assign_hw_monitor(_hw_monitor);
         std::vector<uint8_t> gvd_buff(HW_MONITOR_BUFFER_SIZE);
         _hw_monitor->get_gvd(gvd_buff.size(), gvd_buff.data(), GVD);
         // fooling tests recordings - don't remove
@@ -492,7 +495,8 @@ namespace librealsense
         const platform::usb_device_info &hwm_device,
         const platform::backend_device_group& group,
         bool register_device_notifications)
-        : sr300_camera(ctx, color, depth, hwm_device, group, register_device_notifications) {
+        : sr300_camera(ctx, color, depth, hwm_device, group, register_device_notifications), 
+        device(ctx, group, register_device_notifications) {
 
         static auto device_name = "Intel RealSense SR305";
         update_info(RS2_CAMERA_INFO_NAME, device_name);
@@ -505,6 +509,16 @@ namespace librealsense
     }
 
 
+    command sr300_camera::get_firmware_logs_command() const
+    {
+        return command{ ivcam::GLD, 0x1f4 };
+    }
+
+    command sr300_camera::get_flash_logs_command() const
+    {
+        return command{ ivcam::FlashRead, 0x000B6000, 0x3f8 };
+    }
+
     void sr300_camera::create_snapshot(std::shared_ptr<debug_interface>& snapshot) const
     {
         //TODO: implement
diff --git a/src/ivcam/sr300.h b/src/ivcam/sr300.h
index 18acb24..8454baa 100644
--- a/src/ivcam/sr300.h
+++ b/src/ivcam/sr300.h
@@ -21,6 +21,7 @@
 #include "stream.h"
 #include "fw-update/fw-update-device-interface.h"
 #include "proc/color-formats-converter.h"
+#include "firmware_logger_device.h"
 
 namespace librealsense
 {
@@ -185,7 +186,10 @@ namespace librealsense
         platform::usb_device_info _hwm;
     };
 
-    class sr300_camera : public  device, public debug_interface, public updatable
+    class sr300_camera : public virtual device,
+        public debug_interface,
+        public updatable,
+        public firmware_logger_device
     {
     public:
         std::vector<tagged_profile> get_profiles_tags() const override
@@ -386,7 +390,7 @@ namespace librealsense
             force_hardware_reset();
         }
 
-        synthetic_sensor& get_depth_sensor() { return dynamic_cast<synthetic_sensor&>(get_sensor(_depth_device_idx)); }
+        synthetic_sensor& get_depth_sensor() { return dynamic_cast<synthetic_sensor&>(device::get_sensor(_depth_device_idx)); }
 
         uvc_sensor& get_raw_depth_sensor()
         {
@@ -530,6 +534,11 @@ namespace librealsense
         lazy<ivcam::camera_calib_params> _camer_calib_params;
 
     protected:
+
+        //TODO - add these to device class as pure virtual methods
+        command get_firmware_logs_command() const;
+        command get_flash_logs_command() const;
+
         const uint8_t _color_device_idx;
         std::shared_ptr<hw_monitor> _hw_monitor;
     };
diff --git a/src/l500/CMakeLists.txt b/src/l500/CMakeLists.txt
index 645e08f..47c376c 100644
--- a/src/l500/CMakeLists.txt
+++ b/src/l500/CMakeLists.txt
@@ -11,6 +11,7 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/l500-fw-update-device.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/l500-serializable.cpp"
         "${CMAKE_CURRENT_LIST_DIR}/l500-options.cpp"
+
         "${CMAKE_CURRENT_LIST_DIR}/l500-depth.h"
         "${CMAKE_CURRENT_LIST_DIR}/l500-private.h"
         "${CMAKE_CURRENT_LIST_DIR}/l500-color.h"
@@ -20,6 +21,9 @@ target_sources(${LRS_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/l500-fw-update-device.h"
         "${CMAKE_CURRENT_LIST_DIR}/l500-serializable.h"
         "${CMAKE_CURRENT_LIST_DIR}/l500-options.h"
+
+        "${CMAKE_CURRENT_LIST_DIR}/ac-trigger.h"
+        "${CMAKE_CURRENT_LIST_DIR}/ac-trigger.cpp"
 )
 
 if (ENABLE_L500_DEPTH_INVALIDATION)
diff --git a/src/l500/ac-trigger.cpp b/src/l500/ac-trigger.cpp
new file mode 100644
index 0000000..ddb9632
--- /dev/null
+++ b/src/l500/ac-trigger.cpp
@@ -0,0 +1,968 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2018 Intel Corporation. All Rights Reserved.
+
+#include "ac-trigger.h"
+#include "depth-to-rgb-calibration.h"
+#include "l500-device.h"
+#include "l500-color.h"
+#include "l500-depth.h"
+#include "algo/depth-to-rgb-calibration/debug.h"
+#include "log.h"
+
+
+template < class X > struct string_to {};
+
+template<>
+struct string_to< std::string >
+{
+    static std::string convert( std::string const & s )
+    {
+        return s;
+    }
+};
+
+template<>
+struct string_to< int >
+{
+    static int convert( std::string const & s )
+    {
+        char * p_end;
+        auto v = std::strtol( s.data(), &p_end, 10 );
+        if( errno == ERANGE )
+            throw std::out_of_range( "out of range" );
+        if( p_end != s.data() + s.length() )
+            throw std::invalid_argument( "extra characters" );
+        return v;
+    }
+};
+
+template<>
+struct string_to< bool >
+{
+    static bool convert( std::string const & s )
+    {
+        if( s.length() == 1 )
+        {
+            char ch = s.front();
+            if( ch == '1' || ch == 'T' )
+                return true;
+            if( ch == '0' || ch == 'F' )
+                return false;
+        }
+        else
+        {
+            if( s == "true" || s == "TRUE" || s == "on" || s == "ON" )
+                return true;
+            if( s == "false" || s == "FALSE" || s == "off" || s == "OFF" )
+                return false;
+        }
+        throw std::invalid_argument( "invalid boolean value '" + s + '\'' );
+    }
+};
+
+
+template< class T >
+class env_var
+{
+    bool _is_set;
+    T _value;
+
+public:
+    env_var( char const * name, T default_value, std::function< bool( T ) > checker = nullptr )
+    {
+        auto lpsz = getenv( name );
+        _is_set = (lpsz != nullptr);
+        if( _is_set )
+        {
+            try
+            {
+                _value = string_to< T >::convert( lpsz );
+                if( checker && ! checker( _value ) )
+                    throw std::invalid_argument( "does not check" );
+            }
+            catch( std::exception const & e )
+            {
+                AC_LOG( ERROR,
+                        "Environment variable \"" << name << "\" is set, but its value (\""
+                                                    << lpsz << "\") is invalid (" << e.what()
+                                                    << "); using default of \"" << default_value
+                                                    << "\"" );
+                _is_set = false;
+            }
+        }
+        if( !_is_set )
+            _value = default_value;
+    }
+
+    bool is_set() const { return _is_set; }
+    T value() const { return _value; }
+
+    operator T() const { return _value; }
+};
+
+
+static int get_retry_sf_seconds()
+{
+    static int n_seconds
+        = env_var< int >( "RS2_AC_SF_RETRY_SECONDS", 2, []( int n ) { return n > 0; } );
+    return n_seconds;
+}
+static double get_temp_diff_trigger()
+{
+    static double d_temp
+        = env_var< int >( "RS2_AC_TEMP_DIFF", 0, []( int n ) { return n >= 0; } ).value();
+    return d_temp;
+}
+static std::chrono::seconds get_trigger_seconds()
+{
+    auto n_seconds = env_var< int >( "RS2_AC_TRIGGER_SECONDS",
+        0,  // off by default (600 = 10 minutes since last is the normal default)
+        []( int n ) { return n >= 0; } );
+    // 0 means turn off auto-trigger
+    return std::chrono::seconds( n_seconds );
+}
+
+
+namespace rs2
+{
+    static std::ostream & operator<<( std::ostream & os, stream_profile const & sp )
+    {
+        auto spi = sp.get()->profile;
+        os << '[';
+        if( spi )
+        {
+            os << rs2_format_to_string( spi->get_format() );
+            if( auto vsp = dynamic_cast< const librealsense::video_stream_profile * >( spi ) )
+                os << ' ' << vsp->get_width() << 'x' << vsp->get_height();
+            os << " " << spi->get_framerate() << "fps";
+        }
+        os << ']';
+        return os;
+    }
+}
+
+
+namespace librealsense {
+namespace ivcam2 {
+
+
+    static bool is_auto_trigger_default()
+    {
+        if( get_trigger_seconds().count() )
+            return true;
+        if( get_temp_diff_trigger() )
+            return true;
+        return false;
+    }
+
+    ac_trigger::enabler_option::enabler_option( std::shared_ptr< ac_trigger > const & autocal )
+        : bool_option( is_auto_trigger_default() )
+        , _autocal( autocal )
+    {
+    }
+
+    ac_trigger::reset_option::reset_option( std::shared_ptr< ac_trigger > const & autocal )
+        : bool_option( false )
+        , _autocal( autocal )
+    {
+    }
+
+    void ac_trigger::enabler_option::set( float value )
+    {
+        //bool_option::set( value );
+        if( is_auto_trigger_default() )
+        {
+            // When auto trigger is on in the environment, we control the timed activation
+            // of AC, and do NOT trigger manual calibration
+            bool_option::set( value );
+            if( is_true() )
+            {
+                if( _autocal->_dev.get_depth_sensor().is_streaming() )
+                    _autocal->start();
+                // else start() will get called on stream start
+            }
+            else
+            {
+                _autocal->stop();
+            }
+        }
+        else
+        {
+            // Without the auto-trigger, turning us on never actually toggles us so we stay
+            // "off" and just trigger a new calibration
+            auto & depth_sensor = _autocal->_dev.get_depth_sensor();
+            if( depth_sensor.is_streaming() )
+            {
+                AC_LOG( DEBUG, "Triggering manual calibration..." );
+                _autocal->trigger_calibration();
+            }
+            else
+            {
+                AC_LOG( ERROR, "Cannot trigger calibration: depth sensor is not on!" );
+            }
+        }
+        _record_action( *this );
+    }
+
+    void ac_trigger::reset_option::set( float value )
+    {
+        //bool_option::set( value );
+
+        // Reset the calibration so we can do it all over again
+        if (auto color_sensor = _autocal->_dev.get_color_sensor())
+            color_sensor->reset_calibration();
+        _autocal->_dev.get_depth_sensor().reset_calibration();
+        _autocal->_dev.notify_of_calibration_change( RS2_CALIBRATION_SUCCESSFUL );
+        _record_action( *this );
+    }
+
+
+    // Implementation class: starts another thread responsible for sending a retry
+    // NOTE that it does this as long as our shared_ptr keeps us alive: once it's gone, if the
+    // retry period elapses then nothing will happen!
+    class ac_trigger::retrier
+    {
+        ac_trigger & _ac;
+        unsigned _id;
+        char const * const _name;
+
+    protected:
+        retrier( ac_trigger & ac, char const * name )
+            : _ac( ac )
+            , _name( name ? name : "retrier" )
+        {
+            static unsigned id = 0;
+            _id = ++id;
+        }
+
+        unsigned get_id() const { return _id; }
+        ac_trigger & get_ac() const { return _ac; }
+        char const * get_name() const { return _name; }
+
+        virtual void retry()
+        {
+            AC_LOG( DEBUG, "triggering " << _name << ' ' << get_id() );
+            _ac.trigger_calibration( true );
+        }
+
+    public:
+        virtual ~retrier()
+        {
+            AC_LOG( DEBUG, "~" << get_name() << " " << get_id() );
+        }
+
+        template < class T = retrier >
+        static std::shared_ptr< T > start( ac_trigger & trigger,
+                                           std::chrono::seconds n_seconds,
+                                           const char * name = nullptr )
+        {
+            T * r = new T( trigger, name );
+            auto id = r->get_id();
+            name = r->get_name();
+            AC_LOG( DEBUG, name << ' ' << id << ": " << n_seconds.count() << " seconds starting" );
+            auto pr = std::shared_ptr< T >( r );
+            std::weak_ptr< T > weak{ pr };
+            std::thread([=]() {
+                std::this_thread::sleep_for(n_seconds);
+                auto pr = weak.lock();
+                if (pr && pr->get_id() == id)
+                {
+                    ((retrier *)pr.get())->retry();
+                }
+                else
+                    AC_LOG( DEBUG,
+                            name << ' ' << id << ": " << n_seconds.count()
+                                 << " seconds are up; nothing needed" );
+            } ).detach();
+            return pr;
+        };
+    };
+    class ac_trigger::temp_check : public ac_trigger::retrier
+    {
+    public:
+        temp_check( ac_trigger & ac, const char * name )
+            : retrier( ac, name ? name : "temp check" )
+        {
+        }
+
+    private:
+        void retry() override
+        {
+            auto & trigger = get_ac();
+            if( trigger.is_active() )
+            {
+                AC_LOG( DEBUG, "temp check " << get_id() << ": AC already active" );
+                return;
+            }
+            auto current_temp = trigger.read_temperature();
+            auto d_temp = current_temp - trigger._last_temp;
+            if( d_temp >= get_temp_diff_trigger() )
+            {
+                AC_LOG( DEBUG, "Delta since last calibration is " << d_temp << " degrees Celsius; triggering..." );
+                trigger.trigger_calibration();
+            }
+            else
+            {
+                // We do not update the trigger temperature: that is only updated after calibration
+                AC_LOG( DEBUG, "Delta since last calibration is " << d_temp << " degrees Celsius" );
+                trigger._temp_check = retrier::start< temp_check >( trigger, std::chrono::seconds( 60 ) );
+            }
+        }
+    };
+
+
+    /*
+        Temporary (?) class used to direct AC logs to either console or a special log
+
+        If RS2_DEBUG_DIR is defined in the environment, we try to create a log file in there
+        that has the name "<pid>.ac_log".
+    */
+    class ac_logger : public rs2_log_callback
+    {
+        std::ofstream _f;
+        bool _to_stdout;
+
+    public:
+        explicit ac_logger( bool to_stdout = false )
+            : _to_stdout( to_stdout )
+        {
+            using namespace std::chrono;
+            auto dir = getenv( "RS2_DEBUG_DIR" );
+            if( dir )
+            {
+                std::string filename = to_string()
+                    << dir
+                    << system_clock::now().time_since_epoch().count() * system_clock::period::num / system_clock::period::den
+                    << ".ac_log";
+
+                _f.open( filename );
+                if( _f  &&  _to_stdout )
+                    std::cout << "-D- AC log is being written to: " << filename << std::endl;
+            }
+
+            librealsense::log_to_callback( RS2_LOG_SEVERITY_ALL,
+                { this, []( rs2_log_callback * p ) {} } );
+            AC_LOG( DEBUG, "LRS version: " << RS2_API_FULL_VERSION_STR );
+        }
+
+        void on_log( rs2_log_severity severity, rs2_log_message const & msg ) noexcept override
+        {
+            log_message const & wrapper = (log_message const &)(msg);
+            char const * raw = wrapper.el_msg.message().c_str();
+            if( strncmp( AC_LOG_PREFIX, raw, AC_LOG_PREFIX_LEN ) )
+                return;
+            std::ostringstream ss;
+            ss << "-" << "DIWE"[severity] << "- ";
+            ss << (raw + 5);
+            std::string text = ss.str();
+            if( _to_stdout )
+                std::cout << text << std::endl;
+            if( _f )
+                _f << text << std::endl;
+        }
+
+        void release() override { delete this; }
+    };
+
+
+    ac_trigger::ac_trigger( l500_device & dev, hw_monitor & hwm )
+        : _hwm( hwm )
+        , _dev( dev )
+    {
+        static ac_logger one_logger(
+            env_var< bool >( "RS2_AC_LOG_TO_STDOUT", false )  // log to stdout
+            );
+    }
+
+
+    ac_trigger::~ac_trigger() 
+    { 
+        if( _worker.joinable() )
+        {
+            _is_processing = false;  // Signal the thread that we want to stop!
+            _worker.join();
+        }
+    }
+
+
+    void ac_trigger::trigger_calibration( bool is_retry )
+    {
+        if (false == _dev.get_depth_sensor().is_streaming())
+        {
+            AC_LOG(ERROR, "Depth streaming not found, canceling calibration");
+            stop();
+            return;
+        }
+
+        _retrier.reset();
+        if(is_retry  &&  is_active() )
+        {
+            if( _recycler )
+            {
+                // This is another cycle of AC, after we've woken up from some time after
+                // the previous invalid-scene or bad-result...
+                _n_retries = 0;
+                _recycler.reset();
+            }
+            else if( ++_n_retries > 4 )
+            {
+                AC_LOG( ERROR, "too many retries; aborting" );
+                stop_color_sensor_if_started();
+                call_back( RS2_CALIBRATION_FAILED );
+                calibration_is_done();
+                return;
+            }
+
+            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle " << _n_cycles << " retry " << _n_retries << ")" );
+            call_back( RS2_CALIBRATION_RETRY );
+        }
+        else
+        {
+            if( is_active() )
+            {
+                AC_LOG( ERROR, "Failed to trigger calibration: AC is already active" );
+                return;
+            }
+            _n_retries = 0;
+            _n_cycles = 1;          // now active
+            AC_LOG( INFO, "Camera Accuracy Health check has started in the background" );
+            _next_trigger.reset();  // don't need a trigger any more
+            _temp_check.reset();    // nor a temperature check
+            _recycler.reset();      // just in case
+            start_color_sensor_if_needed();
+            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle 1); now active..." );
+        }
+        command cmd{ GET_SPECIAL_FRAME, 0x5F, 1 };  // 5F = SF = Special Frame, for easy recognition
+        try
+        {
+            _hwm.send( cmd );
+        }
+        catch( std::exception const & e )
+        {
+            AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+        }
+        // Start a timer: enable retries if something's wrong with the special frame
+        if (is_active())
+        {
+            _retrier = retrier::start(*this, std::chrono::seconds(get_retry_sf_seconds()));
+        }
+    }
+
+
+    template<class T>
+    frame_callback_ptr make_frame_callback( T callback )
+    {
+        return {
+            new internal_frame_callback<T>( callback ),
+            []( rs2_frame_callback* p ) { p->release(); }
+        };
+    }
+
+
+    void ac_trigger::start_color_sensor_if_needed()
+    {
+        // With AC, we need a color sensor even when the user has not asked for one --
+        // otherwise we risk misalignment over time. We turn it on automatically!
+
+        auto color_sensor = _dev.get_color_sensor();
+        if( !color_sensor )
+        {
+            AC_LOG( ERROR, "No color sensor in device; cannot run AC?!" );
+            return;
+        }
+
+        if( color_sensor->is_streaming() )
+        {
+            AC_LOG( DEBUG, "Color sensor is already streaming" );
+            return;
+        }
+
+        AC_LOG( INFO, "Color sensor was NOT streaming; turning on..." );
+
+        try
+        {
+            auto & depth_sensor = _dev.get_depth_sensor();
+            auto rgb_profile = depth_sensor.is_color_sensor_needed();
+            if( !rgb_profile )
+                return;  // error should have already been printed
+            //AC_LOG( DEBUG, "Picked profile: " << *rgb_profile );
+
+            AC_LOG( DEBUG, "Open..." );
+            color_sensor->open( { rgb_profile } );
+            AC_LOG( DEBUG, "Start..." );
+
+            color_sensor->start(make_frame_callback([&](frame_holder fref) {}));
+
+            AC_LOG( DEBUG, "Started!" );
+            // Note that we don't do anything with the frames -- they shouldn't end up
+            // at the user. But AC will still get them.
+
+            _own_color_stream = true;
+        }
+        catch( std::exception const & e )
+        {
+            AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+        }
+    }
+
+
+    void ac_trigger::stop_color_sensor_if_started()
+    {
+        if( !_own_color_stream.exchange( false ) )
+            return;
+
+        AC_LOG( INFO, "STOPPING color sensor..." );
+        auto & color_sensor = *_dev.get_color_sensor();
+        color_sensor.stop();
+        AC_LOG( INFO, "CLOSING color sensor..." );
+        color_sensor.close();
+        AC_LOG( INFO, "Closed!" );
+    }
+
+
+    void ac_trigger::set_special_frame( rs2::frameset const & fs )
+    {
+        if( !is_active() )
+        {
+            AC_LOG( ERROR, "Special frame received while is_active() is false" );
+            return;
+        }
+
+        AC_LOG( DEBUG, "special frame received :)" );
+        // Notify of the special frame -- mostly for validation team so they know to expect a frame
+        // drop...
+        call_back( RS2_CALIBRATION_SPECIAL_FRAME );
+
+        if( _is_processing )
+        {
+            AC_LOG( ERROR, "already processing; ignoring special frame!" );
+            return;
+        }
+        auto irf = fs.get_infrared_frame();
+        if( !irf )
+        {
+            AC_LOG( ERROR, "no IR frame found; ignoring special frame!" );
+            //call_back( RS2_CALIBRATION_FAILED );
+            return;
+        }
+        auto df = fs.get_depth_frame();
+        if( !df )
+        {
+            AC_LOG( ERROR, "no depth frame found; ignoring special frame!" );
+            //call_back( RS2_CALIBRATION_FAILED );
+            return;
+        }
+
+        _retrier.reset();  // No need to activate a retry if the following takes a bit of time!
+
+        // We have to read the FW registers at the time of the special frame.
+        // NOTE: the following is I/O to FW, meaning it takes time! In this time, another
+        // thread can receive a set_color_frame() and, since we've already received the SF,
+        // start working even before we finish! NOT GOOD!
+        ivcam2::read_fw_register( _hwm, &_dsm_x_scale, 0xfffe3844 );
+        ivcam2::read_fw_register( _hwm, &_dsm_y_scale, 0xfffe3830 );
+        ivcam2::read_fw_register( _hwm, &_dsm_x_offset, 0xfffe3840 );
+        ivcam2::read_fw_register( _hwm, &_dsm_y_offset, 0xfffe382c );
+        AC_LOG( DEBUG, "dsm registers=  x[" << AC_F_PREC << _dsm_x_scale << ' ' << _dsm_y_scale
+            << "]  +[" << _dsm_x_offset << ' ' << _dsm_y_offset
+            << "]" );
+
+        _sf = fs;  // Assign right before the sync otherwise we may start() prematurely
+        _sf.keep();
+        std::lock_guard< std::mutex > lock( _mutex );
+        if( check_color_depth_sync() )
+            run_algo();
+        else
+            _retrier = retrier::start( *this, std::chrono::seconds( get_retry_sf_seconds() ) );
+    }
+
+
+    void ac_trigger::set_color_frame( rs2::frame const& f )
+    {
+        if( ! is_active()  ||  _is_processing )
+            // No error message -- we expect to get new color frames while processing...
+            return;
+
+        _pcf = _cf;
+        _cf = f;
+        _cf.keep();
+        std::lock_guard< std::mutex > lock( _mutex );
+        if( check_color_depth_sync() )
+            run_algo();
+    }
+
+
+    bool ac_trigger::check_color_depth_sync()
+    {
+        // Only one thread is allowed to start(), and _is_processing is set within
+        // the mutex!
+        if( _is_processing )
+            return false;
+
+        if( !_sf )
+        {
+            //std::cout << "-D- no special frame yet" << std::endl;
+            return false;
+        }
+        if( !_cf )
+        {
+            AC_LOG( DEBUG, "no color frame received; maybe color stream isn't on?" );
+            return false;
+        }
+        if( ! _pcf )
+        {
+            AC_LOG( DEBUG, "no prev color frame received" );
+            return false;
+        }
+        return true;
+    }
+
+
+    void ac_trigger::run_algo()
+    {
+        AC_LOG( DEBUG,
+                "Starting processing:"
+                    << "  color #" << _cf.get_frame_number() << " " << _cf.get_profile()
+                    << "  depth #" << _sf.get_frame_number() << ' ' << _sf.get_profile() );
+        _is_processing = true;
+        _retrier.reset();
+        stop_color_sensor_if_started();
+        if( _worker.joinable() )
+        {
+            AC_LOG( DEBUG, "Waiting for worker to join ..." );
+            _worker.join();
+        }
+        _worker = std::thread(
+            [&]() {
+                try
+                {
+                    AC_LOG( DEBUG, "Calibration algo has started ..." );
+                    call_back( RS2_CALIBRATION_STARTED );
+
+                    static algo::depth_to_rgb_calibration::algo_calibration_info cal_info;
+                    static bool cal_info_initialized = false;
+                    if( !cal_info_initialized )
+                    {
+                        cal_info_initialized = true;
+                        ivcam2::read_fw_table( _hwm, cal_info.table_id, &cal_info );  // throws!
+                    }
+                    algo::depth_to_rgb_calibration::algo_calibration_registers cal_regs;
+                    cal_regs.EXTLdsmXscale = _dsm_x_scale;
+                    cal_regs.EXTLdsmYscale = _dsm_y_scale;
+                    cal_regs.EXTLdsmXoffset = _dsm_x_offset;
+                    cal_regs.EXTLdsmYoffset = _dsm_y_offset;
+
+                    auto df = _sf.get_depth_frame();
+                    auto irf = _sf.get_infrared_frame();
+                    depth_to_rgb_calibration algo( df, irf, _cf, _pcf, cal_info, cal_regs );
+                    _from_profile = algo.get_from_profile();
+                    _to_profile = algo.get_to_profile();
+
+                    auto status = algo.optimize(
+                        [this]( rs2_calibration_status status ) { call_back( status ); } );
+
+                    // It's possible that, while algo was working, stop() was called. In this case,
+                    // we have to make sure that we notify of failure:
+                    if( !is_active() )
+                    {
+                        AC_LOG( DEBUG, "Algo finished (with " << status << "), but stop() was detected; notifying of failure..." );
+                        status = RS2_CALIBRATION_FAILED;
+                    }
+
+                    switch( status )
+                    {
+                    case RS2_CALIBRATION_SUCCESSFUL:
+                        _extr = algo.get_extrinsics();
+                        _intr = algo.get_intrinsics();
+                        _dsm_params = algo.get_dsm_params();
+                        // Fall-thru!
+                    case RS2_CALIBRATION_NOT_NEEDED:
+                        // This is the same as SUCCESSFUL, except there was no change because the
+                        // existing calibration is good enough. We notify and exit.
+                        call_back( status );
+                        break;
+                    case RS2_CALIBRATION_RETRY:
+                        // We want to trigger a special frame after a certain longer delay
+                        if( ++_n_cycles > 5 )
+                        {
+                            // ... but we've tried too many times
+                            AC_LOG( ERROR, "Too many cycles of calibration; quitting" );
+                            call_back( RS2_CALIBRATION_FAILED );
+                        }
+                        else
+                        {
+                            AC_LOG( DEBUG, "Triggering another cycle for calibration..." );
+                            int n_seconds = env_var< int >( "RS2_AC_INVALID_RETRY_SECONDS",
+                                2,  // TODO: should be 60, but changed for manual trigger
+                                []( int n ) { return n > 0; } );
+                            _recycler = retrier::start( *this, std::chrono::seconds( n_seconds ) );
+                        }
+                        break;
+                    case RS2_CALIBRATION_FAILED:
+                        // Report it and quit: this is a final status
+                        call_back( status );
+                        break;
+                    default:
+                        // All the rest of the codes are not end-states of the algo, so we don't expect
+                        // to get here!
+                        AC_LOG( ERROR,
+                            "Unexpected status '" << status << "' received from AC algo; stopping!" );
+                        call_back( RS2_CALIBRATION_FAILED );
+                        break;
+                    }
+                }
+                catch( std::exception& ex )
+                {
+                    AC_LOG( ERROR, "caught exception in calibration algo: " << ex.what() );
+                    call_back( RS2_CALIBRATION_FAILED );
+                }
+                catch( ... )
+                {
+                    AC_LOG( ERROR, "unknown exception in calibration algo!!!" );
+                    call_back( RS2_CALIBRATION_FAILED );
+                }
+                reset();
+                switch( _last_status_sent )
+                {
+                case RS2_CALIBRATION_FAILED:
+                case RS2_CALIBRATION_SUCCESSFUL:
+                case RS2_CALIBRATION_NOT_NEEDED:
+                    calibration_is_done();
+                    break;
+                }
+            } );
+    }
+
+
+    void ac_trigger::calibration_is_done()
+    {
+        // We get here when we've reached some final state (failed/successful)
+        _n_cycles = 0;  // now inactive
+        if( _last_status_sent != RS2_CALIBRATION_SUCCESSFUL )
+            AC_LOG( WARNING, "Camera Accuracy Health has finished unsuccessfully" );
+        else
+            AC_LOG( INFO, "Camera Accuracy Health has finished" );
+
+        // Trigger the next AC -- but only if we're "on", meaning this wasn't a manual calibration
+        if( !auto_calibration_is_on() )
+        {
+            AC_LOG( DEBUG, "Calibration mechanism is not on; not scheduling next calibration" );
+            return;
+        }
+
+        // Trigger after a set amount of time
+        auto n_seconds = get_trigger_seconds();
+        if( n_seconds.count() )
+            start( n_seconds );
+        else
+            AC_LOG( DEBUG, "RS2_AC_TRIGGER_SECONDS is 0; no time trigger" );
+        
+        // Or after a certain temperature change
+        if( get_temp_diff_trigger() )
+        {
+            if( _last_temp = read_temperature() )
+                _temp_check = retrier::start< temp_check >( *this, std::chrono::seconds( 60 ) );
+        }
+        else
+        {
+            AC_LOG( DEBUG, "RS2_AC_TEMP_DIFF is 0; no temperature change trigger" );
+        }
+    }
+
+
+    double ac_trigger::read_temperature()
+    {
+        // The temperature may depend on streaming?
+        auto res = _hwm.send( command{ TEMPERATURES_GET } );
+        if( res.size() < sizeof( temperatures ) )  // New temperatures may get added by FW...
+        {
+            AC_LOG( ERROR,
+                    "Failed to get temperatures; result size= "
+                        << res.size() << "; expecting at least " << sizeof( temperatures ) );
+            return 0;
+        }
+        auto const & ts = *( reinterpret_cast< temperatures * >( res.data() ) );
+        AC_LOG( DEBUG, "HUM temperture is currently " << ts.HUM_temperature << " degrees Celsius" );
+        return ts.HUM_temperature;
+    }
+
+    void ac_trigger::start( std::chrono::seconds n_seconds )
+    {
+        if( is_active() )
+            throw wrong_api_call_sequence_exception( "AC is already active" );
+
+        if( !n_seconds.count() )
+        {
+#if 0 // TODO on auto trigger, we want this back
+            option & o = _dev.get_depth_sensor().get_option( RS2_OPTION_CAMERA_ACCURACY_HEALTH_ENABLED );
+            if( !o.query() )
+            {
+                // auto trigger is turned off
+                AC_LOG( DEBUG, "Camera Accuracy Health is turned off -- no trigger set" );
+                return;
+            }
+#endif
+
+            // Check if we want auto trigger
+            // Note: we arbitrarly choose the time before AC starts at 10 second -- enough time to
+            // make sure the user isn't going to fiddle with color sensor activity too much, because
+            // if color is off then AC will automatically turn it on!
+            if( get_trigger_seconds().count() )
+                n_seconds = std::chrono::seconds( 10 );
+            else if( get_temp_diff_trigger() && (_last_temp = read_temperature()) )
+                _temp_check = retrier::start< temp_check >( *this, std::chrono::seconds( 60 ) );
+            else
+            {
+                AC_LOG( DEBUG, "Camera Accuracy Health auto trigger is disabled in environment" );
+                return;  // no auto trigger
+            }
+        }
+        _is_on = true;
+        if( n_seconds.count() )
+        {
+            AC_LOG( DEBUG, "Calibration will be triggered in " << n_seconds.count() << " seconds..." );
+            // If there's already a trigger, this will simply override it
+            _next_trigger = retrier::start( *this, n_seconds, "next calibration" );
+        }
+    }
+
+    void ac_trigger::stop()
+    {
+        _is_on = false;
+        if( _next_trigger )
+        {
+            AC_LOG( DEBUG, "Cancelling next calibration" );
+            _next_trigger.reset();
+        }
+        if( is_active() )
+        {
+            AC_LOG( DEBUG, "Cancelling current calibration" );
+            _n_cycles = 0;  // now inactive!
+        }
+        stop_color_sensor_if_started();
+        _temp_check.reset();
+        _retrier.reset();
+        _recycler.reset();
+    }
+
+    void ac_trigger::reset()
+    {
+        _sf = rs2::frame{};
+        _cf = rs2::frame{};;
+        _pcf = rs2::frame{};
+
+        _is_processing = false;
+        AC_LOG( DEBUG, "reset()" );
+    }
+
+
+    ac_trigger::depth_processing_block::depth_processing_block(
+        std::shared_ptr< ac_trigger > autocal
+    )
+        : generic_processing_block( "Auto Calibration (depth)" )
+        , _autocal{ autocal }
+    {
+    }
+
+
+    static bool is_special_frame( rs2::depth_frame const& f )
+    {
+        if( !f )
+            return false;
+
+        if( f.supports_frame_metadata( RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE ) )
+        {
+            // We specified 0x5F (SF = Special Frame) when we asked for the SPECIAL_FRAME
+            auto mode = f.get_frame_metadata( RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE );
+            return 0x5F == mode;
+        }
+
+        // When the frame doesn't support metadata, we have to look at its
+        // contents: we take the first frame that has 100% fill rate, i.e.
+        // has no pixels with 0 in them...
+        uint16_t const * pd = reinterpret_cast<const uint16_t *>(f.get_data());
+        for( size_t x = f.get_data_size() / sizeof( *pd ); x--; ++pd )
+        {
+            if( !*pd )
+                return false;
+        }
+        AC_LOG( DEBUG, "frame " << f.get_frame_number() << " has no metadata but 100% fill rate -> assuming special frame" );
+        return true;  // None zero, assume special frame...
+    }
+
+    rs2::frame ac_trigger::depth_processing_block::process_frame( const rs2::frame_source & source,
+                                                                  const rs2::frame & f )
+    {
+        // AC can be triggered manually, too, so we do NOT check whether the option is on!
+
+        auto fs = f.as< rs2::frameset >();
+        if( fs )
+        {
+            auto df = fs.get_depth_frame();
+            if( _autocal->is_expecting_special_frame() && is_special_frame( df ) )
+            {
+                AC_LOG( DEBUG, "frame " << f.get_frame_number() << " is our special frame" );
+                _autocal->set_special_frame( f );
+            }
+            // Disregard framesets: we'll get those broken down into individual frames by generic_processing_block's on_frame
+            return rs2::frame{};
+        }
+
+        if( _autocal->is_expecting_special_frame() && is_special_frame( f.as< rs2::depth_frame >() ) )
+            // We don't want the user getting this frame!
+            return rs2::frame{};
+
+        return f;
+    }
+
+
+    bool ac_trigger::depth_processing_block::should_process( const rs2::frame & frame )
+    {
+        return true;
+    }
+
+
+    rs2::frame ac_trigger::depth_processing_block::prepare_output(
+        const rs2::frame_source & source, rs2::frame input, std::vector< rs2::frame > results )
+    {
+        // The default prepare_output() will send the input back as the frame if the results are empty
+        if( results.empty() )
+            return rs2::frame{};
+
+        return source.allocate_composite_frame( results );
+    }
+
+
+    ac_trigger::color_processing_block::color_processing_block(
+        std::shared_ptr< ac_trigger > autocal
+    )
+        : generic_processing_block( "Auto Calibration (color)" )
+        , _autocal{ autocal }
+    {
+    }
+
+
+    rs2::frame ac_trigger::color_processing_block::process_frame( const rs2::frame_source& source, const rs2::frame& f )
+    {
+        // AC can be triggered manually, too, so we do NOT check whether the option is on!
+
+        // Disregard framesets: we'll get those broken down into individual frames by generic_processing_block's on_frame
+        if( f.is< rs2::frameset >() )
+            return rs2::frame{};
+
+        // We record each and every color frame
+        _autocal->set_color_frame( f );
+
+        // Return the frame as is!
+        return f;
+    }
+
+
+    bool ac_trigger::color_processing_block::should_process( const rs2::frame& frame )
+    {
+        return true;
+    }
+
+
+}  // namespace ivcam2
+}  // namespace librealsense
diff --git a/src/l500/ac-trigger.h b/src/l500/ac-trigger.h
new file mode 100644
index 0000000..46d2ae7
--- /dev/null
+++ b/src/l500/ac-trigger.h
@@ -0,0 +1,197 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2018 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "types.h"
+#include "option.h"
+#include <mutex>
+#include <thread>
+
+
+namespace librealsense {
+
+    class l500_device;
+
+namespace ivcam2 {
+
+
+    /*
+        This is the triggering code for depth-to-RGB-calibration
+    */
+    class ac_trigger : public std::enable_shared_from_this< ac_trigger >
+    {
+        rs2::frameset _sf;
+        rs2::frame _cf, _pcf;  // Keep the last and previous frame!
+
+        float _dsm_x_scale;  // registers read when we get a special frame
+        float _dsm_y_scale;
+        float _dsm_x_offset;
+        float _dsm_y_offset;
+
+        hw_monitor & _hwm;
+        l500_device & _dev;
+
+        bool _is_on = false;
+        std::mutex _mutex;
+        bool _is_processing = false;  // Whether algo is currently running
+        std::thread _worker;
+        unsigned _n_retries;     // how many special frame requests we've made
+        unsigned _n_cycles = 0;  // how many times we've run algo
+
+        rs2_extrinsics _extr;
+        rs2_intrinsics _intr;
+        rs2_dsm_params _dsm_params;
+        stream_profile_interface* _from_profile = nullptr;
+        stream_profile_interface* _to_profile = nullptr;
+
+        class retrier;
+        std::shared_ptr< retrier > _retrier;
+        std::shared_ptr< retrier > _recycler;
+        std::shared_ptr< retrier > _next_trigger;
+        rs2_calibration_status _last_status_sent;
+        std::atomic_bool _own_color_stream{ false };
+
+        class temp_check;
+        double _last_temp = 0;
+        std::shared_ptr< temp_check > _temp_check;
+
+    public:
+        /* Depth frame processing: detect special frames
+        */
+        class depth_processing_block : public generic_processing_block
+        {
+            std::shared_ptr< ac_trigger > _autocal;
+
+        public:
+            depth_processing_block( std::shared_ptr< ac_trigger > autocal );
+
+            rs2::frame process_frame( const rs2::frame_source& source, const rs2::frame& f ) override;
+
+        private:
+            bool should_process( const rs2::frame& frame ) override;
+            rs2::frame prepare_output( const rs2::frame_source& source, rs2::frame input, std::vector<rs2::frame> results ) override;
+        };
+
+        /* Color frame processing: pass color frames to the trigger
+        */
+        class color_processing_block : public generic_processing_block
+        {
+            std::shared_ptr< ac_trigger > _autocal;
+
+        public:
+            color_processing_block( std::shared_ptr< ac_trigger > autocal );
+
+            rs2::frame process_frame( const rs2::frame_source& source, const rs2::frame& f ) override;
+
+        private:
+            bool should_process( const rs2::frame& frame ) override;
+        };
+
+        /* For RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH */
+        class enabler_option : public bool_option
+        {
+            std::shared_ptr< ac_trigger > _autocal;
+
+        public:
+            enabler_option( std::shared_ptr< ac_trigger > const & autocal );
+
+            virtual void set( float value ) override;
+            virtual const char* get_description() const override
+            {
+                return "Trigger Camera Accuracy Health";
+            }
+            virtual void enable_recording( std::function<void( const option& )> record_action ) override { _record_action = record_action; }
+
+        private:
+            std::function<void( const option& )> _record_action = []( const option& ) {};
+        };
+
+        /* For RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH */
+        class reset_option : public bool_option
+        {
+            std::shared_ptr< ac_trigger > _autocal;
+
+        public:
+            reset_option( std::shared_ptr< ac_trigger > const & autocal );
+
+            virtual void set( float value ) override;
+            virtual const char* get_description() const override
+            {
+                return "Reset the FW table for Camera Accuracy Health";
+            }
+            virtual void enable_recording( std::function<void( const option& )> record_action ) override { _record_action = record_action; }
+
+        private:
+            std::function<void( const option& )> _record_action = []( const option& ) {};
+        };
+
+    public:
+        ac_trigger( l500_device & dev, hw_monitor & hwm );
+        ~ac_trigger();
+
+        // Wait a certain amount of time before the next calibration happens. Can only happen if not
+        // already active!
+        void start( std::chrono::seconds n_seconds = std::chrono::seconds(0) );
+
+        // Once triggered, we may want to cancel it... like when stopping the stream
+        void stop();
+
+        // If we're active, calibration is currently in progress (anywhere between asking for a
+        // special frame and finishing with success/failure). No new triggers will be accepted!
+        bool is_active() const { return _n_cycles > 0; }
+
+        // Returns whether the mechanism is on: anywhere between start() and stop(). When on,
+        // the end of one calibration triggers a temperature check and the next calibration.
+        //
+        // Note that is_active() can be true even when we're off -- trigger_calibration()
+        // can manually trigger a calibration, meaning that the calibration will run its
+        // course and then stop...
+        //
+        bool auto_calibration_is_on() const { return _is_on; }
+
+        // Start calibration -- after this, is_active() returns true. See the note for is_on().
+        void trigger_calibration( bool is_retry = false );
+
+        rs2_extrinsics const & get_extrinsics() const { return _extr; }
+        rs2_intrinsics const & get_intrinsics() const { return _intr; }
+        rs2_dsm_params const & get_dsm_params() const { return _dsm_params; }
+        stream_profile_interface * get_from_profile() const { return _from_profile; }
+        stream_profile_interface * get_to_profile() const { return _to_profile; }
+
+        using callback = std::function< void( rs2_calibration_status ) >;
+        void register_callback( callback cb )
+        {
+            _callbacks.push_back( cb );
+        }
+
+    private:
+        void set_special_frame( rs2::frameset const & );
+        void set_color_frame( rs2::frame const & );
+
+        void start_color_sensor_if_needed();
+        void stop_color_sensor_if_started();
+
+        bool is_processing() const { return _is_processing; }
+        bool is_expecting_special_frame() const { return !!_retrier; }
+        double read_temperature();
+        void calibration_is_done();
+
+        std::vector< callback > _callbacks;
+
+        void call_back( rs2_calibration_status status )
+        {
+            _last_status_sent = status;
+            for( auto && cb : _callbacks )
+                cb( status );
+        }
+
+        bool check_color_depth_sync();
+        void run_algo();
+        void reset();
+    };
+
+
+}  // namespace ivcam2
+}  // namespace librealsense
+
diff --git a/src/l500/l500-color.cpp b/src/l500/l500-color.cpp
index 3280234..ac0202c 100644
--- a/src/l500/l500-color.cpp
+++ b/src/l500/l500-color.cpp
@@ -7,6 +7,8 @@
 
 #include "l500-private.h"
 #include "proc/color-formats-converter.h"
+#include "ac-trigger.h"
+#include "algo/depth-to-rgb-calibration/debug.h"
 
 
 namespace librealsense
@@ -39,8 +41,28 @@ namespace librealsense
         color_ep->register_info(RS2_CAMERA_INFO_PHYSICAL_PORT, color_devices_info.front().device_path);
 
         // processing blocks
-        color_ep->register_processing_block(processing_block_factory::create_pbf_vector<yuy2_converter>(RS2_FORMAT_YUYV, map_supported_color_formats(RS2_FORMAT_YUYV), RS2_STREAM_COLOR));
-        
+        if( _autocal )
+        {
+            color_ep->register_processing_block(
+                processing_block_factory::create_pbf_vector< yuy2_converter >(
+                    RS2_FORMAT_YUYV,                                                      // from
+                    map_supported_color_formats( RS2_FORMAT_YUYV ), RS2_STREAM_COLOR,     // to
+                    [=]( std::shared_ptr< generic_processing_block > pb )
+                    {
+                        auto cpb = std::make_shared< composite_processing_block >();
+                        cpb->add(std::make_shared< ac_trigger::color_processing_block >(_autocal));
+                        cpb->add( pb );
+                        return cpb;
+                    } ) );
+        }
+        else
+        {
+            color_ep->register_processing_block(
+                processing_block_factory::create_pbf_vector< yuy2_converter >(
+                    RS2_FORMAT_YUYV,                                                      // from
+                    map_supported_color_formats( RS2_FORMAT_YUYV ), RS2_STREAM_COLOR ) ); // to
+        }
+
         // options
         color_ep->register_option(RS2_OPTION_GLOBAL_TIME_ENABLED, enable_global_time_option);
         color_ep->get_option(RS2_OPTION_GLOBAL_TIME_ENABLED).set(0);
@@ -132,14 +154,195 @@ namespace librealsense
         _color_intrinsics_table_raw = [this]() { return get_raw_intrinsics_table(); };
         _color_extrinsics_table_raw = [this]() { return get_raw_extrinsics_table(); };
 
-        _color_extrinsic = std::make_shared<lazy<rs2_extrinsics>>([this]() { return from_pose(get_color_stream_extrinsic(*_color_extrinsics_table_raw)); });
-        environment::get_instance().get_extrinsics_graph().register_extrinsics(*_color_stream, *_depth_stream, _color_extrinsic);
-        register_stream_to_extrinsic_group(*_color_stream, 0);
+        // This lazy instance will get shared between all the extrinsics edges. If you ever need to override
+        // it, be careful not to overwrite the shared-ptr itself (register_extrinsics) or the sharing
+        // will get ruined. Instead, overwriting the lazy<> function should do it:
+        //      *_color_extrinsic = [=]() { return extr; };
+        _color_extrinsic = std::make_shared<lazy<rs2_extrinsics>>(
+            [this]()
+            {
+                return get_color_stream_extrinsic(*_color_extrinsics_table_raw);
+            } );
+        environment::get_instance().get_extrinsics_graph().register_extrinsics(*_depth_stream, *_color_stream, _color_extrinsic);
+        register_stream_to_extrinsic_group(*_depth_stream, 0);
 
 
         _color_device_idx = add_sensor(create_color_device(ctx, color_devs_info));
     }
 
+    l500_color_sensor * l500_color::get_color_sensor()
+    {
+        return &dynamic_cast< l500_color_sensor & >( get_sensor( _color_device_idx ));
+    }
+
+
+    rs2_intrinsics l500_color_sensor::get_intrinsics( const stream_profile& profile ) const
+    {
+        using namespace ivcam2;
+
+        auto intrinsic = check_calib<intrinsic_rgb>( *_owner->_color_intrinsics_table_raw );
+
+        auto num_of_res = intrinsic->resolution.num_of_resolutions;
+
+        for( auto i = 0; i < num_of_res; i++ )
+        {
+            auto model = intrinsic->resolution.intrinsic_resolution[i];
+            if( model.height == profile.height && model.width == profile.width )
+            {
+                rs2_intrinsics intrinsics;
+                intrinsics.width = model.width;
+                intrinsics.height = model.height;
+                intrinsics.fx = model.ipm.focal_length.x;
+                intrinsics.fy = model.ipm.focal_length.y;
+                intrinsics.ppx = model.ipm.principal_point.x;
+                intrinsics.ppy = model.ipm.principal_point.y;
+
+                if( model.distort.radial_k1 || model.distort.radial_k2 || model.distort.tangential_p1 || model.distort.tangential_p2 || model.distort.radial_k3 )
+                {
+                    intrinsics.coeffs[0] = model.distort.radial_k1;
+                    intrinsics.coeffs[1] = model.distort.radial_k2;
+                    intrinsics.coeffs[2] = model.distort.tangential_p1;
+                    intrinsics.coeffs[3] = model.distort.tangential_p2;
+                    intrinsics.coeffs[4] = model.distort.radial_k3;
+
+                    intrinsics.model = RS2_DISTORTION_INVERSE_BROWN_CONRADY;
+                }
+
+                return intrinsics;
+            }
+        }
+        throw std::runtime_error( to_string() << "intrinsics for resolution " << profile.width << "," << profile.height << " don't exist" );
+    }
+
+
+    rs2_intrinsics ivcam2::rgb_calibration_table::get_intrinsics() const
+    {
+        // TODO: we currently use the wrong distortion model, but all the code is
+        // written to expect the INVERSE brown. The table assumes REGULAR brown.
+        return { width, height,
+                 intr.px, intr.py,  // NOTE: this is normalized!
+                 intr.fx, intr.fy,  // NOTE: this is normalized!
+                 RS2_DISTORTION_INVERSE_BROWN_CONRADY,  // see comment above
+                 { intr.d[0], intr.d[1], intr.d[2], intr.d[3], intr.d[4] } };
+    }
+
+
+    void ivcam2::rgb_calibration_table::set_intrinsics( rs2_intrinsics const & i )
+    {
+        // The table in FW is resolution-agnostic; it can apply to ALL resolutions. To
+        // do this, the focal length and principal point are normalized:
+        width = i.width;
+        height = i.height;
+        intr.fx = 2 * i.fx / i.width;
+        intr.fy = 2 * i.fy / i.height;
+        intr.px = 2 * i.ppx / i.width - 1;
+        intr.py = 2 * i.ppy / i.height - 1;
+        intr.d[0] = i.coeffs[0];
+        intr.d[1] = i.coeffs[1];
+        intr.d[2] = i.coeffs[2];
+        intr.d[3] = i.coeffs[3];
+        intr.d[4] = i.coeffs[4];
+    }
+
+
+    void l500_color_sensor::override_intrinsics( rs2_intrinsics const& intr )
+    {
+        // The distortion model is not part of the table. The FW assumes it is brown,
+        // but in LRS we (mistakenly) use INVERSE brown. We therefore make sure the user
+        // has not tried to change anything from the intrinsics reported:
+        if( intr.model != RS2_DISTORTION_INVERSE_BROWN_CONRADY )
+            throw invalid_value_exception( "invalid intrinsics distortion model" );
+
+        rgb_calibration_table table;
+        AC_LOG( DEBUG, "Reading RGB calibration table 0x" << std::hex << table.table_id );
+        ivcam2::read_fw_table( *_owner->_hw_monitor, table.table_id, &table );
+        AC_LOG( DEBUG, "    version:     " << table.version );
+        AC_LOG( DEBUG, "    timestamp:   " << table.timestamp << "; incrementing" );
+        AC_LOG( DEBUG, "    type:        " << table.type << "; setting to 0x10" );
+        AC_LOG( DEBUG, "    intrinsics:  " << table.get_intrinsics() );
+        table.set_intrinsics( intr );
+        AC_LOG( INFO, "Overriding intr: " << intr );
+        AC_LOG( DEBUG, "    normalized:  " << table.get_intrinsics() );
+        table.update_write_fields();
+        write_fw_table( *_owner->_hw_monitor, table.table_id, table );
+        AC_LOG( DEBUG, "    done" );
+
+        // Intrinsics are resolution-specific, so all the rest of the profile info is not
+        // important
+        _owner->_color_intrinsics_table_raw.reset();
+    }
+
+    void l500_color_sensor::override_extrinsics( rs2_extrinsics const& extr )
+    {
+        rgb_calibration_table table;
+        AC_LOG( DEBUG, "Reading RGB calibration table 0x" << std::hex << table.table_id );
+        ivcam2::read_fw_table( *_owner->_hw_monitor, table.table_id, &table );
+        AC_LOG( DEBUG, "    version:     " << table.version );
+        AC_LOG( DEBUG, "    timestamp:   " << table.timestamp << "; incrementing" );
+        AC_LOG( DEBUG, "    type:        " << table.type << "; setting to 0x10" );
+        AC_LOG( DEBUG, "    raw extr:    " << table.get_extrinsics() );
+        table.extr = to_raw_extrinsics(extr);
+        AC_LOG( INFO , "Overriding extr: " << extr );
+        table.update_write_fields();
+        AC_LOG( DEBUG, "    as raw:      " << table.get_extrinsics());
+        ivcam2::write_fw_table( *_owner->_hw_monitor, table.table_id, table );
+        AC_LOG( DEBUG, "    done" );
+
+
+        environment::get_instance().get_extrinsics_graph().override_extrinsics( *_owner->_depth_stream, *_owner->_color_stream, extr );
+    }
+
+    rs2_dsm_params l500_color_sensor::get_dsm_params() const
+    {
+        throw std::logic_error( "color sensor does not support DSM parameters" );
+    }
+
+    void l500_color_sensor::override_dsm_params( rs2_dsm_params const & dsm )
+    {
+        throw std::logic_error( "color sensor does not support DSM parameters" );
+    }
+
+    void ivcam2::rgb_calibration_table::update_write_fields()
+    {
+        // We don't touch the version...
+        //version = ;
+
+        // This signifies AC results:
+        type = 0x10;
+
+        // The time-stamp is simply a sequential number that we increment
+        ++timestamp;
+    }
+
+    void l500_color_sensor::reset_calibration()
+    {
+        // Read from EEPROM (factory defaults), write to FLASH (current)
+        // Note that factory defaults may be different than the trinsics at the time of
+        // our initialization!
+        rgb_calibration_table table;
+        AC_LOG( DEBUG, "Reading factory calibration from table 0x" << std::hex << table.eeprom_table_id );
+        ivcam2::read_fw_table( *_owner->_hw_monitor, table.eeprom_table_id, &table );
+        AC_LOG( DEBUG, "    version:     " << table.version );
+        AC_LOG( DEBUG, "    timestamp:   " << table.timestamp << "; incrementing" );
+        AC_LOG( DEBUG, "    type:        " << table.type << "; setting to 0x10" );
+        AC_LOG( DEBUG, "Normalized:" );
+        AC_LOG( DEBUG, "    intrinsics:  " << table.get_intrinsics() );
+        AC_LOG( DEBUG, "    extrinsics:  " << table.get_extrinsics() );
+        AC_LOG( DEBUG, "Writing RGB calibration table 0x" << std::hex << table.table_id );
+        ivcam2::write_fw_table( *_owner->_hw_monitor, table.table_id, table );
+        AC_LOG( DEBUG, "    done" );
+
+        _owner->_color_intrinsics_table_raw.reset();
+
+         environment::get_instance().get_extrinsics_graph().override_extrinsics(
+            *_owner->_depth_stream,
+            *_owner->_color_stream,
+             from_raw_extrinsics(table.get_extrinsics()));
+        AC_LOG( INFO, "Color sensor calibration has been reset" );
+    }
+
+
+
     std::vector<tagged_profile> l500_color::get_profiles_tags() const
     {
         std::vector<tagged_profile> tags;
@@ -150,10 +353,12 @@ namespace librealsense
 
     std::vector<uint8_t> l500_color::get_raw_intrinsics_table() const
     {
+        AC_LOG( DEBUG, "RGB_INTRINSIC_GET" );
         return _hw_monitor->send(command{ RGB_INTRINSIC_GET });
     }
     std::vector<uint8_t> l500_color::get_raw_extrinsics_table() const
     {
+        AC_LOG( DEBUG, "RGB_EXTRINSIC_GET" );
         return _hw_monitor->send(command{ RGB_EXTRINSIC_GET });
     }
 }
diff --git a/src/l500/l500-color.h b/src/l500/l500-color.h
dissimilarity index 77%
index e1a01a0..52b28d6 100644
--- a/src/l500/l500-color.h
+++ b/src/l500/l500-color.h
@@ -1,148 +1,129 @@
-// License: Apache 2.0. See LICENSE file in root directory.
-// Copyright(c) 2018 Intel Corporation. All Rights Reserved.
-
-#pragma once
-
-#include <vector>
-#include <string>
-#include <map>
-
-#include "l500-device.h"
-#include "stream.h"
-#include "l500-depth.h"
-
-namespace librealsense
-{
-    class l500_color : public virtual l500_device
-    {
-    public:
-        std::shared_ptr<synthetic_sensor> create_color_device(std::shared_ptr<context> ctx,
-            const std::vector<platform::uvc_device_info>& color_devices_info);
-
-        l500_color(std::shared_ptr<context> ctx,
-            const platform::backend_device_group& group);
-
-        std::vector<tagged_profile> get_profiles_tags() const override;
-
-    protected:
-        std::shared_ptr<stream_interface> _color_stream;
-
-    private:
-        friend class l500_color_sensor;
-
-        uint8_t _color_device_idx = -1;
-
-        lazy<std::vector<uint8_t>> _color_intrinsics_table_raw;
-        lazy<std::vector<uint8_t>> _color_extrinsics_table_raw;
-        std::shared_ptr<lazy<rs2_extrinsics>> _color_extrinsic;
-
-        std::vector<uint8_t> get_raw_intrinsics_table() const;
-        std::vector<uint8_t> get_raw_extrinsics_table() const;
-    };
-
-    class l500_color_sensor : public synthetic_sensor, public video_sensor_interface, public color_sensor
-        {
-        public:
-            explicit l500_color_sensor(l500_color* owner,
-                std::shared_ptr<uvc_sensor> uvc_sensor,
-                std::shared_ptr<context> ctx,
-                std::map<uint32_t, rs2_format> l500_color_fourcc_to_rs2_format,
-                std::map<uint32_t, rs2_stream> l500_color_fourcc_to_rs2_stream)
-                : synthetic_sensor("RGB Camera", uvc_sensor, owner, l500_color_fourcc_to_rs2_format, l500_color_fourcc_to_rs2_stream),
-                _owner(owner)
-            {}
-
-            rs2_intrinsics get_intrinsics(const stream_profile& profile) const override
-            {
-                using namespace ivcam2;
-
-                auto intrinsic = check_calib<intrinsic_rgb>(*_owner->_color_intrinsics_table_raw);
-
-                auto num_of_res = intrinsic->resolution.num_of_resolutions;
-
-                for (auto i = 0; i < num_of_res; i++)
-                {
-                    auto model = intrinsic->resolution.intrinsic_resolution[i];
-                    if (model.height == profile.height && model.width == profile.width)
-                    {
-                        rs2_intrinsics intrinsics;
-                        intrinsics.width = model.width;
-                        intrinsics.height = model.height;
-                        intrinsics.fx = model.ipm.focal_length.x;
-                        intrinsics.fy = model.ipm.focal_length.y;
-                        intrinsics.ppx = model.ipm.principal_point.x;
-                        intrinsics.ppy = model.ipm.principal_point.y;
-
-                        if (model.distort.radial_k1 || model.distort.radial_k2 || model.distort.tangential_p1  || model.distort.tangential_p2 || model.distort.radial_k3)
-                        {
-                            intrinsics.coeffs[0] = model.distort.radial_k1;
-                            intrinsics.coeffs[1] = model.distort.radial_k2;
-                            intrinsics.coeffs[2] = model.distort.tangential_p1;
-                            intrinsics.coeffs[3] = model.distort.tangential_p2;
-                            intrinsics.coeffs[4] = model.distort.radial_k3;
-
-                            intrinsics.model = RS2_DISTORTION_INVERSE_BROWN_CONRADY;
-                        }
-                        
-                        return intrinsics;
-                    }
-                }
-                throw std::runtime_error(to_string() << "intrinsics for resolution "<< profile.width <<","<< profile.height<< " doesn't exist");
-            }
-
-            stream_profiles init_stream_profiles() override
-            {
-                auto lock = environment::get_instance().get_extrinsics_graph().lock();
-
-                auto&& results = synthetic_sensor::init_stream_profiles();
-
-                for (auto&& p : results)
-                {
-                    // Register stream types
-                    if (p->get_stream_type() == RS2_STREAM_COLOR)
-                    {
-                        assign_stream(_owner->_color_stream, p);
-                    }
-
-                    // Register intrinsics
-                    auto&& video = dynamic_cast<video_stream_profile_interface*>(p.get());
-                    const auto&& profile = to_profile(p.get());
-                    std::weak_ptr<l500_color_sensor> wp =
-                        std::dynamic_pointer_cast<l500_color_sensor>(this->shared_from_this());
-                    video->set_intrinsics([profile, wp]()
-                    {
-                        auto sp = wp.lock();
-                        if (sp)
-                            return sp->get_intrinsics(profile);
-                        else
-                            return rs2_intrinsics{};
-                    });
-                }
-
-                return results;
-            }
-
-            processing_blocks get_recommended_processing_blocks() const override
-            {
-                return get_color_recommended_proccesing_blocks();
-            }
-
-            void start(frame_callback_ptr callback) override
-            {
-                _action_delayer.do_after_delay([&]() {
-                        synthetic_sensor::start(callback);
-                });
-            }
-
-            void stop() override
-            {
-                _action_delayer.do_after_delay([&]() {
-                    synthetic_sensor::stop();
-                });
-            }
-        private:
-            const l500_color* _owner;
-            action_delayer _action_delayer;
-        };
-
-}
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2018 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <vector>
+#include <string>
+#include <map>
+
+#include "l500-device.h"
+#include "stream.h"
+#include "l500-depth.h"
+#include "calibrated-sensor.h"
+
+namespace librealsense
+{
+    class l500_color
+        : public virtual l500_device
+    {
+    public:
+        std::shared_ptr<synthetic_sensor> create_color_device(std::shared_ptr<context> ctx,
+            const std::vector<platform::uvc_device_info>& color_devices_info);
+
+        l500_color(std::shared_ptr<context> ctx,
+            const platform::backend_device_group& group);
+
+        l500_color_sensor * get_color_sensor() override;
+
+        std::vector<tagged_profile> get_profiles_tags() const override;
+
+    protected:
+        std::shared_ptr<stream_interface> _color_stream;
+
+    private:
+        friend class l500_color_sensor;
+
+        uint8_t _color_device_idx = -1;
+
+        lazy<std::vector<uint8_t>> _color_intrinsics_table_raw;
+        lazy<std::vector<uint8_t>> _color_extrinsics_table_raw;
+        std::shared_ptr<lazy<rs2_extrinsics>> _color_extrinsic;
+
+        std::vector<uint8_t> get_raw_intrinsics_table() const;
+        std::vector<uint8_t> get_raw_extrinsics_table() const;
+    };
+
+    class l500_color_sensor
+        : public synthetic_sensor
+        , public video_sensor_interface
+        , public calibrated_sensor
+        , public color_sensor
+    {
+    public:
+        explicit l500_color_sensor(l500_color* owner,
+            std::shared_ptr<uvc_sensor> uvc_sensor,
+            std::shared_ptr<context> ctx,
+            std::map<uint32_t, rs2_format> l500_color_fourcc_to_rs2_format,
+            std::map<uint32_t, rs2_stream> l500_color_fourcc_to_rs2_stream)
+            : synthetic_sensor("RGB Camera", uvc_sensor, owner, l500_color_fourcc_to_rs2_format, l500_color_fourcc_to_rs2_stream),
+            _owner(owner)
+        {}
+
+        rs2_intrinsics get_intrinsics( const stream_profile& profile ) const override;
+        
+        // calibrated_sensor
+        void override_intrinsics( rs2_intrinsics const& intr ) override;
+        void override_extrinsics( rs2_extrinsics const& extr ) override;
+        rs2_dsm_params get_dsm_params() const override;
+        void override_dsm_params( rs2_dsm_params const & dsm_params ) override;
+        void reset_calibration() override;
+
+        stream_profiles init_stream_profiles() override
+        {
+            auto lock = environment::get_instance().get_extrinsics_graph().lock();
+
+            auto&& results = synthetic_sensor::init_stream_profiles();
+
+            for (auto&& p : results)
+            {
+                // Register stream types
+                if (p->get_stream_type() == RS2_STREAM_COLOR)
+                {
+                    assign_stream(_owner->_color_stream, p);
+                }
+
+                // Register intrinsics
+                auto&& video = dynamic_cast<video_stream_profile_interface*>(p.get());
+                const auto&& profile = to_profile(p.get());
+                std::weak_ptr<l500_color_sensor> wp =
+                    std::dynamic_pointer_cast<l500_color_sensor>(this->shared_from_this());
+                video->set_intrinsics([profile, wp]()
+                {
+                    auto sp = wp.lock();
+                    if (sp)
+                        return sp->get_intrinsics(profile);
+                    else
+                        return rs2_intrinsics{};
+                });
+            }
+
+            return results;
+        }
+
+        processing_blocks get_recommended_processing_blocks() const override
+        {
+            return get_color_recommended_proccesing_blocks();
+        }
+
+        void start(frame_callback_ptr callback) override
+        {
+            _action_delayer.do_after_delay([&]() {
+                    synthetic_sensor::start(callback);
+                    //_owner->trigger_device_calibration( RS2_CALIBRATION_DEPTH_TO_RGB );
+            });
+        }
+
+        void stop() override
+        {
+            _action_delayer.do_after_delay([&]() {
+                synthetic_sensor::stop();
+            });
+        }
+
+    private:
+        l500_color* const _owner;
+        action_delayer _action_delayer;
+    };
+
+}
diff --git a/src/l500/l500-depth.cpp b/src/l500/l500-depth.cpp
index b8818fb..38cf034 100644
--- a/src/l500/l500-depth.cpp
+++ b/src/l500/l500-depth.cpp
@@ -6,6 +6,7 @@
 #include "context.h"
 #include "stream.h"
 #include "l500-depth.h"
+#include "l500-color.h"
 #include "l500-private.h"
 #include "proc/decimation-filter.h"
 #include "proc/threshold.h" 
@@ -16,6 +17,9 @@
 #include <cstddef>
 #include "metadata-parser.h"
 #include "l500-options.h"
+#include "ac-trigger.h"
+#include "algo/depth-to-rgb-calibration/debug.h"
+
 
 #define MM_TO_METER 1/1000
 #define MIN_ALGO_VERSION 115
@@ -104,7 +108,7 @@ namespace librealsense
             offsetof(md_l500_depth, intel_depth_control);
 
         depth_sensor.register_metadata(RS2_FRAME_METADATA_FRAME_LASER_POWER, make_attribute_parser(&md_l500_depth_control::laser_power, md_l500_depth_control_attributes::laser_power, md_prop_offset));
-        depth_sensor.register_metadata(RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE, make_attribute_parser(&md_l500_depth_control::laser_power_mode, md_rgb_control_attributes::manual_exp_attribute, md_prop_offset));
+        depth_sensor.register_metadata(RS2_FRAME_METADATA_FRAME_LASER_POWER_MODE, make_attribute_parser(&md_l500_depth_control::laser_power_mode, md_l500_depth_control_attributes::laser_power_mode, md_prop_offset));
     }
 
     std::vector<tagged_profile> l500_depth::get_profiles_tags() const
@@ -124,6 +128,7 @@ namespace librealsense
 
         std::vector<stream_interface*> streams = { _depth_stream.get(), _ir_stream.get(), _confidence_stream.get() };
 
+        // TODO
         for (auto& s : streams)
         {
             depth_matchers.push_back(std::make_shared<identity_matcher>(s->get_unique_id(), s->get_stream_type()));
@@ -141,6 +146,51 @@ namespace librealsense
         return std::make_shared<timestamp_composite_matcher>(matchers);
     }
 
+    l500_depth_sensor::l500_depth_sensor(
+        l500_device* owner,
+        std::shared_ptr<uvc_sensor> uvc_sensor,
+        std::map<uint32_t, rs2_format> l500_depth_fourcc_to_rs2_format_map,
+        std::map<uint32_t, rs2_stream> l500_depth_fourcc_to_rs2_stream_map
+    )
+        : synthetic_sensor( "L500 Depth Sensor",
+            uvc_sensor,
+            owner,
+            l500_depth_fourcc_to_rs2_format_map,
+            l500_depth_fourcc_to_rs2_stream_map )
+        , _owner( owner )
+    {
+#ifdef ENABLE_L500_DEPTH_INVALIDATION
+        _depth_invalidation_enabled = true;
+#else
+        _depth_invalidation_enabled = false;
+#endif
+
+        register_option( RS2_OPTION_DEPTH_UNITS, std::make_shared<const_value_option>( "Number of meters represented by a single depth unit",
+            lazy<float>( [&]() {
+                return read_znorm(); } ) ) );
+
+        register_option( RS2_OPTION_DEPTH_OFFSET, std::make_shared<const_value_option>( "Offset from sensor to depth origin in millimetrers",
+            lazy<float>( [&]() {
+                return get_depth_offset(); } ) ) );
+
+        _depth_invalidation_option = std::make_shared<depth_invalidation_option>(
+            0,
+            1,
+            1,
+            0,
+            &_depth_invalidation_enabled,
+            "depth invalidation enabled" );
+        _depth_invalidation_option->on_set( [this]( float val )
+            {
+                if( !_depth_invalidation_option->is_valid( val ) )
+                    throw invalid_value_exception( to_string()
+                        << "Unsupported depth invalidation enabled " << val << " is out of range." );
+            } );
+
+        // The depth invalidation enable option is deprecated for now.
+        //register_option(static_cast<rs2_option>(RS2_OPTION_DEPTH_INVALIDATION_ENABLE), _depth_invalidation_option);
+    }
+
     int l500_depth_sensor::read_algo_version()
     {
         const int algo_version_address = 0xa0020bd8;
@@ -155,6 +205,78 @@ namespace librealsense
         return ver;
     }
 
+    void l500_depth_sensor::override_intrinsics( rs2_intrinsics const & intr )
+    {
+        throw librealsense::not_implemented_exception( "depth sensor does not support intrinsics override" );
+    }
+
+    void l500_depth_sensor::override_extrinsics( rs2_extrinsics const & extr )
+    {
+        throw librealsense::not_implemented_exception( "depth sensor does not support extrinsics override" );
+    }
+
+    rs2_dsm_params l500_depth_sensor::get_dsm_params() const
+    {
+        ac_depth_results table = { { 0 } };
+        read_fw_table( *_owner->_hw_monitor, table.table_id, &table, nullptr,
+            [&]()
+            {
+                //time_t t;
+                //time( &t );                                       // local time
+                //table.params.timestamp = mktime( gmtime( &t ) );  // UTC time
+                // Leave the timestamp & version at 0, so it's recognizable as "new"
+                //table.params.version = table.this_version;
+                table.params.model = RS2_DSM_CORRECTION_AOT;
+                table.params.h_scale = table.params.v_scale = 1.;
+            } );
+        return table.params;
+    }
+
+    void l500_depth_sensor::override_dsm_params( rs2_dsm_params const & dsm_params )
+    {
+        /*  Considerable values for DSM correction:
+            - h/vFactor: 0.98-1.02, representing up to 2% change in FOV.
+            - h/vOffset:
+                - Under AOT model: (-2)-2, representing up to 2deg FOV tilt
+                - Under TOA model: (-125)-125, representing up to approximately
+                  2deg FOV tilt
+            These values are extreme. For more reasonable values take 0.99-1.01
+            for h/vFactor and divide the suggested h/vOffset range by 10.
+        */
+        if( dsm_params.model != RS2_DSM_CORRECTION_AOT )
+            throw invalid_value_exception( "DSM non-AoT (1) mode is currently unsupported" );
+
+        ac_depth_results table( dsm_params );
+        // table.params.timestamp = std::chrono::system_clock::now().time_since_epoch().count();
+        time_t t;
+        time( &t );                                       // local time
+        table.params.timestamp = mktime( gmtime( &t ) );  // UTC time
+        table.params.version = ac_depth_results::this_version;
+
+        // The temperature may depend on streaming?
+        auto res = _owner->_hw_monitor->send( command{TEMPERATURES_GET} );
+        if( res.size() < sizeof( temperatures ) )  // New temperatures may get added by FW...
+        {
+            AC_LOG( ERROR, "Failed to get temperatures; result size= " << res.size() << "; expecting at least " << sizeof( temperatures ) );
+        }
+        else
+        {
+            auto const & ts = *( reinterpret_cast<temperatures *>( res.data() ) );
+            table.params.temp_x2 = byte( ts.LDD_temperature * 2 );
+        }
+
+        AC_LOG( INFO, "Overriding DSM : " << table.params );
+        ivcam2::write_fw_table( *_owner->_hw_monitor, ac_depth_results::table_id, table );
+    }
+
+    void l500_depth_sensor::reset_calibration()
+    {
+        command cmd( ivcam2::fw_cmd::DELETE_TABLE, ac_depth_results::table_id );
+        _owner->_hw_monitor->send( cmd );
+        AC_LOG( INFO, "Depth sensor calibration has been reset" );
+    }
+
+
     float l500_depth_sensor::read_baseline() const
     {
         const int baseline_address = 0xa00e0868;
@@ -248,12 +370,18 @@ namespace librealsense
 
     void l500_depth_sensor::start(frame_callback_ptr callback)
     {
-        _action_delayer.do_after_delay([&]() {
-            if (_depth_invalidation_enabled)
-                synthetic_sensor::start(std::make_shared<frame_validator>(shared_from_this(), callback, _user_requests, _validator_requests));
+        _action_delayer.do_after_delay( [&]() {
+            if( _depth_invalidation_enabled )
+                synthetic_sensor::start(
+                    std::make_shared< frame_validator >( shared_from_this(),
+                                                         callback,
+                                                         _user_requests,
+                                                         _validator_requests ) );
             else
-                synthetic_sensor::start(callback);
-        });
+                synthetic_sensor::start( callback );
+            if( _owner->_autocal )
+                _owner->_autocal->start();
+        } );
     }
 
     void l500_depth_sensor::stop()
@@ -262,11 +390,15 @@ namespace librealsense
             synthetic_sensor::stop();
             _depth_invalidation_option->set_streaming(false);
         });
+        if( _owner->_autocal )
+            _owner->_autocal->stop();
     }
 
     rs2_sensor_mode get_resolution_from_width_height(int width, int height)
     {
-        if ((width == 640 && height == 480) || (width == 480  && height == 640))
+        if ((width == 240 && height == 320) || (width == 320 && height == 240))
+            return RS2_SENSOR_MODE_QVGA;
+        else if ((width == 640 && height == 480) || (width == 480  && height == 640))
             return RS2_SENSOR_MODE_VGA;
         else if ((width == 1024 && height == 768) || (width == 768 && height == 1024))
             return RS2_SENSOR_MODE_XGA;
@@ -287,16 +419,79 @@ namespace librealsense
             vl->get_height() == vr->get_height();
     }
 
+
+    std::shared_ptr< stream_profile_interface > l500_depth_sensor::is_color_sensor_needed() const
+    {
+        // If AC is off, we don't need the color stream on
+        if( !_owner->_autocal )
+            return {};
+
+        auto is_rgb_requested
+            = std::find_if( _user_requests.begin(),
+                            _user_requests.end(),
+                            []( std::shared_ptr< stream_profile_interface > const & sp )
+                            { return sp->get_stream_type() == RS2_STREAM_COLOR; } )
+           != _user_requests.end();
+        if( is_rgb_requested )
+            return {};
+
+        // Find a profile that's acceptable for RGB:
+        //     1. has the same framerate
+        //     2. format is RGB8
+        //     2. has the right resolution (1280x720 should be good enough)
+        auto user_request
+            = std::find_if( _user_requests.begin(),
+                            _user_requests.end(),
+                            []( std::shared_ptr< stream_profile_interface > const & sp ) {
+                                return sp->get_stream_type() == RS2_STREAM_DEPTH;
+                            } );
+        if( user_request == _user_requests.end() )
+        {
+            AC_LOG( ERROR, "Depth input stream profiles do not contain depth!" );
+            return {};
+        }
+        auto requested_depth_profile
+            = dynamic_cast< video_stream_profile * >( user_request->get() );
+
+        auto & color_sensor = *_owner->get_color_sensor();
+        auto color_profiles = color_sensor.get_stream_profiles();
+        auto rgb_profile = std::find_if(
+            color_profiles.begin(),
+            color_profiles.end(),
+            [&]( std::shared_ptr< stream_profile_interface > const & sp )
+            {
+                auto vsp = dynamic_cast< video_stream_profile * >( sp.get() );
+                return vsp->get_stream_type() == RS2_STREAM_COLOR
+                    && vsp->get_framerate() == requested_depth_profile->get_framerate()
+                    && vsp->get_format() == RS2_FORMAT_RGB8
+                    && vsp->get_width() == 1280  // flipped
+                    && vsp->get_height() == 720;
+            } );
+        if( rgb_profile == color_profiles.end() )
+        {
+            AC_LOG( ERROR,
+                "Can't find color stream corresponding to depth; AC will not work" );
+            return {};
+        }
+        return *rgb_profile;
+    }
+
     void l500_depth_sensor::open(const stream_profiles& requests)
     {
         try
         {
+            _user_requests = requests;
             _depth_invalidation_option->set_streaming(true);
 
             if (_depth_invalidation_enabled)
             {
-                auto is_ir_requested = std::find_if(requests.begin(), requests.end(), [](std::shared_ptr<stream_profile_interface> sp)
-                {return sp->get_stream_type() == RS2_STREAM_INFRARED;}) != requests.end();
+                auto is_ir_requested
+                    = std::find_if( requests.begin(),
+                                    requests.end(),
+                                    []( std::shared_ptr< stream_profile_interface > const & sp ) {
+                                        return sp->get_stream_type() == RS2_STREAM_INFRARED;
+                                    } )
+                   != requests.end();
 
                 _validator_requests = requests;
 
@@ -324,43 +519,18 @@ namespace librealsense
 
                     _validator_requests.push_back(*corresponding_ir);
                 }
-                _user_requests = requests;
             }
             else
             {
                 _validator_requests = requests;
             }
 
-            auto dp = std::find_if(requests.begin(), requests.end(), [](std::shared_ptr<stream_profile_interface> sp)
-            {return sp->get_stream_type() == RS2_STREAM_DEPTH;});
-
-            if( supports_option( RS2_OPTION_VISUAL_PRESET ) )
-            {
-                // We want to set the default preset to Max Range (make sure laser power is 100%)
-                // NOTE: This becomes the "default", meaning that in the viewer the user will see "default"
-                // (with power at 88, set by FW!) and, when the sensor is turned on, it will change to Max
-                // Power (with power at 100, again by FW). It's weird but acceptable.
-                // (see RS5-7780)
-                try
-                {
-                    auto&& preset_option = get_option( RS2_OPTION_VISUAL_PRESET );
-                    if( preset_option.query() == RS2_L500_VISUAL_PRESET_DEFAULT )
-                    {
-                        LOG_INFO( "Switching visual preset to MAX_RANGE by default" );
-                        preset_option.set( RS2_L500_VISUAL_PRESET_MAX_RANGE );
-                    }
-                }
-                catch( std::exception const & e )
-                {
-                    LOG_ERROR( "Caught exception while trying to set Max Range preset: " << e.what() );
-                }
-                catch( ... )
-                {
-                    LOG_ERROR( "Caught unknown exception while trying to set Max Range preset!" );
-                }
-            }
-
-            if (dp != requests.end() && supports_option(RS2_OPTION_SENSOR_MODE))
+            auto dp = std::find_if( requests.begin(),
+                                    requests.end(),
+                                    []( std::shared_ptr< stream_profile_interface > sp ) {
+                                        return sp->get_stream_type() == RS2_STREAM_DEPTH;
+                                    } );
+            if( dp != requests.end() && supports_option( RS2_OPTION_SENSOR_MODE ) )
             {
                 auto&& sensor_mode_option = get_option(RS2_OPTION_SENSOR_MODE);
                 auto vs = dynamic_cast<video_stream_profile*>((*dp).get());
@@ -375,17 +545,17 @@ namespace librealsense
                     }
                 }
                 
-                sensor_mode_option.set(get_resolution_from_width_height(vs->get_width(), vs->get_height()));
+                sensor_mode_option.set(float(get_resolution_from_width_height(vs->get_width(), vs->get_height())));
             }
 
-
             synthetic_sensor::open(_validator_requests);
         }
-        catch (...)
+        catch( ... )
         {
+            LOG_ERROR( "Exception caught in l500_depth_sensor::open" );
             _depth_invalidation_option->set_streaming(false);
             throw;
         }
     }
 
-}
+}  // namespace librealsense
diff --git a/src/l500/l500-depth.h b/src/l500/l500-depth.h
index af603b3..5615585 100644
--- a/src/l500/l500-depth.h
+++ b/src/l500/l500-depth.h
@@ -18,6 +18,7 @@
 #include "error-handling.h"
 #include "frame-validator.h"
 #include "l500-options.h"
+#include "calibrated-sensor.h"
 
 namespace librealsense
 {
@@ -83,43 +84,20 @@ namespace librealsense
         float _baseline;
     };
 
-    class l500_depth_sensor : public synthetic_sensor, public video_sensor_interface, public virtual depth_sensor, public virtual l500_depth_sensor_interface
+    class l500_depth_sensor
+        : public synthetic_sensor
+        , public video_sensor_interface
+        , public virtual depth_sensor
+        , public virtual l500_depth_sensor_interface
+        , public calibrated_sensor
     {
     public:
-        explicit l500_depth_sensor(l500_device* owner, std::shared_ptr<uvc_sensor> uvc_sensor, std::map<uint32_t,rs2_format> l500_depth_fourcc_to_rs2_format_map, std::map<uint32_t, rs2_stream> l500_depth_fourcc_to_rs2_stream_map)
-            : synthetic_sensor("L500 Depth Sensor", uvc_sensor, owner, l500_depth_fourcc_to_rs2_format_map, l500_depth_fourcc_to_rs2_stream_map), _owner(owner)
-        {
-#ifdef ENABLE_L500_DEPTH_INVALIDATION
-          _depth_invalidation_enabled = true;
-#else
-          _depth_invalidation_enabled = false;
-#endif
-           
-            register_option(RS2_OPTION_DEPTH_UNITS, std::make_shared<const_value_option>("Number of meters represented by a single depth unit",
-                lazy<float>([&]() {
-                return read_znorm(); })));
-
-            register_option(RS2_OPTION_DEPTH_OFFSET, std::make_shared<const_value_option>("Offset from sensor to depth origin in millimetrers",
-                lazy<float>([&]() {
-                return get_depth_offset(); })));
-
-            _depth_invalidation_option = std::make_shared<depth_invalidation_option>(
-                0,
-                1,
-                1,
-                0,
-                &_depth_invalidation_enabled,
-                "depth invalidation enabled");
-            _depth_invalidation_option->on_set([this](float val)
-            {
-                if (!_depth_invalidation_option->is_valid(val))
-                    throw invalid_value_exception(to_string()
-                        << "Unsupported depth invalidation enabled " << val << " is out of range.");
-            });
-
-            // The depth invalidation enable option is deprecated for now.
-            //register_option(static_cast<rs2_option>(RS2_OPTION_DEPTH_INVALIDATION_ENABLE), _depth_invalidation_option);
-        }
+        explicit l500_depth_sensor(
+            l500_device * owner,
+            std::shared_ptr< uvc_sensor > uvc_sensor,
+            std::map< uint32_t, rs2_format > l500_depth_sourcc_to_rs2_format_map,
+            std::map< uint32_t, rs2_stream > l500_depth_sourcc_to_rs2_stream_map
+        );
 
         std::vector<rs2_option> get_supported_options() const override
         {
@@ -171,16 +149,31 @@ namespace librealsense
 
             auto intrinsic_params = get_intrinsic_params(profile.width, profile.height, get_intrinsic());
 
-            rs2_intrinsics intrinsics;
+            rs2_intrinsics intrinsics = { 0 };
             intrinsics.width = intrinsic_params.pinhole_cam_model.width;
             intrinsics.height = intrinsic_params.pinhole_cam_model.height;
             intrinsics.fx = intrinsic_params.pinhole_cam_model.ipm.focal_length.x;
             intrinsics.fy = intrinsic_params.pinhole_cam_model.ipm.focal_length.y;
             intrinsics.ppx = intrinsic_params.pinhole_cam_model.ipm.principal_point.x;
             intrinsics.ppy = intrinsic_params.pinhole_cam_model.ipm.principal_point.y;
+
+            intrinsics.coeffs[0] = intrinsic_params.pinhole_cam_model.distort.radial_k1;
+            intrinsics.coeffs[1] = intrinsic_params.pinhole_cam_model.distort.radial_k2;
+            intrinsics.coeffs[2] = intrinsic_params.pinhole_cam_model.distort.tangential_p1;
+            intrinsics.coeffs[3] = intrinsic_params.pinhole_cam_model.distort.tangential_p2;
+            intrinsics.coeffs[4] = intrinsic_params.pinhole_cam_model.distort.radial_k3;
+
+            intrinsics.model = RS2_DISTORTION_NONE;
             return intrinsics;
         }
 
+        // calibrated_sensor
+        void override_intrinsics( rs2_intrinsics const & intr ) override;
+        void override_extrinsics( rs2_extrinsics const & extr ) override;
+        rs2_dsm_params get_dsm_params() const override;
+        void override_dsm_params( rs2_dsm_params const & dsm_params ) override;
+        void reset_calibration() override;
+
         stream_profiles init_stream_profiles() override
         {
             auto lock = environment::get_instance().get_extrinsics_graph().lock();
@@ -257,6 +250,8 @@ namespace librealsense
             return get_l500_recommended_proccesing_blocks();
         };
 
+        std::shared_ptr< stream_profile_interface > is_color_sensor_needed() const;
+
         int read_algo_version();
         float read_baseline() const override;
         float read_znorm();
@@ -267,7 +262,7 @@ namespace librealsense
         float get_depth_offset() const;
     private:
         action_delayer _action_delayer;
-        const l500_device* _owner;
+        l500_device * const _owner;
         float _depth_units;
         stream_profiles _user_requests;
         stream_profiles _validator_requests;
diff --git a/src/l500/l500-device.cpp b/src/l500/l500-device.cpp
index 9a1187f..b5b6df1 100644
--- a/src/l500/l500-device.cpp
+++ b/src/l500/l500-device.cpp
@@ -10,6 +10,7 @@
 #include "image.h"
 
 #include "l500-depth.h"
+#include "l500-color.h"
 #include "l500-private.h"
 
 #include "proc/decimation-filter.h"
@@ -22,6 +23,8 @@
 #include "proc/rotation-transform.h"
 #include "fw-update/fw-update-unsigned.h"
 #include "../common/fw/firmware-version.h"
+#include "ac-trigger.h"
+#include "algo/depth-to-rgb-calibration/debug.h"
 
 
 namespace librealsense
@@ -30,12 +33,14 @@ namespace librealsense
         { rs_fourcc('G','R','E','Y'), RS2_FORMAT_Y8 },
         { rs_fourcc('Z','1','6',' '), RS2_FORMAT_Z16 },
         { rs_fourcc('C',' ',' ',' '), RS2_FORMAT_RAW8 },
+        { rs_fourcc('C','N','F','4'), RS2_FORMAT_RAW8 },
     };
 
     std::map<uint32_t, rs2_stream> l500_depth_fourcc_to_rs2_stream = {
         { rs_fourcc('G','R','E','Y'), RS2_STREAM_INFRARED },
         { rs_fourcc('Z','1','6',' '), RS2_STREAM_DEPTH },
-        { rs_fourcc('C',' ',' ',' '), RS2_STREAM_CONFIDENCE }
+        { rs_fourcc('C',' ',' ',' '), RS2_STREAM_CONFIDENCE },
+        { rs_fourcc('C','N','F','4'), RS2_STREAM_CONFIDENCE },
     };
 
     using namespace ivcam2;
@@ -123,66 +128,126 @@ namespace librealsense
         register_info(RS2_CAMERA_INFO_PRODUCT_LINE, "L500");
         register_info(RS2_CAMERA_INFO_CAMERA_LOCKED, _is_locked ? "YES" : "NO");
 
-        std::shared_ptr< freefall_option > freefall_opt;
-        if( _fw_version >= firmware_version( "1.3.5.0" ) )
-        {
-            depth_sensor.register_option(
-                RS2_OPTION_FREEFALL_DETECTION_ENABLED,
-                freefall_opt = std::make_shared< freefall_option >( *_hw_monitor )
-            );
-        }
-        else
-        {
-            LOG_DEBUG( "Skipping Freefall control: requires FW 1.3.5" );
-        }
-        if( _fw_version >= firmware_version( "1.3.12.9" ) )
-        {
-            depth_sensor.register_option(
-                RS2_OPTION_INTER_CAM_SYNC_MODE,
-                std::make_shared< hw_sync_option >( *_hw_monitor, freefall_opt )
-            );
-        }
-        else
-        {
-            LOG_DEBUG( "Skipping HW Sync control: requires FW 1.3.12.9" );
-        }
+        configure_depth_options();
+    }
+
+
+    l500_depth_sensor & l500_device::get_depth_sensor()
+    {
+        return dynamic_cast<l500_depth_sensor &>(get_sensor( _depth_device_idx ));
     }
 
-    std::shared_ptr<synthetic_sensor> l500_device::create_depth_device(std::shared_ptr<context> ctx,
-        const std::vector<platform::uvc_device_info>& all_device_infos)
+
+    std::shared_ptr<synthetic_sensor> l500_device::create_depth_device( std::shared_ptr<context> ctx,
+        const std::vector<platform::uvc_device_info>& all_device_infos )
     {
         auto&& backend = ctx->get_backend();
 
         std::vector<std::shared_ptr<platform::uvc_device>> depth_devices;
-        for (auto&& info : filter_by_mi(all_device_infos, 0)) // Filter just mi=0, DEPTH
-            depth_devices.push_back(backend.create_uvc_device(info));
+        for( auto&& info : filter_by_mi( all_device_infos, 0 ) ) // Filter just mi=0, DEPTH
+            depth_devices.push_back( backend.create_uvc_device( info ) );
 
-        std::unique_ptr<frame_timestamp_reader> timestamp_reader_metadata(new l500_timestamp_reader_from_metadata(backend.create_time_service()));
-        auto enable_global_time_option = std::shared_ptr<global_time_option>(new global_time_option());
-        auto raw_depth_ep = std::make_shared<uvc_sensor>("Raw Depth Sensor", std::make_shared<platform::multi_pins_uvc_device>(depth_devices),
-            std::unique_ptr<frame_timestamp_reader>(new global_timestamp_reader(std::move(timestamp_reader_metadata), _tf_keeper, enable_global_time_option)), this);
-        raw_depth_ep->register_xu(depth_xu);
+        std::unique_ptr<frame_timestamp_reader> timestamp_reader_metadata( new l500_timestamp_reader_from_metadata( backend.create_time_service() ) );
+        auto enable_global_time_option = std::shared_ptr<global_time_option>( new global_time_option() );
+        auto raw_depth_ep = std::make_shared<uvc_sensor>( "Raw Depth Sensor", std::make_shared<platform::multi_pins_uvc_device>( depth_devices ),
+            std::unique_ptr<frame_timestamp_reader>( new global_timestamp_reader( std::move( timestamp_reader_metadata ), _tf_keeper, enable_global_time_option ) ), this );
+        raw_depth_ep->register_xu( depth_xu );
 
-        auto depth_ep = std::make_shared<l500_depth_sensor>(this, raw_depth_ep, l500_depth_fourcc_to_rs2_format, l500_depth_fourcc_to_rs2_stream);
-        
-        depth_ep->register_option(RS2_OPTION_GLOBAL_TIME_ENABLED, enable_global_time_option);
-        depth_ep->get_option(RS2_OPTION_GLOBAL_TIME_ENABLED).set(0);
+        auto depth_ep = std::make_shared<l500_depth_sensor>( this, raw_depth_ep, l500_depth_fourcc_to_rs2_format, l500_depth_fourcc_to_rs2_stream );
 
+        depth_ep->register_option( RS2_OPTION_GLOBAL_TIME_ENABLED, enable_global_time_option );
+        depth_ep->get_option( RS2_OPTION_GLOBAL_TIME_ENABLED ).set( 0 );
+
+        // NOTE: _fw_version is not yet initialized! Any additional options should get added from configure_depth_options()!
         depth_ep->register_info(RS2_CAMERA_INFO_PHYSICAL_PORT, filter_by_mi(all_device_infos, 0).front().device_path);
-       
+        return depth_ep;
+    }
+
+
+    /** This processing block removes all frames that are not of the given stream types
+     *
+     * This is only a workaround!!!
+     * It seems that, when definining a processing block outputs, if any other frames exist there
+     * then an issue can be exhibited where duplicate frames are produced. This solved the issue.
+     */
+    class filtering_processing_block : public generic_processing_block {
+        std::vector< rs2_stream > _streams;
+
+    public:
+        filtering_processing_block( rs2_stream stream_to_pass )
+            : generic_processing_block( "filtering_processing_block" ), _streams( 1, stream_to_pass ) {}
+        filtering_processing_block( std::initializer_list< rs2_stream > const & streams )
+            : generic_processing_block( "filtering_processing_block" ), _streams( streams ) {}
+
+        rs2::frame process_frame( const rs2::frame_source & source,
+                                  const rs2::frame & f ) override {
+            return f;
+        }
+
+    private:
+        bool should_process( const rs2::frame & f ) override {
+            auto fs = f.as< rs2::frameset >();
+            if( fs )
+                return false;  // we'll get the ndividual frames back by themselves:
+            auto it = std::find( _streams.begin(), _streams.end(), f.get_profile().stream_type() );
+            return ( it != _streams.end() );  // keep the frame only if one of those we got
+        }
+        rs2::frame prepare_output( const rs2::frame_source & source, rs2::frame input,
+                                   std::vector< rs2::frame > results ) override {
+            if( results.empty() )
+                return rs2::frame{};
+            return source.allocate_composite_frame(results);
+        }
+    };
+
+
+    void l500_device::configure_depth_options()
+    {
+        synthetic_sensor & depth_sensor = get_depth_sensor();
+
         auto is_zo_enabled_opt = std::make_shared<bool_option>();
         auto weak_is_zo_enabled_opt = std::weak_ptr<bool_option>(is_zo_enabled_opt);
         is_zo_enabled_opt->set(false);
-        depth_ep->register_option(RS2_OPTION_ZERO_ORDER_ENABLED, is_zo_enabled_opt);
+        depth_sensor.register_option(RS2_OPTION_ZERO_ORDER_ENABLED, is_zo_enabled_opt);
 
-        depth_ep->register_processing_block(
+        if( _fw_version >= firmware_version( "1.3.12.0" ) )
+        {
+            // TODO may not need auto-cal if there's no color sensor, like on the rs500...
+            _autocal = std::make_shared< ac_trigger >( *this, *_hw_monitor );
+
+            // Have the auto-calibration mechanism notify us when calibration has finished
+            _autocal->register_callback(
+                [&]( rs2_calibration_status status )
+                {
+                    if( status == RS2_CALIBRATION_SUCCESSFUL )
+                    {
+                        auto & color_sensor = *get_color_sensor();
+                        color_sensor.override_intrinsics( _autocal->get_intrinsics() );
+                        color_sensor.override_extrinsics( _autocal->get_extrinsics() );
+
+                        get_depth_sensor().override_dsm_params( _autocal->get_dsm_params() );
+                    }
+                    notify_of_calibration_change( status );
+                } );
+
+            depth_sensor.register_option(
+                RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH,
+                std::make_shared< ac_trigger::enabler_option >( _autocal )
+            );
+            depth_sensor.register_option(
+                RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH,
+                std::make_shared< ac_trigger::reset_option >( _autocal )
+            );
+        }
+
+        depth_sensor.register_processing_block(
             { {RS2_FORMAT_Z16}, {RS2_FORMAT_Y8} },
             { {RS2_FORMAT_Z16, RS2_STREAM_DEPTH, 0, 0, 0, 0, &rotate_resolution} },
-            [weak_is_zo_enabled_opt]() {
+            [=]() {
                 auto is_zo_enabled_opt = weak_is_zo_enabled_opt.lock();
                 auto z16rot = std::make_shared<rotation_transform>(RS2_FORMAT_Z16, RS2_STREAM_DEPTH, RS2_EXTENSION_DEPTH_FRAME);
                 auto y8rot = std::make_shared<rotation_transform>(RS2_FORMAT_Y8, RS2_STREAM_INFRARED, RS2_EXTENSION_VIDEO_FRAME);
-                auto sync = std::make_shared<syncer_process_unit>(is_zo_enabled_opt);
+                auto sync = std::make_shared<syncer_process_unit>(); // is_zo_enabled_opt );
                 auto zo = std::make_shared<zero_order>(is_zo_enabled_opt);
 
                 auto cpb = std::make_shared<composite_processing_block>();
@@ -190,19 +255,24 @@ namespace librealsense
                 cpb->add(y8rot);
                 cpb->add(sync);
                 cpb->add(zo);
-
+                if( _autocal )
+                {
+                    //sync->add_enabling_option( _autocal->get_enabler_opt() );
+                    cpb->add( std::make_shared< ac_trigger::depth_processing_block >( _autocal ) );
+                }
+                cpb->add( std::make_shared< filtering_processing_block >( RS2_STREAM_DEPTH ) );
                 return cpb;
             }
         );
 
-        depth_ep->register_processing_block(
+        depth_sensor.register_processing_block(
             { {RS2_FORMAT_Z16}, {RS2_FORMAT_Y8} },
             { {RS2_FORMAT_Z16, RS2_STREAM_DEPTH} },
-            [weak_is_zo_enabled_opt]() {
+            [=]() {
                 auto is_zo_enabled_opt = weak_is_zo_enabled_opt.lock();
                 auto z16rot = std::make_shared<identity_processing_block>();
                 auto y8rot = std::make_shared<identity_processing_block>();
-                auto sync = std::make_shared<syncer_process_unit>(is_zo_enabled_opt);
+                auto sync = std::make_shared<syncer_process_unit>(); // is_zo_enabled_opt );
                 auto zo = std::make_shared<zero_order>(is_zo_enabled_opt);
 
                 auto cpb = std::make_shared<composite_processing_block>();
@@ -210,23 +280,28 @@ namespace librealsense
                 cpb->add(y8rot);
                 cpb->add(sync);
                 cpb->add(zo);
-
+                if( _autocal )
+                {
+                    //sync->add_enabling_option( _autocal->get_enabler_opt() );
+                    cpb->add( std::make_shared< ac_trigger::depth_processing_block >( _autocal ) );
+                }
+                cpb->add( std::make_shared< filtering_processing_block >( RS2_STREAM_DEPTH ) );
                 return cpb;
             }
         );
 
-        depth_ep->register_processing_block(
+        depth_sensor.register_processing_block(
             { {RS2_FORMAT_Z16}, {RS2_FORMAT_Y8}, {RS2_FORMAT_RAW8} },
             {
                 {RS2_FORMAT_Z16, RS2_STREAM_DEPTH, 0, 0, 0, 0, &rotate_resolution},
                 {RS2_FORMAT_RAW8, RS2_STREAM_CONFIDENCE, 0, 0, 0, 0, &l500_confidence_resolution}
             },
-            [weak_is_zo_enabled_opt]() {
+            [=]() {
                 auto is_zo_enabled_opt = weak_is_zo_enabled_opt.lock();
                 auto z16rot = std::make_shared<rotation_transform>(RS2_FORMAT_Z16, RS2_STREAM_DEPTH, RS2_EXTENSION_DEPTH_FRAME);
                 auto y8rot = std::make_shared<rotation_transform>(RS2_FORMAT_Y8, RS2_STREAM_INFRARED, RS2_EXTENSION_VIDEO_FRAME);
                 auto conf = std::make_shared<confidence_rotation_transform>();
-                auto sync = std::make_shared<syncer_process_unit>(is_zo_enabled_opt);
+                auto sync = std::make_shared<syncer_process_unit>(); // is_zo_enabled_opt );
                 auto zo = std::make_shared<zero_order>(is_zo_enabled_opt);
 
                 auto cpb = std::make_shared<composite_processing_block>();
@@ -235,28 +310,85 @@ namespace librealsense
                 cpb->add(conf);
                 cpb->add(sync);
                 cpb->add(zo);
-
+                if( _autocal )
+                {
+                    //sync->add_enabling_option( _autocal->get_enabler_opt() );
+                    cpb->add( std::make_shared< ac_trigger::depth_processing_block >( _autocal ) );
+                }
+                cpb->add( std::shared_ptr< filtering_processing_block >(
+                    new filtering_processing_block{RS2_STREAM_DEPTH, RS2_STREAM_CONFIDENCE} ) );
                 return cpb;
             }
         );
 
-        depth_ep->register_processing_block(
+        depth_sensor.register_processing_block(
             { {RS2_FORMAT_Y8} },
             { {RS2_FORMAT_Y8, RS2_STREAM_INFRARED, 0, 0, 0, 0, &rotate_resolution} },
             []() { return std::make_shared<rotation_transform>(RS2_FORMAT_Y8, RS2_STREAM_INFRARED, RS2_EXTENSION_VIDEO_FRAME); }
         );
 
-        depth_ep->register_processing_block(processing_block_factory::create_id_pbf(RS2_FORMAT_Y8, RS2_STREAM_INFRARED));
+        depth_sensor.register_processing_block(processing_block_factory::create_id_pbf(RS2_FORMAT_Y8, RS2_STREAM_INFRARED));
 
-        depth_ep->register_processing_block(
+        depth_sensor.register_processing_block(
             { {RS2_FORMAT_RAW8} },
             { {RS2_FORMAT_RAW8, RS2_STREAM_CONFIDENCE, 0, 0, 0, 0, &l500_confidence_resolution} },
             []() { return std::make_shared<confidence_rotation_transform>(); }
         );
 
-        depth_ep->register_processing_block(processing_block_factory::create_id_pbf(RS2_FORMAT_RAW8, RS2_STREAM_CONFIDENCE));
+        depth_sensor.register_processing_block(processing_block_factory::create_id_pbf(RS2_FORMAT_RAW8, RS2_STREAM_CONFIDENCE));
 
-        return depth_ep;
+        std::shared_ptr< freefall_option > freefall_opt;
+        if( _fw_version >= firmware_version( "1.3.5.0" ) )
+        {
+            depth_sensor.register_option(
+                RS2_OPTION_FREEFALL_DETECTION_ENABLED,
+                freefall_opt = std::make_shared< freefall_option >( *_hw_monitor )
+            );
+        }
+        else
+        {
+            LOG_DEBUG( "Skipping Freefall control: requires FW 1.3.5" );
+        }
+        if( _fw_version >= firmware_version( "1.3.12.9" ) )
+        {
+            depth_sensor.register_option(
+                RS2_OPTION_INTER_CAM_SYNC_MODE,
+                std::make_shared< hw_sync_option >( *_hw_monitor, freefall_opt )
+            );
+        }
+        else
+        {
+            LOG_DEBUG( "Skipping HW Sync control: requires FW 1.3.12.9" );
+        }
+    }
+
+    void l500_device::notify_of_calibration_change( rs2_calibration_status status )
+    {
+        std::time_t now = std::time( nullptr );
+        auto ptm = localtime( &now );
+        char buf[256];
+        strftime( buf, sizeof( buf ), "%T", ptm );
+        AC_LOG( DEBUG, ".,_,.-'``'-.,_,.-'``'-   " << buf << "   status= " << status );
+        for( auto&& cb : _calibration_change_callbacks )
+            cb->on_calibration_change( status );
+    }
+
+    void l500_device::trigger_device_calibration( rs2_calibration_type type )
+    {
+        if( type != RS2_CALIBRATION_DEPTH_TO_RGB )
+            throw not_implemented_exception(
+                to_string() << "unsupported calibration type (" << type << ")" );
+
+        if( !_autocal )
+            throw not_implemented_exception(
+                to_string() << "the current firmware version (" << _fw_version
+                            << ") does not support depth-to-rgb calibration" );
+
+        if( _autocal->is_active() )
+            throw wrong_api_call_sequence_exception( "Camera Accuracy Health is already active" );
+
+        AC_LOG( INFO, "Camera Accuracy Health has been manually triggered" );
+        _autocal->trigger_calibration();
     }
 
     void l500_device::force_hardware_reset() const
@@ -364,19 +496,19 @@ namespace librealsense
 
     void l500_device::update_flash_section(std::shared_ptr<hw_monitor> hwm, const std::vector<uint8_t>& image, uint32_t offset, uint32_t size, update_progress_callback_ptr callback, float continue_from, float ratio)
     {
-        size_t sector_count = size / ivcam2::FLASH_SECTOR_SIZE;
-        size_t first_sector = offset / ivcam2::FLASH_SECTOR_SIZE;
+        int sector_count = int( size / ivcam2::FLASH_SECTOR_SIZE );
+        int first_sector = int( offset / ivcam2::FLASH_SECTOR_SIZE );
 
         if (sector_count * ivcam2::FLASH_SECTOR_SIZE != size)
             sector_count++;
 
         sector_count += first_sector;
 
-        for (size_t sector_index = first_sector; sector_index < sector_count; sector_index++)
+        for (int sector_index = first_sector; sector_index < sector_count; sector_index++)
         {
             command cmdFES(ivcam2::FES);
             cmdFES.require_response = false;
-            cmdFES.param1 = sector_index;
+            cmdFES.param1 = int(sector_index);
             cmdFES.param2 = 1;
             auto res = hwm->send(cmdFES);
 
@@ -388,7 +520,7 @@ namespace librealsense
                 int packet_size = std::min((int)(HW_MONITOR_COMMAND_SIZE - (i % HW_MONITOR_COMMAND_SIZE)), (int)(ivcam2::FLASH_SECTOR_SIZE - i));
                 command cmdFWB(ivcam2::FWB);
                 cmdFWB.require_response = false;
-                cmdFWB.param1 = index;
+                cmdFWB.param1 = int(index);
                 cmdFWB.param2 = packet_size;
                 cmdFWB.data.assign(image.data() + index, image.data() + index + packet_size);
                 res = hwm->send(cmdFWB);
@@ -404,7 +536,7 @@ namespace librealsense
         update_progress_callback_ptr callback, float continue_from, float ratio)
     {
         auto first_table_offset = fs.tables.front().offset;
-        float total_size = fs.app_size + tables_size;
+        float total_size = float(fs.app_size + tables_size);
 
         float app_ratio = fs.app_size / total_size * ratio;
         float tables_ratio = tables_size / total_size * ratio;
@@ -422,7 +554,7 @@ namespace librealsense
         // update read-write section
         auto first_table_offset = flash_image_info.read_write_section.tables.front().offset;
         auto tables_size = flash_image_info.header.read_write_start_address + flash_image_info.header.read_write_size - first_table_offset;
-        update_section(hwm, merged_image, flash_image_info.read_write_section, tables_size, callback, 0, update_mode == RS2_UNSIGNED_UPDATE_MODE_READ_ONLY ? 0.5 : 1.0);
+        update_section(hwm, merged_image, flash_image_info.read_write_section, tables_size, callback, 0, update_mode == RS2_UNSIGNED_UPDATE_MODE_READ_ONLY ? 0.5f : 1.f);
 
         if (update_mode == RS2_UNSIGNED_UPDATE_MODE_READ_ONLY)
         {
@@ -467,6 +599,16 @@ namespace librealsense
         });
     }
 
+    command l500_device::get_firmware_logs_command() const
+    {
+        return command{ ivcam2::GLD, 0x1f4 };
+    }
+
+    command l500_device::get_flash_logs_command() const
+    {
+        return command{ ivcam2::FRB, 0x0011E000, 0x3f8 };
+    }
+
     notification l500_notification_decoder::decode(int value)
     {
         if (l500_fw_error_report.find(static_cast<uint8_t>(value)) != l500_fw_error_report.end())
diff --git a/src/l500/l500-device.h b/src/l500/l500-device.h
index 73a62a1..431c477 100644
--- a/src/l500/l500-device.h
+++ b/src/l500/l500-device.h
@@ -16,11 +16,19 @@
 #include "error-handling.h"
 #include "global_timestamp_reader.h"
 #include "fw-update/fw-update-device-interface.h"
+#include "device-calibration.h"
 
 namespace librealsense
 {
-
-    class l500_device : public virtual device, public debug_interface, public global_time_interface, public updatable
+    class l500_depth_sensor;
+    class l500_color_sensor;
+
+    class l500_device
+        : public virtual device
+        , public debug_interface
+        , public global_time_interface
+        , public updatable
+        , public device_calibration
     {
     public:
         l500_device(std::shared_ptr<context> ctx,
@@ -29,14 +37,27 @@ namespace librealsense
         std::shared_ptr<synthetic_sensor> create_depth_device(std::shared_ptr<context> ctx,
             const std::vector<platform::uvc_device_info>& all_device_infos);
 
-        synthetic_sensor& get_depth_sensor() { return dynamic_cast<synthetic_sensor&>(get_sensor(_depth_device_idx)); }
+        virtual void configure_depth_options();
+
+        virtual l500_color_sensor * get_color_sensor() = 0;
 
+        synthetic_sensor & get_synthetic_depth_sensor() { return dynamic_cast< synthetic_sensor &>(get_sensor( _depth_device_idx )); }
+        l500_depth_sensor & get_depth_sensor();
         uvc_sensor& get_raw_depth_sensor()
         {
-            synthetic_sensor& depth_sensor = get_depth_sensor();
+            synthetic_sensor& depth_sensor = get_synthetic_depth_sensor();
             return dynamic_cast<uvc_sensor&>(*depth_sensor.get_raw_sensor());
         }
 
+        void register_calibration_change_callback( calibration_change_callback_ptr callback ) override
+        {
+            _calibration_change_callbacks.push_back( callback );
+        }
+
+        void trigger_device_calibration( rs2_calibration_type ) override;
+
+        void notify_of_calibration_change( rs2_calibration_status status );
+
         std::vector<uint8_t> send_receive_raw_data(const std::vector<uint8_t>& input) override
         {
             return _hw_monitor->send(input);
@@ -74,11 +95,19 @@ namespace librealsense
         std::shared_ptr<stream_interface> _depth_stream;
         std::shared_ptr<stream_interface> _ir_stream;
         std::shared_ptr<stream_interface> _confidence_stream;
+        
+        std::shared_ptr< ivcam2::ac_trigger > _autocal;
 
         void force_hardware_reset() const;
         bool _is_locked = true;
 
+        //TODO - add these to device class as pure virtual methods
+        command get_firmware_logs_command() const;
+        command get_flash_logs_command() const;
+
         std::vector<rs2_option> _advanced_options;
+
+        std::vector< calibration_change_callback_ptr > _calibration_change_callbacks;
     };
 
     class l500_notification_decoder : public notification_decoder
diff --git a/src/l500/l500-factory.cpp b/src/l500/l500-factory.cpp
index 4bd7d2b..9a57345 100644
--- a/src/l500/l500-factory.cpp
+++ b/src/l500/l500-factory.cpp
@@ -11,6 +11,7 @@
 #include "context.h"
 #include "image.h"
 #include "metadata-parser.h"
+#include "../firmware_logger_device.h"
 
 #include "l500-factory.h"
 #include "l500-depth.h"
@@ -18,6 +19,8 @@
 #include "l500-color.h"
 #include "l500-serializable.h"
 
+#include "../firmware_logger_device.h"
+
 namespace librealsense
 {
     using namespace ivcam2;
@@ -27,7 +30,8 @@ namespace librealsense
         public l500_options,
         public l500_color,
         public l500_motion,
-        public l500_serializable
+        public l500_serializable,
+        public firmware_logger_device
     {
     public:
         rs515_device(std::shared_ptr<context> ctx,
@@ -39,7 +43,10 @@ namespace librealsense
             l500_options(ctx, group),
             l500_color(ctx, group),
             l500_motion(ctx, group),
-            l500_serializable(_hw_monitor, get_depth_sensor())
+            l500_serializable(l500_device::_hw_monitor, get_depth_sensor()),
+            firmware_logger_device(ctx, group, l500_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command())
         {}
 
         std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
@@ -59,7 +66,8 @@ namespace librealsense
     };
 
     // l500
-    class rs500_device : public l500_depth
+    class rs500_device : public l500_depth,
+        public firmware_logger_device
     {
     public:
         rs500_device(std::shared_ptr<context> ctx,
@@ -67,11 +75,15 @@ namespace librealsense
             bool register_device_notifications)
             : device(ctx, group, register_device_notifications),
             l500_device(ctx, group),
-            l500_depth(ctx, group)
+            l500_depth(ctx, group),
+            firmware_logger_device(ctx, group,l500_device::_hw_monitor,
+                get_firmware_logs_command(),
+                get_flash_logs_command())
         {}
 
-        std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
+        l500_color_sensor * get_color_sensor() override { return nullptr; }
 
+        std::shared_ptr<matcher> create_matcher(const frame_holder& frame) const override;
     };
 
     std::shared_ptr<device_interface> l500_info::create(std::shared_ptr<context> ctx,
@@ -111,12 +123,12 @@ namespace librealsense
                 platform::usb_device_info hwm;
 
                 if (!ivcam2::try_fetch_usb_device(group.usb_devices, depth, hwm))
-                    LOG_WARNING("try_fetch_usb_device(...) failed.");
+                    LOG_DEBUG("try_fetch_usb_device(...) failed.");
 
                 if(g.first[0].pid != L500_PID)
                     if (g.second.size() < 2)
                     {
-                        LOG_WARNING("L500 partial enum: " << g.second.size() << " HID devices were recognized (2+ expected)");
+                        LOG_DEBUG("L500 partial enum: " << g.second.size() << " HID devices were recognized (2+ expected)");
 #if !defined(ANDROID) && !defined(__APPLE__) // Not supported by android & macos
                         continue;
 #endif // Not supported by android & macos
@@ -128,7 +140,7 @@ namespace librealsense
             }
             else
             {
-                LOG_WARNING("L500 group_devices is empty.");
+                LOG_DEBUG("L500 group_devices is empty.");
             }
         }
 
@@ -149,6 +161,7 @@ namespace librealsense
 
     std::shared_ptr<matcher> rs515_device::create_matcher(const frame_holder & frame) const
     {
+        LOG_DEBUG( "rs515_device::create_matcher" );
         std::vector<std::shared_ptr<matcher>> depth_rgb_matchers = { l500_depth::create_matcher(frame),
             std::make_shared<identity_matcher>(_color_stream->get_unique_id(), _color_stream->get_stream_type())};
 
diff --git a/src/l500/l500-motion.cpp b/src/l500/l500-motion.cpp
index 2504257..eb2c9cd 100644
--- a/src/l500/l500-motion.cpp
+++ b/src/l500/l500-motion.cpp
@@ -117,16 +117,31 @@ namespace librealsense
         hid_ep->get_option(RS2_OPTION_GLOBAL_TIME_ENABLED).set(0);
         hid_ep->register_option(RS2_OPTION_GLOBAL_TIME_ENABLED, enable_global_time_option);
 
+        // register pre-processing
+        std::shared_ptr<enable_motion_correction> mm_correct_opt = nullptr;
+
+        //  Motion intrinsic calibration presents is a prerequisite for motion correction.
+        try
+        {
+            // L515 motion correction with IMU supported from FW version 01.04.01.00
+            if (_fw_version >= firmware_version("1.4.1.0") && _mm_calib)
+            {
+                mm_correct_opt = std::make_shared<enable_motion_correction>(hid_ep.get(), option_range{ 0, 1, 1, 1 });
+                hid_ep->register_option(RS2_OPTION_ENABLE_MOTION_CORRECTION, mm_correct_opt);
+            }
+        }
+        catch (...) {}
+
         hid_ep->register_processing_block(
             { {RS2_FORMAT_MOTION_XYZ32F, RS2_STREAM_ACCEL} },
             { {RS2_FORMAT_MOTION_XYZ32F, RS2_STREAM_ACCEL} },
-            []() { return std::make_shared<acceleration_transform>(); }
+            [&, mm_correct_opt]() { return std::make_shared<acceleration_transform>(_mm_calib, mm_correct_opt); }
         );
 
         hid_ep->register_processing_block(
             { {RS2_FORMAT_MOTION_XYZ32F, RS2_STREAM_GYRO} },
             { {RS2_FORMAT_MOTION_XYZ32F, RS2_STREAM_GYRO} },
-            []() { return std::make_shared<gyroscope_transform>(); }
+            [&, mm_correct_opt]() { return std::make_shared<gyroscope_transform>(_mm_calib, mm_correct_opt); }
         );
 
         return hid_ep;
@@ -137,6 +152,28 @@ namespace librealsense
           _accel_stream(new stream(RS2_STREAM_ACCEL)),
          _gyro_stream(new stream(RS2_STREAM_GYRO))
     {
+        std::vector<platform::hid_device_info> hid_infos = group.hid_devices;
+
+        if (!hid_infos.empty())
+        {
+            // product id
+            _pid = static_cast<uint16_t>(strtoul(hid_infos.front().pid.data(), nullptr, 16));
+
+            // motion correction
+            _mm_calib = std::make_shared<mm_calib_handler>(_hw_monitor, _pid);
+            _accel_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_ACCEL); });
+            _gyro_intrinsic = std::make_shared<lazy<ds::imu_intrinsic>>([this]() { return _mm_calib->get_intrinsic(RS2_STREAM_GYRO); });
+
+            // use predefined extrinsics
+            _depth_to_imu = std::make_shared<lazy<rs2_extrinsics>>([this]() { return _mm_calib->get_extrinsic(RS2_STREAM_ACCEL); });
+        }
+
+        // Make sure all MM streams are positioned with the same extrinsics
+        environment::get_instance().get_extrinsics_graph().register_extrinsics(*_depth_stream, *_accel_stream, _depth_to_imu);
+        environment::get_instance().get_extrinsics_graph().register_same_extrinsics(*_accel_stream, *_gyro_stream);
+        register_stream_to_extrinsic_group(*_gyro_stream, 0);
+        register_stream_to_extrinsic_group(*_accel_stream, 0);
+
         auto hid_ep = create_hid_device(ctx, group.hid_devices);
         if (hid_ep)
         {
@@ -155,8 +192,15 @@ namespace librealsense
         return tags;
     }
 
-    rs2_motion_device_intrinsic l500_motion::get_motion_intrinsics(rs2_stream) const
+    rs2_motion_device_intrinsic l500_motion::get_motion_intrinsics(rs2_stream stream) const
     {
-        return rs2_motion_device_intrinsic();
+        if (stream == RS2_STREAM_ACCEL)
+            return create_motion_intrinsics(**_accel_intrinsic);
+
+        if (stream == RS2_STREAM_GYRO)
+            return create_motion_intrinsics(**_gyro_intrinsic);
+
+        throw std::runtime_error(to_string() << "Motion Intrinsics unknown for stream " << rs2_stream_to_string(stream) << "!");
+
     }
 }
diff --git a/src/l500/l500-motion.h b/src/l500/l500-motion.h
index aaa276e..a12d119 100644
--- a/src/l500/l500-motion.h
+++ b/src/l500/l500-motion.h
@@ -8,6 +8,7 @@
 #include "device.h"
 #include "stream.h"
 #include "l500/l500-device.h"
+#include "../ds5/ds5-motion.h"
 
 namespace librealsense
 {
@@ -22,7 +23,7 @@ namespace librealsense
 
         std::vector<tagged_profile> get_profiles_tags() const override;
 
-        rs2_motion_device_intrinsic get_motion_intrinsics(rs2_stream) const;
+        rs2_motion_device_intrinsic get_motion_intrinsics(rs2_stream stream) const;
 
     private:
 
@@ -30,6 +31,13 @@ namespace librealsense
 
         optional_value<uint8_t> _motion_module_device_idx;
 
+        std::shared_ptr<mm_calib_handler>        _mm_calib;
+        std::shared_ptr<lazy<ds::imu_intrinsic>> _accel_intrinsic;
+        std::shared_ptr<lazy<ds::imu_intrinsic>> _gyro_intrinsic;
+        std::shared_ptr<lazy<rs2_extrinsics>>   _depth_to_imu;                  // Mechanical installation pose
+
+        uint16_t _pid;    // product PID
+
     protected:
         std::shared_ptr<stream_interface> _accel_stream;
         std::shared_ptr<stream_interface> _gyro_stream;
diff --git a/src/l500/l500-options.cpp b/src/l500/l500-options.cpp
index b6838bf..a9b06a7 100644
--- a/src/l500/l500-options.cpp
+++ b/src/l500/l500-options.cpp
@@ -13,7 +13,7 @@ namespace librealsense
 
     float l500_hw_options::query() const
     {
-        return query(_resolution->query());
+        return query(int(_resolution->query()));
     }
 
     void l500_hw_options::set(float value)
@@ -35,7 +35,7 @@ namespace librealsense
         auto max = _hw_monitor->send(command{ AMCGET, _type, get_max });
         auto step = _hw_monitor->send(command{ AMCGET, _type, get_step });
 
-        auto def = query(_resolution->query());
+        auto def = query(int(_resolution->query()));
 
         if (min.size() < sizeof(int32_t) || max.size() < sizeof(int32_t) || step.size() < sizeof(int32_t))
         {
@@ -44,8 +44,17 @@ namespace librealsense
             throw std::runtime_error(s.str());
         }
 
-        _range = option_range{ float(*(reinterpret_cast<int32_t*>(min.data()))),
-            float(*(reinterpret_cast<int32_t*>(max.data()))),
+        auto max_value = float(*(reinterpret_cast<int32_t*>(max.data())));
+        auto min_value = float(*(reinterpret_cast<int32_t*>(min.data())));
+
+        if (type == noise_filtering) 
+        {
+            // Hack until addressed in firmware
+            min_value = std::min(max_value, std::max(min_value, 2.f));
+        }
+
+        _range = option_range{ min_value,
+            max_value,
             float(*(reinterpret_cast<int32_t*>(step.data()))),
             def };
     }
@@ -65,7 +74,7 @@ namespace librealsense
         }
 
         auto val = *(reinterpret_cast<int32_t*>((void*)res.data()));
-        return val;
+        return float(val);
     }
 
     l500_options::l500_options(std::shared_ptr<context> ctx, const platform::backend_device_group & group) :
@@ -80,12 +89,12 @@ namespace librealsense
             depth_sensor.register_option
             (RS2_OPTION_VISUAL_PRESET, std::make_shared<uvc_xu_option<int >>(raw_depth_sensor, ivcam2::depth_xu, ivcam2::L500_AMBIENT,
                 "Change the depth ambient light to ambient: 1 for no ambient and 2 for low ambient",
-                std::map<float, std::string>{ { RS2_AMBIENT_LIGHT_NO_AMBIENT, "No Ambient"},
-                { RS2_AMBIENT_LIGHT_LOW_AMBIENT, "Low Ambient" }}));
+                std::map<float, std::string>{ { float(RS2_AMBIENT_LIGHT_NO_AMBIENT), "No Ambient"},
+                { float(RS2_AMBIENT_LIGHT_LOW_AMBIENT), "Low Ambient" }}));
         }
         else
         {
-            auto resolution_option = std::make_shared<float_option_with_description<rs2_sensor_mode>>(option_range{ RS2_SENSOR_MODE_VGA,RS2_SENSOR_MODE_XGA,1, RS2_SENSOR_MODE_XGA }, "Notify the sensor about the intended streaming mode. Required for preset ");
+            auto resolution_option = std::make_shared<float_option_with_description<rs2_sensor_mode>>(option_range{ RS2_SENSOR_MODE_VGA,RS2_SENSOR_MODE_COUNT - 1,1, RS2_SENSOR_MODE_XGA }, "Notify the sensor about the intended streaming mode. Required for preset ");
 
             depth_sensor.register_option(RS2_OPTION_SENSOR_MODE, resolution_option);
 
@@ -142,7 +151,8 @@ namespace librealsense
 
     void l500_options::change_preset(rs2_l500_visual_preset preset)
     {
-        if (preset != RS2_L500_VISUAL_PRESET_CUSTOM)
+        if ((preset != RS2_L500_VISUAL_PRESET_CUSTOM) &&
+            (preset != RS2_L500_VISUAL_PRESET_DEFAULT))
             reset_hw_controls();
 
         switch (preset)
@@ -164,6 +174,12 @@ namespace librealsense
         case RS2_L500_VISUAL_PRESET_CUSTOM:
             move_to_custom();
             break;
+        case RS2_L500_VISUAL_PRESET_DEFAULT:
+            LOG_ERROR("L515 Visual Preset option cannot be changed to Default");
+            throw  invalid_value_exception(to_string() << "The Default preset signifies that the controls have not been changed \n"
+                                                           "since initialization, the API does not support changing back to this state.\n"
+                                                           "Please choose one of the other presets");
+            break;
         default: break;
         };
     }
diff --git a/src/l500/l500-options.h b/src/l500/l500-options.h
index 3ba9af6..74ff812 100644
--- a/src/l500/l500-options.h
+++ b/src/l500/l500-options.h
@@ -77,7 +77,7 @@ namespace librealsense
         template<typename T, class ... Args>
         std::shared_ptr<cascade_option<T>> register_option(rs2_option opt, Args... args)
         {
-            auto& depth_sensor = get_depth_sensor();
+            auto& depth_sensor = get_synthetic_depth_sensor();
 
             auto signaled_opt = std::make_shared <cascade_option<T>>(std::forward<Args>(args)...);
             signaled_opt->add_observer([opt, this](float val) {on_set_option(opt, val);});
diff --git a/src/l500/l500-private.cpp b/src/l500/l500-private.cpp
index f38183d..e91d439 100644
--- a/src/l500/l500-private.cpp
+++ b/src/l500/l500-private.cpp
@@ -2,7 +2,16 @@
 //// Copyright(c) 2018 Intel Corporation. All Rights Reserved.
 
 #include "l500-private.h"
+#include "l500-device.h"
+#include "l500-color.h"
+#include "l500-depth.h"
 #include "fw-update/fw-update-unsigned.h"
+#include "context.h"
+#include "core/video.h"
+#include "depth-to-rgb-calibration.h"
+#include "log.h"
+#include <chrono>
+#include "algo/depth-to-rgb-calibration/debug.h"
 
 using namespace std;
 
@@ -10,20 +19,23 @@ namespace librealsense
 {
     namespace ivcam2
     {
-        pose get_color_stream_extrinsic(const std::vector<uint8_t>& raw_data)
+        const int ac_depth_results::table_id;
+        const uint16_t ac_depth_results::this_version;
+        
+        const uint16_t rgb_calibration_table::table_id;
+        const uint16_t rgb_calibration_table::eeprom_table_id;
+
+
+        rs2_extrinsics get_color_stream_extrinsic(const std::vector<uint8_t>& raw_data)
         {
             if (raw_data.size() < sizeof(pose))
                 throw invalid_value_exception("size of extrinsic invalid");
-            auto res = *((pose*)raw_data.data());
-            float trans_scale = 0.001f; // Convert units from mm to meter
-
-            if (res.position.y > 0.f) // Extrinsic of color is referenced to the Depth Sensor CS
-                trans_scale *= -1;
-
-            res.position.x *= trans_scale;
-            res.position.y *= trans_scale;
-            res.position.z *= trans_scale;
-            return res;
+            
+            assert( sizeof( pose ) == sizeof( rs2_extrinsics ) );
+            auto res = *(rs2_extrinsics*)raw_data.data();
+            AC_LOG( DEBUG, "raw extrinsics data from camera:\n" << std::setprecision(15) << res );
+            
+            return from_raw_extrinsics(res);
         }
 
         bool try_fetch_usb_device(std::vector<platform::usb_device_info>& devices,
@@ -64,16 +76,6 @@ namespace librealsense
             if (!is_enabled())
                 throw wrong_api_call_sequence_exception("query option is allow only in streaming!");
 
-#pragma pack(push, 1)
-            struct temperatures
-            {
-                double LLD_temperature;
-                double MC_temperature;
-                double MA_temperature;
-                double APD_temperature;
-            };
-#pragma pack(pop)
-
             auto res = _hw_monitor->send(command{ TEMPERATURES_GET });
 
             if (res.size() < sizeof(temperatures))
@@ -86,7 +88,7 @@ namespace librealsense
             switch (_option)
             {
             case RS2_OPTION_LLD_TEMPERATURE:
-                return float(temperature_data.LLD_temperature);
+                return float(temperature_data.LDD_temperature);
             case RS2_OPTION_MC_TEMPERATURE:
                 return float(temperature_data.MC_temperature);
             case RS2_OPTION_MA_TEMPERATURE:
@@ -195,5 +197,7 @@ namespace librealsense
             auto res = _hwm.send( cmd );
             _record_action( *this );
         }
+
+
     } // librealsense::ivcam2
 } // namespace librealsense
diff --git a/src/l500/l500-private.h b/src/l500/l500-private.h
index 714190c..3bd338d 100644
--- a/src/l500/l500-private.h
+++ b/src/l500/l500-private.h
@@ -6,6 +6,7 @@
 #include "backend.h"
 #include "types.h"
 #include "option.h"
+#include "core/extension.h"
 #include "fw-update/fw-update-unsigned.h"
 
 static const int NUM_OF_RGB_RESOLUTIONS = 5;
@@ -18,6 +19,8 @@ namespace librealsense
     const uint16_t L515_PID_PRE_PRQ     = 0x0b3d;
     const uint16_t L515_PID             = 0x0b64;
 
+    class l500_device;
+
     namespace ivcam2
     {
         // L500 depth XU identifiers
@@ -39,6 +42,8 @@ namespace librealsense
 
         const int REGISTER_CLOCK_0 = 0x9003021c;
 
+        const uint16_t L515_IMU_TABLE   = 0x0243;  // IMU calibration table on L515
+
         enum fw_cmd : uint8_t
         {
             MRD                         = 0x01, //"Read Tensilica memory ( 32bit ). Output : 32bit dump"
@@ -53,15 +58,159 @@ namespace librealsense
             HW_RESET                    = 0x20, //"HW Reset"
             AMCSET                      = 0x2B, // Set options (L515)
             AMCGET                      = 0x2C, // Get options (L515)
+            DELETE_TABLE                = 0x2E,
             PFD                         = 0x3B, // Disable power features <Parameter1 Name="0 - Disable, 1 - Enable" />
+            READ_TABLE                  = 0x43, // read table from flash, for example, read imu calibration table, read_table 0x243 0
+            WRITE_TABLE                 = 0x44,
             DPT_INTRINSICS_GET          = 0x5A,
             TEMPERATURES_GET            = 0x6A,
             DPT_INTRINSICS_FULL_GET     = 0x7F,
             RGB_INTRINSIC_GET           = 0x81,
             RGB_EXTRINSIC_GET           = 0x82,
             FALL_DETECT_ENABLE          = 0x9D, // Enable (by default) free-fall sensor shutoff (0=disable; 1=enable)
+            GET_SPECIAL_FRAME           = 0xA0  // Request auto-calibration (0) special frames (#)
+        };
+
+#pragma pack(push, 1)
+        // Table header returned by READ_TABLE before the actual table data
+        struct table_header
+        {
+            uint8_t                 major;
+            uint8_t                 minor;
+            uint16_t                table_id;
+            uint32_t                table_size;     // full size including: TOC header + TOC + actual tables
+            uint32_t                reserved;       // 0xFFFFFFFF
+            uint32_t                crc32;          // crc of all the actual table data excluding header/CRC
+        };
+#pragma pack(pop)
+
+        // Read a table from firmware and, if FW says the table is empty, optionally initialize it
+        // using your own code...
+        template< typename T >
+        void read_fw_table( hw_monitor & hwm,
+                            int table_id, T * ptable,
+                            table_header * pheader = nullptr,
+                            std::function< void() > init = nullptr )
+        {
+            command cmd( fw_cmd::READ_TABLE, table_id );
+            hwmon_response response;
+            std::vector<byte> data = hwm.send( cmd, &response );
+            size_t expected_size = sizeof( table_header ) + sizeof( T );
+            switch( response )
+            {
+            case hwm_Success:
+                if( data.size() != expected_size )
+                    throw std::runtime_error( to_string()
+                                              << "READ_TABLE (0x" << std::hex << table_id
+                                              << std::dec << ") data size received= " << data.size()
+                                              << " (expected " << expected_size << ")" );
+                if( pheader )
+                    *pheader = *(table_header *)data.data();
+                if( ptable )
+                    *ptable = *(T *)(data.data() + sizeof( table_header ));
+                break;
+
+            case hwm_TableIsEmpty:
+                if( init )
+                {
+                    // Initialize a new table
+                    init();
+                    break;
+                }
+                // fall-thru!
+                
+            default:
+                LOG_DEBUG( "Failed to read FW table 0x" << std::hex << table_id );
+                throw invalid_value_exception( hwmon_error_string( cmd, response ) );
+            }
+        }
+
+        // Write a table to firmware
+        template< typename T >
+        void write_fw_table( hw_monitor & hwm, uint16_t const table_id, T const & table )
+        {
+            command cmd( fw_cmd::WRITE_TABLE, 0 );
+            cmd.data.resize( sizeof( table_header ) + sizeof( table ) );
+
+            table_header * h = (table_header *)cmd.data.data();
+            h->major = 1;
+            h->minor = 0;
+            h->table_id = table_id;
+            h->table_size = sizeof( T );
+            h->reserved = 0xFFFFFFFF;
+            h->crc32 = calc_crc32( (byte *)&table, sizeof( table ) );
+
+            memcpy( cmd.data.data() + sizeof( table_header ), &table, sizeof( table ) );
+            
+            hwmon_response response;
+            hwm.send( cmd, &response );
+            switch( response )
+            {
+            case hwm_Success:
+                break;
+
+            default:
+                LOG_DEBUG( "Failed to write FW table 0x" << std::hex << table_id << " " << sizeof( table ) << " bytes: " );
+                throw invalid_value_exception( to_string() << "Failed to write FW table 0x" << std::hex << table_id << ": " << hwmon_error_string( cmd, response ));
+            }
+        }
+
+        template< typename T >
+        void read_fw_register( hw_monitor & hwm, T * preg, int const baseline_address )
+        {
+            command cmd( ivcam2::fw_cmd::MRD, baseline_address, baseline_address + sizeof( T ) );
+            auto res = hwm.send( cmd );
+            if( res.size() != sizeof( T ) )
+                throw std::runtime_error( to_string()
+                                          << "MRD data size received= " << res.size()
+                                          << " (expected " << sizeof( T ) << ")" );
+            if( preg )
+                *preg = *(T *)res.data();
+        }
+
+#pragma pack(push, 1)
+        struct ac_depth_results  // aka "Algo_AutoCalibration" in FW
+        {
+            static const int table_id = 0x240;
+            static const uint16_t this_version = (RS2_API_MAJOR_VERSION << 12 | RS2_API_MINOR_VERSION << 4 | RS2_API_PATCH_VERSION);
+
+            rs2_dsm_params params;
+
+            ac_depth_results() {}
+            ac_depth_results( rs2_dsm_params const & dsm_params ) : params( dsm_params ) {}
         };
 
+        struct rgb_calibration_table
+        {
+            static const uint16_t table_id = 0x310;        // in flash
+            static const uint16_t eeprom_table_id = 0x10;  // factory calibration - read-only
+
+            uint16_t version;
+            uint16_t type;
+            uint32_t timestamp;
+            uint16_t width;
+            uint16_t height;
+            uint16_t h_offset;
+            uint16_t v_offset;
+            struct /*intrinsics*/
+            {
+                float fx;  // focal length in X, normalize by [-1 1]
+                float fy;  // focal length in Y, normalize by [-1 1]
+                float px;  // Principal point in x, normalize by [-1 1]
+                float py;  // Principal point in x, normalize by [-1 1]
+                float sheer;
+                float d[5];  // RGB forward distortion parameters (k1, k2, p1, p2, k3), brown model
+            } intr;
+            rs2_extrinsics extr;
+            byte reserved[8];
+
+            void set_intrinsics( rs2_intrinsics const & );
+            rs2_intrinsics get_intrinsics() const;
+            rs2_extrinsics const & get_extrinsics() const { return extr; }
+            void update_write_fields();
+        };
+#pragma pack(pop)
+
         enum gvd_fields
         {
             fw_version_offset = 12,
@@ -205,14 +354,22 @@ namespace librealsense
             rgb_common common;
             resolutions_rgb resolution;
         };
-#pragma pack(pop)
 
-        pose get_color_stream_extrinsic(const std::vector<uint8_t>& raw_data);
+        struct temperatures {
+            double LDD_temperature;  // Laser Diode Driver
+            double MC_temperature;
+            double MA_temperature;
+            double APD_temperature;
+            double HUM_temperature;
+            double AlgoTermalLddAvg_temperature;
+        };
+#pragma pack( pop )
+
+        rs2_extrinsics get_color_stream_extrinsic(const std::vector<uint8_t>& raw_data);
 
         bool try_fetch_usb_device(std::vector<platform::usb_device_info>& devices,
                                          const platform::uvc_device_info& info, platform::usb_device_info& result);
 
-
         class l500_temperature_options : public readonly_option
         {
         public:
@@ -368,6 +525,7 @@ namespace librealsense
             std::shared_ptr< freefall_option > _freefall_opt;
         };
 
+        class ac_trigger;
 
     } // librealsense::ivcam2
 } // namespace librealsense
diff --git a/src/media/playback/playback_sensor.cpp b/src/media/playback/playback_sensor.cpp
index 7f36851..6cef0d8 100644
--- a/src/media/playback/playback_sensor.cpp
+++ b/src/media/playback/playback_sensor.cpp
@@ -125,6 +125,7 @@ notifications_callback_ptr playback_sensor::get_notifications_callback() const
     return _notifications_processor.get_callback();
 }
 
+
 void playback_sensor::start(frame_callback_ptr callback)
 {
     LOG_DEBUG("Start sensor " << m_sensor_id);
diff --git a/src/media/record/record_sensor.h b/src/media/record/record_sensor.h
index b1a1708..2e08788 100644
--- a/src/media/record/record_sensor.h
+++ b/src/media/record/record_sensor.h
@@ -89,6 +89,7 @@ namespace librealsense
         }
         void release() override { delete this; }
     };
+
     class frame_holder_callback : public rs2_frame_callback
     {
         std::function<void(frame_holder)> on_frame_function;
diff --git a/src/metadata-parser.h b/src/metadata-parser.h
index 725fe2c..55318e7 100644
--- a/src/metadata-parser.h
+++ b/src/metadata-parser.h
@@ -66,7 +66,6 @@ namespace librealsense
     private:
         bool try_get(const frame& frm, rs2_metadata_type& result) const
         {
-            auto pair_size = (sizeof(rs2_frame_metadata_value) + sizeof(rs2_metadata_type));
             const uint8_t* pos = frm.additional_data.metadata_blob.data();
             while (pos <= frm.additional_data.metadata_blob.data() + frm.additional_data.metadata_blob.size())
             {
@@ -340,7 +339,7 @@ namespace librealsense
     {
     public:
         ds5_md_attribute_actual_fps(bool discrete = true, attrib_modifyer  exposure_mod = [](const rs2_metadata_type& param) {return param; })
-            :_exposure_modifyer(exposure_mod), _discrete(discrete), _fps_values{ 6, 15, 30, 60, 90 }
+            : _fps_values{ 6, 15, 30, 60, 90 } , _exposure_modifyer(exposure_mod), _discrete(discrete)
         {}
 
         rs2_metadata_type get(const librealsense::frame & frm) const override
diff --git a/src/mf/mf-uvc.cpp b/src/mf/mf-uvc.cpp
index f7cff56..7d4a196 100644
--- a/src/mf/mf-uvc.cpp
+++ b/src/mf/mf-uvc.cpp
@@ -309,11 +309,11 @@ namespace librealsense
 
             if (hr == DEVICE_NOT_READY_ERROR)
                 return false;
+            CHECK_HR( hr );
 
             if (bytes_received != len)
                 throw std::runtime_error(to_string() << "Get XU n:" << (int)ctrl << " received " << bytes_received << "/" << len << " bytes");
 
-            CHECK_HR(hr);
             return true;
         }
 
diff --git a/src/option.h b/src/option.h
index 51ea773..e804fbe 100644
--- a/src/option.h
+++ b/src/option.h
@@ -252,6 +252,8 @@ namespace librealsense
         bool is_true() { return (_value > _opt_range.min); }
         // TODO: expose this outwards
         const char* get_description() const override { return "A simple custom option for a processing block"; }
+
+        using ptr = std::shared_ptr< bool_option >;
     };
 
     class uvc_pu_option : public option
@@ -551,4 +553,24 @@ namespace librealsense
        float                   _manual_value;
        std::function<void(const option&)> _recording_function = [](const option&) {};
    };
+
+   class enable_motion_correction : public option_base
+   {
+   public:
+       void set(float value) override;
+
+       float query() const override;
+
+       bool is_enabled() const override { return true; }
+
+       const char* get_description() const override
+       {
+           return "Enable/Disable Automatic Motion Data Correction";
+       }
+
+       enable_motion_correction(sensor_base* mm_ep, const option_range& opt_range);
+
+   private:
+       std::atomic<bool>   _is_active;
+   };
 }
diff --git a/src/proc/motion-transform.cpp b/src/proc/motion-transform.cpp
index 9e87c32..a51690a 100644
--- a/src/proc/motion-transform.cpp
+++ b/src/proc/motion-transform.cpp
@@ -62,7 +62,6 @@ namespace librealsense
         }
         else
         {
-            // TODO Define L500 base transformation alignment
             _imu2depth_cs_alignment_matrix = { {1,0,0},{0,1,0}, {0,0,1} };
         }
     }
diff --git a/src/proc/occlusion-filter.h b/src/proc/occlusion-filter.h
index 52f1a90..ccc783c 100644
--- a/src/proc/occlusion-filter.h
+++ b/src/proc/occlusion-filter.h
@@ -30,7 +30,7 @@ namespace librealsense
     public:
         occlusion_filter();
 
-        bool active(void) const { return (occlusion_none != _occlusion_filter); };
+        bool active(void) const { return (occlusion_none != _occlusion_filter); }
 
         void process(float3* points, float2* uv_map, const std::vector<float2> & pix_coord, const rs2::depth_frame& depth) const;
 
@@ -57,7 +57,7 @@ namespace librealsense
 
         friend class pointcloud;
 
-        void monotonic_heuristic_invalidation(float3* points, float2* uv_map, const std::vector<float2> & pix_coord, const rs2::depth_frame& depth) const;;
+        void monotonic_heuristic_invalidation(float3* points, float2* uv_map, const std::vector<float2> & pix_coord, const rs2::depth_frame& depth) const;
         void comprehensive_invalidation(float3* points, float2* uv_map, const std::vector<float2> & pix_coord) const;
 
         optional_value<rs2_intrinsics>              _depth_intrinsics;
diff --git a/src/proc/pointcloud.cpp b/src/proc/pointcloud.cpp
index 3cae7cf..9ebcf85 100644
--- a/src/proc/pointcloud.cpp
+++ b/src/proc/pointcloud.cpp
@@ -9,7 +9,10 @@
 #include "option.h"
 #include "environment.h"
 #include "context.h"
+#include "../device.h"
+#include "../stream.h"
 #include <iostream>
+#include "device-calibration.h"
 
 #ifdef RS2_USE_CUDA
 #include "proc/cuda/cuda-pointcloud.h"
@@ -60,7 +63,7 @@ namespace librealsense
             }
         }
     }
-
+    
     void pointcloud::inspect_depth_frame(const rs2::frame& depth)
     {
         if (!_output_stream || _depth_stream.get_profile().get() != depth.get_profile().get())
@@ -101,11 +104,88 @@ namespace librealsense
         set_extrinsics();
     }
 
+    template< class callback >
+    calibration_change_callback_ptr create_calibration_change_callback_ptr( callback&& cb )
+    {
+        return {
+            new rs2::calibration_change_callback< callback >( std::move( cb ) ),
+            []( rs2_calibration_change_callback* p ) { p->release(); }
+        };
+    }
+
     void pointcloud::inspect_other_frame(const rs2::frame& other)
     {
         if (_stream_filter != _prev_stream_filter)
         {
             _prev_stream_filter = _stream_filter;
+
+            if (!_registered_auto_calib_cb)
+            {
+                auto sensor = ((frame_interface*)other.get())->get_sensor();
+                if (sensor)
+                {
+                    _registered_auto_calib_cb
+                        = std::shared_ptr< pointcloud >( this, []( pointcloud * p ) {} );
+
+                    auto dev = sensor->get_device().shared_from_this();
+                    device_calibration * d2r = dynamic_cast<device_calibration*>(dev.get());
+                    if( d2r )
+                        try
+                        {
+                            std::weak_ptr< pointcloud > wr{ _registered_auto_calib_cb };
+                            auto fn = [=]( rs2_calibration_status status ) {
+                                auto r = wr.lock();
+                                if( ! r )
+                                    // nobody there any more!
+                                    return;
+                                if( status == RS2_CALIBRATION_SUCCESSFUL )
+                                {
+                                    stream_profile_interface *ds = nullptr, *os = nullptr;
+                                    for( size_t x = 0, N = dev->get_sensors_count(); x < N; ++x )
+                                    {
+                                        sensor_interface & s = dev->get_sensor( x );
+                                        for( auto const & sp : s.get_active_streams() )
+                                        {
+                                            if( sp->get_stream_type() == RS2_STREAM_COLOR )
+                                            {
+                                                auto vspi = As< video_stream_profile_interface >(
+                                                    sp.get() );
+                                                if( vspi )
+                                                {
+                                                    os = vspi;
+                                                    _other_intrinsics = vspi->get_intrinsics();
+                                                    _occlusion_filter->set_texel_intrinsics(
+                                                        _other_intrinsics.value() );
+                                                }
+                                            }
+                                            else if( sp->get_stream_type() == RS2_STREAM_DEPTH )
+                                            {
+                                                ds = sp.get();
+                                            }
+                                        }
+                                    }
+                                    if( ds && os )
+                                    {
+                                        rs2_extrinsics ex;
+                                        if( environment::get_instance()
+                                                .get_extrinsics_graph()
+                                                .try_fetch_extrinsics( *ds, *os, &ex ) )
+                                            _extrinsics = ex;
+                                        else
+                                            LOG_ERROR( "Failed to refresh extrinsics after calibration change" );
+                                    }
+                                }
+                            };
+
+                            d2r->register_calibration_change_callback(
+                                create_calibration_change_callback_ptr( std::move( fn ) ) );
+                        }
+                        catch( const std::bad_weak_ptr & )
+                        {
+                            LOG_WARNING( "Device destroyed" );
+                        }
+                }
+            }
         }
 
         if (_extrinsics.has_value() && other.get_profile().get() == _other_stream.get_profile().get())
@@ -263,10 +343,10 @@ namespace librealsense
         }
         else
         {
-            if (frame.get_profile().stream_type() == RS2_STREAM_DEPTH && frame.get_profile().format() == RS2_FORMAT_Z16)
+            auto p = frame.get_profile();
+            if (p.stream_type() == RS2_STREAM_DEPTH && p.format() == RS2_FORMAT_Z16)
                 return true;
 
-            auto p = frame.get_profile();
             if (p.stream_type() == _stream_filter.stream && p.format() == _stream_filter.format && p.stream_index() == _stream_filter.index)
                 return true;
             return false;
diff --git a/src/proc/pointcloud.h b/src/proc/pointcloud.h
index fb6ac1f..8a4f034 100644
--- a/src/proc/pointcloud.h
+++ b/src/proc/pointcloud.h
@@ -2,7 +2,7 @@
 // Copyright(c) 2017 Intel Corporation. All Rights Reserved.
 
 #pragma once
-#include "../include/librealsense2/hpp/rs_frame.hpp"
+#include "synthetic-stream.h"
 
 namespace librealsense
 {
@@ -57,5 +57,6 @@ namespace librealsense
         void set_extrinsics();
 
         stream_filter _prev_stream_filter;
+        std::shared_ptr< pointcloud > _registered_auto_calib_cb;
     };
 }
diff --git a/src/proc/processing-blocks-factory.h b/src/proc/processing-blocks-factory.h
index 6f77301..5b217ef 100644
--- a/src/proc/processing-blocks-factory.h
+++ b/src/proc/processing-blocks-factory.h
@@ -30,24 +30,33 @@ namespace librealsense
         std::shared_ptr<processing_block> generate();
         
         static processing_block_factory create_id_pbf(rs2_format format, rs2_stream stream, int idx = 0);
-        template<typename T>
-        static std::vector<processing_block_factory> create_pbf_vector(rs2_format src, const std::vector<rs2_format>& dst, rs2_stream stream)
+        template<typename T, typename Fn>
+        static std::vector<processing_block_factory> create_pbf_vector( rs2_format src, const std::vector<rs2_format>& dst, rs2_stream stream, Fn creator )
         {
             std::vector<processing_block_factory> rgb_factories;
-            for (auto d : dst)
+            for( auto d : dst )
             {
                 // register identity processing block if requested
-                if (src == d)
+                if( src == d )
                 {
-                    rgb_factories.push_back({ { {src} }, { {src, stream} }, []() { return std::make_shared<identity_processing_block>(); } });
+                    rgb_factories.push_back( { { {src} }, { {src, stream} }, [=]() { return creator( std::make_shared<identity_processing_block>() ); } } );
                     continue;
                 }
 
-                rgb_factories.push_back({ { {src} }, { {d, stream} }, [d]() { return std::make_shared<T>(d); } });
+                rgb_factories.push_back( { { {src} }, { {d, stream} }, [=]() { return creator( std::make_shared<T>( d )); } } );
             }
 
             return rgb_factories;
         }
+        template<typename T>
+        static std::vector<processing_block_factory> create_pbf_vector( rs2_format src, const std::vector<rs2_format>& dst, rs2_stream stream )
+        {
+            return create_pbf_vector< T >( src, dst, stream,
+                []( std::shared_ptr< generic_processing_block > pb )
+                {
+                    return pb;
+                } );
+        }
 
         stream_profiles find_satisfied_requests(const stream_profiles& sp, const stream_profiles& supported_profiles) const;
         bool has_source(const std::shared_ptr<stream_profile_interface>& source) const;
diff --git a/src/proc/rates-printer.cpp b/src/proc/rates-printer.cpp
index f8a96e2..4d03bae 100644
--- a/src/proc/rates-printer.cpp
+++ b/src/proc/rates-printer.cpp
@@ -27,7 +27,7 @@ namespace librealsense
     {
         auto period = std::chrono::milliseconds(1000 / _render_rate).count();
         auto curr_time = std::chrono::steady_clock::now();
-        double diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - _last_print_time).count();
+        auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - _last_print_time).count();
 
         if (diff < period)
             return;
@@ -45,11 +45,11 @@ namespace librealsense
         }
     }
 
-    rates_printer::profile::profile() : _counter(0), _last_frame_number(0), _acctual_fps(0)
+    rates_printer::profile::profile() : _counter(0), _last_frame_number(0), _actual_fps(0)
     {
     }
 
-    int rates_printer::profile::last_frame_number()
+    unsigned long long rates_printer::profile::last_frame_number()
     {
         return _last_frame_number;
     }
@@ -61,7 +61,7 @@ namespace librealsense
 
     float rates_printer::profile::get_fps()
     {
-        return _acctual_fps;
+        return _actual_fps;
     }
 
     void rates_printer::profile::on_frame_arrival(const rs2::frame& f)
@@ -79,8 +79,8 @@ namespace librealsense
         auto oldest = _time_points[0];
         if (_time_points.size() > _stream_profile.fps())
             _time_points.erase(_time_points.begin());
-        double diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - oldest).count() / 1000.0;
+        auto diff = std::chrono::duration_cast<std::chrono::milliseconds>(curr_time - oldest).count() / 1000.f;
         if (diff > 0)
-            _acctual_fps = _time_points.size() / diff;
+            _actual_fps = _time_points.size() / diff;
     }
 }
diff --git a/src/proc/rates-printer.h b/src/proc/rates-printer.h
index 475f0e7..8a680a8 100644
--- a/src/proc/rates-printer.h
+++ b/src/proc/rates-printer.h
@@ -24,12 +24,12 @@ namespace librealsense
             rs2::stream_profile _stream_profile;
             int _counter;
             std::vector<std::chrono::steady_clock::time_point> _time_points;
-            int _last_frame_number;
-            float _acctual_fps;
+            unsigned long long _last_frame_number;
+            float _actual_fps;
             std::chrono::steady_clock::time_point _last_time;
         public:
             profile();
-            int last_frame_number();
+            unsigned long long last_frame_number();
             rs2::stream_profile get_stream_profile();
             float get_fps();
             void on_frame_arrival(const rs2::frame& f);
diff --git a/src/proc/sse/sse-pointcloud.cpp b/src/proc/sse/sse-pointcloud.cpp
index d881e5e..c74a7de 100644
--- a/src/proc/sse/sse-pointcloud.cpp
+++ b/src/proc/sse/sse-pointcloud.cpp
@@ -175,8 +175,8 @@ namespace librealsense
         auto fy = _mm_set_ps1(other_intrinsics.fy);
         auto ppx = _mm_set_ps1(other_intrinsics.ppx);
         auto ppy = _mm_set_ps1(other_intrinsics.ppy);
-        auto w = _mm_set_ps1(other_intrinsics.width);
-        auto h = _mm_set_ps1(other_intrinsics.height);
+        auto w = _mm_set_ps1(float(other_intrinsics.width));
+        auto h = _mm_set_ps1(float(other_intrinsics.height));
         auto mask_inv_brown_conrady = _mm_set_ps1(RS2_DISTORTION_INVERSE_BROWN_CONRADY);
         auto zero = _mm_set_ps1(0);
         auto one = _mm_set_ps1(1);
diff --git a/src/proc/syncer-processing-block.cpp b/src/proc/syncer-processing-block.cpp
index e8812f1..61ce562 100644
--- a/src/proc/syncer-processing-block.cpp
+++ b/src/proc/syncer-processing-block.cpp
@@ -10,8 +10,9 @@
 
 namespace librealsense
 {
-    syncer_process_unit::syncer_process_unit(std::shared_ptr<bool_option> is_enabled_opt)
-        : processing_block("syncer"), _matcher((new timestamp_composite_matcher({}))), _is_enabled_opt(is_enabled_opt)
+    syncer_process_unit::syncer_process_unit( std::initializer_list< bool_option::ptr > enable_opts )
+        : processing_block("syncer"), _matcher((new timestamp_composite_matcher({})))
+        , _enable_opts( enable_opts.begin(), enable_opts.end() )
     {
         _matcher->set_callback([this](frame_holder f, syncronization_environment env)
         {
@@ -31,14 +32,26 @@ namespace librealsense
         auto f = [&](frame_holder frame, synthetic_source_interface* source)
         {
             // if the syncer is disabled passthrough the frame
-            if (auto is_enabled = _is_enabled_opt.lock())
+            bool enabled = false;
+            size_t n_opts = 0;
+            for( auto& wopt : _enable_opts )
             {
-                if (!is_enabled->is_true())
+                auto opt = wopt.lock();
+                if( opt )
                 {
-                    get_source().frame_ready(std::move(frame));
-                    return;
+                    ++n_opts;
+                    if( opt->is_true() )
+                    {
+                        enabled = true;
+                        break;
+                    }
                 }
             }
+            if( n_opts  &&  ! enabled )
+            {
+                get_source().frame_ready( std::move( frame ) );
+                return;
+            }
 
             single_consumer_frame_queue<frame_holder> matches;
 
diff --git a/src/proc/syncer-processing-block.h b/src/proc/syncer-processing-block.h
index 0f1f001..458d9b5 100644
--- a/src/proc/syncer-processing-block.h
+++ b/src/proc/syncer-processing-block.h
@@ -19,7 +19,15 @@ namespace librealsense
     class syncer_process_unit : public processing_block
     {
     public:
-        syncer_process_unit(std::shared_ptr<bool_option> is_enabled_opt = nullptr);
+        syncer_process_unit( std::initializer_list< bool_option::ptr > enable_opts );
+
+        syncer_process_unit( bool_option::ptr is_enabled_opt = nullptr )
+            : syncer_process_unit( { is_enabled_opt } ) {}
+
+        void add_enabling_option( bool_option::ptr is_enabled_opt )
+        {
+            _enable_opts.push_back( is_enabled_opt );
+        }
 
         ~syncer_process_unit()
         {
@@ -27,6 +35,6 @@ namespace librealsense
         }
     private:
         std::unique_ptr<timestamp_composite_matcher> _matcher;
-        std::weak_ptr<bool_option> _is_enabled_opt;
+        std::vector< std::weak_ptr<bool_option> > _enable_opts;
     };
 }
diff --git a/src/proc/synthetic-stream.cpp b/src/proc/synthetic-stream.cpp
index ab8f80c..dc3920a 100644
--- a/src/proc/synthetic-stream.cpp
+++ b/src/proc/synthetic-stream.cpp
@@ -43,6 +43,10 @@ namespace librealsense
                 _callback->on_frame((rs2_frame*)ptr, _source_wrapper.get_c_wrapper());
             }
         }
+        catch (std::exception const & e)
+        {
+            LOG_ERROR("Exception was thrown during user processing callback: " + std::string(e.what()));
+        }
         catch (...)
         {
             LOG_ERROR("Exception was thrown during user processing callback!");
@@ -164,7 +168,7 @@ namespace librealsense
         auto stream_selector = std::make_shared<ptr_option<int>>(RS2_STREAM_ANY, RS2_STREAM_COUNT, 1, RS2_STREAM_ANY, (int*)&_stream_filter.stream, "Stream type");
         for (int s = RS2_STREAM_ANY; s < RS2_STREAM_COUNT; s++)
         {
-            stream_selector->set_description(s, "Process - " + std::string (rs2_stream_to_string((rs2_stream)s)));
+            stream_selector->set_description(float(s), "Process - " + std::string (rs2_stream_to_string((rs2_stream)s)));
         }
         stream_selector->on_set([this, stream_selector](float val)
         {
@@ -180,7 +184,7 @@ namespace librealsense
         auto format_selector = std::make_shared<ptr_option<int>>(RS2_FORMAT_ANY, RS2_FORMAT_COUNT, 1, RS2_FORMAT_ANY, (int*)&_stream_filter.format, "Stream format");
         for (int f = RS2_FORMAT_ANY; f < RS2_FORMAT_COUNT; f++)
         {
-            format_selector->set_description(f, "Process - " + std::string(rs2_format_to_string((rs2_format)f)));
+            format_selector->set_description(float(f), "Process - " + std::string(rs2_format_to_string((rs2_format)f)));
         }
         format_selector->on_set([this, format_selector](float val)
         {
diff --git a/src/realsense.def b/src/realsense.def
index 13fcea4..8438e01 100644
--- a/src/realsense.def
+++ b/src/realsense.def
@@ -26,7 +26,12 @@ EXPORTS
 
     rs2_get_extrinsics
     rs2_register_extrinsics
+    rs2_override_extrinsics
     rs2_get_motion_intrinsics
+    rs2_override_intrinsics
+    rs2_get_dsm_params
+    rs2_override_dsm_params
+    rs2_reset_sensor_calibration
 
     rs2_get_stream_profiles
     rs2_get_active_streams
@@ -52,6 +57,12 @@ EXPORTS
     rs2_get_notification_category
     rs2_get_notification_serialized_data
 
+    rs2_register_calibration_change_callback
+    rs2_register_calibration_change_callback_cpp
+    rs2_trigger_device_calibration
+    rs2_calibration_type_to_string
+    rs2_calibration_status_to_string
+
     rs2_get_frame_metadata
     rs2_supports_frame_metadata
     rs2_get_frame_timestamp
@@ -356,3 +367,28 @@ EXPORTS
     rs2_get_calibration_table
     rs2_set_calibration_table
 
+    rs2_create_fw_log_message
+    rs2_delete_fw_log_message
+    rs2_get_fw_log
+    rs2_get_flash_log
+    rs2_fw_log_message_severity
+    rs2_fw_log_message_timestamp
+    rs2_fw_log_message_data
+    rs2_fw_log_message_size
+    rs2_init_fw_log_parser
+    rs2_parse_firmware_log
+    rs2_create_fw_log_parsed_message
+    rs2_delete_fw_log_parsed_message
+    rs2_get_fw_log_parsed_message
+    rs2_get_fw_log_parsed_file_name
+    rs2_get_fw_log_parsed_thread_name
+    rs2_get_fw_log_parsed_severity
+    rs2_get_fw_log_parsed_line
+    rs2_get_fw_log_parsed_timestamp
+    
+    rs2_create_terminal_parser
+    rs2_delete_terminal_parser
+    rs2_terminal_parse_command 
+    rs2_terminal_parse_response
+
+
diff --git a/src/rs.cpp b/src/rs.cpp
index e91bc96..2fff29c 100644
--- a/src/rs.cpp
+++ b/src/rs.cpp
@@ -41,6 +41,10 @@
 #include "software-device.h"
 #include "global_timestamp_reader.h"
 #include "auto-calibrated-device.h"
+#include "terminal-parser.h"
+#include "firmware_logger_device.h"
+#include "device-calibration.h"
+#include "calibrated-sensor.h"
 ////////////////////////
 // API implementation //
 ////////////////////////
@@ -114,6 +118,22 @@ struct rs2_sensor_list
     rs2_device dev;
 };
 
+struct rs2_terminal_parser
+{
+    std::shared_ptr<librealsense::terminal_parser> terminal_parser;
+};
+
+struct rs2_firmware_log_message
+{
+    std::shared_ptr<librealsense::fw_logs::fw_logs_binary_data> firmware_log_binary_data;
+};
+
+struct rs2_firmware_log_parsed_message
+{
+    std::shared_ptr<librealsense::fw_logs::fw_log_data> firmware_log_parsed;
+};
+
+
 struct rs2_error
 {
     std::string message;
@@ -183,12 +203,13 @@ int rs2_device_hub_is_device_connected(const rs2_device_hub* hub, const rs2_devi
 }
 HANDLE_EXCEPTIONS_AND_RETURN(0, hub, device)
 
-rs2_device_list* rs2_query_devices(const rs2_context* context, rs2_error** error)
+rs2_device_list* rs2_query_devices(const rs2_context* context, rs2_error** error) BEGIN_API_CALL
 {
     return rs2_query_devices_ex(context, RS2_PRODUCT_LINE_ANY_INTEL, error);
 }
+HANDLE_EXCEPTIONS_AND_RETURN(0, context)
 
-rs2_device_list* rs2_query_devices_ex(const rs2_context* context, int product_mask, rs2_error** error)
+rs2_device_list* rs2_query_devices_ex(const rs2_context* context, int product_mask, rs2_error** error) BEGIN_API_CALL
 {
     VALIDATE_NOT_NULL(context);
 
@@ -208,6 +229,7 @@ rs2_device_list* rs2_query_devices_ex(const rs2_context* context, int product_ma
 
     return new rs2_device_list{ context->ctx, results };
 }
+HANDLE_EXCEPTIONS_AND_RETURN(0, context, product_mask)
 
 rs2_sensor_list* rs2_query_sensors(const rs2_device* device, rs2_error** error) BEGIN_API_CALL
 {
@@ -346,7 +368,77 @@ void rs2_get_video_stream_intrinsics(const rs2_stream_profile* from, rs2_intrins
 
     *intr = vid->get_intrinsics();
 }
-HANDLE_EXCEPTIONS_AND_RETURN(, from, intr)
+HANDLE_EXCEPTIONS_AND_RETURN( , from, intr )
+
+// librealsense wrapper around a C function
+class calibration_change_callback : public rs2_calibration_change_callback
+{
+    rs2_calibration_change_callback_ptr _callback;
+    void* _user_arg;
+
+public:
+    calibration_change_callback( rs2_calibration_change_callback_ptr callback, void* user_arg )
+        : _callback( callback ), _user_arg( user_arg ) {}
+
+    void on_calibration_change( rs2_calibration_status status ) noexcept override
+    {
+        if( _callback )
+        {
+            try
+            {
+                _callback( status, _user_arg );
+            }
+            catch( ... )
+            {
+                std::cerr << "Received an execption from profile intrinsics callback!" << std::endl;
+            }
+        }
+    }
+    void release() override
+    {
+        // Shouldn't get called...
+        throw std::runtime_error( "calibration_change_callback::release() ?!?!?!" );
+        delete this;
+    }
+};
+
+void rs2_register_calibration_change_callback( rs2_device* dev, rs2_calibration_change_callback_ptr callback, void * user, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( dev );
+    VALIDATE_NOT_NULL( callback );
+
+    auto d2r = VALIDATE_INTERFACE( dev->device, librealsense::device_calibration );
+
+    // Wrap the C function with a callback interface that will get deleted when done
+    d2r->register_calibration_change_callback(
+        std::make_shared< calibration_change_callback >( callback, user )
+        );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , dev, callback, user )
+
+void rs2_register_calibration_change_callback_cpp( rs2_device* dev, rs2_calibration_change_callback* callback, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( dev );
+    VALIDATE_NOT_NULL( callback );
+
+    auto d2r = VALIDATE_INTERFACE( dev->device, librealsense::device_calibration );
+
+    // Wrap the C++ callback interface with a shared_ptr that we set to release() it (rather than delete it)
+    d2r->register_calibration_change_callback(
+        { callback, []( rs2_calibration_change_callback* p ) { p->release(); } }
+        );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , dev, callback )
+
+void rs2_trigger_device_calibration( rs2_device * dev, rs2_calibration_type type, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( dev );
+    
+    auto cal = VALIDATE_INTERFACE( dev->device, librealsense::device_calibration );
+
+    cal->trigger_device_calibration( type );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , dev, type )
 
 void rs2_get_motion_intrinsics(const rs2_stream_profile* mode, rs2_motion_device_intrinsic * intrinsics, rs2_error ** error) BEGIN_API_CALL
 {
@@ -1027,7 +1119,47 @@ void rs2_register_extrinsics(const rs2_stream_profile* from,
 
     environment::get_instance().get_extrinsics_graph().register_extrinsics(*from->profile, *to->profile, extrin);
 }
-HANDLE_EXCEPTIONS_AND_RETURN(, from, to)
+HANDLE_EXCEPTIONS_AND_RETURN(, from, to, extrin)
+
+void rs2_override_extrinsics( const rs2_sensor* sensor, const rs2_extrinsics* extrinsics, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( sensor );
+    VALIDATE_NOT_NULL( extrinsics );
+
+    auto ois = VALIDATE_INTERFACE( sensor->sensor, librealsense::calibrated_sensor );
+    ois->override_extrinsics( *extrinsics );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , sensor, extrinsics )
+
+void rs2_get_dsm_params( const rs2_sensor * sensor, rs2_dsm_params * p_params_out, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( sensor );
+    VALIDATE_NOT_NULL( p_params_out );
+
+    auto cs = VALIDATE_INTERFACE( sensor->sensor, librealsense::calibrated_sensor );
+    *p_params_out = cs->get_dsm_params();
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , sensor, p_params_out )
+
+void rs2_override_dsm_params( const rs2_sensor * sensor, rs2_dsm_params const * p_params, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( sensor );
+    VALIDATE_NOT_NULL( p_params );
+
+    auto cs = VALIDATE_INTERFACE( sensor->sensor, librealsense::calibrated_sensor );
+    cs->override_dsm_params( *p_params );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , sensor, p_params )
+
+void rs2_reset_sensor_calibration( rs2_sensor const * sensor, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( sensor );
+
+    auto cs = VALIDATE_INTERFACE( sensor->sensor, librealsense::calibrated_sensor );
+    cs->reset_calibration();
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , sensor )
+
 
 void rs2_hardware_reset(const rs2_device* device, rs2_error** error) BEGIN_API_CALL
 {
@@ -1132,7 +1264,9 @@ const char* rs2_extension_to_string(rs2_extension type)
 const char* rs2_frame_metadata_value_to_string(rs2_frame_metadata_value metadata)         { return rs2_frame_metadata_to_string(metadata); }
 const char* rs2_l500_visual_preset_to_string(rs2_l500_visual_preset preset)               { return get_string(preset); }
 const char* rs2_sensor_mode_to_string(rs2_sensor_mode mode)                               { return get_string(mode); }
-const char* rs2_ambient_light_to_string(rs2_ambient_light ambient)                        { return get_string(ambient); }
+const char* rs2_ambient_light_to_string( rs2_ambient_light ambient ) { return get_string( ambient ); }
+const char* rs2_calibration_type_to_string(rs2_calibration_type type)                     { return get_string(type); }
+const char* rs2_calibration_status_to_string(rs2_calibration_status status)               { return get_string(status); }
 
 void rs2_log_to_console(rs2_log_severity min_severity, rs2_error** error) BEGIN_API_CALL
 {
@@ -1254,6 +1388,7 @@ int rs2_is_sensor_extendable_to(const rs2_sensor* sensor, rs2_extension extensio
     case RS2_EXTENSION_COLOR_SENSOR        : return VALIDATE_INTERFACE_NO_THROW(sensor->sensor, librealsense::color_sensor)           != nullptr;
     case RS2_EXTENSION_MOTION_SENSOR       : return VALIDATE_INTERFACE_NO_THROW(sensor->sensor, librealsense::motion_sensor)          != nullptr;
     case RS2_EXTENSION_FISHEYE_SENSOR      : return VALIDATE_INTERFACE_NO_THROW(sensor->sensor, librealsense::fisheye_sensor)         != nullptr;
+    case RS2_EXTENSION_CALIBRATED_SENSOR   : return VALIDATE_INTERFACE_NO_THROW(sensor->sensor, librealsense::calibrated_sensor)      != nullptr;
 
     default:
         return false;
@@ -1284,8 +1419,10 @@ int rs2_is_device_extendable_to(const rs2_device* dev, rs2_extension extension,
         case RS2_EXTENSION_UPDATABLE             : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::updatable)                   != nullptr;
         case RS2_EXTENSION_UPDATE_DEVICE         : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::update_device_interface)     != nullptr;
         case RS2_EXTENSION_GLOBAL_TIMER          : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::global_time_interface)       != nullptr;
-        case RS2_EXTENSION_AUTO_CALIBRATED_DEVICE: return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::auto_calibrated_interface) != nullptr;
-        case RS2_EXTENSION_SERIALIZABLE          : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::serializable_interface) != nullptr;
+        case RS2_EXTENSION_AUTO_CALIBRATED_DEVICE: return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::auto_calibrated_interface)   != nullptr;
+        case RS2_EXTENSION_DEVICE_CALIBRATION    : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::device_calibration)          != nullptr;
+        case RS2_EXTENSION_SERIALIZABLE          : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::serializable_interface)      != nullptr;
+        case RS2_EXTENSION_FW_LOGGER             : return VALIDATE_INTERFACE_NO_THROW(dev->device, librealsense::firmware_logger_extensions)  != nullptr;
 
         default:
             return false;
@@ -2473,6 +2610,16 @@ void rs2_set_intrinsics(const rs2_sensor* sensor, const rs2_stream_profile* prof
 }
 HANDLE_EXCEPTIONS_AND_RETURN(, sensor, profile, intrinsics)
 
+void rs2_override_intrinsics( const rs2_sensor* sensor, const rs2_intrinsics* intrinsics, rs2_error** error ) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL( sensor );
+    VALIDATE_NOT_NULL( intrinsics );
+    
+    auto ois = VALIDATE_INTERFACE( sensor->sensor, librealsense::calibrated_sensor );
+    ois->override_intrinsics( *intrinsics );
+}
+HANDLE_EXCEPTIONS_AND_RETURN( , sensor, intrinsics )
+
 void rs2_set_extrinsics(const rs2_sensor* from_sensor, const rs2_stream_profile* from_profile, rs2_sensor* to_sensor, const rs2_stream_profile* to_profile, const rs2_extrinsics* extrinsics, rs2_error** error) BEGIN_API_CALL
 {
     VALIDATE_NOT_NULL(from_sensor);
@@ -2962,3 +3109,216 @@ void rs2_load_json(rs2_device* dev, const void* json_content, unsigned content_s
     serializable->load_json(std::string(static_cast<const char*>(json_content), content_size));
 }
 HANDLE_EXCEPTIONS_AND_RETURN(, dev, json_content, content_size)
+
+rs2_firmware_log_message* rs2_create_fw_log_message(rs2_device* dev, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(dev);
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+    
+    return new rs2_firmware_log_message{ std::make_shared <librealsense::fw_logs::fw_logs_binary_data>() };
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, dev)
+
+int rs2_get_fw_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(dev);
+    VALIDATE_NOT_NULL(fw_log_msg);
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+
+    fw_logs::fw_logs_binary_data binary_data;
+    bool result = fw_loggerable->get_fw_log(binary_data);
+    if (result)
+    {
+        *(fw_log_msg->firmware_log_binary_data).get() = binary_data;
+    }
+    return result? 1 : 0;
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, dev, fw_log_msg)
+
+int rs2_get_flash_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(dev);
+    VALIDATE_NOT_NULL(fw_log_msg);
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+
+    fw_logs::fw_logs_binary_data binary_data;
+    bool result = fw_loggerable->get_flash_log(binary_data);
+    if (result)
+    {
+        *(fw_log_msg->firmware_log_binary_data).get() = binary_data;
+    }
+    return result ? 1 : 0;
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, dev, fw_log_msg)
+void rs2_delete_fw_log_message(rs2_firmware_log_message* msg) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(msg);
+    delete msg;
+}
+NOEXCEPT_RETURN(, msg)
+
+const unsigned char* rs2_fw_log_message_data(rs2_firmware_log_message* msg, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(msg);
+    return msg->firmware_log_binary_data->logs_buffer.data();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, msg)
+
+int rs2_fw_log_message_size(rs2_firmware_log_message* msg, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(msg);
+    return msg->firmware_log_binary_data->logs_buffer.size();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, msg)
+
+rs2_log_severity rs2_fw_log_message_severity(const rs2_firmware_log_message* msg, rs2_error** error) BEGIN_API_CALL
+{
+    return msg->firmware_log_binary_data->get_severity();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(RS2_LOG_SEVERITY_NONE, msg)
+
+unsigned int rs2_fw_log_message_timestamp(rs2_firmware_log_message* msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(msg);
+    return msg->firmware_log_binary_data->get_timestamp();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, msg)
+
+int rs2_init_fw_log_parser(rs2_device* dev, const char* xml_content,rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(xml_content);
+    
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+
+    return (fw_loggerable->init_parser(xml_content)) ? 1 : 0;
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, xml_content)
+
+rs2_firmware_log_parsed_message* rs2_create_fw_log_parsed_message(rs2_device* dev, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(dev);
+
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+
+    return new rs2_firmware_log_parsed_message{ std::make_shared <librealsense::fw_logs::fw_log_data>() };
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, dev)
+
+int rs2_parse_firmware_log(rs2_device* dev, rs2_firmware_log_message* fw_log_msg, rs2_firmware_log_parsed_message* parsed_msg, rs2_error** error)BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(dev);
+    VALIDATE_NOT_NULL(fw_log_msg);
+    VALIDATE_NOT_NULL(parsed_msg);
+
+    auto fw_loggerable = VALIDATE_INTERFACE(dev->device, librealsense::firmware_logger_extensions);
+
+    bool parsing_result = fw_loggerable->parse_log(fw_log_msg->firmware_log_binary_data.get(),
+        parsed_msg->firmware_log_parsed.get());
+
+    return parsing_result ? 1 : 0;
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, dev, fw_log_msg)
+
+void rs2_delete_fw_log_parsed_message(rs2_firmware_log_parsed_message* fw_log_parsed_msg) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    delete fw_log_parsed_msg;
+}
+NOEXCEPT_RETURN(, fw_log_parsed_msg)
+
+const char* rs2_get_fw_log_parsed_message(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_message().c_str();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, fw_log_parsed_msg)
+
+const char* rs2_get_fw_log_parsed_file_name(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_file_name().c_str();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, fw_log_parsed_msg)
+
+const char* rs2_get_fw_log_parsed_thread_name(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_thread_name().c_str();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, fw_log_parsed_msg)
+
+rs2_log_severity rs2_get_fw_log_parsed_severity(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_severity();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(RS2_LOG_SEVERITY_NONE, fw_log_parsed_msg)
+
+unsigned int rs2_get_fw_log_parsed_line(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_line();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, fw_log_parsed_msg)
+
+unsigned int rs2_get_fw_log_parsed_timestamp(rs2_firmware_log_parsed_message* fw_log_parsed_msg, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(fw_log_parsed_msg);
+    return fw_log_parsed_msg->firmware_log_parsed->get_timestamp();
+}
+HANDLE_EXCEPTIONS_AND_RETURN(0, fw_log_parsed_msg)
+
+
+rs2_terminal_parser* rs2_create_terminal_parser(const char* xml_content, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(xml_content);
+    return new rs2_terminal_parser{ std::make_shared<librealsense::terminal_parser>(std::string(xml_content)) };
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, xml_content)
+
+void rs2_delete_terminal_parser(rs2_terminal_parser* terminal_parser) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(terminal_parser);
+    delete terminal_parser;
+}
+NOEXCEPT_RETURN(, terminal_parser)
+
+rs2_raw_data_buffer* rs2_terminal_parse_command(rs2_terminal_parser* terminal_parser,
+    const char* command, unsigned int size_of_command, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(terminal_parser);
+    VALIDATE_NOT_NULL(command);
+    VALIDATE_LE(size_of_command, 1000);//bufer shall be less than 1000 bytes or similar
+
+    std::string command_string;
+    command_string.insert(command_string.begin(), command, command + size_of_command);
+
+    auto result = terminal_parser->terminal_parser->parse_command(command_string);
+    return new rs2_raw_data_buffer{ result };
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, terminal_parser, command)
+
+rs2_raw_data_buffer* rs2_terminal_parse_response(rs2_terminal_parser* terminal_parser,
+    const char* command, unsigned int size_of_command,
+    const void* response, unsigned int size_of_response, rs2_error** error) BEGIN_API_CALL
+{
+    VALIDATE_NOT_NULL(terminal_parser);
+    VALIDATE_NOT_NULL(command);
+    VALIDATE_NOT_NULL(response);
+    VALIDATE_LE(size_of_command, 1000); //bufer shall be less than 1000 bytes or similar
+    VALIDATE_LE(size_of_response, 5000);//bufer shall be less than 5000 bytes or similar
+
+
+    std::string command_string;
+    command_string.insert(command_string.begin(), command, command + size_of_command);
+
+    std::vector<uint8_t> response_vec;
+    response_vec.insert(response_vec.begin(), (uint8_t*)response, (uint8_t*)response + size_of_response);
+
+    auto result = terminal_parser->terminal_parser->parse_response(command_string, response_vec);
+    return new rs2_raw_data_buffer{ result };
+}
+HANDLE_EXCEPTIONS_AND_RETURN(nullptr, terminal_parser, command, response)
+
+
+
diff --git a/src/sensor.cpp b/src/sensor.cpp
index d04fd27..cc7f9c2 100644
--- a/src/sensor.cpp
+++ b/src/sensor.cpp
@@ -1093,6 +1093,7 @@ namespace librealsense
             cloned = std::make_shared<motion_stream_profile>(platform::stream_profile{});
         }
 
+        assign_stream(profile, cloned);
         cloned->set_unique_id(profile->get_unique_id());
         cloned->set_format(profile->get_format());
         cloned->set_stream_index(profile->get_stream_index());
@@ -1466,7 +1467,7 @@ namespace librealsense
         }
 
         // Invoke processing blocks callback
-        const auto&& process_cb = make_callback([&, callback, this](frame_holder f) {
+        const auto&& process_cb = make_callback([&, this](frame_holder f) {
             if (!f)
                 return;
 
diff --git a/src/sensor.h b/src/sensor.h
index a58e8ce..a4869aa 100644
--- a/src/sensor.h
+++ b/src/sensor.h
@@ -106,7 +106,7 @@ namespace librealsense
         on_open _on_open;
         std::shared_ptr<metadata_parser_map> _metadata_parsers = nullptr;
 
-        sensor_base* _source_owner;
+        sensor_base* _source_owner = nullptr;
         frame_source _source;
         device* _owner;
         std::vector<platform::stream_profile> _uvc_profiles;
diff --git a/src/stream.h b/src/stream.h
index 4a22197..ec1a7f5 100644
--- a/src/stream.h
+++ b/src/stream.h
@@ -112,7 +112,9 @@ namespace librealsense
         std::shared_ptr<stream_profile_interface> clone() const override
         {
             auto res = std::make_shared<video_stream_profile>(platform::stream_profile{});
-            res->set_unique_id(environment::get_instance().generate_stream_id());
+            auto id = environment::get_instance().generate_stream_id();
+            res->set_unique_id( id );
+            LOG_DEBUG( "video_stream_profile::clone, id= " << id );
             res->set_dims(get_width(), get_height());
             std::function<rs2_intrinsics()> int_func = _calc_intrinsics;
             res->set_intrinsics([int_func]() { return int_func(); });
diff --git a/src/sync.cpp b/src/sync.cpp
index 0f51ffd..a1d7997 100644
--- a/src/sync.cpp
+++ b/src/sync.cpp
@@ -11,7 +11,7 @@ namespace librealsense
 
     std::string frame_to_string(frame_holder& f)
     {
-        std::stringstream s;
+        std::ostringstream s;
         auto composite = dynamic_cast<composite_frame*>(f.frame);
         if(composite)
         {
@@ -23,7 +23,11 @@ namespace librealsense
         }
         else
         {
-             s<<f->get_stream()->get_stream_type()<<" "<<f->get_frame_number()<<" "<<std::fixed <<(double)f->get_frame_timestamp()<<" ";
+            s << f->get_stream()->get_stream_type();
+            s << " " << f->get_stream()->get_unique_id();
+            s << " " << f->get_frame_number();
+            s << " " << std::fixed << (double)f->get_frame_timestamp();
+            s << " ";
         }
         return s.str();
     }
@@ -176,13 +180,17 @@ namespace librealsense
                 matcher = _matchers[stream_id];
                 if (!matcher)
                 {
+                    std::ostringstream ss;
+                    for( auto const & it : _matchers )
+                        ss << ' ' << it.first;
+                    LOG_DEBUG( "stream id " << stream_id << " was not found; trying to create, existing streams=" << ss.str() );
                     matcher = dev->create_matcher(frame);
 
-
-                    matcher->set_callback([&](frame_holder f, syncronization_environment env)
-                    {
-                        sync(std::move(f), env);
-                    });
+                    matcher->set_callback(
+                        [&](frame_holder f, syncronization_environment env)
+                        {
+                            sync(std::move(f), env);
+                        });
 
                     for (auto stream : matcher->get_streams())
                     {
@@ -192,7 +200,6 @@ namespace librealsense
                         }
                         _matchers[stream] = matcher;
                         _streams_id.push_back(stream);
-
                     }
                     for (auto stream : matcher->get_streams_types())
                     {
@@ -204,15 +211,17 @@ namespace librealsense
                         LOG_ERROR("Stream matcher not found! stream=" << rs2_stream_to_string(stream_type));
                     }
                 }
-
                 else if(!matcher->get_active())
                 {
-
                      matcher->set_active(true);
                      _frames_queue[matcher.get()].start();
                 }
             }
         }
+        else
+        {
+            LOG_DEBUG( "sensor does not exist" );
+        }
 
         if(!dev_exist)
         {
@@ -253,7 +262,7 @@ namespace librealsense
 
     void composite_matcher::sync(frame_holder f, syncronization_environment env)
     {
-        std::stringstream s;
+        std::ostringstream s;
         s <<"SYNC "<<_name<<"--> "<< frame_to_string(f)<<"\n";
         LOG_DEBUG(s.str());
 
diff --git a/src/terminal-parser.cpp b/src/terminal-parser.cpp
new file mode 100644
index 0000000..97deffb
--- /dev/null
+++ b/src/terminal-parser.cpp
@@ -0,0 +1,117 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include "terminal-parser.h"
+
+namespace librealsense
+{
+
+    using namespace std;
+
+    terminal_parser::terminal_parser(const std::string& xml_content)
+    {
+        if (!xml_content.empty())
+        {
+            parse_xml_from_memory(xml_content.c_str(), _cmd_xml);
+            update_format_type_to_lambda(_format_type_to_lambda);
+        }
+    }
+
+
+    std::vector<uint8_t> terminal_parser::parse_command(const std::string& line) const
+    {
+        command_from_xml command;
+        vector<string> params;
+
+        get_command_and_params_from_input(line, command, params);
+
+        auto raw_data = build_raw_command_data(command, params);
+
+        for (auto b : raw_data)
+        {
+            cout << hex << fixed << setfill('0') << setw(2) << (int)b << " ";
+        }
+        cout << endl;
+
+        return raw_data;
+    }
+
+    std::vector<uint8_t> terminal_parser::parse_response(const std::string& line,
+        const std::vector<uint8_t>& response) const
+    {
+        command_from_xml command;
+        vector<string> params;
+
+        get_command_and_params_from_input(line, command, params);
+
+        unsigned returned_opcode = *response.data();
+        // check returned opcode
+        if (command.op_code != returned_opcode)
+        {
+            stringstream msg;
+            msg << "OpCodes do not match! Sent 0x" << hex << command.op_code << " but received 0x" << hex << (returned_opcode) << "!";
+            throw runtime_error(msg.str());
+        }
+
+        if (command.is_read_command)
+        {
+            string data;
+            decode_string_from_raw_data(command, _cmd_xml.custom_formatters, response.data(), response.size(), data, _format_type_to_lambda);
+            vector<uint8_t> data_vec;
+            data_vec.insert(data_vec.begin(), data.begin(), data.end());
+            return data_vec;
+        }
+        else
+        {
+            return response;
+        }
+    }
+
+    vector<uint8_t> terminal_parser::build_raw_command_data(const command_from_xml& command, const vector<string>& params) const
+    {
+        if (params.size() > command.parameters.size() && !command.is_cmd_write_data)
+            throw runtime_error("Input string was not in a correct format!");
+
+        vector<parameter> vec_parameters;
+        for (auto param_index = 0; param_index < params.size(); ++param_index)
+        {
+            auto is_there_write_data = param_index >= int(command.parameters.size());
+            auto name = (is_there_write_data) ? "" : command.parameters[param_index].name;
+            auto is_reverse_bytes = (is_there_write_data) ? false : command.parameters[param_index].is_reverse_bytes;
+            auto is_decimal = (is_there_write_data) ? false : command.parameters[param_index].is_decimal;
+            auto format_length = (is_there_write_data) ? -1 : command.parameters[param_index].format_length;
+            vec_parameters.push_back(parameter(name, params[param_index], is_decimal, is_reverse_bytes, format_length));
+        }
+
+        vector<uint8_t> raw_data;
+        encode_raw_data_command(command, vec_parameters, raw_data);
+        return raw_data;
+    }
+
+    void terminal_parser::get_command_and_params_from_input(const std::string& line, command_from_xml& command,
+        vector<string>& params) const
+    {
+        vector<string> tokens;
+        stringstream ss(line);
+        string word;
+        while (ss >> word)
+        {
+            stringstream converter;
+            converter << hex << word;
+            tokens.push_back(word);
+        }
+
+        if (tokens.empty())
+            throw runtime_error("Wrong input!");
+
+        auto command_str = tokens.front();
+        auto it = _cmd_xml.commands.find(command_str);
+        if (it == _cmd_xml.commands.end())
+            throw runtime_error("Command not found!");
+
+        command = it->second;
+        for (auto i = 1; i < tokens.size(); ++i)
+            params.push_back(tokens[i]);
+    }
+
+}
diff --git a/src/terminal-parser.h b/src/terminal-parser.h
new file mode 100644
index 0000000..f64edef
--- /dev/null
+++ b/src/terminal-parser.h
@@ -0,0 +1,34 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "core/extension.h"
+#include "device.h"
+#include <vector>
+#include "../common/parser.hpp"
+
+namespace librealsense
+{
+    class terminal_parser
+    {
+    public:
+        terminal_parser(const std::string& xml_content);
+
+
+        std::vector<uint8_t> parse_command(const std::string& command) const;
+
+        std::vector<uint8_t> parse_response(const std::string& command,
+            const std::vector<uint8_t>& response) const;
+
+    private:
+        void get_command_and_params_from_input(const std::string& line, command_from_xml& command,
+            std::vector<std::string>& params) const;
+        std::vector<uint8_t> build_raw_command_data(const command_from_xml& command,
+            const std::vector<std::string>& params) const;
+
+        std::map<std::string, xml_parser_function> _format_type_to_lambda;
+        commands_xml _cmd_xml;
+    };
+
+}
diff --git a/src/types.cpp b/src/types.cpp
index 5667557..fd11204 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -20,6 +20,35 @@ const double SQRT_DBL_EPSILON = sqrt(std::numeric_limits<double>::epsilon());
 
 namespace librealsense
 {
+    // The extrinsics on the camera ("raw extrinsics") are in milimeters, but LRS works in meters
+    // Additionally, LRS internal algorithms are
+    // written with a transposed matrix in mind! (see rs2_transform_point_to_point)
+    rs2_extrinsics to_raw_extrinsics(rs2_extrinsics extr)
+    {
+        float const meters_to_milimeters = 1000;
+        extr.translation[0] *= meters_to_milimeters;
+        extr.translation[1] *= meters_to_milimeters;
+        extr.translation[2] *= meters_to_milimeters;
+
+        std::swap(extr.rotation[1], extr.rotation[3]);
+        std::swap(extr.rotation[2], extr.rotation[6]);
+        std::swap(extr.rotation[5], extr.rotation[7]);
+        return extr;
+    }
+
+    rs2_extrinsics from_raw_extrinsics(rs2_extrinsics extr)
+    {
+        float const milimeters_to_meters = 0.001f;
+        extr.translation[0] *= milimeters_to_meters;
+        extr.translation[1] *= milimeters_to_meters;
+        extr.translation[2] *= milimeters_to_meters;
+
+        std::swap(extr.rotation[1], extr.rotation[3]);
+        std::swap(extr.rotation[2], extr.rotation[6]);
+        std::swap(extr.rotation[5], extr.rotation[7]);
+        return extr;
+    }
+
     std::string make_less_screamy(const char* str)
     {
         std::string res(str);
@@ -151,7 +180,37 @@ namespace librealsense
         }
 #undef CASE
     }
-    
+
+    const char* get_string( rs2_calibration_type type )
+    {
+#define CASE(X) STRCASE(CALIBRATION, X)
+        switch( type )
+        {
+            CASE( DEPTH_TO_RGB )
+        default: assert( !is_valid( type ) ); return UNKNOWN_VALUE;
+        }
+#undef CASE
+    }
+
+    const char* get_string( rs2_calibration_status value )
+    {
+#define CASE(X) STRCASE(CALIBRATION, X)
+        switch( value )
+        {
+            CASE( SPECIAL_FRAME )
+            CASE( STARTED )
+            CASE( NOT_NEEDED )
+            CASE( SUCCESSFUL )
+            
+            CASE( FAILED )
+            CASE( SCENE_INVALID )
+            CASE( BAD_RESULT )
+            CASE( RETRY )
+        default: assert( !is_valid( value ) ); return UNKNOWN_VALUE;
+        }
+#undef CASE
+    }
+
     const char* get_string(rs2_ambient_light value)
     {
 #define CASE(X) STRCASE(AMBIENT_LIGHT, X)
@@ -216,6 +275,10 @@ namespace librealsense
             CASE(FISHEYE_SENSOR)
             CASE(DEPTH_HUFFMAN_DECODER)
             CASE(SERIALIZABLE)
+            CASE(FW_LOGGER)
+            CASE(AUTO_CALIBRATION_FILTER)
+            CASE(DEVICE_CALIBRATION)
+            CASE(CALIBRATED_SENSOR)
         default: assert(!is_valid(value)); return UNKNOWN_VALUE;
         }
 #undef CASE
@@ -320,7 +383,7 @@ namespace librealsense
             CASE(ZERO_ORDER_ENABLED)
             CASE(ENABLE_MAP_PRESERVATION)
             CASE(FREEFALL_DETECTION_ENABLED)
-            CASE(AVALANCHE_PHOTO_DIODE)
+            case RS2_OPTION_AVALANCHE_PHOTO_DIODE: return "Receiver Gain";
             CASE(POST_PROCESSING_SHARPENING)
             CASE(PRE_PROCESSING_SHARPENING)
             CASE(NOISE_FILTERING)
@@ -329,6 +392,8 @@ namespace librealsense
             CASE(SENSOR_MODE)
             CASE(EMITTER_ALWAYS_ON)
             CASE(THERMAL_COMPENSATION)
+            CASE(TRIGGER_CAMERA_ACCURACY_HEALTH)
+            CASE(RESET_CAMERA_ACCURACY_HEALTH)
         default: assert(!is_valid(value)); return UNKNOWN_VALUE;
         }
 #undef CASE
@@ -507,8 +572,10 @@ namespace librealsense
         {
             CASE(CUSTOM)
             CASE(DEFAULT)
-            CASE(NO_AMBIENT)
-            CASE(LOW_AMBIENT)
+            //CASE(NO_AMBIENT)
+            case RS2_L500_VISUAL_PRESET_NO_AMBIENT: return "No Ambient Light";
+            //CASE(LOW_AMBIENT)
+            case RS2_L500_VISUAL_PRESET_LOW_AMBIENT: return "Low Ambient Light";
             CASE(MAX_RANGE)
             CASE(SHORT_RANGE)
         default: assert(!is_valid(value)); return UNKNOWN_VALUE;
diff --git a/src/types.h b/src/types.h
index f181363..ea39944 100644
--- a/src/types.h
+++ b/src/types.h
@@ -26,6 +26,7 @@
 #define _USE_MATH_DEFINES
 #endif
 #include <cmath>                            // For acos
+#include <ctime>
 #include <stdint.h>
 #include <cassert>                          // For assert
 #include <cstring>                          // For memcmp
@@ -502,19 +503,32 @@ namespace librealsense
     // Enumerated type support //
     /////////////////////////////
 
-#define RS2_ENUM_HELPERS(TYPE, PREFIX) RS2_ENUM_HELPERS_CUSTOMIZED(TYPE, PREFIX, 0, RS2_##PREFIX##_COUNT)
-
-#define RS2_ENUM_HELPERS_CUSTOMIZED(TYPE, PREFIX, START, END) LRS_EXTENSION_API const char* get_string(TYPE value); \
-        inline bool is_valid(TYPE value) { return value >= START && value <END; } \
-        inline std::ostream & operator << (std::ostream & out, TYPE value) { if(is_valid(value)) return out << get_string(value); else return out << (int)value; } \
-        inline bool try_parse(const std::string& str, TYPE& res)       \
-        {                                                            \
-            for (int i = START; i < END; i++) {                      \
-                auto v = static_cast<TYPE>(i);                       \
-                if(str == get_string(v)) { res = v; return true; }   \
-            }                                                        \
-            return false;                                            \
-        }
+#define RS2_ENUM_HELPERS( TYPE, PREFIX )                                                           \
+    RS2_ENUM_HELPERS_CUSTOMIZED( TYPE, 0, RS2_##PREFIX##_COUNT - 1 )
+
+#define RS2_ENUM_HELPERS_CUSTOMIZED( TYPE, FIRST, LAST )                                           \
+    LRS_EXTENSION_API const char * get_string( TYPE value );                                       \
+    inline bool is_valid( TYPE value ) { return value >= FIRST && value <= LAST; }                 \
+    inline std::ostream & operator<<( std::ostream & out, TYPE value )                             \
+    {                                                                                              \
+        if( is_valid( value ) )                                                                    \
+            return out << get_string( value );                                                     \
+        else                                                                                       \
+            return out << (int)value;                                                              \
+    }                                                                                              \
+    inline bool try_parse( const std::string & str, TYPE & res )                                   \
+    {                                                                                              \
+        for( int i = FIRST; i < LAST; i++ )                                                        \
+        {                                                                                          \
+            auto v = static_cast< TYPE >( i );                                                     \
+            if( str == get_string( v ) )                                                           \
+            {                                                                                      \
+                res = v;                                                                           \
+                return true;                                                                       \
+            }                                                                                      \
+        }                                                                                          \
+        return false;                                                                              \
+    }
 
     RS2_ENUM_HELPERS(rs2_stream, STREAM)
     RS2_ENUM_HELPERS(rs2_format, FORMAT)
@@ -532,7 +546,10 @@ namespace librealsense
     RS2_ENUM_HELPERS(rs2_matchers, MATCHER)
     RS2_ENUM_HELPERS(rs2_sensor_mode, SENSOR_MODE)
     RS2_ENUM_HELPERS(rs2_l500_visual_preset, L500_VISUAL_PRESET)
-    RS2_ENUM_HELPERS_CUSTOMIZED(rs2_ambient_light, AMBIENT_LIGHT, RS2_AMBIENT_LIGHT_NO_AMBIENT, RS2_AMBIENT_LIGHT_LOW_AMBIENT)
+    RS2_ENUM_HELPERS(rs2_calibration_type, CALIBRATION_TYPE)
+    RS2_ENUM_HELPERS_CUSTOMIZED(rs2_calibration_status, RS2_CALIBRATION_STATUS_FIRST, RS2_CALIBRATION_STATUS_LAST )
+    RS2_ENUM_HELPERS_CUSTOMIZED(rs2_ambient_light, RS2_AMBIENT_LIGHT_NO_AMBIENT, RS2_AMBIENT_LIGHT_LOW_AMBIENT)
+
 
     ////////////////////////////////////////////
     // World's tiniest linear algebra library //
@@ -587,20 +604,14 @@ namespace librealsense
                 r.rotation[j * 3 + i] = (i == j) ? 1.f : 0.f;
         return r;
     }
-    inline bool operator==(const rs2_extrinsics& a, const rs2_extrinsics& b)
-    {
-        for (int i = 0; i < 3; i++)
-            if (a.translation[i] != b.translation[i])
-                return false;
-        for (int j = 0; j < 3; j++)
-            for (int i = 0; i < 3; i++)
-                if (std::fabs(a.rotation[j * 3 + i] - b.rotation[j * 3 + i])
-                     > std::numeric_limits<float>::epsilon())
-                    return false;
-        return true;
-    }
     inline rs2_extrinsics inverse(const rs2_extrinsics& a) { auto p = to_pose(a); return from_pose(inverse(p)); }
 
+    // The extrinsics on the camera ("raw extrinsics") are in milimeters, but LRS works in meters
+    // Additionally, LRS internal algorithms are
+    // written with a transposed matrix in mind! (see rs2_transform_point_to_point)
+    rs2_extrinsics to_raw_extrinsics(rs2_extrinsics);
+    rs2_extrinsics from_raw_extrinsics(rs2_extrinsics);
+
     inline std::ostream& operator <<(std::ostream& stream, const float3& elem)
     {
         return stream << elem.x << " " << elem.y << " " << elem.z;
@@ -643,7 +654,7 @@ namespace librealsense
             uint32_t w = 0, uint32_t h = 0,
             uint32_t framerate = 0,
             resolution_func res_func = [](resolution res) { return res; }) :
-            format(fmt), stream(strm), index(idx), height(h), width(w), stream_resolution(res_func), fps(framerate)
+            format(fmt), stream(strm), index(idx), width(w), height(h), fps(framerate), stream_resolution(res_func)
         {}
 
         rs2_format format;
@@ -651,6 +662,8 @@ namespace librealsense
         int index;
         uint32_t width, height, fps;
         resolution_func stream_resolution; // Calculates the relevant resolution from the given backend resolution.
+
+        std::pair< uint32_t, uint32_t > width_height() const { return std::make_pair( width, height ); }
     };
 
 
@@ -1045,6 +1058,7 @@ namespace librealsense
     typedef std::shared_ptr<rs2_frame_callback> frame_callback_ptr;
     typedef std::shared_ptr<rs2_frame_processor_callback> frame_processor_callback_ptr;
     typedef std::shared_ptr<rs2_notifications_callback> notifications_callback_ptr;
+    typedef std::shared_ptr<rs2_calibration_change_callback> calibration_change_callback_ptr;
     typedef std::shared_ptr<rs2_software_device_destruction_callback> software_device_destruction_callback_ptr;
     typedef std::shared_ptr<rs2_devices_changed_callback> devices_changed_callback_ptr;
     typedef std::shared_ptr<rs2_update_progress_callback> update_progress_callback_ptr;
@@ -1758,6 +1772,64 @@ namespace librealsense
 
 }
 
+inline std::ostream& operator<<( std::ostream& out, rs2_extrinsics const & e )
+{
+    return out
+        << "[ r["
+        << e.rotation[0] << "," << e.rotation[1] << "," << e.rotation[2] << "," << e.rotation[3] << "," << e.rotation[4] << ","
+        << e.rotation[5] << "," << e.rotation[6] << "," << e.rotation[7] << "," << e.rotation[8]
+        << "]  t[" << e.translation[0] << "," << e.translation[1] << "," << e.translation[2] << "] ]";
+}
+
+inline std::ostream& operator<<( std::ostream& out, rs2_intrinsics const & i )
+{
+    return out
+        << "[ " << i.width << "x" << i.height
+        << "  p[" << i.ppx << " " << i.ppy << "]"
+        << "  f[" << i.fx << " " << i.fy << "]"
+        << "  " << librealsense::get_string( i.model )
+        << " [" << i.coeffs[0] << " " << i.coeffs[1] << " " << i.coeffs[2]
+        << " " << i.coeffs[3] << " " << i.coeffs[4]
+        << "] ]";
+}
+
+inline std::ostream& operator<<( std::ostream& s, rs2_dsm_params const & self )
+{
+    s << "[ ";
+    if( self.timestamp )
+    {
+        time_t t = self.timestamp;
+        auto ptm = localtime( &t );
+        char buf[256];
+        strftime( buf, sizeof( buf ), "%F.%T ", ptm );
+        s << buf;
+
+        unsigned patch = self.version & 0xF;
+        unsigned minor = (self.version >> 4) & 0xFF;
+        unsigned major = (self.version >> 12);
+        s << major << '.' << minor << '.' << patch << ' ';
+    }
+    else
+    {
+        s << "new: ";
+    }
+    switch( self.model )
+    {
+    case RS2_DSM_CORRECTION_NONE: break;
+    case RS2_DSM_CORRECTION_AOT: s << "AoT "; break;
+    case RS2_DSM_CORRECTION_TOA: s << "ToA "; break;
+    }
+    s << "x[" << self.h_scale << " " << self.v_scale << "] ";
+    s << "+[" << self.h_offset << " " << self.v_offset;
+    if( self.rtd_offset )
+        s << " rtd " << self.rtd_offset;
+    s << "]";
+    if( self.temp_x2 )
+        s << " @" << float( self.temp_x2 ) / 2 << "degC";
+    s << " ]";
+    return s;
+}
+
 template<typename T>
 uint32_t rs_fourcc(const T a, const T b, const  T c, const T d)
 {
@@ -1833,23 +1905,36 @@ std::vector<std::shared_ptr<T>> subtract_sets(const std::vector<std::shared_ptr<
     return results;
 }
 
-    enum res_type {
-        low_resolution,
-        medium_resolution,
-        high_resolution
-    };
+enum res_type {
+    low_resolution,
+    medium_resolution,
+    high_resolution
+};
 
-    inline res_type get_res_type(uint32_t width, uint32_t height)
-    {
-        if (width == 256) // Crop resolution
-            return res_type::high_resolution;
+inline res_type get_res_type(uint32_t width, uint32_t height)
+{
+    if (width == 256) // Crop resolution
+        return res_type::high_resolution;
 
-        if (width == 640)
-            return res_type::medium_resolution;
-        else if (width < 640)
-            return res_type::low_resolution;
+    if (width == 640)
+        return res_type::medium_resolution;
+    else if (width < 640)
+        return res_type::low_resolution;
 
-        return res_type::high_resolution;
-    }
+    return res_type::high_resolution;
+}
+
+inline bool operator==( const rs2_extrinsics& a, const rs2_extrinsics& b )
+{
+    for( int i = 0; i < 3; i++ )
+        if( a.translation[i] != b.translation[i] )
+            return false;
+    for( int j = 0; j < 3; j++ )
+        for( int i = 0; i < 3; i++ )
+            if( std::fabs( a.rotation[j * 3 + i] - b.rotation[j * 3 + i] )
+        > std::numeric_limits<float>::epsilon() )
+                return false;
+    return true;
+}
 
 #endif
diff --git a/src/win/win-helpers.cpp b/src/win/win-helpers.cpp
index 0cfbc74..e09c768 100644
--- a/src/win/win-helpers.cpp
+++ b/src/win/win-helpers.cpp
@@ -84,7 +84,7 @@ namespace librealsense
                 if (to_throw)
                     throw windows_backend_exception(descr);
                 else
-                    LOG_INFO(descr);
+                    LOG_DEBUG(descr);
 
                 return false;
             }
diff --git a/third-party/imgui/imgui-fonts-monofont.hpp b/third-party/imgui/imgui-fonts-monofont.hpp
new file mode 100644
index 0000000..f47ab24
--- /dev/null
+++ b/third-party/imgui/imgui-fonts-monofont.hpp
@@ -0,0 +1,1368 @@
+// File: 'AnonymousPro-Regular.ttf' (112072 bytes)
+// Exported using binary_to_compressed_c.cpp
+static const unsigned int monospace_compressed_size = 65326;
+static const unsigned int monospace_compressed_data[65328/4] =
+{
+    0x0000bc57, 0x00000000, 0xc8b50100, 0x00000400, 0x00010025, 0x82100000, 0x00042e04, 0x2f534f00, 0xbe624a32, 0x52010084, 0x28158240, 0x4d445660, 
+    0x72a56a58, 0x080f823c, 0x0000a020, 0x6d63e005, 0x12927061, 0x01009217, 0x00005862, 0x7663e203, 0x8a042074, 0x01009e0a, 0x2f824c68, 0x70662e3c, 
+    0x41926d67, 0x0100fada, 0x00003c66, 0x61676101, 0x15007073, 0x01000800, 0x1f82b8b5, 0x6c671028, 0x73bc6679, 0x1b82bfec, 0x01000c3f, 0x6468f046, 
+    0x6479786d, 0x0100b44d, 0x00008058, 0x6568d809, 0x2bff6461, 0x0100c49a, 0x222e824d, 0x82683600, 0x670a2310, 0x7f82ce02, 0x10821c20, 0x6d682428, 
+    0x6a347874, 0x1f82d035, 0x0000382f, 0x6f6ce204, 0x05b16163, 0x0100a762, 0x2d1f8248, 0x616de204, 0x88047078, 0x01006103, 0x2f82fc47, 0x616e2028, 
+    0x6704656d, 0x9f82685c, 0x00007c3b, 0x6f706a3b, 0xaae67473, 0x0100d736, 0x0000e8a3, 0x7270ce11, 0xf7307065, 0x211f82d4, 0x2f82a067, 0x00ab3b08, 
+    0x00310002, 0x05730300, 0x00030019, 0xb0450007, 0x09b02f08, 0xdc00b02f, 0xb01008b0, 0x01b0d001, 0x0c04b12f, 0x1000b0f4, 0xf40805b1, 0x4500b000, 
+    0x2f02b058, 0x1502b11b, 0x0c84593e, 0x0c820020, 0x3e0f0035, 0x0604b159, 0x1002b0f4, 0xf40606b1, 0x21213130, 0x82012111, 0x73033203, 0x4203befc, 
+    0x2f0247fd, 0x1905d1fd, 0x2f045cfb, 0x086f8200, 0x01000024, 0xa503a403, 0x1f001b00, 0x20b0bd00, 0x2f21b02f, 0xb1dc02b0, 0xb0f40d03, 0x07b01020, 
+    0x2f07b0d0, 0x0c8206b1, 0xb0100723, 0x2f0c820b, 0xd00fb010, 0xb01006b0, 0x03b0d011, 0xd013b010, 0xb0216582, 0x20058415, 0x20118419, 0x211d841c, 
+    0x9c85d01e, 0x8f821020, 0x86131021, 0x8214209c, 0x8714200c, 0x82b6840c, 0x20b684a9, 0x20198206, 0x2b0c8206, 0x00011bb3, 0x0fb32b04, 0x2b040c01, 
+    0xb022e482, 0x0583d004, 0xb0d0082c, 0x0ab0101b, 0x100fb0d0, 0x058412b0, 0xb0d01626, 0x18b0100c, 0x70821784, 0x1d290b82, 0x253130d0, 0x35231523, 
+    0x23038221, 0x11333523, 0x35230382, 0x82211533, 0x15332403, 0x82331123, 0x031128fe, 0xff75dda4, 0x82dd7500, 0x01752100, 0xfe240784, 0xde00ffae, 
+    0xdd250e82, 0x6d08016e, 0x3d0082e4, 0x01f8fe6d, 0x00f8fe08, 0x00000300, 0x830346ff, 0x2b00d305, 0x3b003200, 0x33b3af00, 0x9a820f08, 0x2c082422, 
+    0x29210582, 0x83a68208, 0x8409209a, 0xd0142ba0, 0xb01029b0, 0x24b0d016, 0x8e82b010, 0x2f1c2f08, 0xea2cdab4, 0x405d022c, 0x192c091b, 0x392c292c, 
+    0x592c492c, 0x792c692c, 0x992c892c, 0xb92ca92c, 0x0d2cc92c, 0x102cb05d, 0xb0d01db0, 0x3c832f1d, 0x42842020, 0xd02f2608, 0x33061b40, 0x33263316, 
+    0x33463336, 0x33663356, 0x33863376, 0x33a63396, 0x33c633b6, 0xd5b45d0d, 0x0233e533, 0x2079835d, 0x316d8436, 0xb000dc3d, 0x2ab02f15, 0x2a2fb22f, 
+    0x39121115, 0x068436b2, 0x31302708, 0x27032e05, 0x17161637, 0x35032e11, 0x37023e34, 0x1e153335, 0x26071703, 0x16112726, 0x0e141516, 0x23150702, 
+    0x0d823401, 0x01363623, 0x08268214, 0x01030e94, 0x6489548d, 0x17810c40, 0x83547481, 0x5a312f5c, 0x4b8a5483, 0x06385c7f, 0x60680d8f, 0x5e31b6b6, 
+    0x018a5687, 0x746a6d61, 0x73ccfd61, 0x33523762, 0x3f0a1019, 0x21447a5f, 0x02159565, 0x54411f0f, 0x7040496d, 0xa40a395b, 0x62440aa4, 0x58193d77, 
+    0x29fe1492, 0x4493af43, 0x08415f78, 0x560202aa, 0x22fe2f79, 0xed027d11, 0x0127674d, 0x392b08aa, 0x05000042, 0xe5ffecff, 0x3705c103, 0x17001300, 
+    0x37002b00, 0x45014300, 0x0a0a32b3, 0x00b32b04, 0x05822c09, 0x09187908, 0x402b0438, 0x1600061b, 0x36002600, 0x56004600, 0x76006600, 0x96008600, 
+    0xb600a600, 0x0d00c600, 0x00d5b45d, 0x5d0200e5, 0x002c22b2, 0xb0391211, 0xdab42f22, 0x0222ea22, 0x091b405d, 0x29221922, 0x49223922, 0x69225922, 
+    0x89227922, 0xa9229922, 0xc922b922, 0x405d0d22, 0x7632660f, 0x96328632, 0xb632a632, 0x0732c632, 0x060d405d, 0x26321632, 0x46323632, 0x06325632, 
+    0x32295782, 0x5d0232e5, 0xea38dab4, 0x084d8438, 0x38193835, 0x38393829, 0x38593849, 0x38793869, 0x38993889, 0x38b938a9, 0x5d0d38c9, 0xf4093eb1, 
+    0xb01018b0, 0xb000dc45, 0x17b02f0f, 0x4500b02f, 0x2f15b058, 0x4215b11b, 0x1d2007e3, 0x1d200c82, 0xb3230c82, 0x823b0227, 0x013530d8, 0xb02b0405, 
+    0x2fb1100f, 0xd9b4f401, 0x832fe92f, 0x085e0862, 0x282f182f, 0x482f382f, 0x682f582f, 0x882f782f, 0xa82f982f, 0xc82fb82f, 0xb05d0d2f, 0x41b1101d, 
+    0x1b40f401, 0x41174107, 0x41374127, 0x41574147, 0x41774167, 0x41974187, 0x41b741a7, 0x5d0d41c7, 0xe641d6b4, 0x305d0241, 0x0e140131, 0x2e222302, 
+    0x3e343502, 0x1e323302, 0x27012502, 0x138e1301, 0x2634012b, 0x15062223, 0x32331614, 0x3b0b8c36, 0x5c4527e1, 0x445c3334, 0x5c442626, 0x455c3433, 
+    0xfcc30127, 0x46035ebc, 0x5e442979, 0x43230f82, 0x83432929, 0x29462e1f, 0x4056bafd, 0x3f56563f, 0xdf015640, 0x82058258, 0x0458220d, 0x21398231, 
+    0x39822929, 0x835f3321, 0x5f240829, 0x3cedfa94, 0xaefb1605, 0x27465a35, 0x355c4427, 0x27435c34, 0x035c4327, 0x58584018, 0x58583f40, 0x5640f3fc, 
+    0x3b083883, 0x03000058, 0xe5ffe7ff, 0x2f05bc03, 0x32002700, 0xe3004200, 0x0e0830b3, 0x1eb32b04, 0x2b043b08, 0x30061b40, 0x30263016, 0x30463036, 
+    0x30663056, 0x30863076, 0x30a63096, 0x30c630b6, 0x3808f982, 0x30e530d5, 0x16b25d02, 0x1211300e, 0x2f16b039, 0xf40833b1, 0xea3bdab4, 0x405d023b, 
+    0x193b091b, 0x393b293b, 0x593b493b, 0x793b693b, 0x993b893b, 0xb93ba93b, 0x0d3bc93b, 0x05a9445d, 0x1b2f1924, 0x464519b1, 0x82052007, 0x4105200c, 
+    0x092007b8, 0x09200c82, 0xb13f0c82, 0x40f40728, 0x1728071b, 0x37282728, 0x57284728, 0x77286728, 0x97288728, 0xb728a728, 0x8228c728, 0x28d63183, 
+    0x5d0228e6, 0xb11019b0, 0xb4f4043e, 0x3ee93ed9, 0x26087c83, 0x3e183e08, 0x3e383e28, 0x3e583e48, 0x3e783e68, 0x3e983e88, 0x3eb83ea8, 0x5d0d3ec8, 
+    0x06013130, 0x07170706, 0x41060627, 0x373407ae, 0x34352626, 0x1e323336, 0x0e141502, 0x36010702, 0x32013736, 0x22820382, 0x14159d08, 0x16140316, 
+    0x35033e17, 0x22232634, 0xbc03020e, 0x9d3b5012, 0xb44a9d5e, 0x64874c69, 0x402f1b3c, 0xb3443e25, 0x58774495, 0x775e3e31, 0x30680139, 0x21fe103d, 
+    0xfe35874e, 0x3f341ea8, 0x3923567d, 0x2f4d6533, 0x452b4e68, 0x35021832, 0x934eae56, 0x54429a6b, 0x4c816038, 0x4354693f, 0x4e994e1d, 0x4c29b69a, 
+    0x6e4e466c, 0xfe254454, 0x469142ae, 0x313b17fe, 0x2d1d5001, 0x81605675, 0x772f7203, 0x413a1e4b, 0x5a4e3550, 0x004e3b23, 0x03750101, 0x052f0244, 
+    0x00030019, 0x01b00013, 0x2705f442, 0xb11b2f00, 0x593e1500, 0x4908d982, 0x02032303, 0x29662b2f, 0x2bfe1905, 0x0100d501, 0x8dfebc00, 0xdf05c102, 
+    0x3e001500, 0x050d10b3, 0x1b402b04, 0x10161006, 0x10361026, 0x10561046, 0x10761066, 0x10961086, 0x10b610a6, 0x5d0d10c6, 0xe510d5b4, 0x005d0210, 
+    0x5a8a0ab0, 0x5a841120, 0x022e3c08, 0x12343502, 0x17373636, 0x1415030e, 0x0217021e, 0x70a66b79, 0xa6703c3c, 0x955f486b, 0x67353567, 0x8dfe6193, 
+    0x01f2d554, 0x01878708, 0x54d5f107, 0xdbc04c5a, 0xed7b79ee, 0x824cc3d9, 0x82e52089, 0x86ec2089, 0x00280889, 0x2b040b0d, 0xea0bdab4, 0x405d020b, 
+    0x190b091b, 0x390b290b, 0x590b490b, 0x790b690b, 0x990b890b, 0xb90ba90b, 0x0d0bc90b, 0x11208982, 0x05208985, 0x0520e482, 0x14358985, 0x07060602, 
+    0x35033e27, 0x27022e34, 0x12021e37, 0x733cec02, 0x308583a5, 0x69353569, 0x6b485f95, 0x023c73a5, 0xfafe8735, 0x2f8483f2, 0x79eddbc1, 0xc0dbf079, 
+    0xd5545a4c, 0x00f7fef1, 0x232a8b82, 0x81030100, 0x1100a503, 0x8b424700, 0x820e2005, 0x470e205d, 0x6a840728, 0x593e0f2b, 0x0e0501b2, 0xb2391211, 
+    0x20068504, 0x20068507, 0x2006850a, 0x2006850d, 0x08068410, 0x01313029, 0x25070505, 0x05132313, 0x37252527, 0x03330305, 0xfe810325, 0x375601aa, 
+    0x740eb4fe, 0x37b4fe0e, 0xaafe5601, 0x824c0137, 0x4c01360c, 0xbdb88c02, 0x7dfecb5e, 0x5ecb8301, 0xcd60b8bd, 0x7afe8601, 0x3f9783cd, 0x030d0000, 
+    0x00b003a4, 0xb337000b, 0x04030d02, 0x1003b02b, 0xb0d007b0, 0x09b01002, 0x02b000d0, 0x20050a41, 0x20ac8208, 0x22ac8208, 0x47060bb3, 0x04270614, 
+    0x100bb0d0, 0x82d006b0, 0x21210887, 0x21112311, 0x33112135, 0xa4032111, 0xfe7468fe, 0x74980168, 0xa4019801, 0x970169fe, 0xfe970175, 0x26ff8269, 
+    0x028bfef0, 0x42ba0062, 0x00200545, 0x01205585, 0x01345582, 0x30593e11, 0x23012531, 0xfe620213, 0xbaba60ee, 0x2f02d1fd, 0x00262f82, 0xa403a401, 
+    0x2f821902, 0xb3000923, 0x83758303, 0x82352069, 0x5cfc2e61, 0xa401a403, 0x01010075, 0x02000075, 0x8653872f, 0x490020a9, 0x302a061c, 0x35232131, 
+    0xba2f0233, 0x4d82baba, 0x10ff2926, 0x4a058903, 0xb0254d84, 0x03b02f01, 0x084d822f, 0x01270136, 0x02fd8903, 0x05fe0262, 0x34f9f917, 0x00000606, 
+    0xffdfff03, 0x05c703e9, 0x0008002f, 0x00250011, 0x2f26b0f8, 0xb02f27b0, 0x12b01026, 0x2f12b0d0, 0xf40c00b1, 0x0824a846, 0x1027b037, 0xb2dc1cb0, 
+    0x111c1202, 0x0eb13912, 0xdab4f408, 0x020eea0e, 0x091b405d, 0x290e190e, 0x490e390e, 0x690e590e, 0x890e790e, 0xa90e990e, 0xc90eb90e, 0xb25d0d0e, 
+    0x422f8411, 0x17200520, 0x1720c982, 0x2007ac44, 0x270c8221, 0x593e0f21, 0x172102b2, 0xb02b5182, 0x06b11017, 0xd9b4f406, 0x8306e906, 0x08210854, 
+    0x28061806, 0x48063806, 0x68065806, 0x88067806, 0xa8069806, 0xc806b806, 0xb05d0d06, 0x0bb11021, 0x08b68206, 0x170b0721, 0x370b270b, 0x570b470b, 
+    0x770b670b, 0x970b870b, 0xb70ba70b, 0x0d0bc70b, 0x0bd6b45d, 0x82020be6, 0x345e8480, 0x14133130, 0x26260117, 0x13022223, 0x12323316, 0x27263411, 
+    0x06644601, 0x60461520, 0x68460806, 0x30630223, 0xbbb05e8d, 0xacb66352, 0xfc1012be, 0xbf7638c4, 0x78bf8787, 0xbf763636, 0x77bf8989, 0x918b0235, 
+    0x5a85027f, 0xfdd5fe60, 0x2b01b07d, 0x81480401, 0x83fcfe3b, 0x7171bcf4, 0x8383f4bc, 0x7171baf4, 0x8342f4ba, 0x02002b05, 0x001905e9, 0xb33a0012, 
+    0x83420811, 0x4a0f2006, 0x0f20065d, 0x0f20f982, 0x3d10fa4a, 0xb2f40602, 0x110f0004, 0x11b03912, 0xd012b0d0, 0x21213130, 0x0e113335, 0x32352303, 
+    0x0982023e, 0x02334408, 0xd3d1fde9, 0x7f6a4e12, 0x768c3d44, 0x75d28a4e, 0x5d297b03, 0x4c8e344d, 0xfb4a9676, 0x0001005c, 0x0300000a, 0x002f0577, 
+    0xb0720020, 0x18b32f05, 0x2b04190b, 0x120809b3, 0x09b02b04, 0xd000b010, 0x822f00b0, 0x07b12308, 0x0682f40d, 0xdc22b022, 0x20059541, 0x208e821c, 
+    0x208e871c, 0x080c820a, 0x3e0f0a32, 0x0606b159, 0x101cb0f4, 0xf40615b1, 0xe915d9b4, 0x405d0215, 0x1815081b, 0x38152815, 0x58154815, 0x78156815, 
+    0x98158815, 0xb815a815, 0x0d15c815, 0x2806ba47, 0x11210107, 0x35211133, 0x06ea4501, 0x23150622, 0x08051246, 0x1373033c, 0xfe3d5031, 0x75270239, 
+    0xfc01b0fc, 0x20384727, 0xa8a4759f, 0x54dfec7f, 0x03427395, 0x585636c7, 0x33fe3f62, 0x8bfe0001, 0x27040279, 0x2f56504e, 0xacb67b78, 0x5c31fadd, 
+    0xd9820085, 0xe9ff1b24, 0xd9829803, 0xd4003626, 0x250b24b3, 0x2f22d682, 0xd6821e0c, 0xb1102f37, 0xb1f40913, 0xb0f40800, 0x0bb01024, 0x2f0bb0d0, 
+    0xea1edab4, 0x08ae831e, 0x191e0927, 0x391e291e, 0x591e491e, 0x791e691e, 0x991e891e, 0xb91ea91e, 0x0d1ec91e, 0x2532b25d, 0x39121100, 0xb0102fb0, 
+    0x06064138, 0xf9822a20, 0x49472a20, 0x19b3230f, 0x66821806, 0x10053608, 0xf4060eb1, 0x0e071b40, 0x0e270e17, 0x0e470e37, 0x0e670e57, 0x0e870e77, 
+    0x0ea70e97, 0x0ec70eb7, 0xd6b45d0d, 0x020ee60e, 0x102ab05d, 0xf40621b1, 0xe921d9b4, 0x39858321, 0x21182108, 0x21382128, 0x21582148, 0x21782168, 
+    0x21982188, 0x21b821a8, 0x858321c8, 0x82191821, 0x09f64885, 0x1637272b, 0x3e323316, 0x2e343502, 0x05f64102, 0x2005eb48, 0x08a94223, 0x07066208, 
+    0x9803031e, 0x54997546, 0x4e7da35f, 0xba0c8508, 0x4e683b8a, 0x8d60332d, 0x647f445d, 0x9274923e, 0x764281b0, 0x915465a6, 0x7b853d6d, 0x25466846, 
+    0x8d566801, 0x64343864, 0x97126298, 0x60482798, 0x3965503b, 0x35177514, 0x856e4458, 0xa266a499, 0x5c313b6f, 0x936f5685, 0x5b3b0a13, 0x0200006e, 
+    0x39008200, 0x1905a403, 0x11000e00, 0x0db35100, 0x2b04030c, 0xb0100db0, 0x03b0d008, 0xc342b010, 0x2f072407, 0x4207b11b, 0xb3230fc3, 0x8204030f, 
+    0x1000392c, 0xf40602b1, 0xb0100fb0, 0x04b0d009, 0xd00bb010, 0xb01002b0, 0x0eb0d00d, 0x0807d442, 0x01352137, 0x15331133, 0x01331123, 0xa4030111, 
+    0xfdd3d1fd, 0xae2302b8, 0xfed3d3d3, 0x7549fea4, 0x03770001, 0x77d3fc2d, 0x770100ff, 0x75fd8b02, 0x00010000, 0x03e9ff04, 0x089582aa, 0xa6002a4b, 
+    0xb02f2bb0, 0x00b02f2c, 0x0c15b1dc, 0x15dab4f4, 0x5d0215ea, 0x15091b40, 0x15291519, 0x15491539, 0x15691559, 0x15891579, 0x15a91599, 0x15c915b9, 
+    0x2bb05d0d, 0xd01eb010, 0xb12f1eb0, 0xb0f40c1d, 0x23b2d022, 0x1211001e, 0x05ff4239, 0xca821f20, 0xf8411f20, 0x06262210, 0x05f8411a, 0x06103208, 
+    0x071b40f4, 0x27101710, 0x47103710, 0x67105710, 0x87107710, 0xa7109710, 0xc710b710, 0xb45d0d10, 0x10e610d6, 0x1fb05d02, 0x0621b110, 0x0523b2f4, 
+    0x0ed3411f, 0x41031e21, 0x920808d3, 0x23070622, 0x21152111, 0x33363611, 0x03021e32, 0xb07d48aa, 0x79a05e68, 0x0685084a, 0x44725434, 0x2f587d50, 
+    0x4c7d562f, 0x89369350, 0x58fd3103, 0x6550993c, 0x01447aa8, 0x7da860b6, 0x98683848, 0x75441562, 0x5f352f52, 0x7f4a477d, 0x4043355c, 0xfe758c02, 
+    0x413f3a68, 0x0000ac77, 0xfff8ff02, 0x05be03e9, 0x0022002f, 0xb3df0036, 0x040a0b19, 0x0c00b32b, 0x402b0423, 0x1619061b, 0x36192619, 0x56194619, 
+    0x76196619, 0x96198619, 0xb619a619, 0x8219c619, 0xd52f08c0, 0x0219e519, 0x23dab45d, 0x5d0223ea, 0x23091b40, 0x23292319, 0x23492339, 0x23692359, 
+    0x23892379, 0x23a92399, 0x23c923b9, 0x0ab05d0d, 0x4f2db110, 0xc84407c3, 0x2f052b0c, 0x0f05b11b, 0x1eb3593e, 0x224c2806, 0x06142705, 0x14d9b4f4, 
+    0x538314e9, 0x14084508, 0x14281418, 0x14481438, 0x14681458, 0x14881478, 0x14a81498, 0x14c814b8, 0x19b25d0d, 0x12110f05, 0x1005b039, 0xf40632b1, 
+    0x32071b40, 0x32273217, 0x32473237, 0x32673257, 0x32873277, 0x32a73297, 0x32c732b7, 0xd623ab82, 0x4c32e632, 0x17311129, 0x22232607, 0x3e15020e, 
+    0x1e323303, 0x2e340702, 0x080e8402, 0x021e148a, 0x023e3233, 0x7f47be03, 0xbc8b65ae, 0x8a453373, 0x81c28bcf, 0x698f5a5a, 0x0e356ba1, 0x3c77664e, 
+    0x457bac66, 0x7b542d89, 0x5a7f4c4d, 0x7d542831, 0x5a7b4a56, 0x6cbc0131, 0x714279ac, 0x8583f4ba, 0x876ebdf4, 0x8f506250, 0x5a3378c9, 0x7b452741, 
+    0x814a67ac, 0x5a32365e, 0x834a4b7b, 0x5a313a64, 0x00010084, 0x03000031, 0x00190598, 0xb04b0010, 0x12b02f11, 0xdc05b02f, 0xf40806b1, 0xb01011b0, 
+    0x0eb0d00e, 0x0d0db12f, 0x2406f650, 0xb11b2f0d, 0x0723490d, 0x08143f41, 0x100fb091, 0xf4060bb1, 0x06013130, 0x2307020a, 0x37021a36, 0x11231121, 
+    0x7b980321, 0x021c5094, 0x58230290, 0x92fd7498, 0x04670375, 0xfefe85a0, 0xc1fee7fe, 0x4201b6c1, 0x0a012501, 0x0100ff7d, 0xff030075, 0x03e9fff8, 
+    0x002f05ae, 0x00330027, 0xb3310147, 0x040a0c3e, 0x0c1eb32b, 0xb42b0428, 0x28ea28da, 0x1b405d02, 0x28192809, 0x28392829, 0x28592849, 0x28792869, 
+    0x28992889, 0x28b928a9, 0x5d0d28c9, 0x1e2834b2, 0xb0391211, 0xdab42f34, 0x8434ea34, 0x3422082e, 0x34293419, 0x34493439, 0x34693459, 0x34893479, 
+    0x34a93499, 0x34c934b9, 0x00b15d0d, 0x0fb2f40c, 0x3282000a, 0x1b402808, 0x3e163e06, 0x3e363e26, 0x3e563e46, 0x3e763e66, 0x3e963e86, 0x3eb63ea6, 
+    0x5d0d3ec6, 0xe53ed5b4, 0xb25d023e, 0x823e0a14, 0x14b0242b, 0x8423b22f, 0x2eb12235, 0x061e410c, 0x2914ce4c, 0x390631b3, 0x0fb22b04, 0x35823139, 
+    0x8423b221, 0x19b02b06, 0x062bb110, 0x2bd9b4f4, 0x9f822be9, 0x2b28173c, 0x2b482b38, 0x2b682b58, 0x2b882b78, 0x2ba82b98, 0x2bc82bb8, 0x08b45d0b, 
+    0x2082182b, 0x05b02208, 0x0643b110, 0x071b40f4, 0x27431743, 0x47433743, 0x67435743, 0x87437743, 0xa7439743, 0xc743b743, 0x239e8243, 0x43e643d6, 
+    0x200f5b42, 0x05895037, 0x2208d74c, 0x4503031e, 0x14250593, 0x36323316, 0x0f694213, 0x4aae3208, 0x6462ae81, 0x274a81ac, 0x373f6949, 0x46213b56, 
+    0x54549c76, 0x2146769c, 0x4038583b, 0xb8294a68, 0x9c87879c, 0x948f8f94, 0x785f372f, 0x5f784444, 0x38078737, 0x91676f01, 0x602e2e60, 0x6c356791, 
+    0x06083d5d, 0x2b5e503c, 0x2d588558, 0x0804822d, 0x505e2b44, 0x3d08063c, 0x29026c5d, 0x6e7f7f6e, 0xfe7a7a67, 0x3f654709, 0x653f1d1d, 0x44664647, 
+    0x66442121, 0xe9ff0200, 0xb003e9ff, 0x23002f05, 0xe5003700, 0x000824b3, 0x0ab32b04, 0x2b042e08, 0xb1100ab0, 0xfe820b1a, 0x24064708, 0x24262416, 
+    0x24462436, 0x24662456, 0x24862476, 0x24a62496, 0x24c624b6, 0xd5b45d0d, 0x0224e524, 0x2edab45d, 0x5d022eea, 0x2e091b40, 0x2e292e19, 0x2e492e39, 
+    0x2e692e59, 0x2e892e79, 0x2ea92e99, 0x2ec92eb9, 0x50825d0d, 0x4739b021, 0x05240638, 0x05b11b2f, 0x20073f45, 0x270c820f, 0x593e0f0f, 0x1f0629b3, 
+    0x21050544, 0x77820615, 0x17150739, 0x37152715, 0x57154715, 0x77156715, 0x97158715, 0xb715a715, 0x8215c715, 0x15d62977, 0x5d0215e6, 0x050f1ab2, 
+    0x27060544, 0xb4f40633, 0x33e933d9, 0x083e8583, 0x28331833, 0x48333833, 0x68335833, 0x88337833, 0xa8339833, 0xc833b833, 0x305d0d33, 0xc2490331, 
+    0x083e470c, 0x23030e26, 0x37022e22, 0x2006fe43, 0x06a44135, 0x48172008, 0x8965ae7f, 0x463373be, 0xc289d189, 0x772d5a81, 0x6d9f6945, 0x664c1035, 
+    0xac663a79, 0x448a467b, 0x29210706, 0x05064453, 0x5c032e08, 0x4179ac6d, 0x83f2bc71, 0x6fbcf485, 0x31325088, 0x79c98f50, 0x27425a33, 0x66ac7b46, 
+    0x355e814a, 0x4c7d5831, 0x3964834a, 0x00835a31, 0x05bd4b02, 0x00a4032b, 0x00070003, 0x0800b32f, 0x080e5401, 0xb0100123, 0x06fd4905, 0x1b2f0224, 
+    0x014402b1, 0x82042007, 0x0f04260c, 0x3130593e, 0x06fd5301, 0xba2f0222, 0x022e0082, 0x5cfcbbe9, 0x020000ba, 0x8bfef000, 0x53866202, 0x53852a20, 
+    0x4d0a4055, 0x11260c6d, 0x04b2593e, 0x7d460205, 0x234e8205, 0x13230113, 0x33244e83, 0xba60eefe, 0xfd215182, 0x06894c16, 0xdeffc72c, 0xde031403, 
+    0x09000500, 0x3b4cb000, 0x07252906, 0x01170101, 0xfe4d1403, 0x4d257482, 0x4f2d50fe, 0x22088202, 0x8250fe50, 0x00002605, 0x02a403c7, 0x2dd784f6, 
+    0x07b3000f, 0x2b040406, 0x000303b3, 0xc14c2b04, 0x21112105, 0x2107c54c, 0x28825cfc, 0xfd777f2d, 0x000075d1, 0xff8f0001, 0x8add02de, 0x4c052067, 
+    0x013606a3, 0xfedd0237, 0xb0014e00, 0x014e50fe, 0x4f00fede, 0xb001b101, 0x69820050, 0x0000a826, 0x2f058d03, 0x21266982, 0x0bb39000, 0x68820c08, 
+    0x13080426, 0x0cb02b04, 0x82064856, 0xb12d0808, 0xb4f40803, 0x13ea13da, 0x1b405d02, 0x13191309, 0x13391329, 0x13591349, 0x13791369, 0x13991389, 
+    0x13b913a9, 0x5d0d13c9, 0xb01004b0, 0x06a54223, 0x4d0ce547, 0xb02b0752, 0x16b1101f, 0xd9b4f406, 0x8316e916, 0x16083b4c, 0x16281618, 0x16481638, 
+    0x16681658, 0x16881678, 0x16a81698, 0x16c816b8, 0x7e4d5d0d, 0x14012805, 0x2315040e, 0x50043e34, 0x410806ca, 0x36362707, 0x02163233, 0x01baba2f, 
+    0x6656395e, 0x3b913a56, 0x3b566956, 0x5f3f676c, 0x7b062741, 0xa6b0c312, 0x4403baba, 0x5662754e, 0x4e456d5c, 0x5c5e6b7a, 0x64583963, 0x3a604529, 
+    0xaac2a813, 0x9f4d0200, 0x004f2808, 0xb3400160, 0x82440932, 0x0c5821f3, 0xb323f382, 0x820b0c1e, 0x0900220b, 0x32ff8226, 0x1bb0100b, 0x26a9b6d0, 
+    0x26c926b9, 0xdab45d03, 0x8226ea26, 0x490d3eb1, 0x69265926, 0x89267926, 0x06269926, 0x0909405d, 0x29261926, 0x04263926, 0x5611405d, 0x0d2b5432, 
+    0x405d0823, 0x092b540b, 0xb45d0529, 0x32e532d5, 0x82b05d02, 0xd050335a, 0x58061140, 0x58265816, 0x58465836, 0x58665856, 0x2e835876, 0x96588629, 
+    0xb658a658, 0x8358c658, 0xe558232e, 0x77520258, 0x2f4b2406, 0x434bb11b, 0x3d2007f4, 0x3d270c82, 0xb3593e0f, 0x820e035b, 0x011822b0, 0x2fb08253, 
+    0x05b0100e, 0x3d0bb2d0, 0x3912114b, 0x18531bb2, 0xb0340682, 0x21b0105b, 0x2f21b0d0, 0xb1104bb0, 0xb4f4022d, 0x2de92dd9, 0x4608c582, 0x182d081b, 
+    0x382d282d, 0x582d482d, 0x782d682d, 0x982d882d, 0xb82da82d, 0x0d2dc82d, 0x103db05d, 0xf40237b1, 0x37071b40, 0x37273717, 0x37473737, 0x37673757, 
+    0x37873777, 0x37a73797, 0x37c737b7, 0xd6b45d0d, 0x4537e637, 0x35200cba, 0x27099952, 0x17163233, 0x14113335, 0x20075a4b, 0x091b4804, 0x17373631, 
+    0x2e222306, 0x3e343504, 0x1e323304, 0x48262502, 0x2b860547, 0xc703af08, 0x435a3616, 0x192a361d, 0x423e5e16, 0x22163558, 0x23436544, 0x1883184e, 
+    0x18281c17, 0x3e27110b, 0x714a7559, 0x28285d98, 0x5270995d, 0x803b3582, 0x6f915cc4, 0x1817324f, 0x90704f32, 0x78bf875b, 0x1781fe36, 0x3726263f, 
+    0x34391124, 0x162a3c25, 0x8c44ac02, 0x26144871, 0x4b1c2033, 0x7a603a5e, 0x67874a40, 0x3525233d, 0x1c20f3fd, 0x2f645336, 0x697b8945, 0xa2602b4d, 
+    0xd37375d4, 0x313a60a2, 0x5c338144, 0x57a8967e, 0x7e96a959, 0xb66f335b, 0x273104e6, 0x315f4b2d, 0x492d6e6d, 0x02002d5b, 0x0000c5ff, 0x1905e303, 
+    0x0a000700, 0x19443000, 0x2f062405, 0x4b06b11b, 0xb0240f9b, 0xb0584500, 0x08076e44, 0x0308b32c, 0x302b0402, 0x03232131, 0x01230321, 0x03031333, 
+    0x7b93e303, 0x9379fcfd, 0x7dbab201, 0x7501dbdb, 0x19058bfe, 0xa102d5fc, 0x60825ffd, 0x82310021, 0x82a22004, 0x0e4f0865, 0x24001b00, 0x21b38700, 
+    0x2b04040c, 0x0f0c0bb3, 0x0bb02b04, 0x0a1cb110, 0x0c00b1f4, 0x040db2f4, 0x39121100, 0xea0fdab4, 0x405d020f, 0x190f091b, 0x390f290f, 0x590f490f, 
+    0x790f690f, 0x990f890f, 0xb90fa90f, 0x0d0fc90f, 0x1021b05d, 0x82d015b0, 0x26b0213c, 0x20134746, 0x2dc38203, 0x593e0f03, 0x1f0117b3, 0x0db22b04, 
+    0x1b46171f, 0x06143d06, 0x1003b0f4, 0xf40621b1, 0x14013130, 0x11212306, 0x021e3221, 0x16071415, 0x022e3403, 0x3e240e84, 0x26341302, 0x51080984, 
+    0xf2a20336, 0x0160fedf, 0x7d9e5289, 0xb6f8cb4e, 0x326c5a3a, 0x000100ff, 0x38566c38, 0xfe99af2d, 0x991701e9, 0xbb7501af, 0x1b1905ba, 0xcb6a834a, 
+    0x61014c4a, 0x112f5845, 0x311145fe, 0x87f4fd56, 0x81fefd7b, 0xecff0100, 0xac03e9ff, 0x25002f05, 0x3d51e300, 0xdc122106, 0x30064e4f, 0x08b01026, 
+    0x2f08b0d0, 0xb11012b0, 0xb0f40d11, 0x080c8214, 0x1eb11032, 0x1b40f40c, 0x1e161e06, 0x1e361e26, 0x1e561e46, 0x1e761e66, 0x1e961e86, 0x1eb61ea6, 
+    0x5d0d1ec6, 0xe51ed5b4, 0xb05d021e, 0x25b01011, 0x2f25b0d0, 0x2005b841, 0x20f48211, 0x07b84111, 0x0c820d20, 0x0c870d20, 0x08070e41, 0x0310b23b, 
+    0x3912110d, 0xb1100db0, 0xb4f40619, 0x19e919d9, 0x08b65d02, 0x28191819, 0x405d0319, 0x48193815, 0x68195819, 0x88197819, 0xa8199819, 0xc819b819, 
+    0xb05d0a19, 0x23b11003, 0x39928206, 0x23172307, 0x23372327, 0x23572347, 0x23772367, 0x23972387, 0x23b723a7, 0x928223c7, 0xe623d628, 0x305d0223, 
+    0x39430131, 0x48232010, 0x52080ce5, 0x33ac0313, 0xbe89b0e8, 0x79353579, 0xac7989be, 0x35757529, 0x6a447b5a, 0x2323548b, 0xf46a8b54, 0xa8560160, 
+    0xf4ba71c5, 0xbcf48383, 0x98585671, 0x7b4554fe, 0xa264335a, 0xc76263c6, 0x2701659f, 0x00020000, 0x03000031, 0x001905cf, 0x0015000c, 0x5816b070, 
+    0x3a08057a, 0x1016b0dc, 0xb0d006b0, 0x00b02f06, 0x0c0db110, 0x0ddab4f4, 0x5d020dea, 0x0d091b40, 0x0d290d19, 0x0d490d39, 0x0d690d59, 0x0d890d79, 
+    0x0da90d99, 0x0dc90db9, 0x06b05d0d, 0x4a12b110, 0x964e073f, 0x080e570c, 0xb1100727, 0xb0f40610, 0x42288205, 0x0e200536, 0x23052842, 0x1007021e, 
+    0x2c080985, 0x37cf0312, 0xfe87bf79, 0x85a80158, 0x893979bf, 0xe1feacc1, 0xc1ac1f01, 0xed838b02, 0x190568b3, 0x83ecb46b, 0x19010001, 0x1601d1fb, 
+    0x06f14b00, 0xbf827320, 0x3d000b2a, 0x010c0ab3, 0x0ab02b04, 0x430ee147, 0xb3230f7f, 0x82080607, 0x10022326, 0x8a8204b1, 0xb1100023, 0x07e35c0a, 
+    0x11211523, 0x5c038321, 0x022c08e7, 0xb902fefd, 0xfe751905, 0x19fe752d, 0x09266d8b, 0x06b33600, 0x4682070c, 0xb0100623, 0x064f4801, 0x1b2f0824, 
+    0x6d8708b1, 0x915c0620, 0x06032207, 0x23268204, 0x00b11008, 0x6285f184, 0x21112327, 0x47fd7303, 0x24608202, 0x04420389, 0x216082a4, 0xc582a4fd, 
+    0x3005e142, 0x002f05d7, 0xb3d3002b, 0x040a0c20, 0x0d14b32b, 0x08408213, 0xb0101335, 0x1b40d016, 0x20162006, 0x20362026, 0x20562046, 0x20762066, 
+    0x20962086, 0x20b620a6, 0x5d0d20c6, 0xe520d5b4, 0xb05d0220, 0x2bb11013, 0x14b0f408, 0x432db010, 0x132006d0, 0x13208c82, 0x4f0c184a, 0x2b261065, 
+    0x2b042806, 0xff4d12b2, 0x0f4d0805, 0x061bb110, 0x1bd9b4f4, 0x5d021be9, 0x1b081b40, 0x1b281b18, 0x1b481b38, 0x1b681b58, 0x1b881b78, 0x1ba81b98, 
+    0x1bc81bb8, 0x05b05d0d, 0x0625b110, 0x071b40f4, 0x27251725, 0x47253725, 0x67255725, 0x87257725, 0xa7259725, 0xc725b725, 0x23998225, 0x25e625d6, 
+    0x220c1446, 0x46023e34, 0xd242060c, 0x37362a0d, 0x03213521, 0xbf7937d7, 0x18d74287, 0x11b69e2c, 0xb201dffe, 0xf2858902, 0xde426fba, 0x7b47220c, 
+    0x08de4258, 0x75ddf422, 0x350d1f42, 0x2f0cb060, 0xb02f0db0, 0x01b1dc00, 0x0cb0f408, 0xd005b010, 0x0f5f05b0, 0xd0072605, 0xb01001b0, 0x06c84109, 
+    0x240cb645, 0xb11b2f0a, 0x0f43420a, 0x210dc345, 0xc3450609, 0x21112506, 0x33112311, 0x333c0582, 0xfd8a7303, 0x028989d1, 0x5c028a2f, 0x1905a4fd, 
+    0x4802b8fd, 0xba000100, 0xe9020000, 0x2307ad42, 0x2b040308, 0x8c056e44, 0x07124970, 0x0602b125, 0x4206b0f4, 0x082105a5, 0x299c82d0, 0xb01002b0, 
+    0x0bb0d00a, 0x905430d0, 0x35232305, 0x6e821521, 0xfde90238, 0x02d3d3d1, 0x75d2d22f, 0x75752f04, 0x0100d1fb, 0xe9fffeff, 0x67827303, 0x4c001126, 
+    0x0f0800b3, 0x10206787, 0x1020cb82, 0x080fc944, 0x060ab126, 0x071b40f4, 0x270a170a, 0x470a370a, 0x670a570a, 0x870a770a, 0xa70a970a, 0xc70ab70a, 
+    0xb45d0d0a, 0x0ae60ad6, 0x2305be41, 0x26222302, 0x2008dc4b, 0x3de68211, 0xecaed9d3, 0xaa2b772f, 0x3d735c7d, 0xf2018a16, 0xb7effef8, 0x83a22db6, 
+    0x488f734a, 0x81412703, 0x849e2007, 0xb34a2bf3, 0x04050c04, 0x1004b02b, 0x6a4107b0, 0x82092013, 0x4109209e, 0xb22d1c6a, 0x11060008, 0x31303912, 
+    0x07012321, 0x3dfc8211, 0x01330111, 0xfea89e03, 0x89898a4e, 0xfeb52f02, 0x9a7f0200, 0x19051bfe, 0x7b0285fd, 0x1f44c6fd, 0x0005220a, 0x207d8227, 
+    0x07094101, 0x8218f460, 0x11212f5a, 0x03211133, 0x89befc73, 0x1905b902, 0x458a5cfb, 0x6d000c27, 0xb02f0db0, 0x0845420e, 0xe1600d20, 0xf40c2508, 
+    0x00070ab2, 0x4408cb52, 0x0b200c0c, 0x0b20d882, 0x0620d894, 0x23062644, 0x080002b2, 0xb2213b82, 0x20068505, 0x8206840a, 0x1123248b, 0x83032303, 
+    0x131335e8, 0x8a730333, 0x89e662e7, 0xb2f0eeb2, 0x5ffd3f04, 0xc1fba102, 0x5622e882, 0x9944aa02, 0xb062250d, 0x0bb02f0a, 0xb02aa183, 0x04b0100a, 
+    0x2f04b0d0, 0xf36103b1, 0x52072005, 0x294e072f, 0x4baa8c0c, 0x00230890, 0x46b05845, 0x022208ec, 0x9d830500, 0x06840720, 0x01209683, 0x01219383, 
+    0x31938211, 0x89f1fdaa, 0x8af701c1, 0xb0fb5004, 0xe3fb1905, 0x494b1d04, 0x0013290a, 0xb0e20027, 0x29b02f28, 0x28248f84, 0xd00ab010, 0x2a089e83, 
+    0x14b11000, 0xdab4f408, 0x0214ea14, 0x091b405d, 0x29141914, 0x49143914, 0x69145914, 0x89147914, 0xa9149914, 0xc914b914, 0x825d0d14, 0x1eb125c4, 
+    0x1740f40c, 0x2715c547, 0xb6b45d0b, 0x021ec61e, 0x4307c847, 0x0f200550, 0x460bd857, 0x0f20087d, 0x210bab47, 0xac471b40, 0x13a84705, 0x05207582, 
+    0x5f2ca847, 0xf6520e18, 0x36c72110, 0x3b06b758, 0x87bf7935, 0x3876bf87, 0x875c318a, 0x548b6b56, 0x8b542121, 0x548c6a6b, 0x838b0220, 0x2105b458, 
+    0xc4588383, 0xcf812306, 0xab474d92, 0x9f652207, 0x06ab47c7, 0x1905a233, 0x13000a00, 0x14b07200, 0x2f15b02f, 0xb0dc00b0, 0x06ab4714, 0x4105b121, 
+    0x0b2205e5, 0x8c5cf40c, 0x05b02124, 0x54164556, 0x11290840, 0x2b040306, 0xb11007b0, 0x09e4490e, 0x21112325, 0x49071632, 0x360809d6, 0xd9fed5ec, 
+    0xd7ae0189, 0x8eaa89ec, 0x2701d9fe, 0xa403aa8e, 0xd1fdb8bd, 0xbabb1905, 0x00fe7987, 0x02000079, 0x8dfedfff, 0x2f05c703, 0x30002000, 0x31b01c01, 
+    0x8332b02f, 0x21b122b9, 0x08a98208, 0x21ea2123, 0x1b405d02, 0x21192109, 0x21392129, 0x21592149, 0x21792169, 0x21992189, 0x21b921a9, 0x5d0d21c9, 
+    0x05d949b0, 0xaf832120, 0x0fb03208, 0x1031b02f, 0xb0d017b0, 0x2bb12f17, 0x1b40f40c, 0x2b162b06, 0x2b362b26, 0x2b562b46, 0x2b762b66, 0x2b962b86, 
+    0x2bb62ba6, 0x5d0d2bc6, 0xe52bd5b4, 0x072a4d2b, 0x250c5f59, 0xb11b2f0c, 0x5964110c, 0x820f2006, 0x870f200c, 0x8212200c, 0x5f12200c, 0x3c4207bc, 
+    0x0608210b, 0x07396d82, 0x27081708, 0x47083708, 0x67085708, 0x87087708, 0xa7089708, 0xc708b708, 0x376d8208, 0x08e608d6, 0x0bb05d02, 0x2f0bb0d0, 
+    0xb1101cb0, 0xb4f40626, 0x26e926d9, 0x0839e083, 0x28261826, 0x48263826, 0x68265826, 0x88267826, 0xa8269826, 0xc826b826, 0x25e08226, 0x2eb11012, 
+    0x7f58f401, 0x16072d05, 0x36323316, 0x06061537, 0x27262223, 0x4209f552, 0x103a0855, 0x12323312, 0x692fc703, 0x8b1777a8, 0x17312387, 0xcc19351d, 
+    0xa26e17cf, 0x5f423167, 0x22200808, 0x6b688e52, 0xbd21548b, 0x02beacae, 0xb6e77d8b, 0x66860c77, 0x02750202, 0x0eb5ae02, 0x81e7b273, 0x2d076642, 
+    0x64a2c663, 0x63c6a264, 0xd7fefcfe, 0x65422901, 0x05b03006, 0x000f0019, 0xb08e0018, 0x1ab02f19, 0x4b0ab02f, 0x19200765, 0x2a0b3547, 0x10b1100a, 
+    0xdab4f408, 0x8310ea10, 0x100939e0, 0x10291019, 0x10491039, 0x10691059, 0x10891079, 0x10a91099, 0x10c910b9, 0x20050050, 0x13f34514, 0x4d0c6f44, 
+    0x163f0815, 0x2b040f01, 0xb0100fb0, 0x02b0d002, 0x1006b02f, 0xf40613b1, 0x23213130, 0x23112301, 0x64322111, 0x5c4c0581, 0xaeb03809, 0x89cb83fe, 
+    0xecd7ae01, 0x528b643a, 0xfe90a5ed, 0x902501db, 0x422f02a5, 0x23080587, 0x385c8352, 0x856f0106, 0x7900fe7b, 0x19000100, 0x8303e9ff, 0x3f002f05, 
+    0x0cb3dc00, 0x2b04200a, 0x290b2ab3, 0x293d6f82, 0x0800b110, 0x100cb0f4, 0xb0d008b0, 0x2cb01029, 0x1020b0d0, 0xf40c36b1, 0xb0102ab0, 0x064b4941, 
+    0x1b2f2924, 0xcb4529b1, 0x822b2007, 0x132b210c, 0x20064442, 0x200c8225, 0x20198725, 0x06f46109, 0x4500b024, 0x5043b058, 0x043b2808, 0xb22b041b, 
+    0x4d250508, 0x29080643, 0x40f40611, 0x1711071b, 0x37112711, 0x57114711, 0x77116711, 0x97118711, 0xb711a711, 0x0d11c711, 0x11d6b45d, 0x5d0211e6, 
+    0x328528b2, 0x10252908, 0xf40631b1, 0xe931d9b4, 0x405d0231, 0x1831081b, 0x38312831, 0x58314831, 0x78316831, 0x98318831, 0xb831a831, 0x0d31c831, 
+    0x2508c263, 0x23152726, 0x80533311, 0x0851420a, 0x35171624, 0x7e491133, 0x1771080b, 0x8303031e, 0x50947244, 0x7436b86e, 0x7d603e74, 0x4a623a41, 
+    0x745d372b, 0x708e473c, 0x926e4446, 0x2da15f4d, 0x54317979, 0x60353c6c, 0x56332b48, 0x924a3b71, 0x54014a74, 0x34608552, 0x018b5052, 0x506f438d, 
+    0x583d212d, 0x405a3f38, 0x3719162d, 0x505a7954, 0x4e2d567d, 0x8bfe8850, 0x2b49673b, 0x3a543518, 0x2d374833, 0x5a401a17, 0x01000083, 0x07e15a00, 
+    0x6b000f35, 0xb02f10b0, 0x0db0d00d, 0xdc09b02f, 0x010940b2, 0x8201b05d, 0x01013207, 0x0d00b15d, 0x1009b0f4, 0xf40804b1, 0xb1100db0, 0x230d820c, 
+    0x11b01000, 0x24068e41, 0xb11b2f0e, 0x0f744b0e, 0x5a0eb021, 0x3d4905f8, 0x23012716, 0x33112111, 0xfe822115, 0x3a05d057, 0xe8fe75a4, 0xd3d1fdd2, 
+    0x0375e8fe, 0x016003a4, 0x75d1fb44, 0xfe2f0475, 0x83b901bc, 0x493120a5, 0x192d064d, 0x1ab07000, 0x2f1bb02f, 0xb0dc00b0, 0x06cb461a, 0x450db121, 
+    0x17200575, 0x47075b47, 0x18200cec, 0x18209e82, 0x080f6c4b, 0x0612b126, 0x071b40f4, 0x27121712, 0x47123712, 0x67125712, 0x87127712, 0xa7129712, 
+    0xc712b712, 0xb45d0d12, 0x12e612d6, 0x220c304b, 0x41113311, 0x300807c3, 0x73033311, 0x6c9e6731, 0x31659d6d, 0x6d3d1589, 0x3d6f5858, 0xd1018a14, 
+    0x467fb46f, 0x6fb67f46, 0xb8fc4603, 0x486c843b, 0x3b846c48, 0x01004803, 0x079950ff, 0x31000622, 0x20051e47, 0x20958200, 0x0c074a00, 0x01200c87, 
+    0x29081982, 0x593e0f01, 0x000105b2, 0x30391211, 0x23010131, 0x01013301, 0x4cfee303, 0x9150feba, 0x7b017d01, 0xe7fa1905, 0x72fb1905, 0x5b828e04, 
+    0x5000c121, 0x0c2205f5, 0x5b925900, 0x200cd84a, 0x205b8209, 0x072c4309, 0x494b6887, 0x03b2210c, 0xb2217584, 0x20068508, 0x8206840b, 0x23032283, 
+    0x22028203, 0x82131333, 0xe3032d02, 0x8785a2eb, 0xb891e9a0, 0xb8848783, 0x02238b83, 0x8283fd7d, 0x02ce268f, 0x0443fdbd, 0x20938232, 0x269382e9, 
+    0x001905ba, 0x637a001b, 0xe2870a0f, 0x86821520, 0x8c491520, 0x82072014, 0x82072019, 0x02b13efc, 0x03b0f406, 0x0004b2d0, 0x3912110e, 0xb0d005b0, 
+    0x09b0d006, 0xd00ab0d0, 0xb1100eb0, 0x261c820c, 0x11b0d010, 0x8512b2d0, 0xd013291f, 0xb0d014b0, 0x18b0d017, 0x10252282, 0xb0d01ab0, 0x06a24b1b, 
+    0x3303032f, 0x33352115, 0x35230101, 0x13231521, 0x08068413, 0x33010138, 0x8efeba03, 0x58cfcd58, 0x017f8dfe, 0x6deafe1b, 0xcb6d7501, 0x750169c5, 
+    0x01f0fe71, 0x01757f18, 0x7554feac, 0x021c0275, 0xfe757513, 0x75a2015e, 0xfdedfd75, 0xd98200e4, 0xd982ec20, 0xd982b820, 0x6700142c, 0x080803b3, 
+    0x10b22b04, 0x734a0308, 0x820c2008, 0x870c20bf, 0x0cf34dd9, 0x2308c546, 0x00b11013, 0x0523bf82, 0x8203b110, 0xd0072706, 0xb0d008b0, 0xd9831000, 
+    0xdc820b20, 0x0fb0d027, 0x0510b2d0, 0x8251820c, 0x12b021df, 0x0122c682, 0x2a430123, 0x3fc48a06, 0xfe6ab803, 0xd1fdd2c9, 0x6ac9fed3, 0xe36c7001, 
+    0x70016ce1, 0x8ffda404, 0x757542fe, 0x7102be01, 0x1423b682, 0x8275ec01, 0x310021b1, 0x7720b182, 0x0d2db182, 0x0eb05500, 0x2f0fb02f, 0xb0dc00b0, 
+    0x06b1480e, 0xd001b026, 0x000603b2, 0x06256e83, 0x0d05b110, 0x218b82f4, 0xa15b0bb1, 0x0c425007, 0x20082746, 0x20ba8507, 0x08b74f00, 0x21013527, 
+    0x21112311, 0x3c068215, 0xfc770333, 0xfd9002ba, 0x310375e5, 0x290277fd, 0x2f047575, 0xb501c0fe, 0x01d1fb75, 0x3a8d8245, 0x8bfe7501, 0xd305e902, 
+    0x2d000700, 0x010906b3, 0x01b02b04, 0x0e00b110, 0x4603b0f4, 0x6684069b, 0x593e1125, 0x5f0103b3, 0x06240640, 0x3130f401, 0x213d5b82, 0x21112115, 
+    0x8cfee902, 0xfafe7401, 0x8bfe0601, 0xf96f4807, 0x00010098, 0x0310ff85, 0x0eff63e5, 0x0107052e, 0x62e50337, 0xbc6202fd, 0x33070634, 0xba202582, 
+    0x2f207982, 0x30237984, 0x580e00b3, 0xb123058f, 0x82f40903, 0x08905880, 0x07207c88, 0x02207c87, 0x35207c85, 0x35297a82, 0xfe2f0221, 0xfe07018b, 
+    0x23c583f9, 0x6f680671, 0x02315582, 0xa6032f02, 0x06001905, 0xb0001d00, 0x03b02f00, 0x096f462f, 0x593e1523, 0x05b74bb2, 0x2339bf82, 0x01230101, 
+    0x98a60333, 0xc7fec5fe, 0xb8750198, 0x65022f02, 0xea029bfd, 0x26458200, 0x0346ff00, 0x65bbffa4, 0x05200c0f, 0x21084958, 0x238375ba, 0xf403e526, 
+    0x5405bc02, 0x2f0de564, 0x02372507, 0x52fe29bc, 0x41350442, 0x02006df3, 0x3305774e, 0x2600ba03, 0xed003700, 0xb02f38b0, 0x38b02f39, 0xd000b010, 
+    0x39379c83, 0xdc1cb010, 0xf4080bb1, 0xb2d01eb0, 0x111c001f, 0x0bb03912, 0x822cb010, 0x1028081c, 0xf40c35b1, 0x35061b40, 0x35263516, 0x35463536, 
+    0x35663556, 0x35863576, 0x35a63596, 0x35c635b6, 0xd5b45d0d, 0x0235e535, 0x2506f456, 0xb11b2f17, 0x77471317, 0x821d2006, 0x491d200c, 0x242007af, 
+    0x24200c82, 0x35080c82, 0x300605b3, 0x17b02b04, 0x0610b110, 0x10d9b4f4, 0x5d0210e9, 0x10081b40, 0x10281018, 0x10481038, 0x10681058, 0x10881078, 
+    0x10a81098, 0x10c810b8, 0x1fb25d0d, 0x92831724, 0xb1102424, 0x8c820627, 0x17270739, 0x37272727, 0x57274727, 0x77276727, 0x97278727, 0xb727a727, 
+    0x8227c727, 0x27d6328c, 0x5d0227e6, 0xb01030b0, 0x2db0d02d, 0x2731302f, 0x05276b34, 0x34351727, 0x2223022e, 0x058e5806, 0x15021e30, 0x0e352311, 
+    0x26222303, 0x023e3205, 0xd5563535, 0x02780808, 0x60b98f58, 0x36353b25, 0x5e563b20, 0x4cb06821, 0x7dd1543e, 0x4675934c, 0x645b248a, 0xbeb92d64, 
+    0x89567701, 0x7b433560, 0x66894a2d, 0x58fc733e, 0x021f4577, 0x43040604, 0x15335844, 0x33672f38, 0x84512741, 0x9c9efd5c, 0x172b442d, 0x4c33198e, 
+    0x0a582356, 0x482d1402, 0x00633b35, 0x31000200, 0xa403e9ff, 0x14001905, 0xec002400, 0xb02f25b0, 0x00b02f26, 0x1025b0dc, 0x2a05814d, 0xf40c09b1, 
+    0xb2d00cb0, 0x83000a0d, 0x100024f3, 0x610815b1, 0x092326c1, 0x431cb010, 0xea46062d, 0x0caa6f0c, 0x0814fe48, 0x0620b12c, 0x071b40f4, 0x27201720, 
+    0x47203720, 0x67205720, 0x87207720, 0xa7209720, 0xc720b720, 0xb45d0d20, 0x20e620d6, 0x08b25d02, 0x96832005, 0x10102e08, 0xf4061ab1, 0xe91ad9b4, 
+    0x405d021a, 0x181a081b, 0x381a281a, 0x581a481a, 0x781a681a, 0x981a881a, 0xb81aa81a, 0x0d1ac81a, 0x100db25d, 0x05b0461a, 0x020e1424, 0xf5482223, 
+    0x36112305, 0x85603336, 0x075c0808, 0x33161611, 0x03023e32, 0xae7b42a4, 0x3c8b4c6c, 0x8b3c8989, 0x7bae6c4c, 0x54298b42, 0x759e527d, 0x524e893c, 
+    0x012b547b, 0x81b46bd1, 0x54353648, 0x35fe1905, 0x81493933, 0x87506ab5, 0xfe7d3a64, 0x3a38410e, 0x01008764, 0xe9ff0000, 0xba038103, 0xd7002800, 
+    0xb02f29b0, 0x14b02f2a, 0x21071f4b, 0xab4c1029, 0x10142e06, 0xf40b13b1, 0xb0d016b0, 0x20b11008, 0x53f7820c, 0xad4622ba, 0x2f132405, 0x4213b11b, 
+    0x0d2007dc, 0xa6600c82, 0x088f4f08, 0x7c561220, 0x28a75308, 0xa7530320, 0x5625202b, 0x1e210b79, 0x0f284a02, 0x32334708, 0x81033736, 0x6d8dcd3b, 
+    0x424881b6, 0x2b6cb17a, 0x1040505a, 0x4e2d7b7b, 0x7d543e6c, 0x5d312b54, 0xa2685283, 0x6d5cb22b, 0x6db28148, 0x4981b56a, 0x27392914, 0x3e8bfe87, 
+    0x3a294a66, 0x50508764, 0x523a6287, 0x31440044, 0x19052e07, 0x26001600, 0x27b0e800, 0x2f28b02f, 0x06a153b0, 0xab422720, 0x01b02506, 0xd012b010, 
+    0x2b080583, 0x0ab0d017, 0x0c1fb110, 0x061b40f4, 0x261f161f, 0x461f361f, 0x661f561f, 0x861f761f, 0xa61f961f, 0xc61fb61f, 0xb45d0d1f, 0x1fe51fd5, 
+    0x24072a44, 0xb11b2f0f, 0x074d410f, 0x2019fb47, 0x06346305, 0x0624b122, 0x07395d82, 0x27241724, 0x47243724, 0x67245724, 0x87247724, 0xa7249724, 
+    0xc724b724, 0x355d8224, 0x24e624d6, 0x02b25d02, 0x12112405, 0x1015b039, 0xf40613b1, 0xaa420fb0, 0x31302329, 0x145b2321, 0x2311240e, 0x44032135, 
+    0x3a08071b, 0x3233021e, 0x8a730337, 0x6f4a8d3b, 0x414179b0, 0x4a6fb079, 0x01ba3b8d, 0x8b3b8a44, 0x547d524e, 0x7d542b2b, 0x56769e52, 0x81483835, 
+    0xb56a6bb4, 0x35354981, 0xfd755401, 0x413a41b2, 0x6432055b, 0x02007d3a, 0xe9fffcff, 0xba03ae03, 0x22001900, 0x59427b00, 0x0c407305, 0xf1820a20, 
+    0x3e0f0a2e, 0x0622b359, 0xb02b0400, 0x03b1100a, 0x0338fa84, 0x03270317, 0x03470337, 0x03670357, 0x03870377, 0x03a70397, 0x03c703b7, 0x3308fa83, 
+    0x0203e603, 0x1014b05d, 0xf4061db1, 0xe91dd9b4, 0x405d021d, 0x181d081b, 0x381d281d, 0x581d481d, 0x781d681d, 0x981d881d, 0xb81da81d, 0x0d1dc81d, 
+    0x1331305d, 0x2005ce4e, 0x0d524217, 0x85271521, 0x074e08ee, 0x95ba0f89, 0x6029a469, 0x6c8ec246, 0x414883b4, 0x776db07b, 0x913977b2, 0x4281b017, 
+    0x083a5670, 0xb094a201, 0x62424056, 0xb2814867, 0x83b36a6d, 0xc48d5049, 0x96997577, 0x4371502b, 0xba000100, 0xa4030000, 0x19002f05, 0x02b39f00, 
+    0xc8820708, 0x23056774, 0x18b01002, 0x4c06a544, 0xd9590c22, 0x2f0a240c, 0x420ab11b, 0x1820071b, 0x18200c82, 0x210f0e60, 0x304918b0, 0x4c042005, 
+    0xd0230650, 0x74d007b0, 0x09230652, 0x690eb0d0, 0x734c2c96, 0x23850807, 0x36343335, 0x17163233, 0x23262615, 0x21150622, 0x73fea403, 0xd3d1fdd2, 
+    0xc9c7d3d3, 0x1d17412f, 0x83832b3f, 0x2f038d01, 0x757546fd, 0xc075ba02, 0x750406cb, 0x91850604, 0xff020000, 0x0375fefe, 0x00ba0373, 0x012e001f, 
+    0x2f2fb001, 0xb02f30b0, 0x2fb0dc00, 0xd015b010, 0xb12f15b0, 0x40f40c28, 0x1628061b, 0x36282628, 0x56284628, 0x76286628, 0x96288628, 0xb628a628, 
+    0x0d28c628, 0x28d5b45d, 0x5d0228e5, 0x20be82b0, 0x2c3a8209, 0x080fb110, 0xd01db0f4, 0xb0100fb0, 0x06304120, 0x1b2f1e24, 0x09411eb1, 0x821a2007, 
+    0x871a200c, 0x0cad4f0c, 0x19820f20, 0x77470f20, 0x07345107, 0x040cb32b, 0xb02b0405, 0x2bb11012, 0x39898206, 0x2b172b07, 0x2b372b27, 0x2b572b47, 
+    0x2b772b67, 0x2b972b87, 0x2bb72ba7, 0x89822bc7, 0x2bd63c08, 0x5d022be6, 0x2b1210b2, 0xb0391211, 0x23b1101a, 0xd9b4f406, 0x0223e923, 0x081b405d, 
+    0x28231823, 0x48233823, 0x68235823, 0x88237823, 0xa8239823, 0xc823b823, 0xb25d0d23, 0x82231a1d, 0x31302232, 0x06ec4525, 0x1616372c, 0x35363233, 
+    0x22230635, 0x5b583526, 0x47072008, 0x1c82086d, 0x03374a08, 0xa1774273, 0x47c38b63, 0x68a22b60, 0x9c7aa58e, 0x7941fadb, 0x8f4c6dae, 0x3b8a8a3b, 
+    0x7d524e8d, 0xa6a62b52, 0x0a3b8d4e, 0x37689660, 0x414a6268, 0x64878f58, 0x6ad9fa6c, 0x354983b3, 0x41d95435, 0x89643a3a, 0x3bbea04e, 0x0b6f5542, 
+    0x8e001322, 0x36088953, 0xf40801b1, 0xb01014b0, 0x0cb0d00c, 0x0c0bb12f, 0xd00eb0f4, 0x560c0fb2, 0x495c0914, 0x2f11240c, 0x4111b11b, 0x0b201458, 
+    0x34081982, 0x593e0f0b, 0xb11011b0, 0xb4f40605, 0x05e905d9, 0x1b405d02, 0x05180508, 0x05380528, 0x05580548, 0x05780568, 0x05980588, 0x05b805a8, 
+    0x5d0d05c8, 0x0d000fb2, 0x05195711, 0xdb711120, 0x152c0805, 0x33112311, 0x20331211, 0x8a730311, 0x7b4c796c, 0x89892d56, 0x5801fe63, 0x8a7d3f02, 
+    0x52977546, 0x19055efe, 0x0001a1fd, 0x020085fe, 0x2e089958, 0x000d0003, 0x0e0cb35f, 0xb22b0406, 0x820c0601, 0x01b02252, 0x0616512f, 0x8207b121, 
+    0x590620df, 0x44570927, 0x0c4b430c, 0x2807c851, 0xf40606b1, 0xb1100ab0, 0x82068208, 0xd00c2438, 0x63d00db0, 0x13280561, 0x11333521, 0x11213523, 
+    0x3105476f, 0xd3d3d1fd, 0x04d25d01, 0xe7fabb5e, 0x75ba0275, 0x9382d1fc, 0x75fe0430, 0x1905e902, 0x16000300, 0x00b33e00, 0x93820108, 0x00010f22, 
+    0x0f239383, 0x5c14b12f, 0x868c076a, 0x1b2f122b, 0x3e1312b1, 0x060ab359, 0x05874204, 0xf4061022, 0x01217285, 0x09b95822, 0x14357983, 0xbae90206, 
+    0xf673feba, 0x75246962, 0x355c4456, 0x5c01d317, 0x338282bd, 0x48ca5cf9, 0x4827524c, 0x2f034266, 0xb45cfc75, 0x000100d7, 0x2207775f, 0x5851000b, 
+    0xd74123c5, 0x07154114, 0x2106c558, 0xcc580ab2, 0xc3a23913, 0x89a883fe, 0xc4130289, 0xa2012dfe, 0x05f8fe9a, 0x0195fc19, 0x0054fef6, 0x260a3f5a, 
+    0xb3440009, 0x5c020e08, 0x03240558, 0x02b0f408, 0x4f09f45c, 0xb0430c73, 0x0b4c5a07, 0x08232b82, 0x4e09b0d0, 0x844106a3, 0x41e92006, 0x75250681, 
+    0xfb752f04, 0x089b515c, 0x00ba0328, 0xb0da0021, 0x5e442f22, 0x0ab02905, 0x0aefb2dc, 0x40b25d01, 0xb0210482, 0x200c8201, 0x820c8301, 0x00b12804, 
+    0x0ab0f40c, 0x8209b110, 0x1015238c, 0x0d8214b1, 0xb2d0172c, 0x110a1518, 0x1cb23912, 0x654a010a, 0x08046405, 0x1b2f1624, 0x624416b1, 0x0c7c4414, 
+    0x4a0c6f44, 0x14200c53, 0x14254082, 0xb0593e0f, 0x2923431e, 0x820eb021, 0x1a002191, 0x06849184, 0x2131302b, 0x26341123, 0x15062223, 0x21088511, 
+    0x0983020e, 0x36153325, 0x82173233, 0x16210803, 0x89a40315, 0x494e3538, 0x3135398a, 0x890a213a, 0x89902b89, 0x777c4431, 0x509e026f, 0xfd94a458, 
+    0x2d0783f2, 0x366e5a3a, 0xa403f2fd, 0x89899d87, 0x1d448f8d, 0xba032208, 0x311d4400, 0x44071341, 0x1120501d, 0x20121d44, 0x1c1d4415, 0xeaa4032f, 
+    0x85fe0001, 0xff020000, 0x03e9ffec, 0x59cf84bc, 0x0c2019cf, 0x415fcf59, 0xcc50071a, 0x79cf5908, 0x8145bc28, 0xb46d6fb4, 0x07824581, 0x826f6d21, 
+    0x2f892a07, 0x5252835c, 0x2f2f5a83, 0x0807835a, 0x012f5c2e, 0x7fb26dcf, 0xb27f4848, 0x81b76a6d, 0xb7814949, 0x6687506a, 0x87663a3a, 0x62875050, 
+    0x87623838, 0x31000200, 0xa4038bfe, 0x1300ba03, 0x2027a34d, 0x27634114, 0x6c0fa34d, 0x0c870ce7, 0x1b2f0924, 0xf45809b1, 0x08ff4a07, 0x412fa34d, 
+    0xb2222a84, 0x65710f0d, 0x2726260b, 0x33112311, 0x0aa24d15, 0xa34d0620, 0x44370809, 0x4a6cae7b, 0x89893c8b, 0xae6c927f, 0x2b89447b, 0x4e527d56, 
+    0x873c3c87, 0x567d524e, 0x6dd1012b, 0x364881b2, 0x0537fe35, 0x476c5619, 0x4e6ab583, 0x3a3a6489, 0x4d0cfe41, 0x022605a3, 0x8bfe0000, 0x5b417303, 
+    0x4ef22006, 0x252006ff, 0x2f078950, 0x09b01026, 0x0808b1dc, 0xd00bb0f4, 0x09000cb2, 0x08059c44, 0x0c14b12a, 0x061b40f4, 0x26141614, 0x46143614, 
+    0x66145614, 0x86147614, 0xa6149614, 0xc614b614, 0xb45d0d14, 0x14e514d5, 0x08b05d02, 0x2409024f, 0xb11b2f08, 0x0c994208, 0x0a200c87, 0x0a201982, 
+    0x080c605a, 0x593e0f30, 0xb11005b0, 0xb4f40620, 0x20e920d9, 0x1b405d02, 0x20182008, 0x20382028, 0x20582048, 0x20782068, 0x20982088, 0x20b820a8, 
+    0x5d0d20c8, 0x054f07b2, 0x05614105, 0x071b403b, 0x27191719, 0x47193719, 0x67195719, 0x87197719, 0xa7199719, 0xc719b719, 0x27998219, 0x19e619d6, 
+    0x0cb25d02, 0x2b066141, 0x023e3411, 0x35173233, 0x11231133, 0x6b05784b, 0x36220583, 0x14491137, 0x7a442d05, 0x7f916caf, 0x8b3b8a8a, 0x7aaf6c4a, 
+    0x21075f41, 0x5f413b3b, 0xb56a3c07, 0x566c4783, 0xc901e7fa, 0x81483635, 0x874e6db2, 0x41383a64, 0x3a41f401, 0x5789643a, 0x9e2a06b9, 0x1700ba03, 
+    0x08b38300, 0x89460c0e, 0x0c0d2d05, 0x100cb0f4, 0xb0d00fb0, 0x11b01008, 0x2020c27f, 0x06814c0a, 0x14b02b08, 0x0602b110, 0x02d9b4f4, 0x5d0202e9, 
+    0x02081b40, 0x02280218, 0x02480238, 0x02680258, 0x02880278, 0x02a80298, 0x02c802b8, 0x4d485d0d, 0xd00c3407, 0xb2d00db0, 0x11140a12, 0x31303912, 
+    0x22232601, 0x5415020e, 0x380806a9, 0x15213523, 0x16322112, 0x4a710317, 0x5c845466, 0xd1fdd331, 0x5c01d3d3, 0x4707015e, 0x21032d69, 0x97754825, 
+    0x75d3fe50, 0x75ba0275, 0x120001ea, 0xff010017, 0x03e9fff6, 0x2ecf828b, 0xb0df0032, 0x34b02f33, 0xdc00b02f, 0x770c0eb1, 0x2f08255b, 0xb01033b0, 
+    0x18b0d018, 0x0c29b12f, 0x061b40f4, 0x26291629, 0x46293629, 0x66295629, 0x86297629, 0xa6299629, 0xc629b629, 0xb45d0d29, 0x29e529d5, 0x24079b4e, 
+    0xb11b2f1d, 0x0c3c421d, 0x593e0f26, 0x13052eb3, 0x2105f072, 0x4c82060c, 0x170c0739, 0x370c270c, 0x570c470c, 0x770c670c, 0x970c870c, 0xb70ca70c, 
+    0x820cc70c, 0xd62f084c, 0x020ce60c, 0x101db05d, 0xf40624b1, 0xe924d9b4, 0x405d0224, 0x1824081b, 0x38242824, 0x58244824, 0x78246824, 0x98248824, 
+    0xb824a824, 0x5a24c824, 0x37280b16, 0x20331616, 0x022e3435, 0x4b0a105a, 0x2a080831, 0x1e17021e, 0x528b0303, 0x7f4c9f81, 0x673d5cfc, 0x35016bc8, 
+    0x3d6f5633, 0x4d7f9a4e, 0x56a07747, 0x374ec27b, 0x2b60a450, 0x833d5a69, 0x4c280816, 0x014e7f9b, 0x406c5202, 0x763c4a1b, 0x27a04641, 0x08121f31, 
+    0x643c1e0b, 0x44664652, 0x6b353920, 0x250f2d38, 0x2f272d3b, 0x3a221684, 0x45510064, 0x05ae2a06, 0x001b0019, 0x0c13b385, 0x29f28208, 0x0cb01008, 
+    0x1013b0d0, 0x3a420eb0, 0x0c2f4b06, 0x1b2f0b24, 0xc8440bb1, 0x07165114, 0x0fb03a08, 0x0609b110, 0xd00ab0f4, 0xb0d011b0, 0x03b0d012, 0x0618b110, 
+    0x071b40f4, 0x27181718, 0x47183718, 0x67185718, 0x87187718, 0xa7189718, 0xc718b718, 0xb45d0d18, 0x18e618d6, 0x0a6d6702, 0x35231129, 0x11331133, 
+    0x59211521, 0x30080571, 0xae033736, 0x5295c710, 0xd3356088, 0x8d0189d3, 0x3b2173fe, 0x89663654, 0x9329010a, 0x876036ad, 0x75d90150, 0x8bfe7501, 
+    0x3327fe75, 0x7f27445a, 0x26db8265, 0x03e9ff31, 0x47a40373, 0x14200aff, 0x25067b44, 0xf40c01b1, 0xe88215b0, 0x25050955, 0x0fb2d00e, 0xc1570c00, 
+    0x82002008, 0x870020e3, 0x20f08ce3, 0x2019820d, 0x076c4d0d, 0x0c821120, 0x0c821120, 0x8405b121, 0x170538dd, 0x37052705, 0x57054705, 0x77056705, 
+    0x97058705, 0xb705a705, 0x8305c705, 0xe60527dd, 0xb25d0205, 0xce59110f, 0x6b132005, 0x1121087d, 0x08e88233, 0x2023022c, 0x6d893111, 0x567a4c79, 
+    0x628a8a2d, 0x03a8fefe, 0x7dc0fda4, 0x97754689, 0xfca20152, 0x00ffe95c, 0x01007b01, 0x0000e1ff, 0xcf82c303, 0x870d415a, 0x820320a8, 0x5903208e, 
+    0x415a0fd8, 0xfec32e10, 0x6afeb86c, 0x014e01a4, 0xfca4034c, 0x2203825c, 0x823103cf, 0x86e5205b, 0x0d415a5b, 0x06204e87, 0x06205b82, 0x8f0cb146, 
+    0x31415a68, 0xa0bdc32c, 0xbfa08d95, 0x88918792, 0x87828795, 0xac025c24, 0xf88254fd, 0xea021623, 0x590382fd, 0xba200667, 0x1b22ef82, 0x415a7700, 
+    0x0c45520a, 0x2014e14b, 0x08415a07, 0x5af40321, 0x0422173e, 0x3e5ab0f4, 0x2303272e, 0x23152135, 0x06843717, 0x01032d08, 0xfeba0333, 0xb6b8527f, 
+    0x9184fe4b, 0x87f60001, 0xaa567f01, 0x83015eac, 0x0001f683, 0x0e01798f, 0x7979f2fe, 0x50016001, 0xfefe7b7b, 0xb0220382, 0xd182a0fe, 0x75fee124, 
+    0xd182c103, 0x23001222, 0x430aa75b, 0x354d0f4e, 0x31302605, 0x06060101, 0x062e4d23, 0x37363508, 0x01330137, 0xfec10301, 0x568e2708, 0x2f1b6060, 
+    0x33441c5a, 0x60fe3913, 0x015001a2, 0xfba4034a, 0x233d6270, 0x42111476, 0xbf038d2d, 0x2f03d1fc, 0x00010000, 0x03210482, 0x226f8277, 0x5958000d, 
+    0xb02414f7, 0x03b22f01, 0x5905cb4d, 0x614117fa, 0x1ffa5910, 0x7b02b837, 0x0375fcfd, 0x0285fd2f, 0x0275751d, 0x0100ffba, 0x46fd7575, 0x318f8301, 
+    0x028bfeba, 0x00d305e7, 0xb3460026, 0x04060923, 0x8f4eb02b, 0x2a7c8205, 0xb0f40e26, 0x23b0d013, 0x5a17b010, 0x132e0f05, 0x2b041401, 0x09010ab3, 
+    0x1db22b04, 0x27480a09, 0x01252f06, 0x013130f4, 0x022e2223, 0x23341135, 0x05823235, 0x33023e2e, 0x22231533, 0x0e141115, 0x031e0702, 0x45080782, 
+    0xe7023333, 0x49673d5c, 0x29bbbb29, 0x5c3d6749, 0x2d1aaa5c, 0x3e252540, 0x5caa1a2f, 0x4a2b8bfe, 0xa8013e68, 0x01a870a8, 0x4a663eae, 0xfea86f29, 
+    0x404a2252, 0x2d06062f, 0xfe234940, 0x0100aa58, 0x46ff8d01, 0xb1821702, 0x0f000322, 0x7f05fb4e, 0x2f2d0531, 0x23053130, 0x17023311, 0x06ba8a8a, 
+    0x06595a8d, 0x0322d987, 0xd9820a0e, 0xb1100325, 0x5cf4090d, 0x1c26068e, 0x1003b0d0, 0xd98623b0, 0x1b2f082b, 0x3e1108b1, 0x011eb359, 0x22d9821b, 
+    0x82000126, 0x1008292f, 0xf4010ab1, 0x260013b2, 0x85054c47, 0x232323c6, 0xda853335, 0x032e3722, 0x0f84e282, 0x83021e21, 0xe7022bda, 0x664c29b8, 
+    0xa75d5d3d, 0xd3822f1b, 0x1b2d4230, 0x3d5d5da7, 0xb8294c66, 0xfea8f601, 0x09823e56, 0xa8715208, 0x4b23aa01, 0x08062b40, 0x224a402d, 0x6fa8ae01, 
+    0x3c664a2b, 0x00a852fe, 0x00fcff01, 0x02a803f6, 0x002300b0, 0x3e320100, 0x0e173702, 0x2e222303, 0x0e222304, 0x3e270702, 0x1e323303, 0x258b0204, 
+    0x08152133, 0x462b0687, 0x543d4066, 0x32292b39, 0x08118822, 0x3d426428, 0x292b3b54, 0x2f75012f, 0x0e417352, 0x42709a5a, 0x4550462f, 0x70522f2f, 
+    0x9b580f42, 0x452f4171, 0x002f4652, 0xf95effff, 0x8c062b05, 0x22002602, 0x07000000, 0x71828c00, 0x03007322, 0x37081786, 0x0016008b, 0x00250019, 
+    0x0a0ab368, 0xb42b0420, 0x20ea20da, 0x1b405d02, 0x20192009, 0x20392029, 0x20592049, 0x20792069, 0x20992089, 0x20b920a9, 0x5d0d20c9, 0x0a2017b2, 
+    0x2408ae45, 0xb11b2f1d, 0x07705d1d, 0x0c820e20, 0x0e530e20, 0x02052e10, 0xb32b0423, 0x04100317, 0x1331302b, 0x05245a34, 0x0614153f, 0x03230107, 
+    0x01230321, 0x03012626, 0x16141303, 0x35363233, 0x22232634, 0x3e22f206, 0x25c98252, 0x333f233d, 0x0970a101, 0x339f2b06, 0xdbbc013f, 0x375054db, 
+    0x03835037, 0x2faa053e, 0x23233d52, 0x422f523d, 0x1bfb1d66, 0x8bfe7501, 0x681de304, 0xa10286fc, 0xbc035ffd, 0x50322485, 0xecff0100, 0xac038dfe, 
+    0x2e002f05, 0x27b3ea00, 0x8982110c, 0x0b0d0422, 0x34080582, 0x041a0d1b, 0x101ab02b, 0x40d01db0, 0x1627061b, 0x36272627, 0x56274627, 0x76276627, 
+    0x96278627, 0xb627a627, 0x0d27c627, 0x27d5b45d, 0x5d0227e5, 0xb0101bb0, 0x06716130, 0xe7821a20, 0xf4871a20, 0x0c821620, 0x0c871620, 0x20075c42, 
+    0x0b3b68b0, 0x0c200c84, 0x5d082682, 0x593e0f0c, 0xf40509b1, 0x160819b2, 0xb0391211, 0x22b11016, 0xd9b4f406, 0x0222e922, 0x081b405d, 0x28221822, 
+    0x48223822, 0x68225822, 0x88227822, 0xa8229822, 0xc822b822, 0xb05d0d22, 0x2cb1100c, 0x1b40f401, 0x2c172c07, 0x2c372c27, 0x2c572c47, 0x2c772c67, 
+    0x2c972c87, 0x2cb72ca7, 0xaa822cc7, 0xe62cd623, 0x06c8472c, 0x1415072b, 0x35230607, 0x2e353532, 0x090f5403, 0x2f0cec62, 0x03133233, 0x8fc12dac, 
+    0xca935852, 0x316eb27f, 0x2e18426f, 0x1914bd95, 0x755f5893, 0x740815d5, 0x6f7febb9, 0xff37174b, 0x003100ff, 0x06730300, 0x002602c7, 0x00000026, 
+    0x008b0007, 0x88730100, 0x02732417, 0x842f0026, 0x85d72017, 0x056f7417, 0x828c0621, 0x42302017, 0x2f83099d, 0x82e9ff21, 0x20178347, 0x20178c36, 
+    0x22178200, 0x82530575, 0x0242242f, 0x82060000, 0x82ff205f, 0x2015852d, 0x22158854, 0x88000041, 0x88572015, 0x82d62015, 0x82ff2014, 0x03e92419, 
+    0x88190575, 0x898c2015, 0xff04212b, 0xd7201588, 0xca202b8a, 0xdb2c1588, 0x0100ff00, 0x8dfe0000, 0xba038103, 0xea22eb82, 0x514229b3, 0x0b1d2a0a, 
+    0xb02b041c, 0x1fb0101c, 0x24004bd0, 0x101db024, 0x514233b0, 0x2f1c2406, 0x451cb11b, 0x195207ed, 0x2651420c, 0x51421b20, 0x27064b08, 0x0cb03008, 
+    0x012eb110, 0x071b40f4, 0x272e172e, 0x472e372e, 0x672e572e, 0x872e772e, 0xa72e972e, 0xc72eb72e, 0xb45d0d2e, 0x2ee62ed6, 0x31305d02, 0x42060625, 
+    0x165b1151, 0xaa352a17, 0x93585273, 0x75a464ca, 0x1a1a5b3f, 0x0c665223, 0x06554217, 0xac7f4b23, 0x19235b67, 0x59ffff21, 0x052605c9, 0x00260253, 
+    0xf7410046, 0x20158608, 0x22158854, 0x88000041, 0x8857202b, 0x83d62015, 0x202b8614, 0x41158819, 0x8d6e05f7, 0x20578305, 0x565789d5, 0x57830609, 
+    0x57841585, 0x00aa0026, 0x05fc0200, 0x15855783, 0x2b865784, 0x15855783, 0x31265785, 0x73030000, 0x6d82ff04, 0x57844f20, 0x8384d720, 0xe9ffec24, 
+    0xc584bc03, 0x6d895020, 0x1585ff20, 0x15856d83, 0x15866d84, 0x15856d83, 0x15866d84, 0x15856d83, 0x15856d84, 0x15856d84, 0x00216d84, 0x216d8231, 
+    0x57830573, 0x6d865620, 0x15868482, 0x99825620, 0x41221585, 0x6f430200, 0x58052107, 0xd6211588, 0x832b8900, 0x822b856d, 0x0100246d, 0x5601ba00, 
+    0x0b220593, 0x8f471300, 0x452d0805, 0x2f08b058, 0x1508b11b, 0x3130593e, 0x23132701, 0x17350713, 0x37073327, 0x0cede902, 0xeeee0e6e, 0xed0c6e0e, 
+    0xfd0ec903, 0x0e62029e, 0x290f8370, 0x00000200, 0xe902e902, 0x4382d305, 0x7c00272a, 0xb02f28b0, 0x28b02f29, 0x2b06214c, 0xb01029b0, 0x00b0dc0a, 
+    0x0a14b110, 0x25268f50, 0x1eb1100a, 0x4318f40a, 0x002f246f, 0x0f0219b3, 0x05b32b04, 0x2b042302, 0x46113130, 0x0e210891, 0x13a97b02, 0x653b2808, 
+    0x894c4e87, 0x643b3b64, 0x874e4c89, 0x2b5c3b65, 0x393c644e, 0x2b2b4e66, 0x3c39664e, 0x042b4e64, 0x65894c5e, 0x83653b3b, 0x3c642e1e, 0x4e87643c, 
+    0x2b4d653b, 0x3b654d2b, 0x8225853a, 0x082208ed, 0x89030000, 0x1c001905, 0x8d002300, 0xb02f24b0, 0x1ab02f25, 0x0800b1dc, 0x1024b0f4, 0xb0d003b0, 
+    0xee822f03, 0xd008b022, 0x21065467, 0xbc4d101a, 0x1d270806, 0x1b40f40c, 0x1d161d06, 0x1d361d26, 0x1d561d46, 0x1d761d66, 0x1d961d86, 0x1db61da6, 
+    0x5d0d1dc6, 0xe51dd5b4, 0x835d021d, 0x07bc5a3d, 0x2f0c4470, 0xb11b2f1b, 0x593e0f1b, 0x12060bb3, 0x0bb02b04, 0x2b069d5f, 0x091b20b2, 0x30391211, 
+    0x02262531, 0x07dd4e18, 0x16165b08, 0x26260717, 0x36361127, 0x06061737, 0x03231507, 0x11171614, 0x8d010606, 0x6737d3b2, 0x7f8a588f, 0x296039ba, 
+    0x8d5c5c8d, 0xba396029, 0x83fc8a7f, 0xaa837979, 0xc0000121, 0x527da25e, 0x06a6af10, 0x3e42566b, 0x19fd0650, 0x423f4e08, 0xa2086a56, 0xc2858b02, 
+    0x1fcf0221, 0x3f5800c3, 0x05d32a06, 0x002c002f, 0x0c14b381, 0x288c8201, 0x17b01014, 0x011bb2d0, 0x24898214, 0xb01001b0, 0x06a2492a, 0x200cf664, 
+    0x20c08222, 0x22c08322, 0x82160615, 0x10152633, 0xb0d000b0, 0x29d46207, 0x1022b036, 0xf4061bb1, 0xb0d024b0, 0x16b0d025, 0xd02bb010, 0x33133130, 
+    0x8307f641, 0x22232df2, 0x33111506, 0x14112315, 0x20330706, 0x6d08fc82, 0x35212304, 0x023e3233, 0x31231135, 0x78542dbb, 0x4b5f334e, 0x167d0c38, 
+    0x5c623c52, 0x2933baba, 0x700f01ce, 0xfcfe426d, 0x3e4afea6, 0x0d1e3022, 0x01c702bb, 0x5c834c08, 0x5e3f2335, 0x495a1c3c, 0xf8fe707b, 0x50f2fe75, 
+    0x3bdf1669, 0x21758b8e, 0x01173931, 0x0200003b, 0x46ff1400, 0x8b069a03, 0x4f003f00, 0x50b0a000, 0x2f51b02f, 0xd18450b0, 0x2f002a08, 0xf40c40b1, 
+    0x40061b40, 0x40264016, 0x40464036, 0x40664056, 0x40864076, 0x40a64096, 0x40c640b6, 0xd5b45d0d, 0x0240e540, 0x092f425d, 0xd0064208, 0xb01051b0, 
+    0x10b0dc20, 0x2f10b0d0, 0xb11020b0, 0xb4f40848, 0x48ea48da, 0x1b405d02, 0x48194809, 0x48394829, 0x48594849, 0x48794869, 0x48994889, 0x48b948a9, 
+    0x5d0d48c9, 0xb0d011b0, 0x19b01040, 0x333482d0, 0xb0d026b0, 0x39b01048, 0x34b300d0, 0x2b042b06, 0x14060bb3, 0x2205ab49, 0x5c263736, 0x1e21064c, 
+    0x05284102, 0x15020e2d, 0x15041e14, 0x16070614, 0x43141516, 0x535a0531, 0x2e342408, 0x82143704, 0x36380829, 0x2e343536, 0x06062702, 0x3c483f44, 
+    0x916d3f4b, 0x7b955052, 0x16810c52, 0x5e2d87a0, 0xa06a2f4c, 0x386ba0b8, 0x4240333b, 0x56529571, 0x1560839e, 0x96ba1d7f, 0x2b496537, 0x63081983, 
+    0x8f5e896a, 0x312950ac, 0x4c9f8154, 0x3d033d46, 0x2836834c, 0x7b505c79, 0x582b2d54, 0x84155c85, 0x52331781, 0x465a493c, 0x73916042, 0x2b358548, 
+    0x8750587b, 0x582b355e, 0x8b216089, 0x563b1f8e, 0x4a6c583a, 0x7087583e, 0x39425c49, 0x33582127, 0x3948664e, 0x005e2321, 0xba000100, 0xa403ba00, 
+    0x1300a403, 0xb0210182, 0x0a28660f, 0x593e1322, 0x850b9a4a, 0x3cba2ad6, 0x4c4e8764, 0x3c3c6489, 0x05da4364, 0x8b2f0221, 0x241d820d, 0x00030000, 
+    0x3404821f, 0x0019058b, 0x000f000b, 0xb3920015, 0x04080813, 0x0804b32b, 0x21058205, 0x5f670c00, 0xb0310805, 0x04b0d00c, 0xd00eb010, 0xb01005b0, 
+    0x1b40d010, 0x13161306, 0x13361326, 0x13561346, 0x13761366, 0x13961386, 0x13b613a6, 0x5d0d13c6, 0xe513d5b4, 0x071e5313, 0x26227a75, 0x0402040c, 
+    0x6802b02b, 0x0a27074f, 0x060db110, 0x5f0cb0f4, 0x3024060d, 0x11232131, 0x24250183, 0x21211011, 0x300a8203, 0x15060603, 0x8b031714, 0xfe8aeb89, 
+    0x01f30192, 0x08088279, 0xe371722d, 0xd1fd2f02, 0x01273702, 0xfd750146, 0xfefa0191, 0x13f00106, 0x27c9667d, 0x00010000, 0x03e9ff31, 0x002f05a4, 
+    0xb306013b, 0x82250c24, 0x083522d9, 0x22058216, 0x821b0c30, 0x08002405, 0x7b2b040f, 0x23082467, 0xea1bdab4, 0x405d021b, 0x191b091b, 0x391b291b, 
+    0x591b491b, 0x791b691b, 0x991b891b, 0xb91ba91b, 0x0d1bc91b, 0x03671d82, 0x2f2b2c28, 0x152bb11b, 0x00b0593e, 0x66b05845, 0x6e6e07f6, 0x54b1200c, 
+    0x2b2a2840, 0x061eb110, 0x1ed9b4f4, 0xa1831ee9, 0x181e0839, 0x381e281e, 0x581e481e, 0x781e681e, 0x981e881e, 0xb81ea81e, 0x541ec81e, 0x322a0f40, 
+    0x2e343536, 0x3e343504, 0x755e3502, 0x0a534609, 0x14156f08, 0xa403041e, 0x4b815f35, 0x4e428f63, 0x5c446d35, 0x68563c79, 0x50423c56, 0x4a645241, 
+    0x8913355e, 0x7b955019, 0x2b51774c, 0x3b415041, 0x3c586658, 0x6b3d0c01, 0x35382e4d, 0x562f3168, 0x384b385a, 0x394e3931, 0x4a3f4c44, 0x3b64463d, 
+    0xfc488366, 0x4c4c03b2, 0x2d5e8faa, 0x523e684c, 0x22344162, 0x392f2b1b, 0x04006f50, 0x75010000, 0x53475e04, 0x00372e06, 0xb3bd0040, 0x040a0a1e, 
+    0x082cb32b, 0x2205822d, 0x82380834, 0x0a002405, 0x742b0414, 0x40202476, 0x2823357c, 0x000a28b2, 0xb2391211, 0x21068437, 0x5318dab4, 0xb02422e8, 
+    0x3cb0102c, 0x2b06e945, 0xb11b2f3d, 0x593e133d, 0x050223b3, 0x0f229c82, 0x05821902, 0x3b012f24, 0x4a182b04, 0xbd4c0988, 0x181e2005, 0x26104947, 
+    0x23272307, 0x7d112315, 0x58080572, 0x34370706, 0x15232326, 0x04363233, 0xcd93545e, 0x9ccb6c79, 0xcc98585e, 0x9ac87175, 0x854c415a, 0xb46667b4, 
+    0x854d4d88, 0xb46568b5, 0xbabb4e85, 0x018f23ae, 0x485e330c, 0x335e6229, 0x7d7d3b3a, 0xa4033e37, 0x5c99cb6f, 0x7fcd9350, 0x5898cc73, 0x77cc9854, 
+    0x4f88b264, 0x2331824b, 0x4c85b469, 0x26084182, 0x02f2f2e7, 0x50371ba4, 0x0a795037, 0xd73f2dd3, 0x0003003c, 0x04b80002, 0x00190562, 0x002d0019, 
+    0xb3d50041, 0x82240a38, 0x081422c0, 0x24058207, 0x042e0a1a, 0x244d592b, 0x24e64418, 0x26084982, 0x26381638, 0x46383638, 0x66385638, 0x86387638, 
+    0xa6389638, 0xc638b638, 0xb45d0d38, 0x38e538d5, 0x1ab05d02, 0x7143b010, 0xb3230ea6, 0x821f023d, 0x0317228e, 0x2a058202, 0x0411030c, 0x1029b02b, 
+    0x180233b1, 0x2527d744, 0x22230601, 0x8541022e, 0x07172205, 0xef541826, 0x25372107, 0x391ff275, 0x50cd6062, 0x33356085, 0xcd54855e, 0x8c376a60, 
+    0x6a717566, 0x6a01378c, 0x9e419554, 0x99cb240a, 0x414e415a, 0x2a08079e, 0x6568b486, 0x024e87b4, 0x60359312, 0x834c4f86, 0x48933963, 0x64698b64, 
+    0x6e8d648f, 0x505c9acb, 0x737fcc94, 0x56589acd, 0x8277cf96, 0x82502027, 0x68692137, 0x4a059c41, 0x042d0551, 0x0019055e, 0x0014000c, 0x090fb36e, 
+    0x22ee8210, 0x82070906, 0x09002705, 0xb22b0401, 0x8662100a, 0xb02f2206, 0x05866d06, 0x210ab84a, 0x0c8200b0, 0x200ccc69, 0x06317c13, 0x26149778, 
+    0xb11008b0, 0x6ef4010d, 0xa4780922, 0x2305220a, 0x08018211, 0x04213532, 0x4e816e5e, 0x799e6f81, 0x73fd9d79, 0x01b071b0, 0x01e902d1, 0x01b2fe8a, 
+    0x0276fe4e, 0x01b8fe30, 0x41fe7148, 0x0071bf01, 0xf2000100, 0xc702f403, 0x2f0f5b6c, 0x02012705, 0x2550fec7, 0xe7049301, 0x1f0141f3, 0xba22e382, 
+    0x0f625e04, 0x00072206, 0x07135330, 0x10c25a18, 0xba820620, 0x3e15062f, 0x1002b059, 0xf40500b1, 0xb0d004b0, 0x06746205, 0x35230530, 0xbae90233, 
+    0xbb8cfeba, 0xbb5e04bb, 0xe760bbbb, 0x00a42409, 0x55410013, 0x0c200519, 0x0c204082, 0x20078e4e, 0x320c8202, 0x593e0f02, 0x000113b3, 0x0bb32b04, 
+    0x2b040801, 0x831000b0, 0x10132f55, 0xb0d006b0, 0x0eb0100b, 0x1008b0d0, 0x648210b0, 0x07212528, 0x35213723, 0x03821321, 0x33372108, 0x21152107, 
+    0xa4032103, 0x6f5adffd, 0x01ecfe5a, 0x14fea24a, 0x6e5a2102, 0xfe15015a, 0xec01a2b6, 0x703d8082, 0xba6f5001, 0xb0fe6fba, 0xff020000, 0x030000c1, 
+    0x001905a4, 0x0012000f, 0x080eb356, 0x266a8201, 0x09b0100e, 0x8301b0d0, 0x1a2b7c5e, 0x230c0357, 0x020310b3, 0x0321aa83, 0x253f820c, 0x08b11006, 
+    0xb182f403, 0x040eb12c, 0x213130f4, 0x03231121, 0x98820123, 0x03841120, 0x0311012f, 0x06fea403, 0x01916fe9, 0xfe58028b, 0x37998291, 0xfe6f01eb, 
+    0x7501c506, 0x19058bfe, 0x7937fe79, 0x73011dfe, 0x6dfd9302, 0xff2f9c82, 0x03e9ffd3, 0x002f05d3, 0x0026001b, 0x5b1b0132, 0x58080629, 0x04b01033, 
+    0x2f04b0d0, 0xb0d000b0, 0x34b02f00, 0xdc12b010, 0xb0d00db0, 0x12b02f0d, 0x081cb110, 0x1cdab4f4, 0x5d021cea, 0x1c091b40, 0x1c291c19, 0x1c491c39, 
+    0x1c691c59, 0x1c891c79, 0x1ca91c99, 0x1cc91cb9, 0x1eb25d0d, 0x12110d00, 0x1004b039, 0xf40c27b1, 0xc627b6b4, 0x20328227, 0x159d5217, 0x99520b20, 
+    0x2ab22107, 0x1b413584, 0x0cfb4b05, 0x1b2f1733, 0x3e0f17b1, 0x1009b059, 0xf4062eb1, 0xe92ed9b4, 0x3a50822e, 0x182e081b, 0x382e282e, 0x582e482e, 
+    0x782e682e, 0x982e882e, 0xb82ea82e, 0x822ec82e, 0x090d2283, 0x0883832e, 0xb110172e, 0x40f40622, 0x1722071b, 0x37222722, 0x57224722, 0x77226722, 
+    0x97228722, 0xb722a722, 0x0d22c722, 0x22d6b45d, 0x5d0222e6, 0x22171bb2, 0xb2233282, 0x8309171e, 0x842a2006, 0x31302206, 0x083c4a27, 0x37171623, 
+    0x082f4a15, 0x07272631, 0x01273401, 0x32331616, 0x1425023e, 0x5d011716, 0x2d3c058e, 0x351f234e, 0x8387bf79, 0x52873cba, 0x76362323, 0xb98789bf, 
+    0x6a03853b, 0x2999fd22, 0x0805217a, 0x0f2bfd6e, 0x30650212, 0x8b6b5e8d, 0x54bc2154, 0x8368bf54, 0x6a71bcf4, 0x56a0925b, 0x8369be54, 0x6771baf4, 
+    0x6e028d5a, 0x72fd7996, 0x9f65604e, 0x8a4562c7, 0x568b023f, 0xc6a2645c, 0xf8ff0300, 0xb603dc00, 0x1f00c502, 0x33002900, 0x2fb35200, 0x2b04100a, 
+    0x2f061b40, 0x2f262f16, 0x2f462f36, 0x2f662f56, 0x2f862f76, 0x2fa62f96, 0x2fc62fb6, 0x2a08e082, 0x2fe52fd5, 0xb3005d02, 0x04050227, 0x021bb32b, 
+    0xb02b0423, 0x0bb01005, 0x101bb0d0, 0xb0d015b0, 0x2cb01023, 0x1027b0d0, 0x46d032b0, 0x262107b0, 0xb3421827, 0x5f36200d, 0x262306dd, 0x82072223, 
+    0x253621f3, 0x39084145, 0x3f23b603, 0x75483358, 0x4e6f3535, 0x25415631, 0x33563f25, 0x35356f4e, 0x0d834875, 0x565a4b08, 0x4a4a7f3b, 0xfe543b7f, 
+    0x3b834652, 0x813f5256, 0x5a33d101, 0x5a432642, 0x42264558, 0x5b33335a, 0x5a462541, 0x4125465a, 0x5448335b, 0x415e9f9c, 0x4144589c, 0x0200005e, 
+    0x46ff0000, 0xb003a403, 0x0f000b00, 0x02b32d00, 0xb5820309, 0x0b775618, 0x010fb323, 0x22ce820c, 0x4300010b, 0x561808c9, 0x2108126d, 0x21352111, 
+    0x66fea403, 0x0166fe70, 0x9a01709a, 0xa4035cfc, 0x5afea601, 0x0171a601, 0xfd67fe99, 0x6b83712f, 0x6b84ba20, 0x0500de39, 0x0c000900, 0x2f03b000, 
+    0x060109b3, 0x31302b04, 0x01010725, 0x83010117, 0xc8491844, 0x40023108, 0xea0216fd, 0xfe014d2d, 0xfe4e0002, 0x7168fd4e, 0x418ead82, 0x41880520, 
+    0x27010125, 0x84370101, 0x18982041, 0x2107a249, 0x41830c02, 0xfede012a, 0xb1014d02, 0xfb4eb201, 0x8b5f4282, 0x05a42906, 0x00190019, 0x0c02b36e, 
+    0xb228ef88, 0x11020310, 0x02b03912, 0x5d09d858, 0x11200c50, 0x0be44418, 0x2808e744, 0x04000319, 0x030cb32b, 0x081d4109, 0xb0101928, 0x10b2d006, 
+    0x4c830d02, 0xb0100c2a, 0x09b0d013, 0xd015b010, 0x099e5718, 0x21273527, 0x33033335, 0x08018201, 0x15330338, 0x21150721, 0x73fea403, 0x0171fe88, 
+    0xddfe6c8f, 0x0199cce5, 0x21010221, 0xfee1cc99, 0x8d016ee1, 0x68fe9801, 0x23789801, 0x960179d7, 0x5402acfd, 0xd7796afe, 0xc7820023, 0x8bfe312a, 
+    0xa4037303, 0x9e001500, 0x08894418, 0x0801b125, 0x4f16b0f4, 0xb12806b7, 0xb0f40c07, 0x01b0d00a, 0xf2438483, 0x2060180a, 0x82072014, 0x110721de, 
+    0x66061f4b, 0x04200c48, 0x04271982, 0xb2593e0f, 0x82090702, 0x515418d3, 0x06b22328, 0x2f820e04, 0x2131302b, 0x21023523, 0x23112722, 0x0a4e5d11, 
+    0x8a730328, 0x7b00ff60, 0x4f5d8954, 0xfeec2b07, 0x6afe38fd, 0xc2fd1905, 0x505d8b7d, 0x06496505, 0x2f05b622, 0x2523e382, 0x18b0be00, 0x45080158, 
+    0x27270539, 0xdc0eb010, 0x830005b2, 0xb12a0865, 0xb4f40c16, 0x16ea16da, 0x1b405d02, 0x16191609, 0x16391629, 0x16591649, 0x16791669, 0x16991689, 
+    0x16b916a9, 0x5d0d16c9, 0x461800b0, 0x264529e6, 0x2f132b12, 0x0f13b11b, 0x05b2593e, 0xdc820913, 0x21b13608, 0x1b40f406, 0x21172107, 0x21372127, 
+    0x21572147, 0x21772167, 0x21972187, 0x21b721a7, 0x5d0d21c7, 0xe621d6b4, 0x305d0221, 0x36340331, 0x26372436, 0x1e372724, 0x050d4f03, 0x34012625, 
+    0x820e2726, 0x165e080c, 0x023e3233, 0x01cb7414, 0xfe4e9c10, 0x872da6f8, 0x4770bdfa, 0xcd79c088, 0x104103f5, 0xb0f49111, 0x5c91a862, 0x0133628e, 
+    0x7aa26962, 0xae7d1954, 0x8935753b, 0x81a3f8bd, 0xc14e92cf, 0x64376f01, 0x6246102f, 0x90744c7d, 0x00a47440, 0x2b000100, 0x73030000, 0x0f001905, 
+    0x07b34300, 0xe56d080b, 0xd0002905, 0xb01008b0, 0x07b0d00d, 0x18090e7a, 0x410cd840, 0x052008f4, 0x08051760, 0xb110003b, 0x30f4060c, 0x35212131, 
+    0x21350101, 0x21112311, 0x11210101, 0xfc730333, 0xfe4801b8, 0x794803b8, 0x4501d5fd, 0x2b02bbfe, 0x18027579, 0xfe751702, 0xfd440147, 0x01e8fde9, 
+    0x08294845, 0x0b2d8582, 0x0cb05700, 0x2f0db02f, 0xb1dc02b0, 0x05f36203, 0x86820720, 0x06b12f22, 0x4e07047a, 0x62180cba, 0xb02514aa, 0x00b1100a, 
+    0x069e4806, 0x9069b020, 0x23012106, 0x41499483, 0xa4032d05, 0xe4fe89bb, 0xa403ba8a, 0x5cfba404, 0x75210385, 0x057d7200, 0xa403b22c, 0x94001b00, 
+    0xb02f1cb0, 0xa9622f1d, 0x1cb02a06, 0xd016b010, 0xb12f16b0, 0x07196b10, 0x200cd26e, 0x069b5e07, 0x4500b025, 0x7e12b058, 0x09200be3, 0x2606ab7c, 
+    0xf40303b1, 0x70071b40, 0xb22d2100, 0x11180906, 0x18b03912, 0x040fb110, 0x227583f4, 0x78b0d017, 0x252706f7, 0x32331614, 0x4b173736, 0x3b080537, 
+    0x03102311, 0x35123623, 0x15213523, 0x46d10223, 0x0f231c33, 0x2d52291a, 0xec294356, 0x17168b2b, 0xd3a403d3, 0x083835cf, 0x1f197109, 0x0237563a, 
+    0xfe73fe5a, 0x9301c964, 0x007b7bcd, 0x2008eb82, 0x0375fe04, 0x00a206a4, 0xb3270019, 0x04130807, 0x10b3002b, 0x2b040906, 0x030616b3, 0x09b02b04, 
+    0x056b6d10, 0x1016b02b, 0xb0d019b0, 0x31302f19, 0x05536f01, 0x21101127, 0x35272622, 0x208b8316, 0x080c8235, 0x17163249, 0x3f1da403, 0xfe878129, 
+    0x23431f72, 0x7f2d3b1d, 0x1e920185, 0x27062344, 0x8f790204, 0x85fecbfa, 0x04730404, 0x058e7903, 0x067d0135, 0xff030004, 0x020001f8, 0x002b05bc, 
+    0x00340025, 0xb0c40038, 0x3ab02f39, 0x5239b02f, 0xb02106af, 0x15cd763a, 0xb0d02b2a, 0x32b11000, 0x1b40f408, 0x09e14d18, 0x0fff4d18, 0x185d0d21, 
+    0x2307f14d, 0x35b0101c, 0xb0253183, 0x36b0d036, 0x059e432f, 0x1b2f172b, 0x3e1517b1, 0x0638b359, 0x22ea8235, 0x82210626, 0x01052205, 0x057d472f, 
+    0xb0d00a24, 0xd7762f0a, 0x2fb0282b, 0xd02cb010, 0x182f2cb0, 0x2207a451, 0x76161632, 0x062413a5, 0x022e2223, 0x0809a576, 0x14150685, 0x35210116, 
+    0x75450821, 0x251f4d92, 0x271b201f, 0x561a4237, 0x3d374085, 0x753d73a2, 0x758d395c, 0x4c663da8, 0x441a012b, 0x3527476b, 0x96762544, 0xfdef0148, 
+    0x02bc0244, 0x3d6345f8, 0x0404041b, 0x1d31254b, 0x6d2d230c, 0x3b1b2f29, 0xf8fd425c, 0x3a1c816f, 0x2f213250, 0x08501636, 0x2d4c4302, 0x756ffe3a, 
+    0xff030000, 0x020001ee, 0x002d05fe, 0x00250013, 0xb0b20029, 0x2bb02f2a, 0xdc00b02f, 0x76102ab0, 0xb02305ad, 0x68b11000, 0x0a2028fb, 0x342f0e45, 
+    0xb11b2f0f, 0x593e150f, 0x260629b3, 0x21b32b04, 0x2b040506, 0x2ad668b0, 0x081bac4f, 0x32331663, 0x2113023e, 0xfe022135, 0x5291693d, 0x3b6a8e54, 
+    0x548e6a3b, 0x3d699152, 0x5c462989, 0x455c3635, 0x376f8f27, 0x7427465c, 0xe90217fd, 0x9256a403, 0x66373966, 0x91585a90, 0x69373769, 0x673d5891, 
+    0x49272749, 0x967d3d67, 0xfd664827, 0x0000759a, 0x00ecff01, 0x05bc0300, 0x002d002f, 0x0c17b3c7, 0x25b38224, 0x040d0c00, 0x4b18b42b, 0x2f0823a4, 
+    0x17660f40, 0x17861776, 0x17a61796, 0x17c617b6, 0x0d405d07, 0x17161706, 0x17361726, 0x17561746, 0xd5b45d06, 0x0217e517, 0x1024b05d, 0xf40e1cb1, 
+    0x18059242, 0x250cf440, 0xb11b2f06, 0x7c790f06, 0x066b7f0f, 0x10294008, 0xf40112b1, 0xe912d9b4, 0x405d0212, 0x1812081b, 0x38122812, 0x58124812, 
+    0x78126812, 0x98128812, 0xb812a812, 0x0d12c812, 0x1004b05d, 0xb0d01fb0, 0x3130d020, 0x07021401, 0x21153315, 0x79033e11, 0x0e2b053f, 0x1e141502, 
+    0x21111702, 0x57353335, 0x7b0805a3, 0x021e3233, 0x7d6ebc03, 0x43a4fed3, 0x2716385a, 0x5a5e8556, 0x16295685, 0xfe435836, 0x6e79d3a4, 0x77b67b3f, 
+    0x3f7db677, 0xfe91e502, 0x75725df0, 0x671a2301, 0x523f877b, 0x565689a8, 0x3f52a889, 0x1a677b87, 0x7275ddfe, 0x95130156, 0x62a2d571, 0x00d5a262, 
+    0xdbff0300, 0xba03e9ff, 0x3500ba03, 0x4b003c00, 0x4cb01b01, 0x2f4db02f, 0xb1dc3cb0, 0xb2f40c10, 0x11103c00, 0x4cb03912, 0x85083658, 0x3c34080f, 
+    0xd029b010, 0xb01010b0, 0x08b0d03d, 0x0c43b110, 0x061b40f4, 0x26431643, 0x46433643, 0x66435643, 0x86437643, 0xa6439643, 0xc643b643, 0xb45d0d43, 
+    0x43e543d5, 0x2414f367, 0xb11b2f23, 0x0f006823, 0x4500b025, 0x8233b058, 0x0f332d19, 0x0db3593e, 0x2b042905, 0x1d0500b2, 0x0d218983, 0x06ec5610, 
+    0xb1101d26, 0xb4f40114, 0x24d45918, 0x3b852020, 0xb1103324, 0x435f042c, 0x14b03725, 0xd039b010, 0xb1100db0, 0xb0f40640, 0x46b0102c, 0x253130d0, 
+    0x5d73030e, 0x2634240b, 0x61062223, 0x162105ae, 0x05e64b17, 0x14211522, 0x2006fb45, 0x20298206, 0x21218401, 0x90450715, 0x08198305, 0x35023e98, 
+    0x2b0dc101, 0x75314e3d, 0x785d397d, 0x16301640, 0x5e294746, 0x461a5623, 0x4e194146, 0x841c1770, 0x336b5c45, 0x4e54fe0e, 0x12482f4e, 0x667d2375, 
+    0x50017f4c, 0x50424740, 0x172d0c89, 0x3b3c7b56, 0x1d2f3d21, 0x384323aa, 0x50779e23, 0x02234975, 0x734c6004, 0x2b543b48, 0x4512273d, 0x70454e4e, 
+    0xa64abaa4, 0x25413a94, 0x0165696c, 0x858aa3cd, 0x020265a8, 0x56366660, 0x2948351f, 0xd5ff0300, 0xd103e9ff, 0x1900ba03, 0x2f002400, 0x30b0fc00, 
+    0x2f31b02f, 0x845a30b0, 0x315f0807, 0xdc10b010, 0xf40c1ab1, 0xea1adab4, 0x405d021a, 0x191a091b, 0x391a291a, 0x591a491a, 0x791a691a, 0x991a891a, 
+    0xb91aa91a, 0x0d1ac91a, 0xd00bb05d, 0xb02f0bb0, 0x25b11003, 0x1740f40c, 0x25162506, 0x25362526, 0x25562546, 0x25762566, 0x25962586, 0x5d0b25a6, 
+    0xc625b6b4, 0xb45d0225, 0x82e525d5, 0x05276a06, 0x6c055543, 0x152d0c3b, 0x15b11b2f, 0xb0593e0f, 0x2bb11008, 0x4f591806, 0x081b2408, 0x182b182b, 
+    0x25155359, 0x0cb25d0d, 0x83782b08, 0x28b66d06, 0x20151922, 0x30233282, 0x58372731, 0x9f4e06dc, 0x06c04905, 0x4e0d9e4e, 0x2b2c079d, 0x8145455c, 
+    0xb4716db4, 0x495e9841, 0x62080982, 0x42b6716f, 0x2b5e0395, 0x7f2fc9fd, 0x5c835254, 0x2742fd2f, 0x812f3902, 0x5a835252, 0x744a772f, 0x81b76a9a, 
+    0x79444b49, 0x99794c77, 0x487fb26d, 0x0177444a, 0xfe546acf, 0x383a313c, 0x6b508762, 0x31c4014d, 0x87663a3a, 0xd1000200, 0xb603e9ff, 0x03001905, 
+    0x94001f00, 0x040813b3, 0x0cb32b04, 0x18040308, 0x220d6756, 0x58f4080b, 0x00202a37, 0x0bde4218, 0x366a0b20, 0x821d200b, 0x0f1d260c, 0x16b1593e, 
+    0x08508206, 0x17160732, 0x37162716, 0x57164716, 0x77166716, 0x97168716, 0xb716a716, 0x0d16c716, 0x16d6b45d, 0x5d0216e6, 0x33013130, 0x34012315, 
+    0x3335043e, 0x15040e14, 0x080be042, 0xba2f023b, 0x39a2feba, 0x39566756, 0x68563b91, 0x666d3c56, 0x7b0e7f7f, 0xa6b0c312, 0xbb1905ba, 0x754dbdfc, 
+    0x6c5c5762, 0x6a7b4e46, 0x39625c5f, 0x72966558, 0xaac3a812, 0x02020000, 0x2004822f, 0x24f584e9, 0xb33f0007, 0x21f58305, 0x594804b0, 0x10052207, 
+    0x8e4018b0, 0x82042007, 0x180420af, 0x670c9b43, 0x30260f14, 0x33132131, 0xa4820313, 0x3331022b, 0xbaba3352, 0xfcaa03ba, 0x4e7e8256, 0x6b820717, 
+    0x0f00052c, 0x010900b3, 0xb3002b04, 0x4e180105, 0x352c08aa, 0x71a40321, 0xa403cdfc, 0x0070bf01, 0x172a2d82, 0xa4030000, 0x08005e04, 0x9e421600, 
+    0x08124e05, 0x0001082e, 0x31302b04, 0x23012101, 0x01133703, 0xfe363782, 0x68d3fee3, 0x01a66adb, 0x036f010e, 0x0210fcf0, 0xaefd21d5, 0x4582ba03, 
+    0x75fe043a, 0x2b05a403, 0x97002000, 0x0f0803b3, 0x0fb02b04, 0xd013b010, 0xb01003b0, 0x6407a15d, 0x5c180c33, 0x00200c67, 0x200bfe6a, 0x200c8212, 
+    0x23ee8212, 0x05060cb3, 0x002a4682, 0x0601b110, 0xd002b0f4, 0x8e4505b0, 0x02b02206, 0x05496910, 0x7a16b021, 0x01222b8f, 0x1d4a2115, 0x0f8f790d, 
+    0xfea40323, 0x09254a73, 0x240b9479, 0xfc75a403, 0x08294ac1, 0x3f032e08, 0x06c7c075, 0x06047504, 0x02009181, 0x9000ecff, 0x0f03b803, 0x27001300, 
+    0x06010000, 0x022e2223, 0x27072223, 0x1e323336, 0x37323302, 0x2b119013, 0xc572b803, 0x4445584a, 0x64528133, 0x5a230982, 0x85314445, 0x2e138f09, 
+    0x2dc8cf02, 0x3b892d37, 0x2d382fc5, 0x874dfe90, 0x2e37230c, 0x77820090, 0x0000c52c, 0x1905e303, 0x06000300, 0xb9412100, 0xe244180a, 0x04b1210f, 
+    0x0805fb4c, 0x13330135, 0xe3030101, 0xb201e2fb, 0xaafef8ba, 0x1905aafe, 0x18045cfb, 0x0200e8fb, 0x96000e00, 0x27031403, 0x0b000500, 0xb0000f00, 
+    0x09b02f03, 0x2f01b02f, 0x502f07b0, 0x0f3f06d2, 0x17010102, 0x4d140307, 0x4601bafe, 0x507df54d, 0x4401bcfe, 0x4fe5f850, 0x4a014701, 0x86f8fa50, 
+    0x21978207, 0x4b828d00, 0x25039822, 0x05234b87, 0x880bb02f, 0x0101264b, 0x37273727, 0x37058503, 0x4eb8fe98, 0x2f4ef8f8, 0xf850bcfe, 0xdd0150f8, 
+    0xfa4db9fe, 0xb8fe4efa, 0xd7820785, 0xe1820020, 0xba00a422, 0x07200982, 0x40209782, 0xd14fe385, 0x00b02114, 0x3f07d556, 0xb0593e0f, 0x02b11004, 
+    0x03b0f405, 0xd006b0d0, 0xb0d007b0, 0x0bb0d00a, 0x213130d0, 0x05333523, 0x03270386, 0xfebbbba4, 0x83baba8b, 0x83ba2003, 0x68002000, 0xc9220835, 
+    0x35682602, 0x00412406, 0x88750100, 0x88732017, 0x0dc76517, 0xc7651783, 0x23178405, 0xf2ff0200, 0x0806395c, 0x2a00133c, 0x0ab3a000, 0x2b04160c, 
+    0x000c23b3, 0x1b402b04, 0x0a160a06, 0x0a360a26, 0x0a560a46, 0x0a760a66, 0x0a960a86, 0x0ab60aa6, 0x5d0d0ac6, 0xe50ad5b4, 0xb05d020a, 0x1bb11023, 
+    0x0682f409, 0xd01fb02f, 0xb0101bb0, 0x28b2d027, 0x12112300, 0x05004139, 0x1b2f1823, 0x5a4818b1, 0x821c2008, 0x3a66180c, 0x081b7708, 0x58450024, 
+    0x198226b0, 0x3e0f2635, 0x0621b359, 0xb02b0422, 0x1eb1101c, 0x14b0f406, 0x8224b110, 0x82252006, 0x18142152, 0x30235282, 0x18340131, 0x200eaa61, 
+    0x05364d20, 0x2b563520, 0x15500808, 0x06063521, 0x210aa601, 0x3b2f3039, 0x210c0c21, 0x39302f3b, 0xfe940a21, 0x4a2001e0, 0xe3011d48, 0x1b018bfe, 
+    0x7501e5fe, 0x481d1dfe, 0xcf7b8b02, 0x93525293, 0xcc7b7bcf, 0x94525294, 0x02d9fdcc, 0x4ca402a2, 0xfe758650, 0x19fe752d, 0x4c508575, 0x350b7f49, 
+    0x0022001b, 0xb0fc002a, 0x2cb02f2b, 0xdc00b02f, 0xf40823b1, 0xee840bb2, 0x102bb02a, 0xb0d00fb0, 0x13b22f0f, 0x00230f85, 0x8222b010, 0xb110250f, 
+    0x40f40c27, 0x4123be68, 0x11200530, 0x660b707b, 0x59780c66, 0x6f0d200c, 0xb32e0669, 0x04000322, 0x090bb22b, 0x39121111, 0x068413b2, 0x16b03408, 
+    0x011fb110, 0x1fd9b4f4, 0x5d021fe9, 0x1f081b40, 0x1f281f18, 0x1f481f38, 0x1f681f58, 0x1f881f78, 0x1fa81f98, 0x1fc81fb8, 0x25b05d0d, 0x100db0d0, 
+    0x820129b1, 0x072508a3, 0x27291729, 0x47293729, 0x67295729, 0x87297729, 0xa7299729, 0xc729b729, 0xb45d0d29, 0x29e629d6, 0x31305d02, 0x09394f01, 
+    0x23062727, 0x21101120, 0x07584932, 0x34275808, 0x06222326, 0x23100707, 0x33101122, 0x4e0e0232, 0x0e422f4e, 0xb2ba447f, 0xfeaa2b31, 0xa41701e9, 
+    0x546f162f, 0x0e397164, 0x52523793, 0x8d8f043a, 0x018d8e8e, 0x3894a6a2, 0xc9d52947, 0x01e801c9, 0x6062c2e9, 0x54bca068, 0x9e969779, 0x77014a8f, 
+    0x87fe89fe, 0x82010000, 0x03a82b02, 0x001402a4, 0x00090003, 0xe84501b3, 0x35112905, 0xa4031521, 0x6c6ca801, 0xff201e82, 0x04210882, 0x20218702, 
+    0x29218503, 0x21352101, 0xa2fb0204, 0x25825e04, 0x00020038, 0x03e90237, 0x001705a4, 0x0019000c, 0x0d18b374, 0xb32b040f, 0x9a5f0d0b, 0x00b12b05, 
+    0x07b0f40e, 0x100fb0d0, 0x09820db1, 0xfc5c1420, 0x0c974706, 0x4411a850, 0x142407bd, 0x14b11b2f, 0x0b240c83, 0x0500b110, 0x102a4882, 0xf40608b1, 
+    0xb01000b0, 0x7859d00d, 0x05895406, 0x3e34352b, 0x22153302, 0x05331515, 0x2e0b8921, 0xc0fea403, 0x50775029, 0xd1fdcbcb, 0x8227c2fe, 0xc9c92c09, 
+    0x45dae902, 0x75385c7b, 0x87bb1fdf, 0x82002008, 0x020026c3, 0x056d03ec, 0x24c38419, 0x0e01b36b, 0x24c38200, 0x040d0e0e, 0x826c832b, 0x10012abf, 
+    0xf40d0ab1, 0xb0100db0, 0x22798214, 0x8217b110, 0x100e240c, 0x18dc1bb0, 0x2012f74a, 0x20b5820d, 0x23b5820d, 0x070608b3, 0xb1214084, 0x83bb840b, 
+    0x10083c3a, 0xb0d015b0, 0x18b0100b, 0xd019b0d0, 0x21113130, 0x020e1415, 0x35323523, 0x8a252335, 0x3f01220b, 0x23b88428, 0x3e012f02, 0x0521b885, 
+    0x21af8319, 0xb8867437, 0x002d0883, 0x02aa0101, 0x05e902e9, 0x000c0017, 0x0f73413b, 0x69419985, 0x8207200c, 0x41072099, 0x3022104f, 0x34410131, 
+    0xe902290a, 0x5029c1fe, 0xcaca4f77, 0x2a092a41, 0x00010000, 0x01ec02ba, 0x821905fa, 0x41302069, 0x1941051f, 0x0d06410c, 0x3022f98c, 0xd88a1331, 
+    0x4001ba22, 0x89059241, 0x00002acf, 0x00000003, 0x03a4030d, 0x06e545b0, 0xdf5b3520, 0x23618305, 0x01b0d004, 0x0ed35918, 0x593e132a, 0x050506b3, 
+    0x0bb32b04, 0x07cc5918, 0xf4050022, 0x2a05e67d, 0x33352311, 0x21352125, 0x82ba2f02, 0x75013800, 0xa4035cfc, 0xfcbaf602, 0x75ddba5d, 0xff020000, 
+    0x03f0ffee, 0x84b803b6, 0x851d2067, 0x14c072b4, 0x09313035, 0xfeb60307, 0x011dfe1b, 0xfe6201e3, 0x019efe9e, 0x84d30162, 0xfee5220d, 0x2e11851b, 
+    0xffffff00, 0x0375fee1, 0x021905c1, 0x825a0022, 0x000223c3, 0x1583008c, 0xd282ec20, 0x8c06b822, 0x3a201582, 0x03201582, 0x2006796e, 0x2b7f8201, 
+    0x05a403e5, 0x00030037, 0x03b00013, 0x0aab6e18, 0x593e0f22, 0x0131bf82, 0xa4030127, 0x035ebcfc, 0xfaf80446, 0x16053ced, 0x06f15300, 0x2f05ac26, 
+    0x99003500, 0xe25caf85, 0x0ce04508, 0x011a8308, 0xb32b041b, 0x04120111, 0x1011b02b, 0xb0d000b0, 0x0db11006, 0xd9b4f406, 0x020de90d, 0x081b405d, 
+    0x280d180d, 0x480d380d, 0x680d580d, 0x880d780d, 0xa80d980d, 0xc80db80d, 0xb05d0d0d, 0x1fb11026, 0x1b40f406, 0x1f171f07, 0x1f371f27, 0x1f571f47, 
+    0x1f771f67, 0x1f971f87, 0x1fb71fa7, 0x5d0d1fc7, 0xe61fd6b4, 0xb05d021f, 0x2bb0101b, 0x101ab0d0, 0xb0d02db0, 0x34b01012, 0x113130d0, 0x33033e33, 
+    0x27651632, 0x07062a05, 0x06211521, 0x14141514, 0x20088217, 0x09144e16, 0x022e7608, 0x33352327, 0x34353426, 0xa6233734, 0x89603c0e, 0x33bb8b5a, 
+    0x5c841c79, 0x011b8964, 0x02f4fe00, 0xff0c0102, 0x648b1900, 0x791c845c, 0x5a8bbb33, 0x0e3e6089, 0x02029aa4, 0x625a039a, 0xb04a7faa, 0x9b7b1fbc, 
+    0x1671b0b0, 0x2d18192f, 0xaeb27117, 0xbc217b9e, 0xac7d4ab1, 0x2f177162, 0x16311716, 0x00010000, 0x029600c7, 0x0027035c, 0x00090005, 0xb02f03b0, 
+    0x07bd4801, 0x5c020728, 0x01b9fe4e, 0xb0484e47, 0x01002308, 0x2d824801, 0x2503dd22, 0x05202d85, 0x9f482d85, 0xdd022605, 0xf750bbfe, 0x089248f7, 
+    0x02000023, 0x2a008200, 0x2b055e04, 0x1b001700, 0x55b0bf00, 0x1c20057f, 0x34073f4e, 0x03b0d007, 0x0c1bb110, 0xd014b0f4, 0xb0101db0, 0x18b1dc16, 
+    0x0642510c, 0x590c1156, 0x06200c87, 0x200be274, 0xe3781814, 0x0cbd7f0b, 0x10143608, 0xf40604b1, 0xb0d005b0, 0x11b1100a, 0xd9b4f406, 0x0211e911, 
+    0x081b405d, 0x28111811, 0x48113811, 0x68115811, 0x88117811, 0xa8119811, 0xc811b811, 0xb05d0d11, 0x2e858202, 0xd017b0d0, 0xb0d018b0, 0x19b01005, 
+    0x821ab0d0, 0x1810200b, 0x2008a24e, 0x0ffd4a11, 0x11212108, 0x21112133, 0xfb5e0411, 0xd3d3d3a2, 0x422fc8c7, 0x2b401c16, 0x2f028383, 0xfea4fed3, 
+    0xba02755a, 0x2509f54a, 0xba02d1fc, 0x154146fd, 0x000f240a, 0x41b2001b, 0x1d281215, 0xdc0eb010, 0xf40c10b1, 0x73071f41, 0x15410769, 0x0c08410c, 
+    0x1b2f1722, 0x09e24b18, 0x200c0841, 0x08084117, 0x0e2cdc82, 0xd00fb0d0, 0xb0d010b0, 0x14b1100a, 0x26e66a18, 0x20090841, 0x13084110, 0x21331123, 
+    0x05b45011, 0x23153322, 0x2c090841, 0xd33b8767, 0x4c16a4fe, 0xd383833e, 0x050641d3, 0xfb11122d, 0x0433046d, 0x7591810a, 0x670046fd, 0x022f0563, 
+    0x001905e9, 0xb34b0013, 0x04050e01, 0x8201b02b, 0xf40a2bac, 0xf40e00b1, 0xb01004b0, 0x7b83d007, 0x83d00921, 0xd00b240b, 0x5f1001b0, 0x00210626, 
+    0x82c58310, 0xd011210e, 0x2408556c, 0xb11b2f0c, 0x06556c0c, 0x37231726, 0x11173507, 0x2206596c, 0x6c112715, 0x5f6c085d, 0xeded2b05, 0xf00e9c01, 
+    0x0c6e0ef0, 0x646cd901, 0x0e703905, 0x000c27fe, 0x01750101, 0x022f0281, 0x0003003b, 0x00b00009, 0x2f02b02f, 0x34052545, 0xbaba2f02, 0x00ba8101, 
+    0xfe2e0201, 0x006e038e, 0x000c00bb, 0x12d54541, 0x0e20a383, 0x5b06e246, 0x0b200c51, 0x0b239e82, 0x47593e0f, 0x30210a95, 0x0bbf4631, 0x452e0221, 
+    0xbb2007e7, 0x2707b646, 0x00000200, 0x6d038efe, 0x19226d84, 0x65477900, 0x085e4721, 0x14207b8c, 0x14217b82, 0x06815411, 0xb0258887, 0xb0584500, 
+    0x20198218, 0x20958218, 0x1d2e48b0, 0x73473520, 0x88bb8828, 0x00240808, 0xecff0700, 0x5c04dbff, 0x03002f05, 0x1b000f00, 0x33002700, 0x4b003f00, 
+    0x0ab38501, 0x2b04100a, 0x280a22b3, 0x2e220582, 0x05821c09, 0x400a3a22, 0x46220582, 0xf54b3409, 0xb4240826, 0x22c622b6, 0x17405d02, 0x22162206, 
+    0x22362226, 0x22562246, 0x22762266, 0x22962286, 0x5d0b22a6, 0xe522d5b4, 0xb0282082, 0x16b01022, 0x2f16b0d0, 0x18245b61, 0x24243d6c, 0xea40dab4, 
+    0x087a8240, 0x40091b2b, 0x40294019, 0x40494039, 0x40694059, 0x40894079, 0x40a94099, 0x40c940b9, 0x46b05d0d, 0xdc4db010, 0x2f01b000, 0xb02f31b0, 
+    0x05c04649, 0x2d641320, 0x09f87306, 0x593e1526, 0x1f012bb3, 0x0d30fa82, 0x2b041901, 0xb11013b0, 0xb4f40107, 0x07e907d9, 0x08396183, 0x28071807, 
+    0x48073807, 0x68075807, 0x88077807, 0xa8079807, 0xc807b807, 0x24618207, 0x25b11031, 0x51601801, 0x1fb03125, 0xd037b010, 0xb01025b0, 0x2bb0d03d, 
+    0xd043b010, 0x21054347, 0x67603405, 0x25362808, 0x32333634, 0x54141516, 0x14230a93, 0x8c323316, 0x96252017, 0x98022b2f, 0x0266c8fd, 0x2fddfe3d, 
+    0x00823133, 0xfe2f3333, 0x676662d8, 0x66676262, 0x2f620262, 0x31313233, 0x20138232, 0x830f83d7, 0xcf022317, 0x2682342f, 0x2f343124, 0x2787d7fe, 
+    0xfafc0438, 0x230529df, 0x565640f4, 0x56563f40, 0x9393693f, 0x94946869, 0x108e1afd, 0x0f8e6820, 0x20086f4e, 0x086f4ecb, 0x4f74d620, 0x7417830c, 
+    0x17860567, 0x00c5ff27, 0x06e30300, 0x742f88c7, 0x8c200d7f, 0x2f851782, 0x478c8c20, 0x1788c920, 0x2506e74e, 0x0000ba00, 0x4784e902, 0x74002a21, 
+    0xaa200bc7, 0xfc221782, 0x2f82cb06, 0x77861785, 0x5f832f86, 0x5f871785, 0xc9204785, 0x474f2f88, 0xffdf2407, 0x84c703e9, 0x052f4f5f, 0xff20a786, 
+    0xcb201785, 0x84080f75, 0x0200215f, 0x002d0182, 0x3f056804, 0x30000400, 0xb0002000, 0x05744200, 0x083d4018, 0x58450028, 0x1b2f14b0, 0x424914b1, 
+    0x06142805, 0x0e011207, 0x4e222303, 0xbe6705cf, 0x021e2409, 0x823e3233, 0x175d0803, 0x1e141506, 0x93330302, 0x3b020275, 0x6450390e, 0x393a1e38, 
+    0x391f1e3c, 0x441a3536, 0x273d6783, 0x2454794e, 0x1d393e46, 0x403f3e20, 0x926d9323, 0x05452f19, 0x0aa6953f, 0x66fc0a01, 0x52717a2b, 0x10101510, 
+    0xba7b1017, 0x964a5cd7, 0x130e4c76, 0x1014110e, 0x2b8b7b85, 0xff3b4e58, 0x20c586ff, 0x86c588c9, 0x310021f5, 0x1d76f582, 0x41362005, 0x17850c55, 
+    0x2f82cb20, 0xe5411785, 0x202f8408, 0x841788c9, 0x01002147, 0x22056d41, 0x1800a403, 0x54200348, 0xb12b0f2a, 0xb0f40602, 0x04b11006, 0x18b0f403, 
+    0x251d0348, 0xfc79b602, 0x6b8200d1, 0x03aa2c08, 0x05fc02f4, 0x00050058, 0x01b0000c, 0x2f03b02f, 0x302f05b0, 0x27070131, 0x02012707, 0xf6f235fc, 
+    0x04290135, 0xcfcd4339, 0x82230141, 0x044e372f, 0x054e032f, 0x00130000, 0x11b3000f, 0x2b040202, 0x07020cb3, 0x32822b04, 0x2c11fe52, 0x399c5a4e, 
+    0x26363748, 0x5c503f67, 0x2c09829a, 0x40662735, 0x259ecd04, 0x2f6f252b, 0x2005829c, 0x28818371, 0x025204ba, 0x00c304e9, 0x20ef8203, 0x0a7d4eb3, 
+    0xfde90228, 0x042f02d1, 0x75827152, 0x4604b626, 0x0605f002, 0x0f212182, 0x249f8200, 0xb32f09b0, 0x857b8307, 0x37273775, 0x37323316, 0xa875f002, 
+    0x5e4e75a8, 0x045e7171, 0x4c7474ba, 0x5d825e5e, 0x04750127, 0x052f025e, 0x205d8219, 0x084f6819, 0x27055d42, 0xb11b2f02, 0x593e1502, 0x2c092d47, 
+    0x00bb5e04, 0x04f20002, 0x05b40208, 0x28e182cb, 0xb33a001f, 0x041a0a0a, 0x242c582b, 0x17b3002a, 0x2b040f02, 0x1d0205b3, 0x7a055d70, 0x0e270709, 
+    0x2e222302, 0x7a143702, 0x232a1201, 0x2f2f523d, 0x5a223e52, 0xd2793750, 0xe9042b05, 0x233e5130, 0x30513e23, 0xff79522f, 0x22178305, 0x82505038, 
+    0xf20031cb, 0x2f028dfe, 0x09000000, 0x00b32300, 0x2b04070d, 0x20052b4c, 0x20c88204, 0x072b4704, 0x0c820820, 0x830f0821, 0x790520d5, 0x332f0720, 
+    0x58522f02, 0x2973ca93, 0x755f5893, 0x820029d5, 0x04aa3fe3, 0x05640300, 0x00030077, 0x000f0007, 0xb02f02b0, 0x00b02f06, 0x2f04b02f, 0x23013130, 
+    0x03833313, 0x8daa0231, 0xd1fdba8d, 0x04bb8b8b, 0xfe770100, 0x82770189, 0x02360883, 0x0385fef0, 0x002700fc, 0xb334000c, 0x04030a09, 0x061b402b, 
+    0x26091609, 0x46093609, 0x66095609, 0x86097609, 0xa6099609, 0xc609b609, 0xb45d0d09, 0x09e509d5, 0xa8825d02, 0x5c826283, 0x26222108, 0x37363435, 
+    0x14150617, 0xfc033316, 0x27358f7d, 0x506d3225, 0x667d85fe, 0x27235c40, 0x60484c2d, 0x3b1a9542, 0x17370209, 0xfefc0237, 0x35d7fed7, 0x1005f2f6, 
+    0x2001e4fe, 0x00cbcf44, 0x75010200, 0xe7410482, 0x00072205, 0x0da84e1d, 0x820c3a69, 0x23032882, 0x35231303, 0x572d0233, 0x052e054d, 0x0356fc19, 
+    0xbae7faaa, 0xba000200, 0x7f6a4803, 0x00232608, 0xb02f01b0, 0x052c4205, 0x200c7058, 0x06b35704, 0x23204b85, 0x022e4f82, 0x2b6728e9, 0x2b652bba, 
+    0x2ffe1905, 0x0383d101, 0x0101002d, 0x028bfe37, 0x0098ff62, 0x44130003, 0x7c1808d3, 0x052d09b5, 0x02132303, 0x547fac62, 0x01f3fe68, 0x38be820d, 
+    0x9100d9ff, 0x8504cd03, 0x35002100, 0x36b08500, 0x2f37b02f, 0xb0dc04b0, 0x06074836, 0x1004b027, 0xf40822b1, 0xbb8218b4, 0xb0440823, 0x2cb11016, 
+    0x1b40f40c, 0x2c162c06, 0x2c362c26, 0x2c562c46, 0x2c762c66, 0x2c962c86, 0x2cb62ca6, 0x5d0d2cc6, 0xe52cd5b4, 0x005d022c, 0xb02f09b0, 0x1ab02f11, 
+    0x2f21b02f, 0x0d0331b3, 0x1db32b04, 0x2b042706, 0x2108df82, 0x15161607, 0x17070614, 0x06062707, 0x27262223, 0x26372707, 0x37343526, 0x36173727, 
+    0x17163233, 0x54540337, 0x75cd3e0f, 0x2f353531, 0x3d735073, 0x9e5e5c9e, 0x734e733d, 0x7562312f, 0xb87f754e, 0x753b9e5c, 0x4549184a, 0x3704260f, 
+    0x5ca03e74, 0x2428835c, 0x35312f71, 0x3f29822f, 0xb95c9c3d, 0x774e767f, 0x752f3667, 0x875004fe, 0x67393967, 0x87505087, 0x62373762, 0x02000087, 
+    0x220a377f, 0x501b0007, 0x06231345, 0x7f00b02f, 0x35260645, 0x02331123, 0x00828a17, 0xe902ba28, 0x00ea02ba, 0x02820100, 0x1803a421, 0x351e1d7e, 
+    0xe9021b00, 0x2505c101, 0x60001b00, 0x04090ab3, 0x0ab02b04, 0xc365b010, 0x10042805, 0xb0d008b0, 0x82b02f08, 0x52102008, 0x182006eb, 0x2306aa55, 
+    0x0b0208b3, 0x73082b82, 0x13b11018, 0xd9b4f402, 0x0213e913, 0x081b405d, 0x28131813, 0x48133813, 0x68135813, 0x88137813, 0xa8139813, 0xc813b813, 
+    0x305d0d13, 0x07140131, 0x06060706, 0x33353307, 0x37352115, 0x26343536, 0x23152223, 0x17323334, 0x21c10116, 0x45193b11, 0xfe62932d, 0x372ffc6b, 
+    0xd9667329, 0x04423754, 0x1d2d377f, 0x2f3f1735, 0xf04ea449, 0x2523292f, 0x3129e88a, 0xff2fd682, 0x01dd02fe, 0x002305b2, 0xb3930021, 0x8212091e, 
+    0x861e2089, 0xdab424b5, 0x8312ea12, 0x12093e8b, 0x12291219, 0x12491239, 0x12691259, 0x12891279, 0x12a91299, 0x12c912b9, 0x12b05d0d, 0x05f25c10, 
+    0x1220b223, 0x0886561e, 0xdb821b20, 0x3e151b34, 0x0310b259, 0x03b02b03, 0x0208b110, 0x101bb0f4, 0xe18314b1, 0x78181420, 0x20222273, 0x80561003, 
+    0x06142505, 0x37272223, 0x26050745, 0x35232627, 0x84343532, 0x493720e9, 0x440805bf, 0xb2011607, 0x19cc5c73, 0x296c0f6a, 0x4311213a, 0x6970586a, 
+    0x5c5a3f40, 0x034c4269, 0xcb6b458d, 0x20327b0e, 0x640a0a38, 0x6a7b4a42, 0x485c3338, 0x0035234c, 0x02000001, 0x058501e9, 0x00100019, 0x090fb328, 
+    0x050b6a03, 0x97410d20, 0x07864f06, 0x0210b323, 0x2d198200, 0x02b01010, 0x013130d0, 0x11333521, 0x80820606, 0x82023e21, 0x33210809, 0xdffe8501, 
+    0x4a60145a, 0x2438431f, 0xe9025a6d, 0x3322015b, 0x361c634a, 0x2bfe304b, 0x00000400, 0x07d151ff, 0x00142008, 0x00260023, 0x2f27b0ab, 0xb02f28b0, 
+    0x03b0dc22, 0x2f03b0d0, 0xb01027b0, 0x07b0d007, 0x8211b02f, 0xb1102905, 0xb0f40913, 0x18b11022, 0x1c230682, 0x821cb0d0, 0xb0103228, 0x18b0d01d, 
+    0xd024b010, 0x220725b2, 0xb2391211, 0x52068426, 0xa9690820, 0x395f180c, 0x07355e0c, 0x0224b329, 0xb32b0419, 0x78040214, 0x06250559, 0x0108b2d0, 
+    0x061b5e03, 0xf4021736, 0xb01024b0, 0x19b0d01e, 0xd020b010, 0xb01017b0, 0x23b0d022, 0x90062b4b, 0x2dfe82ee, 0x13352335, 0x15331133, 0x27331523, 
+    0x91520735, 0x3dfe2106, 0x2c0c0741, 0x5ce1fe1f, 0x5a6ff4fa, 0x77c35a5a, 0x05ac5204, 0x41b2fd21, 0xfc370b1b, 0x4b3c5abc, 0xc3fe4e01, 0x9f983c5c, 
+    0x0003009f, 0x03e5ff00, 0x823705a6, 0x001f3409, 0xb0880030, 0x32b02f31, 0xdc0eb02f, 0xb0d000b0, 0x6eb0100e, 0x0e250543, 0x0908b110, 0x06d765f4, 
+    0xb0100827, 0x31b0d014, 0x24ac8210, 0xb02f23b0, 0x24b5822d, 0x092fb110, 0x081941f4, 0x1b2f2d25, 0x4e152db1, 0x19410609, 0x820f200c, 0x0f200819, 
+    0xb3593e0f, 0x0417021c, 0x0230b32b, 0xb02b0420, 0x0bb1100f, 0x30b0f402, 0xd022b010, 0x030124b2, 0x23057842, 0x13012701, 0x421b6543, 0x0e410e0f, 
+    0x215e2a06, 0x46183c10, 0xfe62942d, 0x097b436a, 0x41dffd21, 0x16410b23, 0x5ffc3606, 0x351d2d38, 0x4a2f4016, 0x30ef4ea4, 0x89252229, 0x013129e7, 
+    0x0d474208, 0x42feff21, 0x21290647, 0x34002500, 0x0f013700, 0x3f5d18b0, 0xd0122808, 0xb12f12b0, 0x74f4091e, 0x88442495, 0x0ead4306, 0x1039b037, 
+    0xb0dc33b0, 0x25b0d025, 0x1033b02f, 0xf40929b1, 0xb0d02db0, 0x310c832d, 0xb0d02eb0, 0x35b01029, 0x1236b2d0, 0x39121133, 0x068437b2, 0x2a830020, 
+    0x58450023, 0x07e343b0, 0x0c83b020, 0x1b2f2325, 0x410f23b1, 0x5d5a0672, 0x02352708, 0xb32b042a, 0x61430208, 0xdc102106, 0x34320344, 0xb11026b0, 
+    0xb0f40228, 0x2fb01035, 0x102ab0d0, 0xb0d031b0, 0x26b58228, 0xd034b0d0, 0x44013130, 0x0123211f, 0x42130127, 0x354410bd, 0xf2012718, 0x035ebcfc, 
+    0xc7425c46, 0x1748440a, 0xfa1d0128, 0x16053ced, 0xd142c9fa, 0xff02390c, 0x0300008b, 0x001905cf, 0x001d0010, 0x2f1eb088, 0xb02f1fb0, 0x1eb0dc00, 
+    0x08088f78, 0x00b0d035, 0x0c11b110, 0x11dab4f4, 0x5d0211ea, 0x11091b40, 0x11291119, 0x11491139, 0x11691159, 0x11891179, 0x11a91199, 0x11c911b9, 
+    0x06b05d0d, 0x0c1ab110, 0x5915b0f4, 0xdc420b22, 0x2f053d07, 0x0f05b11b, 0x0ab3593e, 0x2b040706, 0xb1100bb0, 0xb0f40614, 0x16b0100a, 0x1007b0d0, 
+    0x2305de53, 0xf4061ab1, 0x27068d66, 0x35231121, 0x32211133, 0x07597118, 0x23153322, 0x4a080d82, 0x3ccf0312, 0xfe81bf7a, 0x01a6a658, 0x79bf89a8, 
+    0xacc18935, 0xfefee1fe, 0xc1ac1f01, 0xed878d02, 0x5e0266b3, 0x6b460275, 0x0181ecb4, 0xfe170100, 0x17fe752f, 0x00001801, 0x00620001, 0x0344036d, 
+    0x000b004e, 0x09b0000f, 0x4c0bb02f, 0x2308080c, 0x01070209, 0x01012701, 0x03010137, 0x01ddfe44, 0xdffe5023, 0x014eddfe, 0x4edffe21, 0x21012301, 
+    0xdefe0003, 0x23200f83, 0x01220484, 0x23834e22, 0xffffff22, 0x24052157, 0x002602c7, 0x090f4d3a, 0x0002003a, 0x03000031, 0x001905a2, 0x0012000a, 
+    0x2f13b074, 0xb02f14b0, 0x13b0dc00, 0x0eaf6f18, 0xb1100024, 0x6a18080b, 0x042026e8, 0x09524c18, 0x080c3a57, 0x1b2f0422, 0x3e0f04b1, 0x0610b359, 
+    0xb32b0402, 0x040d0609, 0x0131302b, 0x11232110, 0x11331123, 0x34032033, 0x33080a82, 0x03363233, 0xf40cfea2, 0x01f48989, 0x97fe8bf4, 0xb5b4f4f4, 
+    0x8bfe9802, 0x1905ddfe, 0x8cfef3fe, 0x8300fefe, 0xecff0200, 0xb603e9ff, 0x20005c05, 0xc2003000, 0x1806db44, 0x2e07a86a, 0xb01032b0, 0x01b2dc0f, 
+    0x12110f17, 0x841cb239, 0x21b12206, 0xfd6a180c, 0x10172126, 0x2a574e18, 0x924a0820, 0x07104f05, 0x1401b223, 0x84738408, 0x2cb12206, 0x25016606, 
+    0x1331302c, 0x27262637, 0x37171637, 0xde6d0717, 0x34352408, 0x83243636, 0x6d072017, 0xe92e0ce8, 0x2f5629a0, 0x9066752d, 0x8750794e, 0xe86d3760, 
+    0xcb742b05, 0x299c1001, 0x01b74779, 0xf16d10f6, 0x0321080a, 0x2316a0d1, 0x352d7510, 0x337b508f, 0x70bb9b7f, 0x4e92cf81, 0xa269b8c1, 0x4619547a, 
+    0xfeb62f6e, 0x0cfc6d98, 0x2a085f59, 0x00260254, 0x0000005a, 0x828b0006, 0x00023305, 0x038bfe31, 0x001905a6, 0x00210012, 0x2f22b0ec, 0xf78223b0, 
+    0x22b0dc34, 0xd009b010, 0xb12f09b0, 0xb0f40c08, 0x0cb2d00b, 0xfd820009, 0x1000b025, 0x180813b1, 0x2326aa7a, 0x1ab01008, 0x56068043, 0x0e240c9d, 
+    0x0eb11b2f, 0x2007534f, 0x200c8208, 0x3b531808, 0x1d290810, 0x1b40f401, 0x1d171d07, 0x1d371d27, 0x1d571d47, 0x1d771d67, 0x1d971d87, 0x1db71da7, 
+    0x5d0d1dc7, 0xe61dd6b4, 0xb25d021d, 0x05926707, 0x100e2e08, 0xf40118b1, 0xe918d9b4, 0x405d0218, 0x1818081b, 0x38182818, 0x58184818, 0x78186818, 
+    0x98188818, 0xb818a818, 0x0d18c818, 0x0e0cb25d, 0x05ad4618, 0x020e1423, 0x067b7023, 0x0a3a5318, 0x1611073f, 0x023e3233, 0x7842a603, 0x7d966eb1, 
+    0x967d8989, 0x447bb06a, 0x7f522b8b, 0x77779c52, 0x3d06829c, 0x6dd1012b, 0x634883b2, 0x8e0641fe, 0x45623ffe, 0x5271b47f, 0x7f3a6489, 0x39810cfe, 
+    0x6f528b67, 0x52362008, 0xd82e083f, 0x73010000, 0x0000ffff, 0x7503e9ff, 0x4618c204, 0xd8210809, 0x522c8200, 0x7920066d, 0xd9202d88, 0x05212d8b, 
+    0x3d2d8805, 0x00ff00d9, 0xfec5ff02, 0x056f0485, 0x00130019, 0xb37f0016, 0x04030a10, 0x03dab42b, 0xf78303ea, 0x19030939, 0x39032903, 0x59034903, 
+    0x79036903, 0x99038903, 0xb903a903, 0x8203c903, 0x030622f7, 0x25f78210, 0xb01010b0, 0x274ddc18, 0x071b5708, 0x0cfc9118, 0x0a250c84, 0x0ab11b2f, 
+    0x069d460f, 0x0c820e20, 0x0c820e20, 0x0314b329, 0xb22b0408, 0x410c000b, 0x664e0542, 0x23410805, 0x23032103, 0x06013301, 0x33161415, 0x04030301, 
+    0x1f907d6f, 0xfd7b4817, 0x019379fc, 0xb201bab2, 0xfe506d31, 0xfedbdb3f, 0x30667d85, 0x75011d4b, 0x19058bfe, 0x4c2de7fa, 0x0f036048, 0x5ffda102, 
+    0x3fd78200, 0x0385fefe, 0x00ba03fc, 0x00440033, 0x0c42b3f5, 0xb32b0417, 0x040e0a03, 0x100eb02b, 0xf40800b1, 0xc36c0682, 0x100e2406, 0x83d021b0, 
+    0x3929080e, 0x061b40d0, 0x26421642, 0x46423642, 0x66425642, 0x86427642, 0xa6429642, 0xc642b642, 0xb45d0d42, 0x42e542d5, 0xb0005d02, 0x05ca4307, 
+    0xc5822e20, 0xcc512e20, 0x20ec840f, 0x06aa600d, 0xf1430c84, 0x1cb32307, 0xec823d06, 0x2e070f22, 0x4e08ec82, 0xb1102eb0, 0xb4f40627, 0x27e927d9, 
+    0x1b405d02, 0x27182708, 0x27382728, 0x27582748, 0x27782768, 0x27982788, 0x27b827a8, 0x5d0d27c8, 0xb11014b0, 0x40f40634, 0x1734071b, 0x37342734, 
+    0x57344734, 0x77346734, 0x97348734, 0xb734a734, 0x8234c734, 0x34d6389c, 0x5d0234e6, 0xb0103db0, 0x3ab0d03a, 0x2131302f, 0x14150606, 0x41153316, 
+    0x35200654, 0x220a266a, 0x1817021e, 0x2b0f0e65, 0x023e3201, 0x26263535, 0x020e2223, 0x03333682, 0x6d1d1773, 0x1e8f7d50, 0x5b243c17, 0xb92d6464, 
+    0x188f58be, 0x22151765, 0x185602fe, 0x320a0f65, 0x48233f17, 0x667d5a60, 0x9c1d4b30, 0x172b442d, 0x1858858e, 0x20152065, 0x196518fc, 0xffff2d0d, 
+    0xe9ffecff, 0xc706ac03, 0x24002602, 0x42097746, 0x812206e5, 0x17825305, 0x46184420, 0xac220e9f, 0x2d88cb06, 0x20079d53, 0x22458200, 0x88570581, 
+    0x00d6212d, 0x5b865a82, 0x2d888c20, 0x1343da20, 0x0581220a, 0x822d8819, 0x89898817, 0x8cdf205b, 0x205b892d, 0x275b83df, 0x00003100, 0xcf06cf03, 
+    0x25204382, 0x2d83b784, 0x03007723, 0x2b898200, 0x19052904, 0x26001600, 0xd9002a00, 0x24094163, 0xb0f40c01, 0x07416f2b, 0xb0100125, 0x82b0d012, 
+    0x43631805, 0x2f12262f, 0xb02f1ab0, 0x058a4228, 0x0c3f6318, 0x1b2f2724, 0x781827b1, 0xa4420c55, 0x59631814, 0x06292542, 0x213130f4, 0x21346318, 
+    0x03012a08, 0xe9021123, 0x3b752f89, 0x35638f5a, 0x5a8f6335, 0xba2f753b, 0x2f894301, 0x603d3c6c, 0x42232342, 0x5c7b3d60, 0x6554c901, 0x3c631856, 
+    0x3f04281b, 0xd1012ffe, 0x49ffff00, 0x250807df, 0xec000602, 0x02000000, 0xe9fffeff, 0x19052d04, 0x2c001c00, 0x2db00901, 0x2f2eb02f, 0xb1dc02b0, 
+    0xb0f40803, 0xb34c102d, 0x10032506, 0xb0d014b0, 0x18260582, 0x1002b0d0, 0x0b841ab0, 0xb0d01d2a, 0x25b1100c, 0x1b40f40c, 0x2415276c, 0x25c625b6, 
+    0x07246c0d, 0x6905a152, 0xbc640c1a, 0x0c50740c, 0x1b2f0733, 0x3e0f07b1, 0x061cb359, 0xb02b0400, 0x2ab11007, 0x39668206, 0x2a172a07, 0x2a372a27, 
+    0x2a572a47, 0x2a772a67, 0x2a972a87, 0x2ab72aa7, 0x66822ac7, 0xe62ad62e, 0xb25d022a, 0x112a0704, 0x11b03912, 0x2a935818, 0x20111422, 0x2d055047, 
+    0xb0d015b0, 0x17b0101c, 0x013130d0, 0x9b411123, 0x2335280f, 0x33353335, 0x18013315, 0x230cd464, 0x8aba2d04, 0x0ed56418, 0xba8aba26, 0x8b3bbcfe, 
+    0x0ad76418, 0xfce90323, 0x0c9e4117, 0xbb759927, 0x416dfebb, 0xdc64183a, 0x534d1809, 0x02362908, 0x00260026, 0x00070000, 0x2806ab46, 0xe9fffcff, 
+    0xc204ae03, 0x2b4b1802, 0x43d82007, 0x7322083b, 0x2d887906, 0x8506ab46, 0x0505212d, 0xd9202d88, 0x2f592d8a, 0x06c54309, 0x4b182d86, 0x17820945, 
+    0x00010035, 0x0485fe31, 0x00190500, 0xb37b0018, 0x04070c10, 0x4615b32b, 0xb02528dd, 0x0bb01010, 0x08d646d0, 0x1b2f0824, 0x514308b1, 0x0c667107, 
+    0x085e6318, 0x0e060d30, 0x08b02b04, 0x060ab110, 0x1006b0f4, 0x068210b1, 0x55d01121, 0x2120083a, 0x2005d67d, 0x55078315, 0x04350546, 0x1e8f7d00, 
+    0x0308fd17, 0x0247fd42, 0x02fefd02, 0x6c3102b9, 0x06d34650, 0x67190521, 0x7321058d, 0x055b5502, 0xff024008, 0x0385fefc, 0x00ba03ae, 0x00300027, 
+    0x0a03b3bd, 0xb42b040a, 0x0aea0ada, 0x1b405d02, 0x0a190a09, 0x0a390a29, 0x0a590a49, 0x0a790a69, 0x0a990a89, 0x0ab90aa9, 0x5d0d0ac9, 0x030a0db2, 
+    0x46391211, 0x192008b4, 0x1920ca82, 0x0cc46818, 0x4f079447, 0x28220898, 0x924f1e06, 0x276a7d05, 0x8818b020, 0x1a6f0d6a, 0x3130221c, 0x0c974625, 
+    0x0ac64118, 0x15021e23, 0x07936221, 0x9f420320, 0x02072c05, 0x6d191693, 0x17907d50, 0x182b2b12, 0x2a0b8666, 0xba0fdbfc, 0x29a46995, 0x18025e60, 
+    0x22079066, 0x46421602, 0x2923057b, 0x18071d42, 0x2d0b9466, 0x4056b094, 0xe8018342, 0x502b9699, 0xa3424371, 0x42cb2008, 0xdf450875, 0x06474206, 
+    0x09a34d18, 0x3b46df20, 0x06d72108, 0x28252d83, 0x07000000, 0x06694600, 0xfefeff26, 0x05730375, 0x48202d83, 0x06201782, 0x69461782, 0x06d72207, 
+    0x855b8279, 0x07d1422d, 0x05202d85, 0x2d851782, 0x5b8ad920, 0x2d888c20, 0x8507d142, 0x8819202d, 0x0697462d, 0x038bfe25, 0x862f05d7, 0x0006222d, 
+    0x207782e2, 0x24878603, 0x000300d3, 0x0dfb7f23, 0xb0d01933, 0x34b02f19, 0xdc04b010, 0x041900b2, 0xb2391211, 0x21068402, 0x665619b0, 0x06086129, 
+    0xb1100434, 0xb0f40813, 0x13b0d021, 0xd024b010, 0x2f01b000, 0x7b4600b0, 0x2f222405, 0x4222b11b, 0x1e200751, 0x1e200c82, 0xc64d0c87, 0x00b02507, 
+    0x13b05845, 0x8406cf7a, 0x8216200c, 0x1639080c, 0xb3593e0f, 0x04090410, 0x1016b02b, 0xf4062fb1, 0x2f071b40, 0x2f272f17, 0x2f472f37, 0x2f672f57, 
+    0x2f872f77, 0x2fa72f97, 0x2fc72fb7, 0xd6b45d0d, 0x022fe62f, 0x1614b25d, 0x21c9822f, 0x3f491eb0, 0x21b22329, 0x5f4a271e, 0x33012b05, 0x0e140103, 
+    0x26222302, 0x66183727, 0x01282299, 0x6012011b, 0x42a001ba, 0x249f6618, 0x015e0428, 0xfb8bfe75, 0x661860ac, 0x81421fa6, 0x4229200c, 0x002b0b53, 
+    0x03000031, 0x02cd0673, 0x88490026, 0x75250817, 0x77ff0200, 0x2f040000, 0x13001905, 0x99001700, 0xb02f18b0, 0x04b02f19, 0xd000b0dc, 0xb11004b0, 
+    0xb0f40805, 0x0b5f4d18, 0xb010092f, 0x08b0d00d, 0xd00fb010, 0xb01005b0, 0x20058411, 0x20118414, 0x7b691816, 0x2f122413, 0x4412b11b, 0xb44107de, 
+    0x5a08200c, 0xb32f0697, 0x04020101, 0x0614b32b, 0xb02b0406, 0x7db01002, 0x0c2705eb, 0x1001b0d0, 0x83d010b0, 0xd0152611, 0x33013130, 0x09277b15, 
+    0x33353338, 0x33352115, 0x11211103, 0xbcbc7303, 0x89d1fd8a, 0x0289baba, 0x09828a2f, 0x71480437, 0x5c0229fc, 0xd703a4fd, 0xd1d1d171, 0x0601b8fd, 
+    0x0000fafe, 0x21e78301, 0xe7827303, 0xaf001b23, 0x08437bb0, 0xdf820120, 0xc5471c20, 0x0bb12506, 0x0cb0f40c, 0x0b257484, 0xd012b010, 0x250582b0, 
+    0x17b2d016, 0xf856000c, 0x0c945508, 0x6e0cee44, 0x9e620c9a, 0x10b32307, 0xd4820d01, 0xb1101922, 0x27d26718, 0x1010b02a, 0xb0d013b0, 0x15b0100d, 
+    0x00207982, 0x12c06318, 0x21066447, 0x67182315, 0xba260ee6, 0xbbbb89ba, 0x6718fe63, 0x03360bea, 0xbbbb70ee, 0x01ccfe70, 0x0085fe00, 0x4e00ffff, 
+    0x4e030000, 0x9b5f7306, 0x4ad72008, 0x1784067b, 0x82ff0421, 0x00d52617, 0x00060000, 0x202c82d7, 0x05735eff, 0x88360621, 0x066d472d, 0x04211785, 
+    0x472d88c2, 0xb626056d, 0xf0020000, 0x2d887906, 0x20069b44, 0x21178400, 0x2d880505, 0xff00d938, 0xba000100, 0x750385fe, 0x17001905, 0x10b38200, 
+    0x2b040908, 0x3f4714b3, 0x06b22328, 0x90411403, 0x05234405, 0x3019174e, 0xb11b2f12, 0x593e0f12, 0xb11006b0, 0xb0f40608, 0x0541470c, 0xb0d00e2b, 
+    0x08b0d00f, 0xd010b010, 0x0b4647b0, 0x1133353e, 0x15213523, 0x15331123, 0x16141506, 0x7d750333, 0xfe171f90, 0x02d3d31c, 0x31d2d22f, 0x3005935c, 
+    0x751d4b30, 0x75752f04, 0x2d75d1fb, 0x0060484c, 0x28cb8802, 0x00190015, 0x0e0eb3a4, 0x20cd8208, 0x20cdab12, 0x26cd8212, 0xb1100eb0, 0x83f40809, 
+    0xd00b2595, 0x0e0817b2, 0x17251383, 0x0816b12f, 0x082948f4, 0x180cfc6f, 0x480cb046, 0x10200c36, 0x1020f582, 0xef82f591, 0x3648f884, 0x87ef8509, 
+    0x230122ed, 0x21f18a35, 0xf0845d01, 0xbababa22, 0x24063548, 0x75ba0275, 0x24f385fc, 0x00bb7f05, 0x071f42ff, 0x08090162, 0x0000da2c, 0x02007301, 
+    0x75fe0000, 0x1905a403, 0x1c001000, 0x1db06700, 0x2f1eb02f, 0xb1dc0bb0, 0xb0f40c08, 0x14b0101d, 0x2f14b0d0, 0xd6841bb1, 0xb0584522, 0x11bd4518, 
+    0x20072b44, 0x20c68211, 0x31c68211, 0x0e0603b3, 0x11b02b04, 0x0613b110, 0x1017b0f4, 0x068215b1, 0x3b05d268, 0x1bb01013, 0xd01cb0d0, 0x16053130, 
+    0x3e323316, 0x33113502, 0x23021411, 0x21012722, 0x3109cc41, 0x7f310001, 0x3d735c48, 0xd9d38917, 0x85017bd3, 0xd041d1fd, 0x39aa3005, 0x8f734a34, 
+    0xfb9c0448, 0xf0fef864, 0x410a0181, 0x002206d7, 0xc3880400, 0x0d000332, 0x24001100, 0x0cb3b300, 0x2b04060e, 0x1d0c22b3, 0x0c238b82, 0x8207b110, 
+    0x10062acd, 0xb0d009b0, 0x26b01022, 0x05bc4bdc, 0xb2820220, 0xbf870220, 0x0c821020, 0x0c871020, 0x0c286b18, 0x19822020, 0xc7462020, 0x07aa7614, 
+    0x4500b025, 0x1822b058, 0x22070652, 0x82120618, 0x10022974, 0xf40500b1, 0xb11004b0, 0x125f6b18, 0x1000b023, 0x08d642b0, 0xb0d01e24, 0x6b18d01f, 
+    0x01250f71, 0x01333523, 0x0c6b1822, 0x75012b0f, 0xfdbabbbb, 0x01d3d3d1, 0x0b83d35c, 0xf673fe2b, 0x75256963, 0x365c4356, 0x25138216, 0xbb5e04bc, 
+    0xfa41e7fa, 0xe9032205, 0x236b18bb, 0xffff2d10, 0xe9fffeff, 0xcb067303, 0x2b002602, 0x3f085546, 0x00020073, 0x0375fe04, 0x00580558, 0x00180012, 
+    0x0c10b32c, 0x002b040b, 0xb02f18b0, 0x16b02f14, 0x2005b743, 0x065b530e, 0x0606b323, 0x053a5100, 0xf4060c22, 0xa491b682, 0x07270727, 0x5c010127, 
+    0xb36b18f6, 0x4401210c, 0x23058962, 0x48ca75fe, 0x0cb86b18, 0x62c40521, 0xff29069a, 0xfe3100ff, 0x059e038b, 0x209d8219, 0x249d822c, 0x00e20006, 
+    0x20158600, 0x201584a2, 0x2f15874c, 0x31000100, 0xa2030000, 0x0b00a403, 0x04b34a00, 0x14b38418, 0x2007b341, 0x20b98209, 0x14f74e09, 0x1807e046, 
+    0x2815b384, 0x83fec3a2, 0x028989a8, 0xe66b1813, 0xa4032707, 0xf6010afe, 0x5a1854fe, 0x2d200c47, 0x650ca150, 0x4d20094f, 0x75201788, 0x7320c386, 
+    0x2f83c384, 0xba24d987, 0xe9028bfe, 0x2d831584, 0xd982ef88, 0x07262b89, 0xd5007701, 0xc143eafe, 0x41032005, 0x5b840507, 0x01770123, 0x2017845c, 
+    0x252f8d31, 0xba00c100, 0x2f85ba00, 0x885e0421, 0x0007245d, 0x822f02c1, 0xff012293, 0x312f855e, 0x4f000d00, 0x010c0cb3, 0x01b02b04, 0xd005b010, 
+    0x85180cb0, 0x2b4716f3, 0x02b22807, 0x12110600, 0x8503b239, 0x85082006, 0x84092006, 0xb12c0806, 0x30f4030c, 0x11212131, 0x11373507, 0x15371133, 
+    0x03211107, 0xd3befc73, 0xd3d389d3, 0x3302b902, 0x02457f45, 0x46c8fd67, 0x15fe467f, 0x29072165, 0x11001905, 0x04b38900, 0x8382030e, 0x10042108, 
+    0xf40800b1, 0xf40e07b1, 0xb01004b0, 0x05b0d008, 0xd009b010, 0xb01007b0, 0x03b0d00a, 0xd00cb010, 0x23053543, 0x04030fb2, 0x12838582, 0x2407bb5f, 
+    0xb11b2f03, 0x07bb4303, 0x29086b6a, 0x01b11003, 0x05b2f403, 0x2e82030b, 0x8406b221, 0x0bb02606, 0x0309b110, 0x059872f4, 0x840fb221, 0x10b22113, 
+    0x30260684, 0x23110131, 0xba842135, 0x21153324, 0xca823335, 0xd38d0129, 0xd2d25d01, 0x82d1fdd2, 0x01b223c4, 0xc08677f0, 0x01777726, 0x007f45bc, 
+    0x200c0742, 0x0c07422f, 0x24059341, 0x00260253, 0x09a9524f, 0xfe310024, 0xd941038b, 0x412d8305, 0x158308ef, 0x88ba0321, 0x06f5422b, 0x43000021, 
+    0x598506a9, 0xfd47df20, 0x20598506, 0x202d8857, 0x228682df, 0x840100ff, 0x862f202d, 0x01072415, 0x8274fe77, 0x82012077, 0x83752071, 0x00210871, 
+    0xb05e0016, 0x18b02f17, 0xdc00b02f, 0xf40814b1, 0xb0d00eb0, 0x17b02f0e, 0xd011b010, 0xb12f11b0, 0x07036f10, 0x520c004a, 0x10200c4b, 0x2e06a846, 
+    0x030609b3, 0x0fb22b04, 0x12111210, 0x8414b239, 0x31302506, 0x23021425, 0x08080a44, 0x11013735, 0x01331123, 0x73033311, 0x7bd3d9d3, 0x487f3156, 
+    0x29425e41, 0x89dffd0a, 0x8af701c1, 0xf0fef87d, 0x34396081, 0x31584227, 0xb0fb7504, 0xe3fb1905, 0x86001d04, 0xba0330ad, 0xa1002000, 0xb02f21b0, 
+    0x1bb02f22, 0x8208b1dc, 0x102132ad, 0xb0d013b0, 0x12b12f13, 0x15b0f40c, 0x1316b2d0, 0x08e4491b, 0x200c8e6f, 0x18a48218, 0x4a082174, 0xb02007b2, 
+    0x104e4518, 0x26821b20, 0xad461b20, 0x611e2005, 0x2a0805ed, 0xb4f4060c, 0x0ce90cd9, 0x1b405d02, 0x0c180c08, 0x0c380c28, 0x0c580c48, 0x0c780c68, 
+    0x0c980c88, 0x0cb80ca8, 0x5d0d0cc8, 0x570816b2, 0xc34605e4, 0x55342008, 0xf1830528, 0x33121534, 0x14111120, 0x27222306, 0x43198301, 0x355c441f, 
+    0x71186c16, 0xbd2a0ad6, 0xfa445ab8, 0x48270f0e, 0x71184266, 0x032c09e1, 0x0001eaa4, 0xc1fd85fe, 0xff1ad7b4, 0x20079b68, 0x089b6836, 0xf741d820, 
+    0xecff2705, 0xbc03e9ff, 0x1782c204, 0x00005025, 0x57000600, 0x8f6905e1, 0x88792005, 0x06c7492d, 0x05212d85, 0x4e2d8805, 0x2d850563, 0x2d88ea20, 
+    0x5b8bdd20, 0x88760521, 0x51dd202d, 0xb0220863, 0x1582c706, 0xdb423320, 0x230c820c, 0x54059e03, 0x53201782, 0x06220a82, 0xa5458b00, 0x05b02208, 
+    0x422d8619, 0x002607db, 0x9e038bfe, 0x2b88ba03, 0x2209db42, 0x88cb06b0, 0x08555559, 0x03000025, 0x8858059e, 0x2317822d, 0x1900ffff, 0x8320f982, 
+    0x34208784, 0xff21878b, 0x201782f6, 0x2087848b, 0x85878a54, 0x855b832d, 0x86d6202d, 0x832d85e3, 0x822d855b, 0x01003717, 0x8dfe1900, 0x2f058303, 
+    0xb0004800, 0x290a15b3, 0x06b32b04, 0x05820d0d, 0x320b3331, 0x32b02b04, 0x0800b110, 0x1015b0f4, 0x82d011b0, 0x35b02e0c, 0x1029b0d0, 0xf40c3fb1, 
+    0xb01033b0, 0x0646484a, 0x1b2f3224, 0x7d4432b1, 0x82342007, 0x4634200c, 0x2e20076b, 0x2e200c82, 0x200c5348, 0x06f55811, 0x19821220, 0x3e0f122c, 
+    0x0a11b259, 0x3912112e, 0x068431b2, 0x2eb02908, 0x063ab110, 0x3ad9b4f4, 0x5d023ae9, 0x3a081b40, 0x3a283a18, 0x3a483a38, 0x3a683a58, 0x3a883a78, 
+    0x3aa83a98, 0x3ac83ab8, 0x23057564, 0x1507020e, 0x21072368, 0x84182626, 0x372a2e44, 0x52467b5c, 0x60ca9358, 0x84182fa0, 0x4a242c48, 0x0a3b5c79, 
+    0x076d6118, 0x8b475022, 0x30518418, 0xfef6ff2f, 0x038b038d, 0x003b00ba, 0x0c32b3a5, 0x08734121, 0x170c0029, 0xdab42b04, 0x8317ea17, 0x17093bfc, 
+    0x17291719, 0x17491739, 0x17691759, 0x17891779, 0x17a91799, 0x17c917b9, 0x47185d0d, 0xe44924b8, 0x2f262405, 0x4126b11b, 0x0a200790, 0x0a290c82, 
+    0xb0593e11, 0x2db11026, 0x52951806, 0x05ac5f25, 0x200c6841, 0x966b1837, 0x623b2b22, 0x5852427d, 0xf27aca93, 0x6b183d5a, 0x4424259a, 0x06254162, 
+    0x23055841, 0x3c450512, 0x24a36b18, 0x42081d43, 0x4b4309ef, 0x061d4306, 0x4309ef42, 0x002d054b, 0xa4038bfe, 0x26021905, 0x00003500, 0x0ba54300, 
+    0x1584ae20, 0x158b5520, 0x03000024, 0x598306a4, 0x07212b83, 0x08a54300, 0x03e9ff25, 0x82d405ae, 0x282d8343, 0x01770107, 0x00a5ff5c, 0x82398201, 
+    0x19053f2f, 0x86001700, 0xb02f18b0, 0x0fb0d00f, 0xdc07b02f, 0x010740b2, 0x0802b15d, 0x1007b0f4, 0x14820bb0, 0x0eb11023, 0x200c840d, 0x201b8213, 
+    0x201b8213, 0x290e8212, 0x15b01002, 0x1012b0d0, 0x564319b0, 0x0c904b06, 0x22080560, 0x48000117, 0x0223052b, 0x7eb0f406, 0x002f0532, 0xd008b010, 
+    0xb01017b0, 0x10b0d00a, 0x820cb110, 0xd0142118, 0x30244c82, 0x11230131, 0x2605c947, 0x11333523, 0x86231121, 0x02332203, 0x05d247e9, 0xe8fed33f, 
+    0x75a40375, 0x02d2e8fe, 0x7515fe60, 0x71eb0175, 0xbcfed301, 0x47feb901, 0x2dfe4401, 0x016d1800, 0x0023260a, 0x0c02b3a3, 0x257b8213, 0x17b01013, 
+    0xcb4cb0d0, 0x10022505, 0xb0d01db0, 0x21200582, 0x7d064b51, 0x1a240ce3, 0x1ab11b2f, 0x5c140d53, 0x232008f4, 0x2e08ce84, 0x07b1100e, 0x1b40f406, 
+    0x07170707, 0x07370727, 0x07570747, 0x07770767, 0x07970787, 0x07b707a7, 0x5d0d07c7, 0xe607d6b4, 0xb05d0207, 0x82b01000, 0x102329dd, 0xb0d016b0, 
+    0x18b1101e, 0x1927ed82, 0xd020b0d0, 0x83d021b0, 0x141529f0, 0x3233021e, 0x06173736, 0x20054d55, 0x83fa8335, 0x11333903, 0x11211521, 0xd32f0233, 
+    0x36543b21, 0x730a8966, 0x5295c710, 0xd3356088, 0x22080082, 0xfe8d0189, 0xbe01d373, 0x445a3368, 0x19657f27, 0x6036ad93, 0x71685087, 0x01750001, 
+    0x758bfe75, 0x180000ff, 0x2c078361, 0x26027306, 0x00003600, 0xd7000700, 0x057b5e00, 0xe9ff3126, 0x00057303, 0x56201782, 0x06201782, 0x2d881783, 
+    0x2d883620, 0x6f06c746, 0x04210563, 0x822d88c3, 0x202d8817, 0x462d8879, 0x2d8506c7, 0x88060521, 0x8717822d, 0x3e07212d, 0xdb202d88, 0xcb20898c, 
+    0x17822d88, 0xea205b88, 0xf5462d88, 0x205b8606, 0x822d8877, 0x01002517, 0x85fe3100, 0x192ecd82, 0xa7002600, 0x0e0c11b3, 0x23b32b04, 0x0582030a, 
+    0x1b081e22, 0x20290f5f, 0x05975423, 0x5f28b021, 0x0f24090f, 0x0fb11b2f, 0x42070c46, 0x0e500c27, 0x1809200c, 0x1807e84d, 0x5d2afe44, 0xf14105d6, 
+    0x33112306, 0x46711411, 0x83352005, 0x0706300a, 0x16141506, 0x7df80233, 0x1012148f, 0x186d1021, 0x210c9188, 0xbb6d877f, 0x40292606, 0x4603021d, 
+    0x9988187f, 0xb8fc290f, 0x2d2bf2b4, 0x0060484c, 0x34061941, 0x00a403fe, 0xb399001f, 0x040c0c0f, 0x0a1cb32b, 0xb02b0407, 0x085b7907, 0x17b01023, 
+    0x210e82d0, 0x06511ab1, 0x180d200a, 0x490b1d81, 0xf78c0c9e, 0x26821a20, 0x7f581a20, 0x600a2007, 0xb2290621, 0x110d0008, 0x12b13912, 0x8c891806, 
+    0x050b4128, 0x02352325, 0x83112023, 0x086850ff, 0x1415062f, 0xfe033316, 0x171e8f7d, 0xfefe623e, 0x025218a8, 0x09695907, 0x00ffe926, 0x40027b01, 
+    0x0b5c6f18, 0xff2dfa83, 0x00c1ffff, 0x06e30300, 0x002602cb, 0x0cf75738, 0x1782e520, 0x5805c322, 0x58201782, 0x06231782, 0x7c00d600, 0x2d830957, 
+    0x2d8c3a20, 0x75fee124, 0x2d84c103, 0x84052563, 0x3100212d, 0x77224382, 0x4382c906, 0x314e3b20, 0x832f200c, 0x53052117, 0x5b201782, 0x840b414c, 
+    0x888e202d, 0x00da272d, 0xff750100, 0x2d8500ff, 0x2d881920, 0x9d4c1782, 0x06772206, 0x202d88cd, 0x202d8cdf, 0x202d8857, 0x05e553df, 0xa42a5b82, 
+    0x16002f05, 0x00b39d00, 0x147f040e, 0x08052105, 0x470c1579, 0xc3530554, 0x0cd8420c, 0x182f0821, 0x180a6b75, 0x200cc041, 0x24198202, 0x593e0f02, 
+    0x515118b1, 0x51162009, 0x0727051c, 0x100cb0d0, 0x6d0613b1, 0x2520276e, 0x2108d445, 0x7f183634, 0x02250aa3, 0xd1fdd217, 0x0b4618d3, 0x7575220b, 
+    0x9b7f1875, 0x06c9410c, 0xcb06a422, 0x8e20f982, 0x20086d41, 0x26178277, 0x03e9ffdb, 0x825605ba, 0x419e2017, 0x0220066d, 0xd3201582, 0xd3201582, 
+    0x8f202d84, 0xd5202d8c, 0xd1201782, 0x9f202d84, 0x00272d89, 0x038bfe19, 0x822f0583, 0x47342043, 0xff210945, 0x221582f6, 0x82ba038b, 0x47542015, 
+    0x87470e71, 0x01002924, 0x5e048d01, 0x2f064602, 0x32081f7a, 0x31302f01, 0x11230301, 0x65544602, 0x2ffe2f06, 0x8200d101, 0x0400241b, 0x84a4035e, 
+    0x00072a25, 0xb339000b, 0x04090808, 0x088c542b, 0x250c5367, 0xb11b2f0a, 0x6855150a, 0x18012005, 0x25077e5b, 0xb0d008b0, 0x5985d009, 0x35230124, 
+    0x03820533, 0x02276183, 0xfdbbbb17, 0x85baba16, 0x2ffe2669, 0xffbbbbbb, 0x065964ff, 0x22022f24, 0xd5828101, 0x7701032a, 0x00008cfe, 0x5fffffff, 
+    0x2206874e, 0x85850122, 0xd2fd2117, 0x2322178c, 0x11837701, 0x01020023, 0x28178387, 0x00001700, 0x2f06e902, 0x21178202, 0x31828afe, 0x89010222, 
+    0x5b242f84, 0xc703e9ff, 0x22221782, 0x47868f01, 0x1785ce20, 0xb8205f82, 0x94201784, 0xbc201790, 0x00211783, 0x82178b9d, 0x03e92233, 0x221782a4, 
+    0x82a70126, 0x01062217, 0x20058278, 0x079e1002, 0x00226301, 0x0d4a0031, 0x00052805, 0x0c03b32a, 0x732b0400, 0xb03a1ad3, 0x02b11000, 0x3130f406, 
+    0x21152113, 0x03312311, 0x8916fd73, 0xfb751905, 0x4918005c, 0x01204c3d, 0x9c189584, 0x77206d8b, 0x87598d18, 0x6024fb8a, 0xb02f0cb0, 0x7c679b18, 
+    0xdfff033c, 0xc703e9ff, 0x03002f05, 0x2b001700, 0x2cb0e900, 0x2f2db02f, 0xb0dc04b0, 0x9c52102c, 0x04330806, 0x0818b110, 0x18dab4f4, 0x5d0218ea, 
+    0x18091b40, 0x18291819, 0x18491839, 0x18691859, 0x18891879, 0x18a91899, 0x18c918b9, 0x0eb05d0d, 0x0c22b110, 0x7d1340f4, 0x092d1192, 0x9609405d, 
+    0xb622a622, 0x0422c622, 0x069a7d5d, 0x20058b42, 0x0b137d13, 0x31077849, 0x020601b3, 0x13b02b04, 0x061db110, 0x1dd9b4f4, 0x7c831de9, 0x87180820, 
+    0xb0251a3f, 0x27b11009, 0x8e8c1806, 0x05e24225, 0x1f996218, 0xd701e52e, 0xe20229fe, 0x89bf7636, 0x3577bf89, 0x08319618, 0x875c3137, 0x548b6b56, 
+    0x8b542121, 0x548c6a6b, 0x75c70220, 0xbaf48339, 0x619d1871, 0xbc712707, 0xcf8183f4, 0x98184d92, 0x8d7a0b93, 0xd19c1806, 0x31002561, 0x9e030000, 
+    0x91576784, 0x07fe4a17, 0x5d0c465a, 0x91570c8a, 0x459c181d, 0x08d3451a, 0x87820620, 0x18093078, 0x840f614d, 0x078a4819, 0x0001b235, 0x39121104, 
+    0x01213130, 0x33012301, 0xfe500301, 0x6a85fe83, 0x04280558, 0x0573fb8d, 0x00e7fa19, 0x22093344, 0x106d000c, 0x2201599c, 0x82000321, 0xa4033300, 
+    0x07001905, 0x13000f00, 0x14b07e00, 0x2f15b02f, 0xc77614b0, 0x01b12b06, 0x15b0f40b, 0xdc06b010, 0x098203b1, 0xb0d00831, 0x09b01001, 0x1000b0d0, 
+    0xb0d00bb0, 0x75b01006, 0x644a07f9, 0x2f062d0c, 0x0f06b11b, 0x11b3593e, 0x2b041206, 0x00212683, 0x230582dc, 0xf40602b1, 0x04213983, 0x05c058d0, 
+    0x2206375e, 0x5bdc0ab0, 0x3021055f, 0x06015031, 0x01213208, 0x11231521, 0x01231121, 0x79211521, 0xfc79b202, 0xfd2b035c, 0xa403794e, 0x01bafd79, 
+    0x0129fed7, 0xfeb8b82d, 0xbba404d3, 0xd0fe3001, 0x0075defe, 0x08a14402, 0x01219d10, 0x094d434b, 0x4b00073a, 0xb02f08b0, 0x00b02f09, 0x0801b1dc, 
+    0x1008b0f4, 0xb0d005b0, 0x04b12f05, 0x4a078b58, 0x26440cb4, 0x06024214, 0x21313026, 0x11211123, 0x032e0382, 0xd1fd8a73, 0x04420389, 0x055cfba4, 
+    0xab720019, 0x919d180c, 0x515f18ad, 0x180f208f, 0x749bff99, 0x052305a9, 0x18140019, 0x20a67597, 0x20b18403, 0x30b182bc, 0x00220019, 0xb391002b, 
+    0x040d0c23, 0x0806b32b, 0x22058207, 0x511a0c00, 0x12270557, 0x1006b0d0, 0x18d014b0, 0x8324bf40, 0x1f2b082a, 0x061b40d0, 0x26231623, 0x46233623, 
+    0x66235623, 0x86237623, 0xa6239623, 0xc623b623, 0xb45d0d23, 0x23e523d5, 0x07b05d02, 0x5426b010, 0x054906b3, 0x4506200c, 0xf5560667, 0x232a0807, 
+    0x35032e35, 0x37023e34, 0x1e153335, 0x2e340703, 0x36112702, 0x16142536, 0x030e1117, 0x6f3dbc03, 0x5e8a5e9b, 0x3b3b6f99, 0x0882996f, 0x6f9b4108, 
+    0x4727893d, 0x9587436b, 0x879142fd, 0x25476943, 0xa8628f02, 0xac0a507f, 0x7d500aae, 0xa86362a8, 0xa20d4f81, 0x7f520aa2, 0x7d4663aa, 0xfd0c4062, 
+    0x8dc71625, 0x0216c78d, 0x60420cdb, 0xff01007d, 0xd8179a18, 0x27087d4b, 0xb355001b, 0x04090c0c, 0x08837118, 0x04190823, 0x069b672b, 0x65180420, 
+    0xd7740934, 0x0c945d0c, 0x1b2f1a23, 0xdc7b18b1, 0x072f4908, 0x0131302b, 0x11070214, 0x02261123, 0x05015435, 0x06821720, 0x82033e21, 0x0333080c, 
+    0x8ab4a873, 0x1189a6b6, 0x8a43522d, 0x102f5241, 0xcd27038a, 0xfe1600ff, 0x164401bc, 0x01cd0201, 0x350efef0, 0x0f4e6675, 0xa1fc5f03, 0x75664e0f, 
+    0x64f20135, 0x8e2a082f, 0x89012202, 0x03000000, 0x3b528c00, 0xecff2105, 0xb8240c82, 0x23028e06, 0x002f1185, 0x00940102, 0x00ffff00, 0x03e9ff02, 
+    0x822f06aa, 0x829f202f, 0x0102222f, 0x20158477, 0x20158200, 0x22158281, 0x82a30126, 0x86062015, 0xfe0c2415, 0x8473038b, 0x8aa52015, 0xffba2415, 
+    0x4fe902e9, 0x41890aab, 0x2005c14f, 0x09c14fb2, 0x032d6d85, 0x001300ba, 0xb3cc0029, 0x04140c00, 0x98bd182b, 0x05f84b24, 0x1b2f1d24, 0x99571db1, 
+    0x0c176807, 0x19822020, 0x86542020, 0x82252007, 0x1825200c, 0x082bc383, 0x1019b036, 0xf4060fb1, 0xe90fd9b4, 0x405d020f, 0x180f081b, 0x380f280f, 
+    0x580f480f, 0x780f680f, 0x980f880f, 0xb80fa80f, 0x0d0fc80f, 0x251cb25d, 0x39121119, 0x0f191eb2, 0x22200683, 0x30220d84, 0xbc551331, 0x2e373406, 
+    0x0e222303, 0x3e340702, 0x16323302, 0x03331317, 0x55032313, 0x340805e2, 0x613b1b8b, 0x475c3c43, 0x34141434, 0x433c5c47, 0x891b3b61, 0x6492602d, 
+    0x3829b67b, 0x93838393, 0x7bb62938, 0x2d609264, 0x8340d301, 0x6a46466c, 0x843f4085, 0x3507826a, 0xb05e3f84, 0x899b5287, 0x2ffe0e01, 0x0e012dfe, 
+    0x8a529c89, 0xa77700b0, 0x05a82805, 0x001a002f, 0x630d0134, 0xb32a054b, 0x04270810, 0x27dab42b, 0xc78327ea, 0x19270939, 0x39272927, 0x59274927, 
+    0x79276927, 0x99278927, 0xb927a927, 0x8227c927, 0x271e22c7, 0x21c08210, 0xbc181eb0, 0xb127254c, 0xb2f40c16, 0x83160513, 0x10042932, 0xb0d031b0, 
+    0x36b01016, 0x1806f359, 0x180cdf6e, 0x470c1545, 0xb32307fd, 0x54210624, 0x2b080598, 0x40f4061b, 0x171b071b, 0x371b271b, 0x571b471b, 0x771b671b, 
+    0x971b871b, 0xb71ba71b, 0x0d1bc71b, 0x1bd6b45d, 0x5d021be6, 0x1b0003b2, 0xb2236c82, 0x82242113, 0x0bb02b06, 0x062cb110, 0x2cd9b4f4, 0xd9832ce9, 
+    0x2c083f08, 0x2c282c18, 0x2c482c38, 0x2c682c58, 0x2c882c78, 0x2ca82c98, 0x2cc82cb8, 0x31305d0d, 0x27262205, 0x34112311, 0x3233023e, 0x1415021e, 
+    0x16160706, 0x020e1415, 0x35363227, 0x23232634, 0x08833335, 0x022e6c08, 0x020e2223, 0x16161115, 0x9163ee01, 0x70428940, 0x98605a9c, 0x6d753868, 
+    0x74429485, 0xa28f62a2, 0x5a5aa6aa, 0x401e8791, 0x67354a66, 0x933c3251, 0xfe313017, 0x541f0541, 0x3b39698f, 0x68407d5e, 0xa62925a0, 0x6489527b, 
+    0x7490753a, 0x8e759375, 0x4150256c, 0x6644202b, 0x412dfd46, 0x00010038, 0x038bfe00, 0x00a4037b, 0x463e000e, 0xb2230521, 0x6106070b, 0x00240800, 
+    0x00b11b2f, 0x2014ec64, 0x27198206, 0x593e1106, 0x00060bb2, 0x30252e82, 0x030e0131, 0x08d08207, 0x01330142, 0x03371236, 0x5639117b, 0xfe8a4d77, 
+    0x3d019e73, 0x03138b77, 0xfcfe77a4, 0xb4fe6bf1, 0xcf034a01, 0x01c7b4fc, 0x0200d9ac, 0xe9ff2700, 0x2f057903, 0x37002700, 0x2eb31101, 0x2b04110c, 
+    0x190c00b3, 0x07220582, 0x7543280c, 0x14b22326, 0x7f820711, 0x244fb918, 0x1b402208, 0x2e162e06, 0x2e362e26, 0x2e562e46, 0x2e762e66, 0x2e962e86, 
+    0x2eb62ea6, 0x5d0d2ec6, 0xe52ed5b4, 0x05bf462e, 0x34423920, 0x821e2006, 0x4d1e20e4, 0x0c2007e7, 0x0c210c82, 0x22f1820f, 0x821e0c14, 0xb0340871, 
+    0x25b1101e, 0xd9b4f406, 0x0225e925, 0x0813405d, 0x28251825, 0x48253825, 0x68255825, 0x88257825, 0x405d0925, 0xa8259809, 0xc825b825, 0xb05d0425, 
+    0x33b1100c, 0x07232f82, 0x82331733, 0x27173c2f, 0x47333733, 0x67335733, 0x87337733, 0xa7339733, 0xc733b733, 0xb45d0b33, 0x82e633d6, 0x31303120, 
+    0x041e1401, 0x020e1415, 0x022e2223, 0x37363435, 0x18052d47, 0x25096553, 0x27263401, 0x955b0606, 0x3e7a0805, 0x524e0102, 0x527b917b, 0x629e6e3c, 
+    0x3b6f9e60, 0x4025a8a6, 0x4b271c2f, 0x8454456d, 0x6a303d3d, 0x0158433e, 0x858594a2, 0x6f431fa2, 0x466e4e4e, 0x2944041f, 0x7f62524c, 0x9b6166a0, 
+    0x733e3e73, 0xee76619b, 0x3733195c, 0x542b2942, 0x29212943, 0x3b162162, 0xbd7217fd, 0x75bd4747, 0x35596e39, 0x006e5838, 0x00000100, 0x8103e9ff, 
+    0x3000ba03, 0x1cb3bf00, 0x2b042b0c, 0x7b4d2bb0, 0x40270806, 0x161c061b, 0x361c261c, 0x561c461c, 0x761c661c, 0x961c861c, 0xb61ca61c, 0x0d1cc61c, 
+    0x1cd5b45d, 0x5d021ce5, 0x5d101cb0, 0x2b4505bb, 0x2f052405, 0x4205b11b, 0x4018075d, 0x1522084b, 0x8b181606, 0x37630800, 0x18b02024, 0x2a2abc54, 
+    0x15162eb2, 0x30391211, 0x44341331, 0x072405fd, 0x22232626, 0x27054541, 0x22231533, 0x1415020e, 0x0bb05418, 0x34355908, 0x26263736, 0xa177420c, 
+    0x3dc99961, 0x769a2966, 0x401ea38e, 0xcece4262, 0x23446444, 0xa47b94b6, 0xcf3f602f, 0x7daa64a0, 0x635c7148, 0x3fa4025e, 0x64274769, 0x54464664, 
+    0x33194a58, 0x1b741b29, 0x501b372b, 0x42484c5a, 0x4a276364, 0x7748436b, 0x00771012, 0x02000100, 0x08061b6b, 0x82002841, 0xb02f29b0, 0x22b02f2a, 
+    0x0c00b1dc, 0x00dab4f4, 0x5d0200ea, 0x00091b40, 0x00290019, 0x00490039, 0x00690059, 0x00890079, 0x00a90099, 0x00c900b9, 0x29b05d0d, 0xd00ab010, 
+    0xb22f0ab0, 0x82220a0f, 0xb12808ce, 0x40f40c18, 0x1618061b, 0x36182618, 0x56184618, 0x76186618, 0x96188618, 0xb618a618, 0x0d18c618, 0x18d5b45d, 
+    0x5d0218e5, 0x08d34118, 0x1b2f1132, 0x3e1511b1, 0x060fb159, 0x053130f4, 0x27022e34, 0x26055f42, 0x21352137, 0x42040615, 0x48080558, 0x15031e17, 
+    0x27070614, 0x02033636, 0x37583b21, 0x669ebd54, 0x83e8ae64, 0xea023bfe, 0xcdd9feb8, 0x9373486d, 0x6284474a, 0x3c75743b, 0x25734458, 0x040c192b, 
+    0xbd642306, 0xb4cb68a0, 0x75753598, 0xcbbca031, 0x508d715c, 0x284e821f, 0x564a5833, 0x21682999, 0x20fd8360, 0x0597660c, 0x001d002b, 0x2f1eb091, 
+    0xb02f1fb0, 0x082e661e, 0xb2f40825, 0x82101100, 0x1fb029d5, 0xdc07b010, 0xf40808b1, 0x18052e42, 0x200ca757, 0x20c0821b, 0x073b421b, 0x6d180720, 
+    0x10200bec, 0x23064c66, 0x030700b2, 0x2005cd67, 0x278165b1, 0x2905da5f, 0x32333636, 0x23111516, 0x94183411, 0x07210b1b, 0x08178427, 0x1f2f0142, 
+    0xa09a6883, 0x685a568a, 0x232d8a8d, 0x151b2122, 0x6d471d39, 0x664e0603, 0x49fcc0b8, 0x9074b703, 0xecfd92a0, 0x2f2bec02, 0x0e0a6b0f, 0x03000058, 
+    0xe9ff2900, 0x2f057f03, 0x1e001300, 0xa4002900, 0x15e16818, 0xf4081927, 0xb1100ab0, 0x2606821a, 0x19b0d024, 0x4b25b010, 0x045b0644, 0x0742180c, 
+    0x06252108, 0x0805db49, 0x0614b12e, 0x071b40f4, 0x27141714, 0x47143714, 0x67145714, 0x87147714, 0xa7149714, 0xc714b714, 0xb45d0d14, 0x14e614d6, 
+    0x0fb05d02, 0x061fb110, 0x25bc5c18, 0x11d36818, 0x32013708, 0x2137023e, 0x2213031e, 0x2107020e, 0x7f03032e, 0x71a36731, 0x2f699f73, 0x739f692f, 
+    0x2f69a173, 0x6c4e54fe, 0xfd041f44, 0x442102c0, 0x6a4e4e6a, 0x02022144, 0x0b820440, 0x8b023608, 0x63b2f895, 0x95f8b263, 0x64b4f894, 0xfdfab264, 
+    0xbd894e3f, 0x89bd6c6c, 0x495c044e, 0x6868b383, 0x004983b3, 0xffba0001, 0x03e902e9, 0x001100a4, 0x080db35d, 0x07d55708, 0x0cbf5a18, 0x1b2f0327, 
+    0x3e0f03b1, 0x076c6959, 0xb1100323, 0x38ff840f, 0x270f170f, 0x470f370f, 0x670f570f, 0x870f770f, 0xa70f970f, 0xc70fb70f, 0x2eff830f, 0x020fe60f, 
+    0x0311b25d, 0x3912110b, 0x48253130, 0x270805ea, 0x35231135, 0x33141121, 0xe9023732, 0x2d2b3916, 0xd3253e52, 0x316a5d01, 0x0d0c021b, 0x37563a1f, 
+    0xfd795c02, 0x0011712b, 0x2d7d0f6c, 0xe1ff0100, 0xc1030000, 0x12002f05, 0x07435d00, 0x2f0e2205, 0xf4a8181b, 0x0cbb5009, 0x200a7d54, 0x08eb820e, 
+    0x100eb02b, 0xf40608b1, 0xe908d9b4, 0x405d0208, 0x1808081b, 0x38082808, 0x58084808, 0x78086808, 0x98088808, 0xb808a808, 0x0d08c808, 0x06a9545d, 
+    0x26275608, 0x06222326, 0x33362707, 0x01171632, 0xb6fe1d03, 0x01a2b0fe, 0x331339a0, 0x2f5a1c44, 0x5660601b, 0xf801278e, 0xd1fc2f03, 0x2d8ebe03, 
+    0x76141041, 0xfb633d23, 0x01000071, 0x8bfe3100, 0xa4039803, 0xac002100, 0xb02f22b0, 0x16b02f23, 0x0813b1dc, 0x1600b2f4, 0x2d8c8313, 0x08b01022, 
+    0x2f08b0d0, 0xf40c07b1, 0xdc420ab0, 0x0c406d06, 0x430c6e69, 0xf7410cd3, 0x45002408, 0x821fb058, 0x0f1f27ff, 0x00b2593e, 0x58820907, 0x8406b221, 
+    0x03b02e06, 0x060eb110, 0x071b40f4, 0x270e170e, 0x1cc6180e, 0xd019231d, 0x35841bb2, 0x20060e42, 0xcd711826, 0x1411240e, 0x62323316, 0x370805e9, 
+    0x15750226, 0x683c6289, 0x6d898917, 0x41542f4e, 0x1d298b25, 0x151b1d31, 0x6c482531, 0x3e694c9e, 0x052bfe39, 0x6a9bfd19, 0x734e2977, 0xfd150247, 
+    0x112f2d16, 0x590d0c6d, 0x2406b564, 0x00a4037b, 0x0737560a, 0x4e490020, 0x0cfd460b, 0xb222e087, 0x4e490307, 0x02062306, 0x4c492307, 0xb2233907, 
+    0x83fe8b9e, 0x772f01a4, 0xa403127f, 0xd521fef0, 0xe1fca403, 0xd98101c5, 0x3b064946, 0x002f058b, 0xb3c3003a, 0x04380c1d, 0x0c27b32b, 0xb22b042e, 
+    0x11273800, 0x1b403912, 0x22418318, 0x3803b223, 0x262b821d, 0xb12f03b0, 0x18f40812, 0x2924927b, 0xb01027b0, 0xb000dc3c, 0x63182f2a, 0x15260975, 
+    0x22b3593e, 0x81823303, 0x17061622, 0x17218183, 0x20558316, 0x29b94c08, 0x01313025, 0x47352626, 0x16210e9a, 0x07994733, 0x46021e21, 0x35200991, 
+    0x3d07b346, 0x6f1b0136, 0x93714473, 0x3fa44e50, 0x467a462b, 0x8d8b9975, 0x7d4cf6f6, 0x73462f58, 0x9d464c93, 0x21230808, 0x7537583b, 0x94508dc3, 
+    0xa623b002, 0x587f4e60, 0x6a232331, 0x647d1823, 0x27747f71, 0x4e375e48, 0x4613315c, 0x2f2d0ba6, 0x0c192b25, 0x50230a04, 0xa66c6d85, 0x05991000, 
+    0x262d6201, 0x27b0ce00, 0x2f28b02f, 0xb0dc00b0, 0x0b697827, 0x2bff6f18, 0xb0100823, 0x0b38471e, 0x1db24518, 0x26277b7c, 0x220507b2, 0x18391211, 
+    0x4d331770, 0x07210ae5, 0x06cf4d34, 0xa6181520, 0x3f08088b, 0x966eb079, 0x6931897b, 0xaa696f9f, 0x29894078, 0x3d4e7952, 0x3c2b4c6b, 0x7d544e87, 
+    0xd1012b54, 0x4881b26d, 0x0341fe61, 0x89b05c46, 0xb5834754, 0x6487506a, 0x8e5a293a, 0x3841fa64, 0x0087623a, 0x2507ff43, 0x2b00ba03, 0xe95caf00, 
+    0x4b2c2006, 0xb0250693, 0x1bb0102d, 0x057545dc, 0x00b03108, 0x0c11b110, 0x061b40f4, 0x26111611, 0x46113611, 0x66115611, 0x86117611, 0xa6119611, 
+    0xc611b611, 0xb45d0d11, 0x11e511d5, 0x1bb05d02, 0x0c22b110, 0x254c5218, 0x1eb00022, 0x44050144, 0x6c4907ce, 0x0e834b28, 0x15020e23, 0x12df4314, 
+    0x8148022f, 0xcd8d6db4, 0xa22b603b, 0x5b835268, 0x0c714a31, 0x583b213a, 0x91c16f37, 0x6cd10154, 0x6c4781b5, 0x5244425c, 0x5087643a, 0x254e7d5e, 
+    0x2211ca43, 0x436a3808, 0xfa2808c7, 0x1600a403, 0xcd002900, 0x20068b49, 0x06974c2a, 0x102bb029, 0xb2dc05b0, 0x41050f00, 0x520806ed, 0x40f40c1a, 
+    0x161a061b, 0x361a261a, 0x561a461a, 0x761a661a, 0x961a861a, 0xb61aa61a, 0x0d1ac61a, 0x1ad5b45d, 0x5d021ae5, 0xb11005b0, 0xb4f40c24, 0x24ea24da, 
+    0x1b405d02, 0x24192409, 0x24392429, 0x24592449, 0x24792469, 0x24992489, 0x24b924a9, 0x470d24c9, 0xec4606c5, 0xb746180c, 0x10142b08, 0xf40600b1, 
+    0xb0d017b0, 0x6118100a, 0x17292991, 0xd029b010, 0x1e013130, 0x09304e03, 0x33023e25, 0x4c211521, 0x4e0806da, 0x35023e32, 0x27022e34, 0x542b8902, 
+    0x79422944, 0xa66664a6, 0x83494177, 0x23026ab5, 0xb6aadbfd, 0x4a72522b, 0x2b54754a, 0x395a4223, 0x4e122f03, 0x663e7869, 0x484279a6, 0x6a6db27f, 
+    0x75427bae, 0x874ea0c0, 0x58333a62, 0x763c4a7d, 0x4e145069, 0xa4290609, 0x1300a403, 0x05b35c00, 0x08836108, 0x1b2f0224, 0x734302b1, 0x820e2007, 
+    0x0f0e250c, 0x02b0593e, 0x0bec7618, 0x24059448, 0x08071b40, 0x4ab51817, 0x21d2821f, 0xc5823521, 0x18141121, 0x080a5476, 0xfe8d0122, 0xfea40373, 
+    0x231d6a73, 0x52281a0e, 0x253e522d, 0x75752f03, 0x0871a0fd, 0x1f196b07, 0x0037563a, 0x312a9f82, 0xa403e9ff, 0x1d00b603, 0x614c9500, 0x05045a09, 
+    0xf40c082c, 0xb0101fb0, 0x12b1dc19, 0x5218f40c, 0x774924fb, 0x0c736605, 0x0cad6018, 0xe8820020, 0xe8820020, 0x030db123, 0x08d882f4, 0x0d170d26, 
+    0x0d370d27, 0x0d570d47, 0x0d770d67, 0x0d970d87, 0x0db70da7, 0x5d0d0dc7, 0xe60dd6b4, 0x305d020d, 0x2e220531, 0x28074e55, 0x023e3233, 0x27263435, 
+    0x05015237, 0xd3014c08, 0x3c6e9a5e, 0x674c2d89, 0x4c7d5c39, 0x852b2523, 0x71352b29, 0x603017b0, 0x3e02608d, 0x623dc2fd, 0x7b4e2344, 0xbd684493, 
+    0xdb60355c, 0x99bf5e7b, 0xff020061, 0x038bfeec, 0x00ba03be, 0x002d0021, 0x0c19b3b7, 0xb32b0412, 0x820c080b, 0x0c052805, 0x402b0425, 0x1819061b, 
+    0x082079cc, 0x100cb035, 0xb0d01cb0, 0x22b0100b, 0x25dab4d0, 0x5d0225ea, 0x25091b40, 0x25292519, 0x25492539, 0x25692559, 0x25892579, 0x25a92599, 
+    0x25c925b9, 0x05b05d0d, 0x512fb010, 0xdb48062b, 0x2f0b330c, 0x110bb11b, 0x00b0593e, 0x062ab110, 0x2ad9b4f4, 0x4c832ae9, 0x2a08a408, 0x2a282a18, 
+    0x2a482a38, 0x2a682a58, 0x2a882a78, 0x2aa82a98, 0x2ac82ab8, 0x31305d0d, 0x021e3201, 0x020e1415, 0x11231107, 0x3435032e, 0x06173736, 0x16141506, 
+    0x3e341117, 0x36360302, 0x022e3435, 0x15062223, 0x85525402, 0x6f3d355e, 0x5e8a609b, 0x643b6f99, 0x4742525c, 0x2d138791, 0x9787024c, 0x27523f29, 
+    0xba031a23, 0x6cb58147, 0x507daa62, 0x019dfe0a, 0x7f500a63, 0xe58362a8, 0xaf355e46, 0x17c98d6c, 0x4e2b8302, 0xaafc203a, 0x508dc917, 0x2d3a6487, 
+    0xff010032, 0x0375fef8, 0x00bc03a4, 0x663c000b, 0x40460dd9, 0x210c820c, 0xaa7601b2, 0x8507200c, 0x8409200d, 0x30340806, 0x23020931, 0x01370101, 
+    0x01013301, 0xc9fe0c03, 0x01a4c7fe, 0x798dfe8d, 0x2d014a01, 0x0181fea2, 0x0275fe5e, 0x02ebfd2b, 0x45690283, 0x2702c1fd, 0xaefd6afd, 0x08fb7c18, 
+    0x005e0425, 0x574b001b, 0x12201fc1, 0x23056e45, 0xb11b2f0a, 0x08bca818, 0x200c0e6e, 0x23198204, 0x593e1104, 0x312cb757, 0xffcdd101, 0x9dfe1600, 
+    0x01166301, 0xd101cd02, 0xb7572dfe, 0xfcfa2205, 0x05b75706, 0x0100d338, 0xe9fff2ff, 0xb603b603, 0xd6003400, 0x080c13b3, 0x1cb32b04, 0x05821908, 
+    0x220c2d2b, 0x00b22b04, 0x12111c19, 0xa8711839, 0xa6581824, 0x552d2025, 0xe96b09bd, 0x8228200c, 0x412820e0, 0x194c0796, 0x8232200c, 0x0f322719, 
+    0x00b2593e, 0x8b820d03, 0x1003b023, 0x27eb6cb1, 0xd01fb022, 0x29060b4c, 0x3435022e, 0x1737023e, 0x0a52030e, 0x11352605, 0x16141133, 0x058e5533, 
+    0x0bed7c18, 0x17d35908, 0x64485072, 0x160a1c40, 0x1787151f, 0x3908151e, 0x8a563d46, 0x3b463d58, 0x171e150a, 0x14211587, 0x64401c0c, 0xa273504a, 
+    0x77446752, 0x8d3e64a8, 0x352f818b, 0x7d7f752d, 0xa4a6ac33, 0xfe510194, 0xa6a494af, 0x7f7d33ac, 0x2f352d75, 0x3e8d8b81, 0x4477a864, 0xffff0067, 
+    0x22050b4f, 0x68021905, 0x0022065b, 0x256f008c, 0x84a42007, 0x00b22415, 0x85060000, 0x058f7515, 0x022f0625, 0x59ad0122, 0x31210a1d, 0x079d68ff, 
+    0x1d592b84, 0x05c14105, 0x26222b82, 0x2b82b601, 0x26073359, 0x03000031, 0x828e0673, 0x82cf206d, 0x83072015, 0x75012557, 0x77ff0100, 0x2b084382, 
+    0x00190573, 0xb0e80023, 0x25b02f24, 0x1024b02f, 0xb0d021b0, 0x20b12f21, 0x03b0f40c, 0x1025b0d0, 0xb2dc09b0, 0x11092104, 0x11b23912, 0xa87e0684, 
+    0x58452206, 0x175b18b0, 0x0c2f450c, 0x2107a251, 0x268200b0, 0x1b2f2023, 0x081759b1, 0x67083246, 0xb22305b6, 0x84000e04, 0x2206845a, 0x50100eb0, 
+    0x062129ee, 0x3db01810, 0x02b02128, 0x08125718, 0x15210324, 0x6a771123, 0x020e2205, 0x06757823, 0x77113521, 0x23330988, 0xbbfe0189, 0x5801fe63, 
+    0x2d523e25, 0x0e1a2654, 0x776a1d23, 0x21080687, 0x751905ba, 0x000116fe, 0x90fe85fe, 0x1f3a5637, 0x08096d19, 0x7d700171, 0x9775468a, 0x045efe52, 
+    0x376d00a4, 0xa4350806, 0x2602c906, 0x0000cd01, 0x8b000700, 0x75010000, 0xecff0100, 0xac03e9ff, 0x2e002f05, 0x2fb0b700, 0x2f30b02f, 0xb0dc15b0, 
+    0x00b0d000, 0x102fb02f, 0xb0d00bb0, 0x8211820b, 0xf40d23fe, 0x0c8217b0, 0x24b11030, 0x21b0f408, 0x1014b0d0, 0xb0d02eb0, 0xa2462f2e, 0x15d97205, 
+    0x06223a08, 0xb22b0423, 0x11100413, 0x10b03912, 0x061cb110, 0x1cd9b4f4, 0x5d021ce9, 0x1c081b40, 0x1c281c18, 0x1c481c38, 0x1c681c58, 0x1c881c78, 
+    0x1ca81c98, 0x1cc81cb8, 0x04b05d0d, 0x32521810, 0x0601272a, 0x22230607, 0xbe4d042e, 0x33352407, 0x4a342311, 0x420805f0, 0x21152107, 0x1e171616, 
+    0x13323303, 0x7433ac03, 0x915bb074, 0x17334f70, 0x89bf7736, 0x752aab79, 0x7a5a3575, 0x55866045, 0x4602052b, 0x2303bafd, 0x47371526, 0x60f43557, 
+    0x64a75601, 0x7e5b3462, 0x1858a796, 0x33087897, 0x335a7a46, 0x5bb08a54, 0x47ab5875, 0x1b304227, 0x01002701, 0x2505c777, 0x3f002f05, 0xbb18d300, 
+    0xb2296dd3, 0x11250508, 0x11b13912, 0xcabb1806, 0x660768fa, 0x12694218, 0x00008c28, 0x01007301, 0xa944feff, 0x00112206, 0xf1c4184c, 0xff02227e, 
+    0x328b8275, 0x0019059c, 0x00240008, 0x0c15b3ba, 0xb32b0423, 0x82120c05, 0x080e2405, 0x572b0400, 0x052625e0, 0xd009b010, 0x42180eb0, 0x09240951, 
+    0x09b11b2f, 0x0f114318, 0x4500b024, 0x4218b058, 0x1a200c2a, 0x1a3c2682, 0xb3593e0f, 0x0403060b, 0x1009b02b, 0xf40613b1, 0x091a1eb2, 0xb0391211, 
+    0x21b1101a, 0x28df8318, 0x26340129, 0x33112323, 0x82013632, 0x15162304, 0x0d820614, 0x18112321, 0x080bd748, 0x03113544, 0x4c5c6c12, 0xfe6c5c4c, 
+    0xb3a14aec, 0xbbd1a3b3, 0x2b4c3a20, 0x18163628, 0x5e19200d, 0x857f7101, 0x047f00fe, 0xbcd0fd25, 0x04b6bbbc, 0x372bfca4, 0x091f3a56, 0x0809730a, 
+    0x004a0471, 0x00310002, 0x29410300, 0x001b2c05, 0x0c1bb39f, 0xb32b0409, 0x820d0c10, 0x41142005, 0x10352929, 0xd004b010, 0xb0101bb0, 0x0db0d00b, 
+    0xd018b010, 0xb01014b0, 0x06944a1d, 0x550cea60, 0x09200c37, 0x25060c75, 0x584500b0, 0x0c8217b0, 0x02681720, 0x04033705, 0x1017b02b, 0xf40605b1, 
+    0xb01011b0, 0x03b0d00c, 0xd019b010, 0x0e413130, 0x11052208, 0x20018533, 0x08144132, 0x24070641, 0xbb891ffd, 0x06094189, 0xf426fd86, 0xd0fd1905, 
+    0x02413002, 0x75022305, 0x48188bfd, 0x17330b7f, 0x18b0a100, 0x2f19b02f, 0xb01018b0, 0x15b0d015, 0x4714b12f, 0x19200557, 0x26055747, 0x12110915, 
+    0x590ab139, 0x50470700, 0x18cd8c19, 0x28090076, 0x0602b110, 0x0904b2f4, 0x08468200, 0x1006b033, 0xf4060eb1, 0xe90ed9b4, 0x405d020e, 0x180e081b, 
+    0x380e280e, 0x580e480e, 0x780e680e, 0x980e880e, 0xb80ea80e, 0x0d0ec80e, 0x1002b05d, 0xb0d016b0, 0x47f78217, 0x23200910, 0x18130547, 0x46075ab0, 
+    0xfd2309fb, 0x463f02c1, 0xf14609f2, 0x069e2606, 0x012602c9, 0x09f146d4, 0xffffff29, 0x03e9ffe1, 0x827b06c1, 0x84dd2017, 0x00d93c17, 0x00750100, 
+    0xfe310001, 0x057303c1, 0x000b0019, 0x0c08b353, 0xb32b0405, 0x82030802, 0x72002005, 0x02200575, 0x6705ff4a, 0xe6410cc0, 0x0c11570c, 0x088ab018, 
+    0xf4060824, 0xcf8209b0, 0x11212127, 0x11211123, 0x35038333, 0xa4fe7303, 0x89a4fe8a, 0xfe8a2f02, 0x053f01c1, 0x045cfb19, 0xc37100a4, 0x05fd4265, 
+    0xe782a220, 0x1500082c, 0x16b07300, 0x2f17b02f, 0x035c0db0, 0x5b16202a, 0x05210731, 0x48da830c, 0xce630500, 0x5641180c, 0x060a2608, 0xb02b0403, 
+    0x05d64210, 0xb1101225, 0x42f40614, 0x212605d1, 0x36322111, 0xca422101, 0x230c8205, 0x19032115, 0x07c8c518, 0x01a1fd2d, 0xececd527, 0x0352fed7, 
+    0x4247fd42, 0x012b06cf, 0xbbbcbcf5, 0x751905b6, 0x18030000, 0x2108ab5b, 0xd018000e, 0x8572f28d, 0x00003749, 0xa403c1fe, 0x0f001905, 0x52001800, 
+    0x000b0db3, 0x10b32b04, 0x0582050c, 0x160c0822, 0x0a300582, 0x2b040b0b, 0xb0100ab0, 0xb000dc1a, 0x0eb02f0a, 0x60120243, 0xb13d079d, 0xb0f40608, 
+    0x16b0d015, 0x1006b0d0, 0xf40617b1, 0x3e353130, 0x11351202, 0x11331121, 0x08058223, 0x14012339, 0x07060602, 0x39231121, 0x011f3c58, 0xfd7bbbfd, 
+    0x75017b52, 0x39503117, 0x75ebbc01, 0x01bc7131, 0x4201e123, 0x4cfe5cfb, 0xc1fe3f01, 0xfeb01605, 0x399ad1f2, 0x18002f04, 0x3a6f6fcf, 0x0000c1ff, 
+    0x1905e303, 0x7f001300, 0x000813b3, 0x00b02b04, 0xd008b010, 0x5a1013b0, 0x0644083f, 0x0c23470c, 0x440ce36d, 0x324e0c13, 0x2f0f300c, 0x0f0fb11b, 
+    0x02b2593e, 0x12110600, 0x8508b239, 0x850b2006, 0x84112006, 0x31302d06, 0x01271121, 0x33010123, 0x11331101, 0x0b820582, 0x11072708, 0xfe378d01, 
+    0x3f018ffa, 0x0195c1fe, 0x37018a37, 0x01c1fe95, 0xfafe8f3f, 0x64060237, 0xe10296fd, 0xbcfd3802, 0x03844402, 0x1ffdc83f, 0xfd646a02, 0x000100fa, 
+    0x03e9ff1b, 0x002f0598, 0xb3e4003e, 0x042b0d2d, 0x0c37b32b, 0x08d9821f, 0xb1103737, 0xb1f40914, 0xb0f40800, 0x0bb0102d, 0x2f0bb0d0, 0xea1fdab4, 
+    0x405d021f, 0x191f091b, 0x391f291f, 0x591f491f, 0x791f691f, 0x991f891f, 0xb91fa91f, 0x0d1fc91f, 0x282d835d, 0x29b0d029, 0x2b3ab22f, 0x24c08200, 
+    0xb01037b0, 0x3e421840, 0x08395e13, 0x395e1a20, 0x27395d07, 0x1032b027, 0xf40623b1, 0x9bb718b4, 0x052d2224, 0x23858232, 0x1a193ab2, 0x475e0682, 
+    0x37272409, 0x52161716, 0x2e3905e8, 0x32352302, 0x3435023e, 0x22232627, 0x06060706, 0x33112315, 0x33033e15, 0x05076532, 0x031e6b08, 0x75469803, 
+    0xa45e5499, 0x85084e7d, 0x8b5c5d0c, 0x2d4e683b, 0x5c8e6132, 0x3e648043, 0x41744949, 0x36282a79, 0x4a18757d, 0x54306058, 0x843e6b92, 0x4769457c, 
+    0x56680124, 0x3338648d, 0x12639666, 0x284c4d96, 0x503a6246, 0x75143965, 0x43593616, 0x3243426e, 0x4c702629, 0x31989c01, 0x31122942, 0x7055865c, 
+    0x3c0a1392, 0xd3426f59, 0x0009280b, 0x2f0ab062, 0x182f0bb0, 0x2a08cd67, 0xf40c01b1, 0xb0100bb0, 0x18b1dc05, 0x4708da8b, 0x03200c83, 0x0b1d4818, 
+    0x18076041, 0x280c857e, 0x000502b2, 0xb2391211, 0x08068407, 0x13313020, 0x33011133, 0x01112311, 0x01893123, 0xfd8ac1f8, 0x1905aaf2, 0x1d04e3fb, 
+    0x5004e7fa, 0x214eb0fb, 0x06732607, 0x01260279, 0x081747d2, 0x7b437320, 0x739e2006, 0xe7207803, 0x2206614b, 0x718b0013, 0x01300675, 0x0802b1dc, 
+    0x1014b0f4, 0xb0d012b0, 0x05b12f12, 0x1814a648, 0x240c9565, 0xb11b2f0c, 0x0f897d0c, 0x1000b03a, 0xf40603b1, 0x000a0db2, 0xb0391211, 0x10b1100a, 
+    0x1b40f406, 0x10171007, 0x1eeae118, 0x01313026, 0x21112311, 0x3b05944a, 0x16163727, 0x11353233, 0xfe8a7303, 0x523e255b, 0x1b27542d, 0x6a1d230e, 
+    0xe7fa1905, 0x21077b4a, 0x7a4a6d19, 0xac797305, 0x77000b21, 0x32108153, 0x338002b1, 0xecffecff, 0x2f05ac03, 0xe3002500, 0xb02f26b0, 0x12b02f27, 
+    0x21071f53, 0xe25c1026, 0xfbd91006, 0xc2240d01, 0x83f4ba6e, 0x23083653, 0x335a7b45, 0x2405bb79, 0x2501659d, 0x069d6200, 0x1805754a, 0x4e9a7dcd, 
+    0x05250525, 0x00120019, 0x12e57d5a, 0x4d0c1b67, 0x0a2508eb, 0x1b40f406, 0xd2d61807, 0x11b22221, 0x066c6304, 0x06060122, 0x1807ec55, 0x331ef0b0, 
+    0x70fb1905, 0x77233e62, 0x2d421114, 0xfcbf038d, 0x003003d0, 0x01713310, 0xc1fe33f2, 0x19051f04, 0x4f000b00, 0x040c07b3, 0x0bb32b04, 0x05820808, 
+    0x020b012d, 0x01b02b04, 0xdc0db010, 0x6101b000, 0x15240a18, 0x00b0593e, 0x0fe55618, 0xcd680320, 0x00b12c06, 0x07b0f406, 0xd008b0d0, 0x50253130, 
+    0x112c099e, 0xfc7b1f04, 0x2f02898d, 0x4cfe758a, 0x21079e50, 0xb34a5cfb, 0x0013220b, 0x10037b5e, 0xb0f40c32, 0x0cb01015, 0x080bb1dc, 0xd00eb0f4, 
+    0x0c000fb2, 0x180dcf6f, 0x180cce52, 0x2b0ce6de, 0xb3593e0f, 0x04110605, 0x0d0fb22b, 0x20051943, 0x05fb5a13, 0x35023e24, 0x99823311, 0x20230223, 
+    0x31b61811, 0x1905330d, 0x897dc0fd, 0x52987446, 0xe7faa201, 0x00ff5e02, 0x5d447b01, 0x000b250b, 0x2f0cb07c, 0x072bdd83, 0xdc00b02f, 0x0100efb2, 
+    0x8240b25d, 0x01b12104, 0x00239e82, 0x8203b010, 0x83032013, 0x21048213, 0xbc8206b1, 0xb1100723, 0x2006820a, 0x05444106, 0x485a0020, 0x148d180f, 
+    0x3261180c, 0x02b12e14, 0x0ab0f406, 0xd00bb0d0, 0x33013130, 0x06ec5111, 0x0121112c, 0x04018a8d, 0x895cfc89, 0xea510401, 0xe7fa2105, 0xad840783, 
+    0x2c06cf41, 0xb36f000f, 0x04000c03, 0x0807b32b, 0x2b058204, 0x04080c0b, 0x100bb02b, 0xf40b0cb1, 0xb0210682, 0x2655820e, 0xdc11b010, 0x180db000, 
+    0x410abc83, 0x98180743, 0x8c4e0c7e, 0x0820600c, 0xe9410320, 0x219d8207, 0xa0820cb0, 0x8a523120, 0x23a58405, 0x11231133, 0xa5839c82, 0x857b7b21, 
+    0x5cfb23a2, 0x8a4fa404, 0x02002205, 0x29008200, 0x1905a203, 0x15000c00, 0x31527600, 0x10162106, 0x3705096e, 0xf40c12b1, 0xb0d001b0, 0x06b01017, 
+    0x0c0db1dc, 0x0ddab4f4, 0x5d020dea, 0x1db4df18, 0x18125245, 0x2208ac40, 0x82100603, 0x100023fb, 0xb3820bb1, 0xb1100927, 0x30f40612, 0x52a78331, 
+    0x2320072d, 0x33081355, 0xb4b27501, 0xfeb6c7c7, 0x1903ecc7, 0xb4b46f81, 0x1905816f, 0x2708f555, 0xfe857fcd, 0x00007f00, 0x3009bd7d, 0x0013000a, 
+    0xb3870017, 0x04000c01, 0x0c06b32b, 0x2405820b, 0x04140c15, 0xb8d8182b, 0x10012625, 0xb0d00fb0, 0xcf4d1815, 0x0c934d09, 0x1b2f1424, 0x6e4314b1, 
+    0x07704c0c, 0x19821620, 0x0c821620, 0x0603b323, 0x051b570e, 0xd2841020, 0xe0563320, 0x89212007, 0x113336d0, 0xa2878923, 0xfea4b2b2, 0x6cdb01f2, 
+    0x5d89895d, 0x8940016c, 0x56d68789, 0xfa2108db, 0x06c756e7, 0x2205c953, 0x436c0013, 0xc953068f, 0x5314202b, 0xc25335c9, 0x53332014, 0x892013c0, 
+    0x2d0ebd53, 0xf8ff0100, 0xb803e9ff, 0x2e002f05, 0x6f5cbe00, 0x102f2b06, 0xb0d018b0, 0x17b12f18, 0x795cf40d, 0x10303006, 0xb1dc23b0, 0xb0f4080a, 
+    0x17b0d00d, 0x821ab010, 0x5c10201f, 0xb222056f, 0x8c182e1b, 0x2773098c, 0x2a40080c, 0x2ab11b2f, 0xb3593e0f, 0x040a060d, 0x102ab02b, 0xf40602b1, 
+    0x02071b40, 0x02270217, 0x02470237, 0x02670257, 0x02870277, 0x02a70297, 0x02c702b7, 0xd6b45d0d, 0x0202e602, 0x101eb05d, 0xf40612b1, 0x243e9618, 
+    0x2a1bb235, 0x3912111e, 0x12133130, 0x023e3233, 0x37363637, 0x76213521, 0x152605d9, 0x15331123, 0x50503636, 0x0e670805, 0x27222304, 0x606f2726, 
+    0x475735f4, 0x23261537, 0x02bafd03, 0x552b0546, 0x7a456086, 0x7575355a, 0x8979ab2a, 0x173677bf, 0x91704f33, 0x7474b05b, 0xfe850133, 0x42301bd9, 
+    0x58ab4727, 0x8ab05b75, 0x7a5a3354, 0x98ac0146, 0xbc715658, 0xa75883f4, 0x345b7e96, 0x00a76462, 0xff310002, 0x05a803e9, 0x000e002f, 0x42de0022, 
+    0x1e2806cd, 0x2b040b08, 0x140c07b3, 0x0b2afa82, 0xd003b010, 0xb01001b0, 0xa818d00c, 0xb0242475, 0x24b01007, 0x13508a18, 0x200c5844, 0xf66b180d, 
+    0x0aad430b, 0xb0217782, 0x290f6f09, 0x1005b036, 0xf40619b1, 0xe919d9b4, 0x405d0219, 0x1819081b, 0x38192819, 0x12b8e418, 0x305d0d34, 0x11331331, 
+    0x20211233, 0x20211011, 0x23112303, 0x50663225, 0x05307305, 0x021e3508, 0x0dac8931, 0x21011401, 0xecfedffe, 0x0289ac0d, 0x203c2f56, 0x3c200d0d, 
+    0x213b2f2f, 0x3b210c0c, 0xaefd1905, 0x5cfd6802, 0x69025efd, 0x525eaefd, 0x7b7bcc94, 0x0a208e18, 0xff020027, 0x030000f4, 0x06035573, 0x19b09427, 
+    0x2f1ab02f, 0x6eda18b0, 0x1ab02407, 0x460ab010, 0x052105cf, 0x05407410, 0x1023bd83, 0x1840f408, 0x232300fa, 0xb0100bb0, 0x07778c18, 0x670c3046, 
+    0x00240875, 0x0eb05845, 0x0806ac66, 0x0113b328, 0xb02b0400, 0x0cb01000, 0x2f0cb0d0, 0xb11008b0, 0x30f40615, 0x032e0131, 0x33363435, 0x11231121, 
+    0x13230123, 0x0a821614, 0x22213108, 0x527d0106, 0xec39658b, 0x8aae01d7, 0xae83feca, 0x0190a69b, 0x90dcfe24, 0x063502a6, 0x52835c38, 0xe7fabbba, 
+    0xd1fd2f02, 0x7987a403, 0x007b0002, 0xfe28e982, 0x7303e9ff, 0x2600ba03, 0x0125d310, 0xff003f80, 0x05a403e9, 0x000d002f, 0xb00a013a, 0x3cb02f3b, 
+    0x103bb02f, 0xb0d00eb0, 0x29b12f0e, 0xb618f408, 0xa46125ca, 0x3c320805, 0xdc33b010, 0xf40c08b1, 0xea08dab4, 0x405d0208, 0x1908091b, 0x39082908, 
+    0x59084908, 0x79086908, 0x99088908, 0xb908a908, 0x0d08c908, 0xd01bb05d, 0xb3611bb0, 0x0c247f06, 0x1b2f1b24, 0xbd461bb1, 0x82382007, 0x0f382c0c, 
+    0x2eb3593e, 0x2b040b06, 0x181038b0, 0x2029a3cf, 0x13c21813, 0x18b12b29, 0x1fb1f402, 0x29b2f406, 0x51451338, 0x55142005, 0x262506a9, 0x27062223, 
+    0x05a17a34, 0x0af95318, 0x0ae1f318, 0x08056e6a, 0xac96024c, 0x56774697, 0xa69aa82f, 0x733f969d, 0x3e2d609e, 0x291f2d31, 0x2b472939, 0x3a273374, 
+    0x3d233331, 0x192d506b, 0x31645848, 0x467ba862, 0x62a87b46, 0xbc01eeeb, 0x5d31bf9f, 0xbfa04f81, 0xf8962fbf, 0x191264b2, 0x52211c12, 0x07823729, 
+    0xb47f4331, 0x31462d71, 0xae753b18, 0x7dac6275, 0x5a480148, 0x032b086d, 0x001000a4, 0x0026001d, 0x4b23b3a9, 0x0c250577, 0xb42b0411, 0x5f7718da, 
+    0x1eb22322, 0x4d7c0b11, 0x0c00262b, 0x040eb2f4, 0x18328300, 0x710a1cbe, 0xb32914b5, 0x04210619, 0x210eb22b, 0x352d8319, 0x16b11005, 0x03b0f406, 
+    0x0623b110, 0x013130f4, 0x21230614, 0xe57b2111, 0x34032308, 0x1084022e, 0x13023e24, 0x09842634, 0x03364708, 0xfebac7a2, 0x44d10110, 0x46426885, 
+    0xb65c7d66, 0x2752432e, 0x4801b8fe, 0x29445429, 0xfe74862d, 0x7465019b, 0x870a0186, 0x15a40383, 0x484c5e35, 0x711d1a62, 0x352b4a01, 0xf4fe0a1d, 
+    0xfe331f0a, 0xfe4c5291, 0xd7544ec7, 0x03a42306, 0x4d1800a4, 0x3367131b, 0x2f042707, 0x0f04b11b, 0x4d18593e, 0x032c141b, 0xd1fc75a4, 0x00020000, 
+    0x03c1fe00, 0x955a4983, 0x5a698733, 0x03221c95, 0x945a3535, 0x020e290a, 0x23112107, 0x2740562f, 0x2f08935a, 0x21443521, 0x75eba601, 0xdf9c580a, 
+    0xd1fcc191, 0x2905915a, 0xcb742204, 0x021c73a0, 0xd21800ba, 0xff39e6e5, 0x030000f0, 0x00a403b4, 0xb37f0013, 0x04030806, 0x1006b02b, 0xb0d00db0, 
+    0xc1e31803, 0x2f012409, 0x4101b11b, 0x1b790cdf, 0xa55a180c, 0x180f200c, 0x180e1f75, 0x280cc35e, 0x010a03b2, 0xb2391211, 0x20068506, 0x2006850c, 
+    0x21068411, 0x025b3130, 0x0325080b, 0x11231107, 0x01230327, 0x99e2fe0e, 0x018a0401, 0xe2fe9904, 0xd9931e01, 0xd9318a31, 0x010c0293, 0x0177fe98, 
+    0x2d038489, 0x01f4fd68, 0xa6fe48a2, 0xfe485a01, 0xaf63005e, 0x037f2606, 0x002e00ba, 0x20d182c5, 0x27d18520, 0x00b0d000, 0x20dab42f, 0x2186bf18, 
+    0x6120b021, 0xb024062f, 0x30b01006, 0x24063149, 0xb11b2f2a, 0x20e8872a, 0x200c820b, 0x29e8820b, 0x1a061db3, 0x03b22b04, 0xa17f1d1a, 0xef551806, 
+    0x2ab02127, 0x2329f45a, 0x14013130, 0x1807bf7f, 0x230af56b, 0x23022e34, 0x2506c77f, 0x06222326, 0x924a2707, 0x034b0805, 0x5c625f73, 0xaa7d4871, 
+    0x3fcfa064, 0x7ba42f60, 0x4423b793, 0x9c9c4464, 0x8ea37f83, 0x66299a76, 0x6199c93d, 0x024277a1, 0x107744a4, 0x43487712, 0x63274a6b, 0x4c484264, 
+    0x371b505a, 0x5d741b2b, 0x54584a33, 0x64644646, 0x50694727, 0x0322080b, 0xbf5a00a4, 0x0c3c6b2a, 0xbf5a0c87, 0xa4032b37, 0xf00210fd, 0x12035cfc, 
+    0xbf5aeefc, 0x06052b08, 0xf2012602, 0x06000000, 0x0582d900, 0x7c536518, 0xff01002a, 0x03e9ffe7, 0x00a40373, 0x4127bd5a, 0xbd5a0713, 0xa4032780, 
+    0x2f035cfc, 0x4f6aa0fd, 0xd5022108, 0x180bf341, 0x432e374e, 0x0c870c1d, 0x240c1b5f, 0xb11b2f06, 0x050e5f06, 0x12110826, 0x0005b239, 0x0a200684, 
+    0xea180684, 0xe5351191, 0xb289e862, 0x02b2eef0, 0x011dfee3, 0x031dfde3, 0x011afea4, 0x5aa18be6, 0xaa4430bd, 0x20a3940c, 0x06be4604, 0x0609b325, 
+    0x842b0402, 0x11212294, 0x05475123, 0x8a73032d, 0x8989d1fd, 0x018a2f02, 0x825efea2, 0x0173228e, 0xbb37108d, 0xd3435601, 0x03732305, 0x4d1800a4, 
+    0xcd41276f, 0x6f4d181c, 0x2f032318, 0x6482d1fc, 0x10020021, 0x5a0131d1, 0x09d94318, 0xd7002823, 0xd5de10b0, 0xb0231b01, 0x18486b5c, 0x2219d5de, 
+    0x5b004450, 0x03220759, 0x4e1800a4, 0x2e433ed7, 0x07934507, 0x100eb024, 0xf21802b1, 0xe8181915, 0x012d1dd7, 0xfd4301ec, 0x02757546, 0x01bdfeba, 
+    0x25a582b8, 0x75fee1ff, 0xa582c103, 0x6513cc18, 0xff032308, 0x038bfee3, 0x001905c1, 0x0024000a, 0xb032012f, 0x10b02f30, 0x2f10b0d0, 0xb2dc00b0, 
+    0x5d010080, 0x0483d0b2, 0x04823020, 0x1010b02c, 0xf40805b1, 0xb01000b0, 0x0583d00b, 0x05831520, 0x822fb121, 0x83172012, 0x2ab02109, 0x2a203182, 
+    0x04833183, 0x04833020, 0x2a001827, 0xb1391211, 0x2922821d, 0x22b0102f, 0x101db0d0, 0x184a31b0, 0x18162006, 0x200ba5c8, 0x200c8213, 0x07594113, 
+    0x200c3775, 0x21198223, 0x1b4b1123, 0x0c645306, 0x2608a172, 0x02b11013, 0x18b4f406, 0x2524a9d2, 0x08b1100d, 0xe678f406, 0x0bb22324, 0xbd82080d, 
+    0x1315b223, 0x20068302, 0x20068518, 0x08148422, 0xd027b023, 0xb01002b0, 0x3130d02d, 0x22232601, 0x16141506, 0x15373233, 0x26222306, 0x33363435, 
+    0x33111732, 0x22068211, 0x82141516, 0x11272312, 0x90181323, 0x07330849, 0x54398d01, 0x4a49494a, 0x58353954, 0x8f8e8e8f, 0x888a3558, 0x878a2008, 
+    0x022e081a, 0xc9ac5fe7, 0x7d5eaac9, 0xebecfc56, 0xb50156fe, 0xfe564bfe, 0x56fceceb, 0x31024cfe, 0xc9c9aa5e, 0x01005fac, 0x0000ecff, 0xa403ba03, 
+    0xcf181b00, 0x0025c711, 0x04c1fe31, 0x5bd1821f, 0x4b1828c1, 0xc15b1405, 0xfe792b28, 0x033f0148, 0x03d1fca4, 0xc149fc2f, 0x34c15b0c, 0x4214c749, 
+    0xc15b07b2, 0x5b352018, 0x033215c1, 0x7dd7fea4, 0x98754589, 0x5cfc8b52, 0x00ff0002, 0xc3447b01, 0x48bf5b0a, 0x18149c4e, 0x440cd361, 0xbf5b07e7, 
+    0x06494122, 0x07835c20, 0xad830020, 0x2206cd41, 0x5b75000f, 0x014d32bf, 0x14e7410c, 0x2115bf5b, 0x23562f0b, 0x31302105, 0x8618c55b, 0x03d129a8, 
+    0xfed5fc2f, 0x003f0148, 0x2106c55b, 0xc55ba403, 0x5abd8c55, 0xc55b05eb, 0xdd20082a, 0xa0aeaea2, 0x03ec98fe, 0xdf5c6919, 0x03695cdf, 0x858bfea4, 
+    0x03879291, 0x4deafd2f, 0x56bbfe54, 0x8208c55b, 0x000330bf, 0x0017000e, 0x0c14b387, 0xb32b040c, 0x820f0c08, 0x0c012a05, 0xb02b0400, 0x04b01014, 
+    0x15c318d0, 0x01b02124, 0x870ec55b, 0x0cf079bf, 0x1b2f0224, 0xb55002b1, 0x08d94f07, 0x12060522, 0x08098b18, 0x01313027, 0x01231133, 0x079a5c33, 
+    0xc95b3320, 0x1b033b08, 0x6efd8989, 0xa1a19aa0, 0x89d5fe98, 0x545c5201, 0x5c54a2a2, 0x5cfca403, 0xda842f02, 0x75fda422, 0x916fda85, 0x24d98206, 
+    0x0013000a, 0x09575f6f, 0xb0d0082d, 0x10b12f08, 0x00b0f40c, 0x8215b0d0, 0xb1dc23db, 0x8a180c0b, 0x5f5d257b, 0xe4461805, 0x8207200c, 0x820720cc, 
+    0x01b323cc, 0xbf820e06, 0xb1100728, 0x30f40610, 0x846f1331, 0x30bb8408, 0x32211121, 0x6501ba36, 0xbac7c9ba, 0x028910fe, 0x0703545f, 0x012cb58f, 
+    0xe9ff2300, 0xba03a403, 0x7b002000, 0x0b206e85, 0x0b206182, 0x20074841, 0x200c8215, 0x206e8515, 0x052e411f, 0x06042708, 0x04d9b4f4, 0x5d0204e9, 
+    0x04081b40, 0x04280418, 0x04480438, 0x04680458, 0x04880478, 0x04a80498, 0x04c804b8, 0xea825d0d, 0x1cb12d08, 0x1b40f406, 0x1c171c07, 0x1c371c27, 
+    0x1c571c47, 0x1c771c67, 0x1c971c87, 0x1cb71ca7, 0x5d0d1cc7, 0xe61cd6b4, 0x305d021c, 0x26210131, 0x560be450, 0x26200518, 0x37059469, 0x01213736, 
+    0x14fd0117, 0xa26894b4, 0xcd3b602b, 0x81b66d8d, 0xb6814848, 0x07d74118, 0x0fb89a3d, 0x1702fefd, 0x4452aa85, 0x476c5c42, 0x6d6cb581, 0x6b4881b2, 
+    0x5044425c, 0x5b008eb6, 0xe1830567, 0x16000e22, 0x2108675b, 0x675b0c15, 0x5b112005, 0x09560f67, 0x07b02422, 0x7e18b010, 0xdc5513b6, 0x0c02480c, 
+    0x2412675b, 0x1b40f401, 0x774a1807, 0x05b02521, 0x0113b110, 0x27806618, 0x0810675b, 0x23101130, 0x31101122, 0x0112bd89, 0xfe170104, 0x0ef8fee9, 
+    0x5c0289bd, 0x038d8e8e, 0x0168fea4, 0xfe17feae, 0xfeaf0118, 0x79015868, 0x89fe7701, 0x4b5b87fe, 0xa4033507, 0x16000d00, 0x17b09100, 0x2f18b02f, 
+    0xb01017b0, 0x03b0d003, 0x10300b82, 0xb1dc08b0, 0xb0f40809, 0x0db01003, 0x2f0db0d0, 0xb1220882, 0xcd820c0e, 0x0e062808, 0x0e260e16, 0x0e460e36, 
+    0x0e660e56, 0x0e860e76, 0x0ea60e96, 0x0ec60eb6, 0xd5b45d0d, 0x020ee50e, 0x1009b05d, 0x42d012b0, 0xd27b0567, 0x1073180c, 0x07f6550c, 0x0611b323, 
+    0x054b5b00, 0xb0d00a2d, 0x13b11006, 0x3130f406, 0x5b262601, 0x3c081448, 0xc7b2a65a, 0x8af001ba, 0xc2acfedf, 0x01758597, 0x759cfe64, 0x08750185, 
+    0x87928985, 0x75015cfc, 0x8b028bfe, 0x4601544e, 0xffffff56, 0x03e9fffc, 0x021905ae, 0x00ef0126, 0x00060000, 0x0805828c, 0x8fff0124, 0x730375fe, 
+    0x27001905, 0x28b0af00, 0x2f29b02f, 0xb01028b0, 0x01b0d001, 0x0c04b12f, 0xd007b0f4, 0xf28229b0, 0x08b2dc29, 0x12110d01, 0x8415b239, 0x1ab12806, 
+    0x04b0f408, 0x8223b010, 0x744d1827, 0xc0791809, 0x0c6b7f0c, 0x1b2f2431, 0x3e0f24b1, 0x0618b359, 0xb32b0412, 0x82060605, 0x100528e1, 0xb2d000b0, 
+    0x6c022408, 0x1e2106c1, 0x4ec71806, 0x06b02d25, 0xd026b010, 0x33033130, 0x33153335, 0x231f7a7c, 0xbb89a271, 0x38167b7c, 0xbb5e04a2, 0xd1fe75bb, 
+    0x85fe0001, 0x56371bfd, 0x6d181e3a, 0x02710908, 0x078a75e5, 0x53e90321, 0xa42c079b, 0x26025405, 0x0000ed01, 0x8b000600, 0xfb4d0582, 0x08414409, 
+    0x149b4418, 0x061eb323, 0x20ea8200, 0x2a855a0a, 0xb1101426, 0xb4f4061b, 0x23490019, 0x13313023, 0x78511816, 0x9f51180d, 0x2107260b, 0xb80f8b15, 
+    0x153e449a, 0x15b6942b, 0xa2010602, 0x4450b68e, 0x059d4d42, 0x080d4618, 0x7585aa22, 0x0cdddd18, 0x33b0d925, 0x1834b02f, 0x083adddd, 0x29061721, 
+    0x29262916, 0x29462936, 0x29662956, 0x29862976, 0x29a62996, 0xb6b45d0b, 0x0229c629, 0x18d5b45d, 0x201fe0dd, 0x96c918b1, 0xd7dd1828, 0x00022fb2, 
+    0x020000ba, 0x001905e9, 0x000d0003, 0xe818b35f, 0x357c8249, 0x19052107, 0x08798018, 0x82008c21, 0x040023a4, 0xa98675fe, 0x3e001625, 0x180800b3, 
+    0x7c795fe8, 0xb0320533, 0x1b00a403, 0x95002400, 0x0f0c01b3, 0x21b32b04, 0x05821a0c, 0x1c0c1632, 0x21b02b04, 0xd011b010, 0xea1cdab4, 0x405d021c, 
+    0x1c47c518, 0x7c16b021, 0x10240933, 0x10b11b2f, 0x68104550, 0x51490886, 0x82192007, 0x82192026, 0x13b3230c, 0x6b821f06, 0xb1101036, 0xb0f40600, 
+    0x21b11019, 0x0ab2f406, 0x12112119, 0x13313039, 0x200efa7b, 0x08346521, 0x6b491120, 0x7bba2008, 0xcd2e0cfe, 0xa2a29977, 0x01fefe97, 0x79545cb2, 
+    0xc6565479, 0x05007c08, 0x4ad50221, 0x7f490f5a, 0x03b02c05, 0x001200a4, 0xb39f001b, 0x82000c12, 0x065d69ff, 0x82130c21, 0x10123499, 0xb0d002b0, 
+    0x0fb01004, 0x13dab4d0, 0x5d0213ea, 0x19091b40, 0x261b770c, 0x17b01007, 0x7c0bb0d0, 0x265b090f, 0x0ced470c, 0x620c0557, 0x0422080b, 0x77821006, 
+    0x07307182, 0x1010b0d0, 0xb0d016b0, 0x18b1100e, 0x3130f406, 0x4106047c, 0x23200905, 0x23090741, 0x89bb8931, 0xbb22fc86, 0xfd866d02, 0x8bfea424, 
+    0xf3857501, 0xfeba0125, 0x4a190146, 0x01230575, 0x62008fff, 0x841805f9, 0x1c20098d, 0x200eb546, 0x0ab5461d, 0x460eb121, 0xd78205ae, 0xb0100123, 
+    0xcc0e1919, 0x0736600b, 0x480cae46, 0x18240cc5, 0x18b11b2f, 0x4605e469, 0x0d200ab5, 0x6507b546, 0xb024277b, 0x1ab01006, 0x7c10b546, 0xaa460c1f, 
+    0x07207c08, 0x7c0ca046, 0x97460a22, 0x05a22709, 0x01260254, 0x974600f4, 0xffff2106, 0x2105a152, 0x15820605, 0x495afd20, 0xc1fe250b, 0xa4037303, 
+    0x58231f7c, 0xb120294b, 0x25221f7c, 0xd1fca403, 0x635f2f03, 0xd3053307, 0x41000700, 0xb02f08b0, 0x01b02f09, 0x0d00b1dc, 0x6418b0f4, 0xa6790e67, 
+    0x087a5f12, 0xb1100626, 0x30f40602, 0x3305a06a, 0x03211123, 0x16fd752f, 0x05fe0289, 0xfbd1fed3, 0x0019055c, 0x04216787, 0x4f67ab5e, 0x0f220c65, 
+    0x5557593e, 0x33012408, 0x8a112111, 0x5e042367, 0xce82d1fe, 0x08934418, 0x8e06a22c, 0x23002602, 0x07000000, 0x7c82da00, 0xffff7528, 0xe9ff3100, 
+    0x1784a403, 0x178d4320, 0x03000023, 0x201784cf, 0x21178b25, 0x2f82feff, 0x17847320, 0x2f904520, 0x27201785, 0xba20178c, 0x5f854782, 0x178c4720, 
+    0x17823120, 0x2e202f85, 0x0c82178c, 0x05a40323, 0x20a78219, 0x200a824e, 0x7ea78306, 0xbd85065f, 0xbd8b3782, 0x088f7818, 0x2d8a5120, 0xa3821920, 
+    0xa3848320, 0xbb8c3420, 0x1782f620, 0x5b848b20, 0x2d8a5420, 0x2d847184, 0x898d3520, 0xae202d82, 0x55201784, 0xc120458c, 0xe322b982, 0xa182cd06, 
+    0x17843820, 0x00004127, 0xffff7901, 0xcd7318ff, 0x0041220f, 0x85158204, 0x88c9202d, 0x418b202d, 0x2d860577, 0x17825420, 0x0d435820, 0x202d850a, 
+    0x182d888e, 0x85073561, 0x8819205b, 0x8217822d, 0x82ec205b, 0x84b82089, 0x8c3a2089, 0x29741889, 0x1889820f, 0x2024f5a0, 0x38458204, 0x05460400, 
+    0x00090019, 0x00190011, 0xb312011d, 0x04040c03, 0x0c00b32b, 0x22058207, 0x82140c10, 0x18290805, 0x2b040c08, 0xea0cdab4, 0x405d020c, 0x190c091b, 
+    0x390c290c, 0x590c490c, 0x790c690c, 0x990c890c, 0xb90ca90c, 0x0d0cc90c, 0x2510695d, 0xb010142d, 0x1ab0d01a, 0x1018b02f, 0x83d01bb0, 0x4d1f2005, 
+    0x052406b7, 0x05b11b2f, 0x6707f144, 0x4d180cd5, 0xd6450ca6, 0x0cf87b0c, 0x40821c20, 0x3e0f1c34, 0x010ab359, 0xb22b0412, 0x11050002, 0x07b23912, 
+    0x06820a12, 0x1016b025, 0x18010eb1, 0x25262b41, 0x1ab11000, 0x9e82f406, 0x21313038, 0x23110323, 0x11133311, 0x35320133, 0x15222334, 0x11201714, 
+    0x03822110, 0x15210534, 0xaafe0121, 0xb4c189cb, 0x744a0189, 0xff777974, 0x01820100, 0x02fe2108, 0x02fefe01, 0x02fcfe03, 0x54fc1905, 0xb2fcac03, 
+    0xc0bfbfc0, 0x012f016f, 0xfed1fe2f, 0x0075e7d1, 0x2d249d41, 0x00d3ff01, 0x02d10302, 0x00050050, 0xa4180020, 0xbd5e0798, 0x37fc870c, 0x07253130, 
+    0x01270101, 0xfe50d103, 0x4e4efe52, 0x4e500002, 0x50feb001, 0x22080882, 0x00060000, 0x04460044, 0x00190419, 0x003a002f, 0x00490045, 0x015f0054, 
+    0x0a59b322, 0xb32b0418, 0x82460a3f, 0x0a492205, 0x3b058213, 0x04300a27, 0x1027b02b, 0xb0d000b0, 0x06b01046, 0x2f06b0d0, 0xb01049b0, 0x18b0d008, 
+    0x8207a369, 0x841e200e, 0x202f081d, 0x103fb0d0, 0xb0d02bb0, 0xdab42f2b, 0x0230ea30, 0x091b405d, 0x29301930, 0x49303930, 0x69305930, 0x89307930, 
+    0xa9309930, 0xc930b930, 0x835d0d30, 0x363e082d, 0x2f36b0d0, 0xb01030b0, 0x13b0d03b, 0xd04ab010, 0x59061b40, 0x59265916, 0x59465936, 0x59665956, 
+    0x59865976, 0x59a65996, 0x59c659b6, 0xd5b45d0d, 0x0259e559, 0x1059b05d, 0xb0d050b0, 0x33832f50, 0x83d05521, 0xdc6126a0, 0x0243b300, 0x22b38203, 
+    0x82330224, 0x02462205, 0x22058207, 0x82140254, 0x100323bf, 0xa1840cb0, 0xb0d01232, 0x1bb01024, 0x1054b0d0, 0xb0d01fb0, 0x2ab01014, 0x2c201784, 
+    0x37261184, 0x1007b0d0, 0x17843eb0, 0xb0d04726, 0x4db01033, 0x60821184, 0xb0104323, 0x9e9e185c, 0x35262507, 0x14152335, 0x22079a57, 0x57233533, 
+    0x162506a3, 0x35331515, 0x07a55734, 0x3315232a, 0x34031632, 0x06222326, 0x32221782, 0x0a821136, 0x16243682, 0x25363233, 0x19863f82, 0x33161424, 
+    0xef571133, 0x35363007, 0x4e6f1904, 0x6ee86a4e, 0x6e6e4e4e, 0x8360624e, 0x4e200805, 0x4e6ce66c, 0x4e6f6f4e, 0x6f4e6060, 0x2929395b, 0x39296037, 
+    0x355e2939, 0xfe392929, 0x375ae6e4, 0x39230782, 0x83626029, 0x39292314, 0x33830201, 0x3f822a82, 0x5782398c, 0x02214882, 0x2326830c, 0xcffd3760, 
+    0xe3244685, 0xa001e6e6, 0x37223984, 0x498566fe, 0x03000022, 0x27066542, 0x000300c7, 0x000d0007, 0x1806c068, 0x530c7c44, 0x0321089e, 0x06fa4f01, 
+    0xb0d0042e, 0x06b01003, 0x013130d0, 0x05213521, 0x01200382, 0x26058042, 0x01d5fea2, 0x838bfd2b, 0xa4022105, 0x26078c42, 0x71715602, 0x4289fd71, 
+    0x02310892, 0x25000000, 0xc7025c04, 0x15001100, 0xb3001b00, 0x23578311, 0x060109b3, 0x26053464, 0x09b0d012, 0x8214b010, 0x2325325d, 0x26032722, 
+    0x33352323, 0x16161732, 0x33331617, 0x086b8211, 0xa25c0423, 0x66aa7bd7, 0xd9a4a4b4, 0x2b56297b, 0xfea2b464, 0x25700190, 0x910f0191, 0x88439471, 
+    0xc5019443, 0x2bd98271, 0x00004a00, 0x19055604, 0x09000400, 0x31266782, 0x020908b3, 0xe7502b04, 0x0ce57d05, 0x2c085343, 0x06b11003, 0x01b0f401, 
+    0x0108b110, 0x08db82f4, 0x11210128, 0x23010121, 0x07013311, 0x37270727, 0x37173727, 0x56040717, 0x81fe73fd, 0xef017f01, 0xe4e4e4fd, 0x7d500201, 
+    0x02844e7d, 0x027d5035, 0x0575fd8b, 0x0272fd19, 0x01c5fb1f, 0x7e7e4d9f, 0x827d7d4d, 0x7d50221e, 0x057d5700, 0x015c043c, 0x000b002f, 0x2f0cb046, 
+    0xb02f0db0, 0x0cb0dc01, 0xd004b010, 0xb12f04b0, 0x77840908, 0xf4090922, 0x0eaabf18, 0x73410b20, 0x100b260a, 0xb0d006b0, 0x269e8602, 0x21152125, 
+    0x83352335, 0x21240805, 0x00ff5c04, 0x01fea2fd, 0x0181016d, 0xc1c1c16e, 0x00c0c06e, 0xbc000200, 0x6204feff, 0x1f00a203, 0x9a002800, 0x2e06035e, 
+    0x15b1dc00, 0xdab4f40a, 0x0215ea15, 0x191b405d, 0x321cdb1f, 0x24b01029, 0x2f24b0d0, 0xf40923b1, 0x002428b2, 0x85391211, 0x2f25249e, 0x5725b11b, 
+    0x0f250c63, 0x10b1593e, 0x25e47d02, 0x0522b223, 0x264a8225, 0xb11025b0, 0x18f40127, 0x210b5140, 0x4018031e, 0x7b080750, 0x031e3727, 0x15010705, 
+    0x15211123, 0x49620423, 0x5063ac7f, 0x1656758f, 0x63431349, 0x90524579, 0x4c283d6a, 0x4a163f69, 0xfe335c7b, 0x8ffe508a, 0xdd9c016f, 0xac62d301, 
+    0x58314a7d, 0x3b144c7d, 0x3d2b4c68, 0x3f548f69, 0x13476579, 0x75561449, 0x014e6091, 0xa001e370, 0x0100006f, 0xd9ffe3ff, 0x7d035404, 0x1e001500, 
+    0x120900b3, 0xb0002b04, 0x15b32f08, 0x2b040001, 0x05010db3, 0x2105df52, 0x9986d012, 0x17213a08, 0x17010107, 0x3e322107, 0x35213502, 0x54540421, 
+    0xfe75ca96, 0xfe4ebf8b, 0x4e4401bc, 0x5c7501bf, 0xfe4579a0, 0x0325024a, 0x98c9700e, 0x014cc058, 0x4e450142, 0xa07846be, 0x2b6d835c, 0x00004800, 
+    0x2f015c03, 0x40000700, 0xb0276682, 0x00b02f09, 0x4c08b0dc, 0x09260810, 0x1000b0f4, 0xf94105b1, 0x08de4607, 0x83dc0221, 0x01042a17, 0x1002b0f4, 
+    0xb0d006b0, 0x088f8207, 0x11212125, 0x35211533, 0xfc5c0333, 0x36026eec, 0xc02f0170, 0x000100c0, 0x04480200, 0x00d1025e, 0x00090003, 0x820701b3, 
+    0x313025c6, 0x15213511, 0x48221482, 0xf1828989, 0xfe8d0127, 0x0617028b, 0x2321828b, 0x0801b319, 0x53182082, 0x02270811, 0x02b11b2f, 0x82593e11, 
+    0x11332aec, 0x8a8d0123, 0xf88b068a, 0x84338600, 0x00052455, 0x1803b31c, 0x20090f56, 0x20308204, 0x82308204, 0x04022268, 0x2236822b, 0x83211521, 
+    0xd1022938, 0x028ab9fd, 0x43fc89d1, 0x6f839183, 0x3b859182, 0x77430420, 0x873b850c, 0x231130a4, 0x8a170211, 0xfb894802, 0x00bd03ba, 0x838d0101, 
+    0x22a982cb, 0x89120005, 0x03b322a9, 0x84438207, 0x826d82a2, 0x470228a4, 0x8b062ffd, 0x858946fc, 0x83db84fd, 0x08052231, 0x216b8302, 0x06412f03, 
+    0x3311220a, 0x24318311, 0xba038948, 0x236184fb, 0x5e048bfe, 0x07226182, 0x61852500, 0x1001b025, 0x41d005b0, 0x06200811, 0x0620e082, 0x748ca483, 
+    0x8a20e283, 0xb9217682, 0x8977848a, 0x224986e5, 0x78010800, 0x49830527, 0x274c0620, 0x82002005, 0x83002049, 0x07052149, 0x26052a41, 0x35211123, 
+    0x82331121, 0x73fe21f0, 0xfe239382, 0x82bd038b, 0x052f4195, 0x025e042b, 0x000700d1, 0x0805b322, 0x072f4106, 0x40820520, 0x2f410520, 0x00b02508, 
+    0xd003b010, 0x3105da41, 0x11231121, 0xb9fd5e04, 0x8948028a, 0x0343fc89, 0x094100bd, 0x20d98605, 0x41458218, 0xe3850c09, 0x11243b84, 0x15211133, 
+    0x02217d82, 0x243b8247, 0x46fcba03, 0x413b8489, 0x0b220615, 0x3b853700, 0x1005b02e, 0xb0d008b0, 0x0ab01002, 0x03b000d0, 0x0920d185, 0x09209082, 
+    0x01249089, 0xd005b010, 0x07209683, 0x5a849685, 0x5e849a83, 0x61849d85, 0x0220a185, 0x8d266882, 0x8b035e04, 0xe9820300, 0xb3000f33, 0x04050504, 
+    0x0700b32b, 0x302b0401, 0x21150131, 0x23038335, 0xa2fb5e04, 0x03310383, 0xfe89898b, 0x008a8a8c, 0xd3000200, 0xd1028bfe, 0x43378506, 0x42430745, 
+    0x0c002408, 0x8209b0f4, 0xb1dc2a89, 0x00f40c04, 0xb02f02b0, 0x0d7f4104, 0x4500b024, 0xd641b058, 0x2a688207, 0x023b1123, 0x5c012311, 0x82ec8989, 
+    0x088b2362, 0xef42f800, 0x259b8208, 0xb33e000b, 0x2b780803, 0x05924605, 0x0e00b128, 0xd008b0f4, 0xc0780bb0, 0x2f032b09, 0x1103b11b, 0x08b3593e, 
+    0xc2830907, 0xc2820520, 0x8200b021, 0x84d02084, 0x23113dc8, 0x21112111, 0x04152315, 0x8ab9fd5e, 0x5c017501, 0x8a1702d3, 0x8c03fefc, 0xeb897401, 
+    0xd1836d82, 0x025e0427, 0x000b00d1, 0x060f4649, 0xbf840320, 0x100cb022, 0x08276a83, 0x0c07b12f, 0x1804b0f4, 0x87091747, 0x20cc8471, 0x207e8207, 
+    0x217e8307, 0x78820700, 0x070ab323, 0x06414105, 0x23207882, 0x04237c84, 0x8273fe5e, 0x75012ede, 0xfc89d102, 0xfd480243, 0x01d102b8, 0x064b4175, 
+    0x825e0421, 0x460520e7, 0x74820a8b, 0xb0d00226, 0x01b12f02, 0x0d277482, 0xdc09b010, 0x460c0ab1, 0x0120068b, 0x01206b82, 0x42074561, 0x03220800, 
+    0xf7820007, 0x07050622, 0x72837884, 0x21021d22, 0x01240682, 0x8b03895c, 0x03277a82, 0x0589fb02, 0x84eb8900, 0x05e142f4, 0x82170221, 0x000b2575, 
+    0x0e07b33b, 0x0922b483, 0x2d5b0a08, 0x82022005, 0x10012373, 0xf95004b0, 0x22628806, 0x82030706, 0x05012162, 0xb0206882, 0x63421f82, 0x35332205, 
+    0x06636e23, 0x01d3d330, 0x018abb5c, 0x89eb8a8d, 0x74fc8cfe, 0x65860203, 0x5541d120, 0x0c4e410c, 0xb0d00022, 0x6841dc82, 0x0a094805, 0x5541dc87, 
+    0x8209200a, 0x41022079, 0x11200655, 0x2320d783, 0x233edb82, 0x015c0135, 0x89ec8975, 0xfed102d3, 0x022ffd8b, 0x03b8fd48, 0x020089bd, 0x8bfe0000, 
+    0x5341d102, 0xb3422406, 0x820b0e06, 0x0c03213e, 0x0b29b883, 0xd001b010, 0xb11006b0, 0x074f4108, 0x0caa6c18, 0x4f417288, 0x04092207, 0x0556492b, 
+    0x03231122, 0xba417284, 0x25748305, 0xfb890203, 0xea840300, 0x01008a2e, 0x8d018d01, 0x8b065e04, 0x34000b00, 0x2105b143, 0x718409b3, 0xb110002a, 
+    0xb0f40e0b, 0x09b0d006, 0x2405af42, 0x09b32f03, 0x2b8b8205, 0x020705b3, 0x02b02b04, 0xd007b010, 0xd6826382, 0x21113330, 0x33152315, 0xfe020315, 
+    0x47028a8b, 0x5482d3d3, 0x8903752b, 0xe98900fd, 0x0001008c, 0x068b45d3, 0x35000b22, 0x2606a342, 0x00b1dc09, 0x42b0f40c, 0x0520082e, 0x00210c82, 
+    0x256b8210, 0x2f03b000, 0x688707b0, 0x01050622, 0x6284c684, 0x83113321, 0x48022366, 0xc4828bfe, 0x028d0132, 0x02740148, 0x02bbfdcf, 0x8b48fc45, 
+    0x00020000, 0xc7847482, 0xc9820520, 0x67863220, 0x00266082, 0x2f00b0d0, 0x8f4203b1, 0x0c062508, 0x01b000f4, 0x03206484, 0x0922cd84, 0x64830607, 
+    0x5e841320, 0x05840120, 0x0389d326, 0x89eafd02, 0x8d26c582, 0x8cfbfe04, 0xcc85018a, 0xcb820020, 0x79820020, 0x8b061722, 0x2e246382, 0x020808b3, 
+    0x22070f7c, 0x841008b0, 0x06e644d1, 0xb02f0926, 0x03b32f05, 0x200b2741, 0x06704213, 0x23112136, 0x01191935, 0x8bfe8a8d, 0xe91902a2, 0xfc000389, 
+    0x8c8bfe77, 0x02235b84, 0x84d10248, 0x0727415b, 0x20082041, 0x22bf820b, 0x43b0d004, 0xc2840552, 0x20052741, 0x063e4301, 0xc2830920, 0x54351121, 
+    0x2136077b, 0xec89d311, 0x028bfe89, 0xba038948, 0x4502bbfd, 0x8cfe31fd, 0x64820200, 0x61848d20, 0xbf840520, 0x000e0522, 0x0921bf82, 0x05f1530c, 
+    0x4102b121, 0xa6450584, 0x2f072406, 0x820506b3, 0x09014756, 0x17255c83, 0x21113311, 0x235c8335, 0x02032ffd, 0xeb2abc84, 0x02fb7404, 0x0200008a, 
+    0xfb458d01, 0x235d8306, 0x0803b331, 0xb0275d82, 0x08b01003, 0x4400b0d0, 0x0120057f, 0x220efd45, 0x82070506, 0x48032080, 0x01200569, 0xfc435a83, 
+    0x478d2006, 0x03240522, 0xfd890302, 0x4508fc43, 0x042505bf, 0x008b065e, 0x20bf8203, 0x09e3414c, 0xb0d00126, 0x00b12f01, 0x2005e341, 0x05ff4405, 
+    0xb0100524, 0xc545d009, 0x2f0a2d18, 0x110ab11b, 0x07b3593e, 0x2b040807, 0x4807cb45, 0x5c240582, 0x89ec8989, 0x732bcc82, 0x088bfe89, 0x8946fc00, 
+    0x820043fc, 0x86d32071, 0x000330dd, 0x000f0009, 0x2f10b058, 0xb02f11b0, 0x89b01010, 0x1011237d, 0x7d8507b0, 0xb0100729, 0x04b0d00c, 0x850eb010, 
+    0x46052083, 0x0d201249, 0x0d208382, 0x0a248383, 0x2b040b05, 0x04208982, 0x33218986, 0x0a0a4113, 0x77208d8e, 0x200e1141, 0x06914900, 0x22057341, 
+    0x5c020805, 0x06260573, 0x1002b0d0, 0x714708b0, 0x08204409, 0x200ed441, 0x2b6a8221, 0x11231115, 0x8d013521, 0x73fe8a8a, 0x2407d441, 0x020374fc, 
+    0x0791448a, 0x008b0623, 0x17714107, 0x4205bb47, 0x08280598, 0xb000f40c, 0x08b02f06, 0x7141ed92, 0x09c44808, 0x33352322, 0x21074147, 0x4347d3d3, 
+    0xbd032a05, 0xf8ba0389, 0x03000000, 0x20d98300, 0x207982d1, 0x23798205, 0xb354000f, 0x2205ad42, 0x840c0c0d, 0x02b126e1, 0x05b0f40c, 0x05c94c10, 
+    0x230a6242, 0x0cb02f03, 0x68187d85, 0x0e270c26, 0x0eb11b2f, 0x42593e11, 0xfe8313d3, 0x0135232d, 0xd3231133, 0x02d38989, 0x41898948, 0x04210c04, 
+    0x208f8374, 0x228f8302, 0x41035e04, 0x28200509, 0x47145d49, 0x012105c3, 0x06de4e05, 0x480b6349, 0xfd330590, 0xd1028ab9, 0x8d01a2fb, 0xfefc8a8a, 
+    0xfe010203, 0x41008989, 0x04240563, 0x00d1025e, 0xd542e983, 0x2e49470a, 0x03070022, 0x2305714c, 0x03b0d006, 0x25079b45, 0x35231123, 0x50471521, 
+    0x04d32506, 0x8973fe5e, 0xba288182, 0x8989bd03, 0x460443fc, 0x84066741, 0x000530d7, 0x000f0009, 0x0e00b34e, 0xb32b0405, 0x840e0c0d, 0x0767414d, 
+    0x55470820, 0x0cc54706, 0x2208c142, 0x82070706, 0x05002133, 0x0a208186, 0x0b268184, 0x013130d0, 0x81822311, 0x47069249, 0x858205d6, 0x85a2fb21, 
+    0xfc172b89, 0x8a020374, 0x89897401, 0xe0478cfe, 0x05a34405, 0x574b0420, 0x000b2205, 0x0591461e, 0x03b00025, 0x4408b32f, 0x854a098d, 0x021d330e, 
+    0x8d013521, 0xfb47028a, 0x890203a2, 0x00fd0003, 0xef49eb89, 0x4c002005, 0x0b220805, 0x2f443800, 0x05594109, 0x13460520, 0x0a50450d, 0x1000b025, 
+    0x83d006b0, 0x82092065, 0x0a5645c3, 0x89d31536, 0x8d0189ec, 0x03894802, 0x04bdfbba, 0x8946fc43, 0x00000300, 0x26064147, 0x000b0005, 0x423a000f, 
+    0x574506a9, 0xd00e210f, 0xb028c683, 0x0cb32f07, 0x2b040d05, 0x98055745, 0x85d38369, 0x20d4866c, 0x07f943fc, 0x41069543, 0x0f220623, 0x674b3d00, 
+    0xd00a2609, 0xb01002b0, 0x09f5430c, 0x1b2f0b27, 0x3e110bb1, 0x113c4159, 0x1009b024, 0xdc840db0, 0x6c442120, 0x06464109, 0x44b9fd21, 0xfd200708, 
+    0x21067c45, 0xa7428a02, 0x8b062308, 0xe5820700, 0xff445b20, 0x44032006, 0x032805ef, 0xd006b010, 0xb01010b0, 0x0a278282, 0x0c09b12f, 0x440ab0f4, 
+    0x052005fc, 0x4a080e44, 0x9d490c79, 0x07002108, 0x6b06f04c, 0x938305d0, 0x21150124, 0x95822311, 0x08053c42, 0x04113320, 0x8973fe5e, 0x898bfe89, 
+    0xd102d3d3, 0x0843fc89, 0x0346fc00, 0x0300f8ba, 0xba0389bd, 0x99430400, 0x06294405, 0x17001124, 0x81417800, 0x440f2006, 0xb02a1c2b, 0x14b0100f, 
+    0x100cb0d0, 0x304116b0, 0x440d2005, 0x15241237, 0x15b11b2f, 0x2f0e3744, 0xb01000b0, 0x01b0d00c, 0xd00fb010, 0xb01006b0, 0x20056852, 0x08294213, 
+    0x20054f44, 0x09564125, 0x8989d32a, 0x894602d3, 0x71fe8f01, 0x200d5a44, 0x0bcc45eb, 0xeeff012c, 0xb603eeff, 0x0300b803, 0x554a1d00, 0x0f71740a, 
+    0x0931302d, 0xfeb60303, 0x011bfe1d, 0x84d301e5, 0x00e53605, 0x08000100, 0x5604cfff, 0x0500ec02, 0xb0000900, 0x01b02f05, 0x0829822f, 0x01370229, 
+    0xfc560401, 0x5eb6fefc, 0xa4020201, 0x35fd9a02, 0xfe3bfe01, 0x00730271, 0x00f2ff02, 0x03b40300, 0x000800aa, 0x4153000f, 0xb02208cf, 0x4d521010, 
+    0x090d2706, 0x1003b0f4, 0x53500eb1, 0x0c936907, 0x1b2f032a, 0x3e0f03b1, 0x0209b359, 0x27060d4a, 0x09b0d005, 0xd00bb010, 0x0d2f3383, 0x3130f401, 
+    0x11231501, 0x35231121, 0x82330309, 0x03240807, 0x10feebb4, 0x01e101e7, 0xfea0fe60, 0x1001d99e, 0xfe6bc701, 0x6b5c01a4, 0x00fee301, 0x9efe6201, 
+    0x3b01c5fe, 0x0c20958c, 0x20070741, 0x206b8207, 0x79e51807, 0x855f820f, 0x0101225e, 0x265e8b05, 0xfea4fee1, 0x875c01f4, 0x1f1d3b5a, 0xf4fe0c01, 
+    0x00000300, 0x1404d9ff, 0x0c008103, 0x14001000, 0x00b33000, 0xe34f0809, 0x010c2a06, 0xb32b0409, 0x04000108, 0x0516432b, 0x100cb034, 0xb0d00fb0, 
+    0x11b01000, 0x1008b0d0, 0x30d013b0, 0xbf512531, 0x08d08207, 0x21052123, 0x23032135, 0x14043335, 0x4fbe17fe, 0x4401bcfe, 0x7901be4f, 0xfd2b01bb, 
+    0x018dfe5f, 0xbabab973, 0x07bf51e5, 0x6dc00131, 0x64fd6d6d, 0x0004006f, 0x04000048, 0x82140514, 0x00072a09, 0x0019000d, 0x090db367, 0x22798201, 
+    0x82110910, 0x0a072205, 0x8405820a, 0x11b02895, 0xd015b010, 0x181010b0, 0x640879fa, 0x002b0c75, 0x00b11b2f, 0xb3593e0f, 0x820e0119, 0x02052132, 
+    0xac82be82, 0x0108b128, 0x1002b0f4, 0x06820bb1, 0xb0100e29, 0x19b0d012, 0x5114b010, 0x212705ee, 0x15272301, 0x82211101, 0x23012401, 0x82352315, 
+    0x333522bb, 0x08bf8215, 0x0234fc3d, 0x9d950137, 0xfe2501f8, 0x0291fe81, 0xb36cb200, 0x05b26cb3, 0xfa6dfe14, 0x02eefcfa, 0xfb7f01b8, 0xb12b01c9, 
+    0xb2b26eb1, 0x4a000200, 0x5e04d3ff, 0x0800d103, 0x22000c00, 0x820909b3, 0xb00022b1, 0xefbc1803, 0x080b6708, 0xd4180820, 0x07240819, 0x01170101, 
+    0x11297d82, 0xfd5e0433, 0x4e7901d1, 0x084682fe, 0x87fe4e35, 0x5afc2f02, 0x9a016e6e, 0x024e87fe, 0x4efe0100, 0xf8fd85fe, 0x0000a203, 0xff0a0001, 
+    0x037b04d9, 0x0015007d, 0x0903b318, 0x002b0415, 0xb32f0db0, 0x82020101, 0x094808ea, 0x2b040f01, 0x21133130, 0x1e142115, 0x27213302, 0x27010137, 
+    0x2e222137, 0x020a3502, 0x454afe25, 0x015ca079, 0x014ebf75, 0x4ebcfe44, 0x758bfebf, 0x035496ca, 0xa05c6f7d, 0x4ebe4678, 0xbefebbfe, 0x9858c04c, 
+    0x030070c9, 0xd924c982, 0x81035c04, 0x07280982, 0x30001400, 0x0c0911b3, 0x09236983, 0x8303b32f, 0x07b323bb, 0xdf5f0401, 0xd00b3205, 0xb01003b0, 
+    0x00b0d00d, 0xd00fb010, 0xb01007b0, 0x06b05611, 0x35231124, 0x7e830533, 0x15211124, 0x8b821123, 0xfe5c043d, 0xb8700190, 0xfeacfeb8, 0xfebe4ebb, 
+    0xbd2b0117, 0x4ebe7b01, 0xfd6d1403, 0x83396f64, 0x9c02307c, 0xbe40fe6d, 0x0002004e, 0x04d3ff00, 0x82d10314, 0x000c267f, 0x0900b322, 0x207d8301, 
+    0x0849410c, 0x2208e241, 0x8307010a, 0x232123f1, 0xea823311, 0x21012408, 0x37012135, 0x6e6e1404, 0x02fef0fe, 0xfd7b0150, 0xfe3102cf, 0xa2035085, 
+    0x00fe31fe, 0x6e79014e, 0x824e7b01, 0x00023753, 0x05680404, 0x00240044, 0x00540048, 0x2f55b0c1, 0xb02f56b0, 0x57711055, 0x10562906, 0xb1dc21b0, 
+    0xb4f40a27, 0x236c7b18, 0x21b03408, 0xd02db010, 0xb02f2db0, 0x39b11010, 0x1b40f40a, 0x39163906, 0x39363926, 0x39563946, 0x39763966, 0x39963986, 
+    0x39b639a6, 0x5d0d39c6, 0xe539d5b4, 0x835d0239, 0xd0472734, 0x002f47b0, 0x574552b0, 0x2f2f2405, 0x432fb11b, 0x352007c4, 0x35200c82, 0xb3250c82, 
+    0x040c0245, 0x08c0562b, 0x35b02108, 0x021db110, 0xd014b0f4, 0xb02f14b0, 0x3db01045, 0x2f3db0d0, 0x06013130, 0x22230607, 0x22232627, 0x352a0785, 
+    0x33363734, 0x16161732, 0x08843233, 0x14150626, 0x26071617, 0x36221683, 0x26833737, 0x2c850720, 0x23861783, 0x03222b84, 0x4a820714, 0x07069608, 
+    0x16162512, 0x4e246804, 0x472d5e63, 0x48292d4a, 0x777b224a, 0x9a5a4e79, 0x372b5639, 0x5656220d, 0x926d9332, 0x9a263331, 0x070a0431, 0x115c2024, 
+    0x6888915e, 0x333e730e, 0x14465c6b, 0x3f3c5c31, 0x331a385a, 0x378e0f4e, 0x2b0c4c35, 0x0601021d, 0x6f010202, 0x1b876d75, 0xd11d1a1a, 0x73a5c5d3, 
+    0x0a0d1889, 0x7b851c19, 0x56505a8b, 0x67cb7641, 0x0a0e045a, 0x21142927, 0x5b6c121d, 0xa2b6b37c, 0x151f2313, 0x31041975, 0x19585256, 0x01040404, 
+    0x0e093c0a, 0x054d7100, 0x2f05bc22, 0x01c1dd10, 0x00012d42, 0x00700200, 0x00070061, 0x00040058, 0x00290d82, 0x000a0000, 0x02000200, 0x830482a6, 
+    0x0038210f, 0x4a090185, 0x027701c4, 0x0356037f, 0x03b3036e, 0x044504f9, 0x04910479, 0x04b804a3, 0x058705cd, 0x062f06c2, 0x073007e5, 0x087e08c2, 
+    0x0ac209c6, 0x0aac0a82, 0x0bee0ad6, 0x0b230b0a, 0x0cbc0c9d, 0x0e6e0def, 0x0e770e17, 0x0fdf0eae, 0x10ce0f87, 0x10481002, 0x10aa1087, 0x114211fb, 
+    0x134a12ed, 0x14911320, 0x15a91456, 0x15371509, 0x16ee1581, 0x168e1647, 0x16cb16b8, 0x171917f6, 0x183e172b, 0x19b11803, 0x1a041a57, 0x1bef1a77, 
+    0x1c1b1cb3, 0x1cab1c65, 0x1d241dee, 0x1e2a1ec2, 0x20831fd5, 0x219b2033, 0x22c22154, 0x2258222a, 0x230b23a2, 0x238b2343, 0x24f823e4, 0x24862451, 
+    0x25062592, 0x25c925bd, 0x25e125d5, 0x26f825ed, 0x260e2603, 0x26242619, 0x26e9262f, 0x27ff26f4, 0x2715270a, 0x272b2720, 0x27412736, 0x2757274c, 
+    0x276d2762, 0x27832778, 0x2799278e, 0x27af27a4, 0x284928d2, 0x2a4d29cb, 0x2a362a0c, 0x2c7c2ba8, 0x2dfb2c35, 0x2d6d2d59, 0x2edd2d98, 0x2f0b2f2e, 
+    0x2fb62f80, 0x30f92fd7, 0x31cf305d, 0x31ad316a, 0x326632f0, 0x335933a4, 0x359734f1, 0x3657368e, 0x370537d2, 0x373f371c, 0x38f837bc, 0x3844381e, 
+    0x82a13869, 0xad8c0b01, 0xc538b938, 0x173a5739, 0x3a3a283a, 0xf83a9c3a, 0x5c3b2d3b, 0xb83b903b, 0xcf3bc33b, 0x813ce93b, 0xaf3c983c, 0xbe3d3a3d, 
+    0x183e073e, 0xb23e4f3e, 0xf13fe53f, 0x0940fd3f, 0x21401540, 0x39402d40, 0x51404540, 0x69405d40, 0xcc40c040, 0xe440d840, 0x2641f040, 0x67413e41, 
+    0x96417941, 0xfc41af41, 0x3e422142, 0x8a427142, 0xd442ad42, 0x8043ec42, 0xb243a043, 0x87440d44, 0x4d45b844, 0xb646dc45, 0x54472b47, 0xbc476047, 
+    0x73486848, 0x29491d49, 0x40493449, 0xb7494b49, 0x9c4a904a, 0xb34aa74a, 0xca4abe4a, 0xe14ad54a, 0xf84aec4a, 0xae4ba64b, 0x7f4c734c, 0x964c8a4c, 
+    0xad4ca14c, 0x1f4db84c, 0xd14dc54d, 0xe84ddc4d, 0xff4df34d, 0x164e0a4e, 0x2c4e214e, 0x124f064f, 0x924f1e4f, 0x1f501350, 0x36502a50, 0x4d504150, 
+    0xbe505850, 0x46513a51, 0x3d52a851, 0x8c524952, 0xa2529752, 0xed52e152, 0x0453f952, 0x1b530f53, 0x33532753, 0x81533f53, 0xf153e553, 0x0754fc53, 
+    0x1e541254, 0x35542954, 0x0e558c54, 0x25551a55, 0x3c553155, 0x53554855, 0x6a555f55, 0x80557555, 0x97558c55, 0xae55a355, 0xc555ba55, 0x26577f56, 
+    0x3d573257, 0x53574857, 0x6b575f57, 0x5b58d557, 0x72586758, 0x89587e58, 0xa0589558, 0xb758ac58, 0xce58c358, 0xd8595b59, 0xef59e459, 0x065afb59, 
+    0x1d5a125a, 0x345a295a, 0x4b5a405a, 0xc95abd5a, 0xe05ad45a, 0xf65aeb5a, 0x0c5b015b, 0x2a5b175b, 0x6d5b615b, 0x855b795b, 0x9d5b915b, 0xb55ba95b, 
+    0xf35bc05b, 0x975c725c, 0xf45cbd5c, 0x825d3b5d, 0x6b5e375e, 0xd75eaa5e, 0x6f5f285f, 0x7e60d35f, 0x1361b660, 0xa9615661, 0x8d620262, 0x5263fa62, 
+    0x6a635e63, 0x80637563, 0x96638b63, 0x4764a163, 0x56651865, 0xd4662f66, 0xca675367, 0xaa685d68, 0x3d69e968, 0xf969c669, 0x586bad6a, 0x916cf96b, 
+    0x846d346d, 0x9c6efc6d, 0x2e6fdb6e, 0xee6fe36f, 0x0470f96f, 0x1a700f70, 0xd0702670, 0x7b71dc70, 0x6f723b72, 0xc1727b72, 0xd2735673, 0x55744974, 
+    0xa2746174, 0x3675d574, 0xda75b575, 0x66762f76, 0x9977d076, 0xed77e177, 0x94782c78, 0x2c79e578, 0x0f7ad779, 0x157b6c7a, 0xbb7b687b, 0xb37c467c, 
+    0x447df37c, 0xee7d9b7d, 0xba7e4e7e, 0xb67f147f, 0xd1805c80, 0x6d829681, 0x25830083, 0xea837783, 0xf9845384, 0x4c854185, 0xf3858b85, 0x8b864486, 
+    0x6e873687, 0xc2881c88, 0x4d891589, 0x948a2b8a, 0x248bd48a, 0xd18b7b8b, 0x9e8c318c, 0x6a8df98c, 0x738e028e, 0x0f8f7e8e, 0x8a8f1a8f, 0x8a904090, 
+    0xdb909590, 0xd9915e91, 0x66925b92, 0xb2927192, 0x1a93e692, 0x32932693, 0x4a933e93, 0x62935693, 0x79936e93, 0x90938593, 0xa7939c93, 0xbf93b393, 
+    0xd693cb93, 0xed93e293, 0x0494f993, 0x1b941094, 0xea942d94, 0x2095fc94, 0x69962f96, 0xe3969c96, 0xa9971d97, 0x1198e097, 0x3c982298, 0x77985a98, 
+    0xa8989098, 0xf298cd98, 0x33991599, 0x82996699, 0xeb99b499, 0x639a289a, 0xd29a969a, 0x3d9b0c9b, 0xa39b709b, 0x029cd19b, 0x629c319c, 0xeb9ca09c, 
+    0x589d1b9d, 0xcd9da09d, 0x549e0c9e, 0xad9e7a9e, 0x219fe69e, 0xd19f6d9f, 0x09a0f09f, 0x80a054a0, 0x22a1c1a0, 0x87a154a1, 0xf6a1c7a1, 0x78a3d2a2, 
+    0x01000000, 0xc52c0384, 0x84a049fe, 0xf53c0f5f, 0x00081b00, 0xc6230083, 0x83d045f5, 0x31d52b07, 0x5bff7e09, 0x7b0475fe, 0x0f823e07, 0x02000923, 
+    0x23008400, 0x31005e04, 0x04840884, 0xffecff2b, 0x007501e7, 0x00e500bc, 0x28108223, 0x010000f0, 0xff290075, 0x220b82df, 0x821b000a, 0xff042805, 
+    0xff3100f8, 0x82e9fff8, 0x00f02217, 0x261182c7, 0xffa8008f, 0x82c5ffdf, 0x82ec2015, 0x86312049, 0xffba2207, 0x820d85fe, 0x85df200f, 0x19002103, 
+    0x31272d82, 0xc1ffc5ff, 0x82ffe9ff, 0x2241822b, 0x84ba0085, 0x84e52087, 0xff00252d, 0x00fcfffe, 0xba223985, 0x3f820400, 0x3184ba20, 0x07822b82, 
+    0xf6ff0022, 0xe1220d84, 0xa582e5ff, 0x2f00e126, 0x8d01ba00, 0xfc202d82, 0xc5205182, 0x65864f83, 0x02892482, 0x85fcff21, 0x22678201, 0x82aa00ba, 
+    0x82312005, 0x85ec203b, 0x829f8703, 0x00002215, 0x200d8208, 0x20098214, 0x2007821f, 0x20938400, 0x200d82f2, 0x20ab8200, 0x20f182d3, 0x203f8400, 
+    0x21db8400, 0x0083002b, 0xf8ff0424, 0x4782eeff, 0xd5ffdb26, 0x2f02d100, 0x17221282, 0x0f820400, 0x0e00c524, 0xad848d00, 0x9782c520, 0xf2ffdf2d, 
+    0x0000dbff, 0x3700a4ff, 0x83010000, 0x8200207f, 0x82e12035, 0x000226ad, 0x01c70000, 0x82058248, 0x7501235b, 0x25822e02, 0xc5ffec22, 0x03826182, 
+    0x2d83f984, 0xdfffba26, 0x0200dfff, 0x31200382, 0xc383ad84, 0x8b824e20, 0x7501b624, 0x0182f200, 0xf002aa24, 0x0b82aa00, 0x3701ba25, 0x8301d9ff, 
+    0xff1b2277, 0x265384fe, 0xfffeff00, 0x8262008b, 0xff312469, 0x84e1ffec, 0x82002057, 0x8203825f, 0x83ec2019, 0x8203896d, 0xff00225b, 0x2239828b, 
+    0x82fcff31, 0x82038c29, 0x8bfe203d, 0x262b8203, 0xff77ff31, 0x824e0077, 0x83ba2001, 0xb600218b, 0x09830582, 0x43827882, 0x57410420, 0x8231200a, 
+    0x21038619, 0x0b845eff, 0x0583c785, 0x49840120, 0x5b82df20, 0x0f820386, 0x03880020, 0xf6ff1923, 0x82038b00, 0x8902885b, 0x21098c43, 0x1942c1ff, 
+    0x00312206, 0x8547822f, 0x82ba2003, 0xffdb2415, 0x84d5ffd3, 0x2142824d, 0xf7828d01, 0x5fffc528, 0x17005fff, 0x01835bff, 0x8b840f83, 0x22057941, 
+    0x83dfff31, 0x85ff20a9, 0x4100200d, 0x2b20067b, 0xec242582, 0xe9ffecff, 0xba202982, 0x2006bf41, 0x2227820c, 0x84020000, 0x822720b3, 0x0002245a, 
+    0x8429000c, 0x84e1203b, 0x82022013, 0x00312127, 0x00220583, 0x3b823100, 0x0582f820, 0x1f84f220, 0x0984ec20, 0x77ff3122, 0xec220782, 0x13821900, 
+    0xfeffba24, 0x0d8275ff, 0x03827720, 0x8505ad41, 0x223983db, 0x821b00c1, 0x210f824f, 0xa784e7ff, 0x0584df20, 0x9182ec20, 0x5582e120, 0xc1439183, 
+    0xff312109, 0xf4226583, 0x8f82feff, 0x23823182, 0xf0fffc22, 0x4d840d82, 0x7d823f86, 0x00249f84, 0xe3ffe1ff, 0x3f8aa384, 0x82230021, 0xfff42481, 
+    0x838ffffc, 0xf6ff2123, 0x00219b83, 0x829b8404, 0x82ff2011, 0x08df419b, 0x57843120, 0x4b84ba20, 0x19205f83, 0x76822d82, 0xffc1ff23, 0x200388e5, 
+    0x823182ec, 0x24878213, 0xff4400d3, 0x200a82d3, 0x2a03824a, 0x00e3ffbc, 0x01000048, 0x838d018d, 0x82038505, 0x24028517, 0x008d01d3, 0x840182d3, 
+    0x840b970d, 0x27048c1c, 0x0800eeff, 0xf2fff2ff, 0x48241482, 0x0a004a00, 0x00200382, 0x31067d41, 0x06000001, 0x008bfe8b, 0xff5e0400, 0x04e3ff5e, 
+    0x1182007b, 0x02892782, 0x0300012e, 0x90015e04, 0x00000500, 0x33059a05, 0x25209182, 0x03390785, 0x017b00a0, 0x020105d1, 0x03090606, 0x05000202, 
+    0x0200a004, 0xa90070af, 0x293c87ca, 0x73736c6d, 0x00004000, 0x638502fb, 0x018b0627, 0x00002075, 0x231f839f, 0x1905a403, 0x0e820782, 0x01220582, 
+    0x00830100, 0x000c002d, 0x00ff08f8, 0xff070008, 0x820900fe, 0x82fe20b3, 0x820920ab, 0x000b240b, 0x82fdff09, 0x820a201d, 0x000d2205, 0x2205820b, 
+    0x820c000e, 0x000f2205, 0x2205820d, 0x820e0010, 0x82112005, 0x00fc2a05, 0xff0f0012, 0x001300fc, 0x22058210, 0x82110014, 0x00152205, 0x20058212, 
+    0x2a058216, 0x001700fb, 0x00fbff13, 0x82140018, 0x00192205, 0x22058215, 0x8216001a, 0x001b2205, 0x20058217, 0x2a05821c, 0x001d00fa, 0x00faff18, 
+    0x8219001e, 0x001f2205, 0x2205821a, 0x821b0020, 0x82212005, 0x00f92a05, 0xff1c0022, 0x002300f9, 0x2205821d, 0x821e0024, 0x00252205, 0x2205821f, 
+    0x82200026, 0x82272005, 0x00f82a05, 0xff210028, 0x002900f8, 0x22058222, 0x8223002a, 0x002b2205, 0x20058224, 0x2a05822c, 0x002d00f7, 0x00f7ff25, 
+    0x8226002e, 0x002f2205, 0x22058227, 0x82280030, 0x00312205, 0x20058229, 0x2a058232, 0x003300f6, 0x00f6ff2a, 0x822b0034, 0x00352205, 0x2205822c, 
+    0x822d0036, 0x82372005, 0x00f52a05, 0xff2e0038, 0x003900f5, 0x2205822f, 0x8230003a, 0x003b2205, 0x22058231, 0x8232003c, 0x823d2005, 0x00f42a05, 
+    0xff33003e, 0x003f00f4, 0x22058234, 0x82350040, 0x00412205, 0x20058236, 0x2a058242, 0x004300f3, 0x00f3ff37, 0x82380044, 0x00452205, 0x22058239, 
+    0x823a0046, 0x00472205, 0x2005823b, 0x2a058248, 0x004900f2, 0x00f2ff3c, 0x823d004a, 0x004b2205, 0x2205823e, 0x823f004c, 0x824d2005, 0x00f12a05, 
+    0xff40004e, 0x004f00f1, 0x22058241, 0x82420050, 0x00512205, 0x22058243, 0x82440052, 0x82532005, 0x00f02a05, 0xff450054, 0x005500f0, 0x22058246, 
+    0x82470056, 0x00572205, 0x20058248, 0x2a058258, 0x005900ef, 0x00efff49, 0x824a005a, 0x005b2205, 0x2205824b, 0x824c005c, 0x005d2205, 0x2005824d, 
+    0x2a05825e, 0x005f00ee, 0x00eeff4e, 0x824f0060, 0x00612205, 0x22058250, 0x82510062, 0x82632005, 0x00ed2a05, 0xff520064, 0x006500ed, 0x22058253, 
+    0x82540066, 0x00672205, 0x22058255, 0x82560068, 0x82692005, 0x00ec2a05, 0xff57006a, 0x006b00ec, 0x22058258, 0x8259006c, 0x006d2205, 0x2005825a, 
+    0x2a05826e, 0x006f00eb, 0x00ebff5b, 0x825c0070, 0x00712205, 0x2205825d, 0x825e0072, 0x00732205, 0x2005825f, 0x2a058274, 0x007500ea, 0x00eaff60, 
+    0x82610076, 0x00772205, 0x22058262, 0x82630078, 0x82792005, 0x00e92a05, 0xff64007a, 0x007b00e9, 0x22058265, 0x8266007c, 0x007d2205, 0x22058267, 
+    0x8268007e, 0x827f2005, 0x00e82a05, 0xff690080, 0x008100e8, 0x2205826a, 0x826b0082, 0x00832205, 0x2005826c, 0x2a058284, 0x008500e7, 0x00e7ff6d, 
+    0x826e0086, 0x00872205, 0x2205826f, 0x82700088, 0x00892205, 0x20058271, 0x2a05828a, 0x008b00e6, 0x00e6ff72, 0x8273008c, 0x008d2205, 0x22058274, 
+    0x8275008e, 0x828f2005, 0x00e52a05, 0xff760090, 0x009100e5, 0x22058277, 0x82780092, 0x00932205, 0x22058279, 0x827a0094, 0x82952005, 0x00e42a05, 
+    0xff7b0096, 0x009700e4, 0x2205827c, 0x827d0098, 0x00992205, 0x2005827e, 0x2a05829a, 0x009b00e3, 0x00e3ff7f, 0x8280009c, 0x009d2205, 0x22058281, 
+    0x8282009e, 0x009f2205, 0x20058283, 0x2a0582a0, 0x00a100e2, 0x00e2ff84, 0x828500a2, 0x00a32205, 0x22058286, 0x828700a4, 0x82a52005, 0x00e12a05, 
+    0xff8800a6, 0x00a700e1, 0x22058289, 0x828a00a8, 0x00a92205, 0x2205828b, 0x828c00aa, 0x82ab2005, 0x00e02a05, 0xff8d00ac, 0x00ad00e0, 0x2205828e, 
+    0x828f00ae, 0x00af2205, 0x20058290, 0x2a0582b0, 0x00b100df, 0x00dfff91, 0x829200b2, 0x00b32205, 0x22058293, 0x829400b4, 0x00b52205, 0x20058295, 
+    0x2a0582b6, 0x00b700de, 0x00deff96, 0x829700b8, 0x00b92205, 0x22058298, 0x829900ba, 0x82bb2005, 0x00dd2a05, 0xff9a00bc, 0x00bd00dd, 0x2205829b, 
+    0x829c00be, 0x00bf2205, 0x2205829d, 0x829e00c0, 0x82c12005, 0x00dc2a05, 0xff9f00c2, 0x00c300dc, 0x220582a0, 0x82a100c4, 0x00c52205, 0x200582a2, 
+    0x2a0582c6, 0x00c700db, 0x00dbffa3, 0x82a400c8, 0x00c92205, 0x220582a5, 0x82a600ca, 0x00cb2205, 0x200582a7, 0x2a0582cc, 0x00cd00da, 0x00daffa8, 
+    0x82a900ce, 0x00cf2205, 0x220582aa, 0x82ab00d0, 0x82d12005, 0x00d92a05, 0xffac00d2, 0x00d300d9, 0x220582ad, 0x82ae00d4, 0x00d52205, 0x220582af, 
+    0x82b000d6, 0x82d72005, 0x00d82a05, 0xffb100d8, 0x00d900d8, 0x220582b2, 0x82b300da, 0x00db2205, 0x200582b4, 0x2a0582dc, 0x00dd00d7, 0x00d7ffb5, 
+    0x82b600de, 0x00df2205, 0x220582b7, 0x82b800e0, 0x00e12205, 0x200582b9, 0x2a0582e2, 0x00e300d6, 0x00d6ffba, 0x82bb00e4, 0x00e52205, 0x220582bc, 
+    0x82bd00e6, 0x82e72005, 0x00d52a05, 0xffbe00e8, 0x00e900d5, 0x220582bf, 0x82c000ea, 0x00eb2205, 0x220582c1, 0x82c200ec, 0x82ed2005, 0x00d42a05, 
+    0xffc300ee, 0x00ef00d4, 0x220582c4, 0x82c500f0, 0x00f12205, 0x200582c6, 0x2a0582f2, 0x00f300d3, 0x00d3ffc7, 0x82c800f4, 0x00f52205, 0x220582c9, 
+    0x82ca00f6, 0x00f72205, 0x200582cb, 0x2a0582f8, 0x00f900d2, 0x00d2ffcc, 0x82cd00fa, 0x00fb2205, 0x220582ce, 0x82cf00fc, 0x82fd2005, 0x00d12a05, 
+    0xffd000fe, 0x00ff00d1, 0x280582d1, 0x00040000, 0x0a740200, 0x00001005, 0x00236f02, 0x10060b00, 0x6f020000, 0x0c000023, 0x00001007, 0x00226f02, 
+    0x02100d00, 0x216f0272, 0x00830007, 0x00000224, 0x03820300, 0x03001424, 0x07840100, 0xce030422, 0xb2260782, 0x06008000, 0x09823200, 0x000dae08, 
+    0x007e0022, 0x013001ff, 0x01510131, 0x01770153, 0x017f0178, 0x02ff0192, 0x02c7021b, 0x038603dd, 0x038c038a, 0x03a803a1, 0x03bf03a9, 0x04ce03c0, 
+    0x044f040c, 0x045f045c, 0x1e031e91, 0x1e1f1e0b, 0x1e571e41, 0x1e6b1e61, 0x20f31e85, 0x201a2015, 0x2022201e, 0x20302026, 0x2044203a, 0x211621ac, 
+    0x22262122, 0x22062202, 0x2212220f, 0x221e221a, 0x2248222b, 0x23652260, 0x23182303, 0x237d2326, 0x24ce2388, 0x25002523, 0x250c2502, 0x25142510, 
+    0x251c2518, 0x252c2524, 0x253c2534, 0x25c6256c, 0xe01327ca, 0xf9c3f607, 0xff02fb00, 0x2ab182ff, 0x000d0000, 0x00230020, 0x820001a0, 0x013224b3, 
+    0x82540152, 0x827920b3, 0x02fc2ab3, 0x02c60218, 0x038403d8, 0x22b38288, 0x82a3038e, 0x82aa20b3, 0xc12408b3, 0x0e040104, 0x5e045104, 0x021e9004, 
+    0x1e1e0a1e, 0x561e401e, 0x6a1e601e, 0xf21e801e, 0x18201320, 0x20201c20, 0x3920b384, 0x1120b390, 0x6420b38a, 0x2420b384, 0x5020b39e, 0x0026b386, 
+    0xfff8c3f6, 0xb38201fb, 0xf5ff0126, 0xe1ff0000, 0xf3320382, 0xf2ffa4ff, 0xf0ff5cff, 0xefff41ff, 0x73ff12ff, 0xd1835bff, 0xf3fd2d08, 0xf1fdf2fd, 
+    0xeffdf0fd, 0xeefdc6fe, 0xedfdd9fc, 0xbafdbbfd, 0xb8fdb9fd, 0x18e488fd, 0x00e412e4, 0xcce3e0e3, 0xbce3c4e3, 0x3ce3a8e3, 0x03833183, 0xe083e023, 
+    0x08038294, 0x0fe07652, 0x68df1be1, 0x94de77df, 0x89dea0de, 0x89de0000, 0x6fde72de, 0x2dde5dde, 0x30df2ede, 0x11df1cdf, 0xb1debbde, 0x18de6cde, 
+    0x3bdd3cdd, 0x2fdd32dd, 0x29dd2cdd, 0x1fdd26dd, 0x11dd18dd, 0xf7dc0add, 0xedda9edc, 0x662252db, 0x00001f0a, 0x0100bd05, 0x00215d83, 0x200582ae, 
+    0x900382b0, 0x5a012302, 0x14905c01, 0x0127109c, 0x013c0138, 0x95440140, 0x32012124, 0x15a61795, 0x2784f820, 0x0003f508, 0x00e100e0, 0x00a100aa, 
+    0x00830082, 0x009400e3, 0x008400e4, 0x0089008c, 0x00a7009b, 0x00e500a2, 0x00d80088, 0x00910081, 0x00e700e6, 0x0095008b, 0x00c10086, 0x00e800dc, 
+    0x00a8009c, 0x00ea00e9, 0x00a000eb, 0x00c700ab, 0x00ac00c5, 0x00610060, 0x0062008e, 0x006300c9, 0x00c800c6, 0x00ca00cd, 0x00cc00cb, 0x006400ec, 
+    0x00ce00d1, 0x00ad00cf, 0x00ed0065, 0x00d4008f, 0x00d300d2, 0x00ee0066, 0x008700ef, 0x00670068, 0x006b0069, 0x006c006a, 0x006d009e, 0x006e006f, 
+    0x00710070, 0x00720073, 0x00750074, 0x007600f0, 0x00770078, 0x007b0079, 0x00b6007a, 0x007d009f, 0x007e007c, 0x00f1007f, 0x00b800f2, 0x00df00d6, 
+    0x00da00d9, 0x00de00db, 0x00dd00d7, 0x02b100b0, 0x00b40030, 0x00c200b5, 0x00b300b2, 0x008000c3, 0x008500c0, 0x00320297, 0x006e02d0, 0x48082082, 
+    0x09b04b2c, 0x01b15850, 0xb8598e01, 0xb085ff01, 0x09b11d44, 0x2d5e5f03, 0x202c01b0, 0x44694520, 0x2d6001b0, 0xb02c02b0, 0x2d212a01, 0x202c03b0, 
+    0x2503b046, 0x23585246, 0x208a2059, 0x8a64498a, 0x68204620, 0x04b06461, 0x82078425, 0x8a652918, 0xb0202f59, 0x69585300, 0x54260582, 0x40b02158, 
+    0x0a881b59, 0x59596526, 0x04b02d3a, 0x31824683, 0x8a212d82, 0x20408259, 0x8240866a, 0x08128407, 0x2dfd2f29, 0x4b2c05b0, 0x2603b020, 0x58515850, 
+    0x1b4480b0, 0x594440b0, 0x2021211b, 0x50c0b045, 0x44c0b058, 0x5959211b, 0x8806b02d, 0x22ab82a3, 0x8518697d, 0x2c0727ad, 0x2d2a06b0, 0x418508b0, 
+    0xb0585329, 0x00b01b40, 0x838a8a59, 0x5853294f, 0x80b02123, 0x8a1b8a8a, 0x5f82c182, 0xc0200f84, 0xb8220f8d, 0x108f0001, 0x108b4020, 0x2503b027, 
+    0x8001b845, 0x824a8250, 0x21232206, 0x2310831b, 0x21232123, 0x5929a182, 0x09b02d44, 0x58534b2c, 0x31a28245, 0x002d5921, 0x00b00000, 0x01b2002b, 
+    0x012b0207, 0x058308b2, 0x4208b72e, 0x1825303f, 0xb72b0800, 0x3d3f5309, 0x0a240985, 0x2f3d5267, 0x0b211384, 0x211d874c, 0x0987530c, 0x52610d22, 
+    0x0e252786, 0x0f151b21, 0x223b8209, 0x8801b700, 0x8802203c, 0x4d03213c, 0x04203287, 0x05204688, 0x06206e88, 0x07204688, 0x003e5a87, 0x07040fb2, 
+    0x2000b02b, 0x18697d45, 0x2a000044, 0x5a006f00, 0x7b007900, 0x75008b00, 0x05828900, 0x7b200f83, 0x75220982, 0xcc825c01, 0x8dfe192c, 0xa2030000, 
+    0x14051900, 0x0f821900, 0x0c00002a, 0x03009600, 0x09040100, 0x76200d82, 0x0b850382, 0x1a000124, 0x17867600, 0x0e000224, 0x0b869000, 0x3e000324, 
+    0x0b869e00, 0x6d820420, 0x0b86dc20, 0x1a000524, 0x0b860601, 0x28000624, 0x0b862001, 0x5c000724, 0x0b864801, 0x23820920, 0x0b86a420, 0x30000b24, 
+    0x0b86be01, 0x0b8a0c20, 0xe6380d26, 0x4300ee01, 0x7020c582, 0x7230c582, 0x67006900, 0x74006800, 0x28002000, 0x29006300, 0x4d260782, 0x72006100, 
+    0x09826b00, 0x1d825320, 0x29826d20, 0x73006e22, 0x20240584, 0x30003200, 0x39220182, 0x09842d00, 0x0b823120, 0x27822e20, 0x6c004122, 0x20200182, 
+    0x4d873582, 0x15827320, 0x65007222, 0x65203782, 0x76201582, 0x64260982, 0x41002e00, 0x47846e00, 0x83007921, 0x82752055, 0x0020221d, 0x221f8250, 
+    0x8252006f, 0x00672221, 0x20458275, 0x200f8261, 0x832b8231, 0x00332a67, 0x0055003b, 0x0057004b, 0x9109824e, 0x203b853d, 0x913d8e2d, 0x20658727, 
+    0x20298e20, 0x20758256, 0x20858272, 0x21958469, 0x77890020, 0x6bb14391, 0xdf846920, 0x20006124, 0xd3827400, 0x64006122, 0x6d206d82, 0x22085b41, 
+    0x4166006f, 0x2e211c6b, 0x19874100, 0x51826820, 0x70007426, 0x2f003a00, 0x77210182, 0x22018300, 0x826d002e, 0x822d206f, 0x00742203, 0x836b8275, 
+    0x002e22d3, 0x20d98263, 0x1ced416d, 0x2007d141, 0x238d9c2c, 0x00280020, 0x518375af, 0x4020ef87, 0x55429d82, 0x42732005, 0xa3870e53, 0x83002921, 
+    0x8277202f, 0x8274201d, 0x05a94169, 0x42007321, 0x2022093d, 0xcb824600, 0xf9826e20, 0x4e002024, 0x4f826100, 0xb1826520, 0x2011a741, 0x06514220, 
+    0x0d002e22, 0x54200182, 0x87414b82, 0x203d8905, 0x20478253, 0x20478266, 0x20458277, 0x20618272, 0x20738220, 0x204b8273, 0x2007826c, 0x210f8263, 
+    0x7783006e, 0x11826420, 0x6e007524, 0x83846400, 0x83002021, 0x24718395, 0x00490053, 0x221b824c, 0x8470004f, 0x20978b2b, 0x83418c4c, 0x136142cf, 
+    0x83003121, 0x1b81439b, 0x01930110, 0x00202175, 0x42092d42, 0x21420d0b, 0x00632e07, 0x0070006f, 0x00650069, 0x00200064, 0x20078262, 0x2211826c, 
+    0x822c0077, 0x0061220d, 0x4215846e, 0x6124056d, 0x73006c00, 0x20241b82, 0x76006100, 0x69200382, 0x61200f82, 0x6c203182, 0x20213382, 0x09e54200, 
+    0x39826120, 0x41004624, 0x41845100, 0x3a007422, 0x67430782, 0x00732a0d, 0x00720063, 0x00700069, 0x20518274, 0x2003822e, 0x204b8269, 0x2c5b822e, 
+    0x00670072, 0x004f002f, 0x004c0046, 0x2101840d, 0x01f3002d, 0x43002021, 0x50260913, 0x4e004500, 0x93822000, 0x4e004f24, 0x09825400, 0x49004c24, 
+    0x15844300, 0x05825320, 0x43002021, 0x20201511, 0x2024b982, 0x36003200, 0x46243182, 0x62006500, 0x7522f382, 0x05826100, 0x11827920, 0x20050f43, 
+    0xf3098237, 0x002d22df, 0x2201820d, 0x82520050, 0x004126bf, 0x0042004d, 0x22c9844c, 0x82680054, 0x002024a9, 0x826f0067, 0x006c22a9, 0x459f8273, 
+    0x742005d5, 0x23441986, 0x00202221, 0x06c14128, 0x3d822920, 0xef826120, 0x07826520, 0x51827420, 0x4f822020, 0x69007424, 0x15476d00, 0x84742006, 
+    0x8277206b, 0x00722619, 0x0064006c, 0x201b8277, 0x83138464, 0x42762005, 0x7020068b, 0x65212f82, 0x05254500, 0x63208b85, 0x6c203182, 0x61223182, 
+    0x3b846200, 0x83006121, 0x222f8355, 0x45660020, 0x70200851, 0x6f227982, 0x45826a00, 0x1f826320, 0x2c007322, 0x7522858a, 0x01827000, 0x21826f20, 
+    0x15847420, 0x3b89f585, 0xb5846320, 0x6f225785, 0x23826e00, 0x59826520, 0x72201f83, 0x20204b84, 0x66206582, 0x61241582, 0x61006300, 0x6520b982, 
+    0x6920d382, 0x20200b82, 0x33430d82, 0x006c2205, 0x20378269, 0x20e98267, 0x20f58669, 0x832f8263, 0x846d20b9, 0x826e20ff, 0x20b5831f, 0x431d8265, 
+    0x27410b6b, 0x84702005, 0x417620bb, 0x6120080f, 0x66203b82, 0x65209384, 0x200a9743, 0x08af456f, 0x61201b83, 0x65215782, 0x054d4100, 0x25826b20, 
+    0xb7846920, 0x68007723, 0x20998300, 0x87118268, 0x827320df, 0x826d200b, 0x827920a9, 0x00622107, 0x73205183, 0xa9412582, 0x43642005, 0x6d200cf7, 
+    0x72206182, 0xed48eb82, 0x84202005, 0x822020d3, 0x82612013, 0x0074228b, 0x203b826e, 0x83bf8272, 0x82702061, 0x09034437, 0x42006f21, 0x1d83052f, 
+    0x8309b546, 0x05db4369, 0x7d822020, 0x44006c21, 0x8d830569, 0x20202d85, 0xab831182, 0x59826520, 0x8b07af46, 0x051b41b3, 0x7520b185, 0x65247782, 
+    0x2c006400, 0x73207782, 0x1f486d82, 0x20118705, 0x20b3826d, 0x20ad8264, 0x08d94466, 0x53826120, 0x7220db83, 0x6420b382, 0x33831582, 0x07827220, 
+    0x75006222, 0xfd443d82, 0x07614105, 0x79006c22, 0x61205582, 0x91836182, 0x39826f20, 0x0f886720, 0x68007422, 0x1f854182, 0x20056947, 0x206b826e, 
+    0x20858474, 0x45bf826f, 0x1f830545, 0x6d202985, 0x6c22a784, 0x35827600, 0x2e007322, 0x54202782, 0xa9424184, 0x05994209, 0x65826920, 0x3f826320, 
+    0x6e21c785, 0x20718500, 0x2089846e, 0x223b8264, 0x82690072, 0x0be94243, 0x8507e941, 0x0063223f, 0x21418261, 0x1d410020, 0x22d58305, 0x8264006e, 
+    0x0711414f, 0x6d006522, 0x64201b84, 0x13871582, 0x411b0b41, 0x2f20052f, 0x7220db82, 0xe341db8c, 0x82612009, 0x20e7836f, 0x107b4873, 0x200dbd42, 
+    0x06614364, 0x74006122, 0x35870982, 0x200f494b, 0x204d8220, 0x22a38261, 0x44730065, 0x5b410a35, 0x07ed4107, 0x7383df83, 0x411f1141, 0x9d431567, 
+    0x413f9309, 0x68200547, 0x7724cd82, 0x76006500, 0x72220382, 0x8b822c00, 0x87055941, 0x055f4189, 0x6c20bd83, 0x61202182, 0x87145749, 0x090543e3, 
+    0xfb822020, 0x70007922, 0x39443182, 0x0d8d4707, 0x7220af8b, 0x71252582, 0x69007500, 0x20098300, 0x440d826d, 0x662005fb, 0x43068b41, 0x27851111, 
+    0x9d436120, 0x0fe14906, 0xa3826920, 0x220f5943, 0x82640020, 0x056b414d, 0x6120d987, 0x70219f82, 0x05fb4200, 0x87056943, 0x826420c7, 0x8263202b, 
+    0x458b8991, 0x3943091f, 0x82752005, 0x00692163, 0x2005b542, 0x10df4274, 0x7220f383, 0x20086745, 0x83d78269, 0x8265207f, 0x0dd34207, 0x44007321, 
+    0x4428052b, 0x46004500, 0x4e004900, 0x54200382, 0x4f200382, 0x53200982, 0x22203f82, 0x6f201582, 0x4a060946, 0x22200ff1, 0x21069d4d, 0x57830066, 
+    0x20055344, 0x2073886f, 0x229f8220, 0x46740065, 0x662208cd, 0xe9826900, 0x15826520, 0x85822020, 0x0b846520, 0x2109cb41, 0xbf430062, 0x4c202009, 
+    0x48211469, 0x05eb4300, 0x3d826520, 0x45822820, 0x594b2920, 0x15774112, 0x22055743, 0x86630020, 0x41722073, 0x554c0671, 0x054f4107, 0x99846120, 
+    0x75007322, 0x68202782, 0x85083544, 0x07b94551, 0x450b3144, 0x6f2005c3, 0x72202f82, 0x0d833182, 0x2c20e189, 0x62209b82, 0x69201982, 0x64206982, 
+    0x7d490b82, 0x0b13430d, 0x3b826f20, 0x6d477520, 0x09fd4608, 0x22059541, 0x4e520022, 0xbf4c0efd, 0x17874113, 0x21074b42, 0xe543006e, 0x00732209, 
+    0x20518270, 0x0ea74563, 0xa3847320, 0xf9847520, 0x66229d83, 0xaf4c7400, 0x4f63200e, 0x732012e9, 0x61202582, 0xa5422984, 0x05974107, 0x4f22bb87, 
+    0x67827200, 0x03826720, 0x6c208183, 0x56206382, 0x970c294f, 0x427420b7, 0x734806cd, 0x82652007, 0x82742097, 0x05154845, 0x4d058f48, 0xf1471b87, 
+    0x82702005, 0x436e20b1, 0xdf4406c9, 0x46058305, 0x7f421787, 0x20e78733, 0x10f9464d, 0xeb43e7a5, 0x11974309, 0x6d002025, 0x49006100, 0x9b850599, 
+    0xbd830d83, 0x2307f143, 0x002c006f, 0x2005d343, 0x23e5826c, 0x00690074, 0x13831983, 0x72006f22, 0x2006cf41, 0x06074962, 0x75007423, 0x22218700, 
+    0x822d0020, 0x0f574801, 0x48072f44, 0x6f2109c1, 0x87578300, 0x095f452d, 0xe1436620, 0x1569410a, 0x420fbd4a, 0x2b431d05, 0x82792005, 0x00632255, 
+    0x83f38268, 0x47cb85c5, 0x722205af, 0x15826d00, 0xc9827420, 0x0f41a387, 0x00702105, 0xd589e783, 0x35427420, 0x1b194206, 0x26076345, 0x006e0020, 
+    0x82770065, 0x82652073, 0x00762409, 0x82720069, 0x436e204d, 0xd9410887, 0x00412307, 0x57830075, 0xad426983, 0x0bc54117, 0x49827320, 0x5b846720, 
+    0x2005c746, 0x420b8265, 0x652005ff, 0x2008db46, 0x206b8470, 0x20058267, 0x206f8261, 0x2017886d, 0x20098274, 0x20c38263, 0x2043826e, 0x20f18263, 
+    0x209d826c, 0x20258277, 0x088b4369, 0x4605d741, 0x70200be1, 0x73203d84, 0x2020bb84, 0x6820cf82, 0x20220982, 0x0f846300, 0x3b847420, 0x850b6b49, 
+    0x212741fd, 0x502afd85, 0x52004500, 0x49004d00, 0x01825300, 0x4f004924, 0x91824e00, 0x03822620, 0x0b844320, 0x29464420, 0x8450200e, 0x826d208b, 
+    0x537320bd, 0x3f450a0b, 0x84682005, 0x0065211b, 0x8505b941, 0x846e20fb, 0x054d4ad7, 0x4209674b, 0x0942053b, 0x00722205, 0x4c378267, 0x69410943, 
+    0x20f58d07, 0x2255826f, 0x82610074, 0x846e2077, 0x05c54903, 0x22050541, 0x4d790070, 0x1f42104d, 0x20698919, 0x20c18275, 0x0ce74a65, 0x0d847920, 
+    0x83070545, 0x05b94129, 0xeb49a187, 0x221b8509, 0x8264006f, 0x8266208d, 0x490f837f, 0x854c17f5, 0x8273200b, 0x006c22eb, 0x4baf826c, 0x75231949, 
+    0x91006e00, 0x094f501d, 0x9d113b4e, 0x007324ed, 0x4d620075, 0x202108af, 0x0d214200, 0x6f006622, 0x6c208f82, 0x77200582, 0x42085941, 0x6420055b, 
+    0x2006494d, 0x248f826f, 0x003a0073, 0x2201820d, 0x82290031, 0x824e20bb, 0x4c6920c5, 0xef520889, 0x20879909, 0x42438220, 0x634405d9, 0x8345830d, 
+    0x826920cf, 0x206f831f, 0x20738276, 0x20af8264, 0x41938261, 0x6d2105dd, 0x0de34500, 0x814d2c20, 0x11794608, 0xa9456185, 0x058f4a1f, 0x4c0fa74d, 
+    0x97850d63, 0x85826520, 0x3b496620, 0x84322006, 0x2173b9f9, 0x31450020, 0x1b2b410d, 0x734c9b8d, 0x17694211, 0x4c09634e, 0x2c22335f, 0x954e2000, 
+    0x00692308, 0x31490064, 0x00742605, 0x00610068, 0x201b8274, 0x20078265, 0x430d8263, 0x29420b75, 0x43742005, 0x714e0699, 0x0061220b, 0x06df4e62, 
+    0x41582f89, 0x051d4b0b, 0x55496920, 0x00612206, 0x4271826e, 0xdf490549, 0x09c74b13, 0x97827320, 0x954d5183, 0x0db1490b, 0xab846420, 0x210b9f42, 
+    0xfb480061, 0x83a78305, 0x822d2067, 0x826c20af, 0x846e209d, 0x8274204b, 0x84782005, 0x0ddb49e1, 0x75006824, 0x29826d00, 0x2d006e24, 0x23827200, 
+    0xa1826120, 0x3147d583, 0x86682005, 0x82652011, 0x425d831b, 0x8983057b, 0x22090f43, 0x41700061, 0x70200651, 0x69202582, 0x99514b82, 0x416d2005, 
+    0x69200649, 0x6520f582, 0x6d205d94, 0xad835d82, 0x33846420, 0x2005a550, 0x20138269, 0x8383826c, 0x0077216d, 0x6f87df85, 0x85006521, 0x208585c1, 
+    0x201d8262, 0x0811536e, 0x2020d589, 0xbd561382, 0x117b4f05, 0x41006f21, 0x2d830559, 0x87006521, 0x0dfd4e67, 0x3f846520, 0x594b6920, 0x82762006, 
+    0x00652265, 0x08e15477, 0x200bdb4b, 0x204d8475, 0x063b4372, 0x44003321, 0x6f230535, 0x43002000, 0x27431f9d, 0x416d8533, 0x4f4b0977, 0x0b5d4c23, 
+    0xc3826c20, 0xb1827320, 0x07822020, 0x70007822, 0x22062d51, 0x47740069, 0x74200a9d, 0x6e201b82, 0x70200f82, 0x461a0147, 0x20200df3, 0x4a060947, 
+    0x72210be9, 0x059f4f00, 0x6f007025, 0x49006e00, 0xe15709e9, 0x4d482013, 0xff420a0b, 0x4d692007, 0x73200859, 0x72229d82, 0x354b6900, 0x416e200e, 
+    0x7942069b, 0x826c2005, 0x058b4d1f, 0x200df345, 0x21858270, 0x194d0069, 0x52792005, 0x2b500abf, 0x07294209, 0x41832983, 0x6e006522, 0x11446f82, 
+    0x0bff4d07, 0x52057b41, 0x3422098f, 0x8b512900, 0x07954c0a, 0x45076d41, 0xf59f0d03, 0xe54e3589, 0x00202109, 0x950baf49, 0x1b5b4557, 0x68007325, 
+    0x47006100, 0x7b500583, 0x20c9850d, 0x08cd5464, 0x6f24fb83, 0x6f006d00, 0x2c20f984, 0x65241782, 0x64006e00, 0xed830f82, 0x0f826520, 0x20056d43, 
+    0x50138261, 0x742305d5, 0x43006900, 0x61200545, 0x4206c351, 0x55851fed, 0x63007826, 0x70006500, 0x20206782, 0x6f200382, 0x61205982, 0x6b201182, 
+    0x6f224382, 0xab827700, 0x61826520, 0xab446720, 0x84682006, 0x11fd4907, 0x97826920, 0x41006e21, 0x6741150f, 0x0b854527, 0x4b05315b, 0x8b410919, 
+    0x077f440d, 0x9183af83, 0x72006922, 0x6521b582, 0x333d4300, 0x2005894a, 0x0c374235, 0x4919c141, 0x69210d79, 0x05934200, 0x49058941, 0x2f481339, 
+    0x00702209, 0x20a58261, 0x08b74174, 0x850f054d, 0x00752359, 0x23830073, 0x4e058f52, 0x65221749, 0x25826e00, 0x6520f583, 0x52067143, 0x094a231d, 
+    0x006d210b, 0x85426987, 0x8b71970d, 0x1307535f, 0x42e1f752, 0x41421913, 0x4c542005, 0x4e2308cb, 0x52004100, 0xa95b07df, 0x0062231b, 0xdd4e0065, 
+    0x00652805, 0x00200073, 0x4475006e, 0x09430619, 0x00762607, 0x0069006f, 0x211b8264, 0x97580069, 0x4c6e2005, 0xeb48126d, 0x826e200f, 0x00692231, 
+    0x4b398274, 0x2023053b, 0x56006100, 0xdf470dd3, 0x28b78505, 0x00490044, 0x00430053, 0x22b5824c, 0x844d0049, 0x20b583c5, 0x5b098248, 0x53280b1d, 
+    0x46004f00, 0x57005400, 0x52202782, 0x37831b84, 0x50002024, 0x19825200, 0x45825620, 0x15824420, 0xab824420, 0x21822220, 0x07825320, 0x22221f83, 
+    0x09822c00, 0x1d825720, 0x48005422, 0x55202782, 0x20204182, 0x52204386, 0x4e202782, 0x59200f82, 0x5b832182, 0x0f842020, 0x4b200d83, 0x4e222f82, 
+    0x3b844400, 0x58004522, 0x45206384, 0x5583a582, 0x6f824f20, 0x1f822020, 0x15824d20, 0x07824c20, 0x27864520, 0x4e004922, 0x5520c584, 0x0b830f82, 
+    0x55824720, 0x85004221, 0x824e206f, 0x82542079, 0x202f830f, 0x838b844d, 0x00202235, 0x89178254, 0x87d98575, 0x82492095, 0x206f85cd, 0x41398246, 
+    0x43200517, 0x4120c382, 0x54206782, 0x4220a982, 0x4c204782, 0x59204b84, 0x4620a784, 0x4e200b84, 0x37833584, 0x5b824620, 0x39825220, 0x03824120, 
+    0x2f825020, 0x6d825220, 0xa1824920, 0x4c005522, 0x20240d84, 0x55005000, 0x5020cb82, 0x6f5c2782, 0x20598305, 0x832d8244, 0x004e22ad, 0x20678249, 
+    0x851f8246, 0x004522cb, 0x5c59824d, 0x2b4105a7, 0x82432005, 0x00502237, 0x20218459, 0x20978247, 0x83858454, 0x86542069, 0x822c2029, 0x8254204b, 
+    0x0041221f, 0x20118244, 0x2075844d, 0x4125844b, 0x4f220543, 0x37825400, 0x21824520, 0x458a2020, 0x35822e20, 0x20207383, 0x4f207f82, 0x45220b82, 
+    0x79885600, 0xff845320, 0xc1824c20, 0x91092142, 0x82202087, 0x824f2025, 0x82442023, 0x82522037, 0x82422041, 0x82202007, 0x8249200f, 0x07915c81, 
+    0x20091d41, 0x21c3824e, 0x7f420020, 0x822c2009, 0x82442031, 0x20af8329, 0x08834147, 0xaf8b4783, 0x85004c21, 0x8449204d, 0x82542057, 0x42378343, 
+    0x41201303, 0x5920c782, 0x4b835382, 0x91844e20, 0x33824120, 0x53222d83, 0x0f825000, 0x49844320, 0x87004c21, 0x8244203f, 0x8452200f, 0x05514117, 
+    0x49215385, 0x22cd8300, 0x8254004e, 0x412b8599, 0xa7500543, 0x82532005, 0x0051222f, 0x06274155, 0x23844920, 0x31822020, 0x89004121, 0x225f83c5, 
+    0x82480057, 0x09754123, 0x83056741, 0x822020a1, 0x44432033, 0xe3410a35, 0x20738309, 0x831d8652, 0x00542143, 0x54207983, 0xc541d182, 0x8257200f, 
+    0x825320b9, 0x2225835f, 0x84520041, 0x053d420d, 0x46002022, 0x4f200f82, 0x1b838d82, 0x15434f20, 0x20638506, 0x20938454, 0x42138220, 0x55850585, 
+    0x4e004922, 0x200ee342, 0x062d4320, 0x85005521, 0x20378727, 0x428f8246, 0x21440597, 0x874b8511, 0x8220207b, 0x20fb8929, 0x22a98244, 0x824c0041, 
+    0x004e22a5, 0x20538247, 0x44098420, 0x2e222379, 0xfd820d00, 0x541f4f47, 0x0d203f55, 0x6f4f6582, 0x0d755511, 0x83735754, 0x23595497, 0x22202783, 
+    0x540cad4a, 0x8383715d, 0x617b5f54, 0x6354050d, 0x2331852b, 0x00720065, 0x83836554, 0x0061218d, 0x838b6754, 0x17ff5191, 0x83696954, 0x0f295c85, 
+    0x6b547d83, 0x876f544b, 0x2b4c8783, 0x118d4405, 0x835b7154, 0x89755477, 0x541b7742, 0x8b836f77, 0x42837954, 0x63240719, 0x75006c00, 0x20083155, 
+    0x069b5365, 0x72006522, 0x5d08dd62, 0x7b540545, 0x09a5425b, 0x50007421, 0x7d540523, 0x54878375, 0x93838f7f, 0x83898354, 0x07956c8d, 0x838b8554, 
+    0x1f295297, 0x83758754, 0x31895499, 0x8d543583, 0x1333478b, 0x54002021, 0x81836b8f, 0x42839154, 0x19432369, 0x5f935407, 0x4a055b42, 0x9b51116f, 
+    0x541d8305, 0x87838399, 0x54093154, 0x8383759b, 0x48819d54, 0x6d210787, 0x79976700, 0x99678383, 0x1fa15413, 0x4d056572, 0xa554070d, 0x0d7f720b, 
+    0x210dcb55, 0xa7540020, 0x568d836f, 0xa9540795, 0x5417830b, 0xbd8513ad, 0x8385af54, 0x83b1548b, 0x23056b45, 0x00520045, 0x5183b354, 0x4620054b, 
+    0x5406d763, 0x014681b5, 0x004f2105, 0xb754898d, 0x548d8377, 0x67438bb9, 0x87bb5405, 0xbd548d83, 0x05c34283, 0x2345bf54, 0x00020000, 0xff230084, 
+    0x827b0045, 0x82012008, 0x21028c03, 0x15847002, 0x0002dd08, 0x00060003, 0x00080007, 0x000a0009, 0x000c000b, 0x000e000d, 0x0010000f, 0x00120011, 
+    0x00140013, 0x00160015, 0x00180017, 0x001a0019, 0x001c001b, 0x001e001d, 0x0020001f, 0x00220021, 0x00240023, 0x00260025, 0x00280027, 0x002a0029, 
+    0x002c002b, 0x002e002d, 0x0030002f, 0x00320031, 0x00340033, 0x00360035, 0x00380037, 0x003a0039, 0x003c003b, 0x003e003d, 0x0040003f, 0x00420041, 
+    0x00440043, 0x00460045, 0x00480047, 0x004a0049, 0x004c004b, 0x004e004d, 0x0050004f, 0x00520051, 0x00540053, 0x00560055, 0x00580057, 0x005a0059, 
+    0x005c005b, 0x005e005d, 0x0060005f, 0x00620061, 0x00640063, 0x00660065, 0x00680067, 0x006a0069, 0x006c006b, 0x006e006d, 0x0070006f, 0x00720071, 
+    0x0805df71, 0x770076a6, 0x79007800, 0x7b007a00, 0x7d007c00, 0x7f007e00, 0x81008000, 0x83008200, 0x85008400, 0x87008600, 0x89008800, 0x8b008a00, 
+    0x8d008c00, 0x8f008e00, 0x91009000, 0x93009200, 0x95009400, 0x97009600, 0x99009800, 0x9b009a00, 0x9d009c00, 0x9f009e00, 0xa100a000, 0xa300a200, 
+    0xa500a400, 0xa700a600, 0xa900a800, 0xab00aa00, 0xad000201, 0xaf00ae00, 0xb100b000, 0xb300b200, 0xb500b400, 0xb700b600, 0xb900b800, 0xbb00ba00, 
+    0x0301bc00, 0xbf00be00, 0xc100c000, 0xc300c200, 0xc500c400, 0xc700c600, 0xc900c800, 0x3606f57f, 0x00ce00cd, 0x00d000cf, 0x00d200d1, 0x00d400d3, 
+    0x00d600d5, 0x7fd800d7, 0x430b06a9, 0x00dd00dc, 0x00df00de, 0x00e100e0, 0x01050004, 0x00bd0004, 0x000501e8, 0x00f300f2, 0x00f500f1, 0x00f600f4, 
+    0x00f000e9, 0x00ed00eb, 0x00ec00ea, 0x010601ee, 0x01080107, 0x010a0109, 0x00fd000b, 0x010c01fe, 0x010e010d, 0x01ff000f, 0x01100100, 0x01120111, 
+    0x01130101, 0x01150114, 0x01170116, 0x01190118, 0x011b011a, 0x011d011c, 0x00f8001e, 0x011f01f9, 0x01210120, 0x01230122, 0x01250124, 0x01270126, 
+    0x01290128, 0x012b012a, 0x012d012c, 0x01fa002e, 0x0130012f, 0x01320131, 0x01340133, 0x01360135, 0x01380137, 0x013a0139, 0x013c013b, 0x00e2003d, 
+    0x013e01e3, 0x0140013f, 0x01420141, 0x01440143, 0x01460145, 0x01480147, 0x014a0149, 0x014c014b, 0x014e014d, 0x0150014f, 0x01520151, 0x01540153, 
+    0x00560155, 0x00fc00fb, 0x01e500e4, 0x01580157, 0x015a0159, 0x015c015b, 0x015e015d, 0x0160015f, 0x01620161, 0x01640163, 0x01660165, 0x01680167, 
+    0x016a0169, 0x016c016b, 0x016e016d, 0x0070016f, 0x01e700e6, 0x01720171, 0x01740173, 0x01760175, 0x01780177, 0x017a0179, 0x017c017b, 0x017e017d, 
+    0x0180017f, 0x01820181, 0x01840183, 0x01860185, 0x01880187, 0x018a0189, 0x018c018b, 0x018e018d, 0x0190018f, 0x01920191, 0x01940193, 0x01960195, 
+    0x01980197, 0x019a0199, 0x019c019b, 0x019e019d, 0x01a0019f, 0x01a201a1, 0x01a401a3, 0x01a601a5, 0x01a801a7, 0x01aa01a9, 0x01ac01ab, 0x01ae01ad, 
+    0x01b001af, 0x01b201b1, 0x01b401b3, 0x01b601b5, 0x01b801b7, 0x01ba01b9, 0x01bc01bb, 0x01be01bd, 0x01c001bf, 0x01c201c1, 0x01c401c3, 0x01c601c5, 
+    0x01c801c7, 0x01ca01c9, 0x01cc01cb, 0x01ce01cd, 0x01d001cf, 0x01d201d1, 0x01d401d3, 0x01d601d5, 0x01d801d7, 0x01da01d9, 0x01dc01db, 0x01de01dd, 
+    0x01e001df, 0x01e201e1, 0x01e401e3, 0x01e601e5, 0x01e801e7, 0x01ea01e9, 0x01ec01eb, 0x01ee01ed, 0x01f001ef, 0x01f201f1, 0x01f401f3, 0x01f601f5, 
+    0x01f801f7, 0x01fa01f9, 0x01fc01fb, 0x01fe01fd, 0x020002ff, 0x02020201, 0x02040203, 0x02060205, 0x02080207, 0x020a0209, 0x020c020b, 0x020e020d, 
+    0x0210020f, 0x02120211, 0x02140213, 0x02160215, 0x02180217, 0x021a0219, 0x021c021b, 0x021e021d, 0x0220021f, 0x02220221, 0x02240223, 0x02260225, 
+    0x02280227, 0x022a0229, 0x022c022b, 0x022e022d, 0x0230022f, 0x02320231, 0x00340233, 0x023502ef, 0x02370236, 0x02390238, 0x023b023a, 0x023d023c, 
+    0x023f023e, 0x02410240, 0x02430242, 0x02450244, 0x02470246, 0x02490248, 0x024b024a, 0x024d024c, 0x024f024e, 0x02510250, 0x02530252, 0x02550254, 
+    0x02570256, 0x02590258, 0x025b025a, 0x025d025c, 0x025f025e, 0x02610260, 0x02630262, 0x02650264, 0x02670266, 0x02690268, 0x026b026a, 0x026d026c, 
+    0x026f026e, 0x07710270, 0x30696e75, 0x04304130, 0x6f727545, 0x6d6f630b, 0x6361616d, 0x746e6563, 0x442a1886, 0x616d4107, 0x6e6f7263, 0x07856107, 
+    0x62410628, 0x65766572, 0x06846106, 0x6f410729, 0x656e6f67, 0x8561076b, 0x430b2d07, 0x63726963, 0x6c666d75, 0x630b7865, 0x0a240b89, 0x746f6443, 
+    0x0a215885, 0x230a8863, 0x61634406, 0x06215a82, 0x27068564, 0x6f726344, 0x45077461, 0x07216885, 0x21078565, 0x69844506, 0x84650621, 0x450a2106, 
+    0x0a213d88, 0x210a8865, 0x7e854507, 0x85650721, 0x45062107, 0x65205185, 0x0b210684, 0x21888947, 0x0b89670b, 0x89470a21, 0x8867204b, 0x470c210a, 
+    0x210a0541, 0x0c8a670c, 0x89480b21, 0x680b213b, 0x04260b89, 0x72616248, 0x04826804, 0x74490628, 0x65646c69, 0x06846906, 0x85490721, 0x690721c1, 
+    0x06210785, 0x21c28449, 0x06846906, 0x85490721, 0x690721ab, 0x02270785, 0x69024a49, 0x894a0b6a, 0x6a0b2157, 0x0c210b89, 0x21888a4b, 0x0c8c6b0c, 
+    0x65726733, 0x616c6e65, 0x6369646e, 0x63614c06, 0x06657475, 0x2106846c, 0x278b4c0c, 0x0c8a6c20, 0x634c0628, 0x6e6f7261, 0x06846c06, 0x824c0421, 
+    0x6c0421fd, 0x06210482, 0x203f854e, 0x203f856e, 0x21328a4e, 0x0c8a6e0c, 0x844e0621, 0x6e062138, 0x0b350684, 0x6f70616e, 0x6f727473, 0x03656870, 
+    0x03676e45, 0x07676e65, 0x21f4854f, 0x07856f07, 0x844f0621, 0x6f0621f5, 0x0d2f0684, 0x6e75684f, 0x75726167, 0x75616c6d, 0x8b6f0d74, 0x5206210d, 
+    0x06217c84, 0x21068472, 0x768a520c, 0x8a720c21, 0x5206210c, 0x06217c84, 0x20068572, 0x212e8453, 0x06847306, 0x41530b21, 0x0b21093a, 0x210b8973, 
+    0x408a540c, 0x8a740c21, 0x5406210c, 0x74204685, 0x04260684, 0x72616254, 0x04827404, 0x74550628, 0x65646c69, 0x06847506, 0x85550721, 0x750721cd, 
+    0x06210785, 0x21ce8455, 0x06847506, 0x72550527, 0x05676e69, 0x21058375, 0xe18c550d, 0x0d8b7520, 0x41550721, 0x072105f2, 0x21078575, 0xa189570b, 
+    0x8a770b21, 0x8a59200b, 0x8979200b, 0x5a06210b, 0x0621e484, 0x2106847a, 0xbb425a0a, 0x7a0a2108, 0x05280a88, 0x676e6f6c, 0x45410773, 0x07222384, 
+    0x07846561, 0x734f0b26, 0x6873616c, 0x6f200b85, 0x0c210b89, 0x0a0a4153, 0x44730c21, 0x32390f07, 0x75074131, 0x3230696e, 0x74054231, 0x736f6e6f, 
+    0x6569640d, 0x69736572, 0x250d8473, 0x706c410a, 0x0a846168, 0x70450c24, 0x7a826973, 0x08220c84, 0x15857445, 0x6f490922, 0x0c270986, 0x63696d4f, 
+    0x846e6f72, 0x550c211f, 0x0a242c8a, 0x67656d4f, 0x11212e85, 0x8c2e8269, 0x84052061, 0x42042a61, 0x05617465, 0x6d6d6147, 0x238e8461, 0x07343933, 
+    0x04216f86, 0x201a825a, 0x226f8203, 0x82685405, 0x83042009, 0x4b053670, 0x61707061, 0x6d614c06, 0x02616462, 0x4e02754d, 0x69580275, 0x31818607, 
+    0x03695002, 0x056f6852, 0x6d676953, 0x61540361, 0x8d860775, 0x68500325, 0x82430369, 0x73502303, 0x47830c69, 0x0f208987, 0x0f872086, 0x89610a21, 
+    0x8a6520f6, 0x820820c9, 0x20df8480, 0x84c78309, 0x75142109, 0xd48d1f85, 0x04213f84, 0x212e8262, 0xd4836705, 0x65640526, 0x0761746c, 0x04214b86, 
+    0x2018827a, 0x21038203, 0xd2847405, 0x05214c83, 0x20d2846b, 0x41d2846c, 0x42290503, 0x756e0243, 0x07697802, 0x0559416f, 0x68720325, 0x8373066f, 
+    0x053121d4, 0x03210684, 0x86db8274, 0x7003217f, 0x6320d782, 0x8e820382, 0x6d6f0526, 0x0c616765, 0x200b6b41, 0x20a68e0f, 0x8453860c, 0x860c20c3, 
+    0x200c841c, 0x843c840a, 0x6109290a, 0x31696966, 0x33323030, 0x35210987, 0x20098831, 0x89098832, 0x8834201d, 0x88352013, 0x88362009, 0x88372009, 
+    0x88382009, 0x87392009, 0x30362109, 0x63880988, 0x63873620, 0x88343121, 0x8831204f, 0x88312045, 0x88312045, 0x88322045, 0x88322045, 0x88322045, 
+    0x883220a9, 0x8832209f, 0x8832204f, 0x8832209f, 0x88322059, 0x88322059, 0x88332059, 0x88332059, 0x88332059, 0x41332059, 0x33200803, 0x33206388, 
+    0x33206388, 0x33206388, 0x33206388, 0x33206388, 0x34206388, 0x34206388, 0x34206388, 0x34206388, 0x34206388, 0x17416388, 0x88342009, 0x88342063, 
+    0x88342063, 0x88342063, 0x88362063, 0x88362095, 0x88362031, 0x88362031, 0x88362031, 0x88372031, 0x88372095, 0x8837208b, 0x8837208b, 0x8837208b, 
+    0x88372059, 0x88372059, 0x88372059, 0x88372059, 0x88382059, 0x88382059, 0x883820ef, 0x88382063, 0x88382063, 0x88382063, 0x88382063, 0x88382063, 
+    0x88382063, 0x88382063, 0x88392063, 0x88392063, 0x88392063, 0x88392063, 0x88392063, 0x88392063, 0x88392063, 0x88392063, 0x89372063, 0x21638745, 
+    0x63873031, 0x87303121, 0x3031211d, 0x2008bb42, 0x21638730, 0x63873031, 0x87303121, 0x30312163, 0x31216387, 0x21638730, 0xc7873031, 0x88303121, 
+    0x88312063, 0x20b38963, 0x28db8935, 0x6e750738, 0x30453169, 0x20078632, 0x20078633, 0x20078641, 0x21078542, 0x07864531, 0x07854620, 0x86303421, 
+    0x85312007, 0x36352107, 0x37200786, 0x36200785, 0x36201f86, 0x36201f86, 0x362a4f86, 0x67570642, 0x65766172, 0x06857706, 0x63615724, 0x0d827475, 
+    0x09210684, 0x070d4557, 0x87770921, 0x59062109, 0x79202885, 0x09270684, 0x69696661, 0x86323030, 0x313623e9, 0xb9843533, 0x30333222, 0x3222b984, 
+    0xd1843133, 0x3233323d, 0x706f0934, 0x6e6f6974, 0x0f79656b, 0x73617265, 0x746f7465, 0x69726568, 0x83746867, 0x333223a3, 0x07856437, 0x31863820, 
+    0x84656321, 0x3234270f, 0x46530833, 0x00833031, 0x09840883, 0x30200882, 0x33200888, 0x86821a86, 0x1a830982, 0x11873420, 0x08873820, 0x08873920, 
+    0x08873620, 0x08873720, 0x08863520, 0x47873420, 0x3e873220, 0x86313521, 0x3235211a, 0x33200886, 0x32204787, 0x32201187, 0x32202387, 0x07844787, 
+    0x86823020, 0x2c873420, 0x86873320, 0x08883220, 0x32207d87, 0x33208f87, 0x1a870888, 0x62873420, 0x74883120, 0x86863020, 0xaa873220, 0x2c883420, 
+    0x34215987, 0x20238631, 0x87d78834, 0x83d68459, 0x88352098, 0x844788e0, 0x620c3d11, 0x6b63616c, 0x6d616964, 0x09646e6f, 0x63656863, 0x72616d6b, 
+    0x6873056b, 0x09746669, 0x6c360584, 0x0b6b636f, 0x74726576, 0x6c616369, 0x04626174, 0x79706f63, 0x36826204, 0x6e650623, 0x23108264, 0x736e6906, 
+    0x03201e82, 0x09290a82, 0x6c707061, 0x65706f65, 0x0507476e, 0x00394122, 0x032c0083, 0x02000900, 0x01000d00, 0x0200ffff, 0x4a7afa05, 0x00008ed9, 
+};
+
diff --git a/third-party/imgui/imgui.cpp b/third-party/imgui/imgui.cpp
index de724e6..fcfb604 100644
--- a/third-party/imgui/imgui.cpp
+++ b/third-party/imgui/imgui.cpp
@@ -6536,7 +6536,6 @@ bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v
                 bb.Min.x -= 0.5;
                 bb.Max.x += 0.5;
             }
-            float grab_paddingl = 2.0f;
             //Vertical fills from down upwards
             fill_br.Min = bb.Min;
             fill_br.Min.y = grab_bb.Min.y;
diff --git a/third-party/imgui/imgui_impl_glfw.cpp b/third-party/imgui/imgui_impl_glfw.cpp
index ca0b45b..cddf0b9 100644
--- a/third-party/imgui/imgui_impl_glfw.cpp
+++ b/third-party/imgui/imgui_impl_glfw.cpp
@@ -139,6 +139,9 @@ void ImGui_ImplGlFw_KeyCallback(GLFWwindow*, int key, int, int action, int mods)
     if (action == GLFW_RELEASE)
         io.KeysDown[key] = false;
 
+    if (mods && GLFW_MOD_CONTROL) io.KeysDown[GLFW_KEY_LEFT_CONTROL] = true;
+    else io.KeysDown[GLFW_KEY_LEFT_CONTROL] = false;
+
     (void)mods; // Modifiers are not reliable across systems
     io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];
     io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];
diff --git a/tools/convert/converters/converter-bin.hpp b/tools/convert/converters/converter-bin.hpp
index 54f4e48..4c0595f 100644
--- a/tools/convert/converters/converter-bin.hpp
+++ b/tools/convert/converters/converter-bin.hpp
@@ -44,8 +44,8 @@ namespace rs2 {
                             shift--;
                         }
 
-                        f = f - 1.0;
-                        uint32_t mantissa = f * ((1U << 23) + 0.5f);
+                        f = f - 1.f;
+                        uint32_t mantissa = uint32_t(f * ((1U << 23) + 0.5f));
                         uint32_t exponent = shift + ((1 << 7) - 1);
 
                         ieee754 = (sign << 31) | (exponent << 23) | mantissa;
diff --git a/tools/fw-logger/CMakeLists.txt b/tools/fw-logger/CMakeLists.txt
index 77dc526..8a762ca 100644
--- a/tools/fw-logger/CMakeLists.txt
+++ b/tools/fw-logger/CMakeLists.txt
@@ -5,16 +5,7 @@ cmake_minimum_required(VERSION 3.1.0)
 
 project(RealsenseToolsFirmwareLogger)
 
-add_executable(rs-fw-logger rs-fw-logger.cpp fw-log-data.cpp
-    fw-log-data.h
-    fw-logs-formating-options.cpp
-    fw-logs-formating-options.h
-    fw-logs-parser.cpp
-    fw-logs-parser.h
-    fw-logs-xml-helper.cpp
-    fw-logs-xml-helper.h
-    string-formatter.cpp
-    string-formatter.h)
+add_executable(rs-fw-logger rs-fw-logger.cpp)
 set_property(TARGET rs-fw-logger PROPERTY CXX_STANDARD 11)
 if(WIN32 OR ANDROID)
     target_link_libraries(rs-fw-logger ${DEPENDENCIES})
diff --git a/tools/fw-logger/readme.md b/tools/fw-logger/readme.md
index 127b844..1e3eb55 100644
--- a/tools/fw-logger/readme.md
+++ b/tools/fw-logger/readme.md
@@ -5,7 +5,13 @@
 If you are suspecting that you have an issue that is related to the cameras firmware, please use this tool and provide the output together with the FW version number when you are creating an issue.
 In order to run this, ensure that your camera is streaming. This can be done using the [realsense-viewer](https://github.com/IntelRealSense/librealsense/tree/development/tools/realsense-viewer) or [rs-capture Sample](https://github.com/IntelRealSense/librealsense/tree/development/examples/capture)
 
+## Command Line Parameters
+|Flag   |Description   |Default|
+|---|---|---|
+|`-l <xml-path>`|xml file ful path, used to parse the logs||
+|`-f`|collect flash logs instead of firmware logs||
+
 ## Usage
 After installing `librealsense` run `rs-fw-logger` to launch the tool. 
-rs-fw-logger  >  filename  will save the FW logs to the filename.
+
 
diff --git a/tools/fw-logger/rs-fw-logger.cpp b/tools/fw-logger/rs-fw-logger.cpp
index a906f96..6085f86 100644
--- a/tools/fw-logger/rs-fw-logger.cpp
+++ b/tools/fw-logger/rs-fw-logger.cpp
@@ -1,19 +1,19 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include <librealsense2/rs.hpp>
+#include "librealsense2/rs.hpp"
+#include "librealsense2/hpp/rs_internal.hpp"
 #include <fstream>
 #include <thread>
 #include "tclap/CmdLine.h"
-#include "fw-logs-parser.h"
+
 
 
 using namespace std;
 using namespace TCLAP;
-using namespace fw_logger;
 using namespace rs2;
 
-string hexify(unsigned char n)
+string char2hex(unsigned char n)
 {
     string res;
 
@@ -48,29 +48,24 @@ int main(int argc, char* argv[])
 {
     CmdLine cmd("librealsense rs-fw-logger example tool", ' ', RS2_API_VERSION_STR);
     ValueArg<string> xml_arg("l", "load", "Full file path of HW Logger Events XML file", false, "", "Load HW Logger Events XML file");
-    cmd.add(xml_arg);
+    SwitchArg flash_logs_arg("f", "flash", "Flash Logs Request", false);
+    cmd.add(xml_arg); 
+    cmd.add(flash_logs_arg);
     cmd.parse(argc, argv);
 
     log_to_file(RS2_LOG_SEVERITY_WARN, "librealsense.log");
-    // Obtain a list of devices currently present on the system
 
-    unique_ptr<fw_logs_parser> fw_log_parser;
     auto use_xml_file = false;
     auto xml_full_file_path = xml_arg.getValue();
-    if (!xml_full_file_path.empty())
-    {
-        ifstream f(xml_full_file_path);
-        if (f.good())
-        {
-            fw_log_parser = unique_ptr<fw_logs_parser>(new fw_logs_parser(xml_full_file_path));
-            use_xml_file = true;
-        }
-    }
+
+    bool are_flash_logs_requested = flash_logs_arg.isSet();
 
     context ctx;
     device_hub hub(ctx);
 
-    while (true)
+    bool should_loop_end = false;
+
+    while (!should_loop_end)
     {
         try
         {
@@ -78,47 +73,80 @@ int main(int argc, char* argv[])
             auto dev = hub.wait_for_device();
             cout << "RealSense device was connected...\n";
 
-            vector<uint8_t> input;
-            auto str_op_code = dev.get_info(RS2_CAMERA_INFO_DEBUG_OP_CODE);
-            auto op_code = static_cast<uint8_t>(stoi(str_op_code));
-            input = {0x14, 0x00, 0xab, 0xcd, op_code, 0x00, 0x00, 0x00,
-                     0xf4, 0x01, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00,
-                     0x00, 0x00, 0x00, 0x00, 0x00,    0x00, 0x00, 0x00};
-
-            cout << "Device Name: " << dev.get_info(RS2_CAMERA_INFO_NAME) << endl <<
-                    "Device Location: " << dev.get_info(RS2_CAMERA_INFO_PHYSICAL_PORT) << endl << endl;
-
             setvbuf(stdout, NULL, _IONBF, 0); // unbuffering stdout
 
-            while (hub.is_connected(dev))
+            auto fw_log_device = dev.as<rs2::firmware_logger>();
+
+            bool using_parser = false;
+            if (!xml_full_file_path.empty())
             {
-                this_thread::sleep_for(chrono::milliseconds(100));
+                ifstream f(xml_full_file_path);
+                if (f.good())
+                {
+                    std::string xml_content((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
+                    bool parser_initialized = fw_log_device.init_parser(xml_content);
+                    if (parser_initialized)
+                        using_parser = true;
+                }
+            }
 
-                auto raw_data = dev.as<debug_protocol>().send_and_receive_raw_data(input);
-                vector<string> fw_log_lines = {""};
-                if (raw_data.size() <= 4)
-                    continue;
+            bool are_there_remaining_flash_logs_to_pull = true;
 
-                if (use_xml_file)
+            while (hub.is_connected(dev))
+            {
+                if (are_flash_logs_requested && !are_there_remaining_flash_logs_to_pull)
                 {
-                    fw_logs_binary_data fw_logs_binary_data = {raw_data};
-                    fw_logs_binary_data.logs_buffer.erase(fw_logs_binary_data.logs_buffer.begin(),fw_logs_binary_data.logs_buffer.begin()+4);
-                    fw_log_lines = fw_log_parser->get_fw_log_lines(fw_logs_binary_data);
-                    for (auto& elem : fw_log_lines)
-                        elem = datetime_string() + "  " + elem;
+                    should_loop_end = true;
+                    break;
+                }
+                auto log_message = fw_log_device.create_message();
+                bool result = false;
+                if (are_flash_logs_requested)
+                {
+                    result = fw_log_device.get_flash_log(log_message);
                 }
                 else
                 {
-                    stringstream sstr;
-                    sstr << datetime_string() << "  FW_Log_Data:";
-                    for (size_t i = 0; i < raw_data.size(); ++i)
-                        sstr << hexify(raw_data[i]) << " ";
-
-                    fw_log_lines.push_back(sstr.str());
+                    result = fw_log_device.get_firmware_log(log_message);
+                }
+                if (result)
+                {
+                    std::vector<string> fw_log_lines;
+                    if (using_parser)
+                    {
+                        auto parsed_log = fw_log_device.create_parsed_message();
+                        bool parsing_result = fw_log_device.parse_log(log_message, parsed_log);
+                        
+                        stringstream sstr;
+                        sstr << parsed_log.timestamp() << " " << parsed_log.severity() << " " << parsed_log.message()
+                            << " " << parsed_log.thread_name() << " " << parsed_log.file_name()
+                            << " " << parsed_log.line();
+
+                        fw_log_lines.push_back(sstr.str());
+                    }
+                    else
+                    {
+                        stringstream sstr;
+                        sstr << log_message.get_timestamp();
+                        sstr << " " << log_message.get_severity_str();
+                        sstr << "  FW_Log_Data:";
+                        std::vector<uint8_t> msg_data = log_message.data();
+                        for (int i = 0; i < msg_data.size(); ++i)
+                        {
+                        sstr << char2hex(msg_data[i]) << " ";
+                        }
+                        fw_log_lines.push_back(sstr.str());
+                    }
+                    for (auto& line : fw_log_lines)
+                        cout << line << endl;
+                }
+                else
+                {
+                    if (are_flash_logs_requested)
+                    {
+                        are_there_remaining_flash_logs_to_pull = false;
+                    }
                 }
-
-                for (auto& line : fw_log_lines)
-                    cout << line << endl;
             }
         }
         catch (const error & e)
diff --git a/tools/realsense-viewer/CMakeLists.txt b/tools/realsense-viewer/CMakeLists.txt
index 5f44da8..fc0d4a6 100644
--- a/tools/realsense-viewer/CMakeLists.txt
+++ b/tools/realsense-viewer/CMakeLists.txt
@@ -114,7 +114,8 @@ if(WIN32)
         ${ELPP_FILES}
         ${CMAKE_CURRENT_SOURCE_DIR}/res/resource.h
         ${CMAKE_CURRENT_SOURCE_DIR}/res/realsense-viewer.rc
-        ../../common/windows-app-bootstrap.cpp)
+        ../../common/windows-app-bootstrap.cpp
+        )
 
     source_group("3rd Party" FILES
         ../../third-party/tinyfiledialogs/tinyfiledialogs.c
diff --git a/tools/realsense-viewer/realsense-viewer.cpp b/tools/realsense-viewer/realsense-viewer.cpp
index 6553d57..a1732ca 100644
--- a/tools/realsense-viewer/realsense-viewer.cpp
+++ b/tools/realsense-viewer/realsense-viewer.cpp
@@ -154,8 +154,6 @@ bool refresh_devices(std::mutex& m,
         return false;
     try
     {
-        auto prev_size = current_connected_devices.size();
-
         //Remove disconnected
         auto dev_itr = begin(current_connected_devices);
         while (dev_itr != end(current_connected_devices))
@@ -299,49 +297,18 @@ int main(int argc, const char** argv) try
     std::vector<device> connected_devs;
     std::mutex m;
 
-#ifdef BUILD_SHARED_LIBS
-    // Configure the logger
-    el::Configurations conf;
-    conf.set(el::Level::Global, el::ConfigurationType::Format, "[%level] %msg");
-    conf.set(el::Level::Info, el::ConfigurationType::Format, "%msg");
-    conf.set(el::Level::Debug, el::ConfigurationType::Enabled, "false");
-    el::Loggers::reconfigureLogger("default", conf);
-    // Create a dispatch sink which will get any messages logged to EasyLogging, which will then
-    // post the messages on the viewer's notification window.
-    class viewer_model_dispatcher : public el::LogDispatchCallback
-    {
-    public:
-        std::weak_ptr<notifications_model> notifications;  // only the default ctor is available to us...!
-    protected:
-        void handle(const el::LogDispatchData* data) noexcept override
-        {
-            // TODO align LRS and Easyloging severity levels. W/A for easylogging on Linux
-            if (data->logMessage()->level() > el::Level::Debug)
-            {
-                if (auto not_model = notifications.lock())
-                    not_model->add_log(
-                        data->logMessage()->logger()->logBuilder()->build(
-                        data->logMessage(),
-                        data->dispatchAction() == el::base::DispatchAction::NormalLog));
-            }
-        }
-    };
-    el::Helpers::installLogDispatchCallback< viewer_model_dispatcher >("viewer_model_dispatcher");
-    auto dispatcher = el::Helpers::logDispatchCallback< viewer_model_dispatcher >("viewer_model_dispatcher");
-    dispatcher->notifications = viewer_model.not_model;
-    el::Helpers::uninstallLogDispatchCallback< el::base::DefaultLogDispatchCallback >("DefaultLogDispatchCallback");
-#else
     std::weak_ptr<notifications_model> notifications = viewer_model.not_model;
      rs2::log_to_callback( RS2_LOG_SEVERITY_INFO,
         [notifications]( rs2_log_severity severity, rs2::log_message const& msg )
-         {
+        {
             if (auto not_model = notifications.lock())
-                not_model->add_log( msg.raw() );
-         } );
-#endif
+            {
+                not_model->output.add_log(severity, msg.filename(), msg.line_number(), msg.raw());
+            }
+        });
+
     window.on_file_drop = [&](std::string filename)
     {
-
         add_playback_device(ctx, *device_models, error_message, viewer_model, filename);
         if (!error_message.empty())
         {
@@ -553,7 +520,6 @@ int main(int argc, const char** argv) try
 
                     ImGui::SetCursorPosY(ImGui::GetCursorPosY() + 5);
 
-                    bool connect = false;
                     static char ip_input[255];
                     std::copy(ip_address.begin(), ip_address.end(), ip_input);
                     ip_input[ip_address.size()] = '\0';
@@ -638,9 +604,16 @@ int main(int argc, const char** argv) try
 
         viewer_model.show_top_bar(window, viewer_rect, *device_models);
 
-        viewer_model.show_event_log(window.get_font(), viewer_model.panel_width,
-            window.height() - (viewer_model.is_output_collapsed ? viewer_model.default_log_h : 20),
-            window.width() - viewer_model.panel_width, viewer_model.default_log_h);
+        auto output_rect = rect{ viewer_model.panel_width,
+            window.height() - viewer_model.get_output_height(),
+            window.width() - viewer_model.panel_width, viewer_model.get_output_height() };
+
+        std::vector<rs2::device> devices;
+        for (auto&& dev_model : *device_models)
+        {
+            devices.push_back(dev_model->dev);
+        }
+        viewer_model.not_model->output.draw(window, output_rect, devices);
 
         // Set window position and size
         ImGui::SetNextWindowPos({ 0, viewer_model.panel_y });
diff --git a/tools/rs-imu-calibration/README.md b/tools/rs-imu-calibration/README.md
index 7f2b3f0..533a2ef 100644
--- a/tools/rs-imu-calibration/README.md
+++ b/tools/rs-imu-calibration/README.md
@@ -30,7 +30,7 @@ The script runs you through the 6 main orientations of the camera.
 For each direction there are the following steps:
 *	**Rotation:**<br>
   *	The script prints the following line, describing how to orient the camera:<br>
-`Align to direction:  [ 0. -1.  0.]   Upright facing out`<br>
+`Align to direction:  [ 0. -1.  0.]   Mounting screw pointing down, device facing out`<br>
   *	Then it prints the status (rotate) and the difference from the desired orientation:<br>
   `Status.rotate:           [ 1.0157 -0.1037  0.9945]:                 [False False False]`<br>
   *	You have to bring the numbers to [0,0,0] and then you are in the right direction and the script moves on to the next status.<br><br>
@@ -60,6 +60,7 @@ Thats it. At the end a confirmation message appears:<br>
 `SUCCESS: saved calibration to camera.`
 
 **NOTICE:**<br>
+Press ESC key to abort the calibration process.
 CTRL-C isnt working so press CTRL-Z and then `kill -9 %1` if you want to terminate in the middle
 
 **Appendix A:**<br>
diff --git a/tools/rs-imu-calibration/rs-imu-calibration.py b/tools/rs-imu-calibration/rs-imu-calibration.py
index 211e66a..e9c16c6 100644
--- a/tools/rs-imu-calibration/rs-imu-calibration.py
+++ b/tools/rs-imu-calibration/rs-imu-calibration.py
@@ -17,6 +17,9 @@ import threading
 READ_TABLE  = 0x43     # READ_TABLE 0x243 0
 WRITE_TABLE = 0x44     # WRITE_TABLE 0 <table>
 
+# L515 minimum firmware version required to support IMU calibration
+L515_FW_VER_REQUIRED = '01.04.01.00'
+
 is_data = None
 get_key = None
 if os.name == 'posix':
@@ -540,6 +543,7 @@ def wait_for_rs_device(serial_no):
         now = int(round(time.time() * 1000))
     raise Exception('No RealSense device' + str('.' if len(serial_no) == 0 else ' with serial number: '+serial_no))
 
+
 def main():
     if any([help_str in sys.argv for help_str in ['-h', '--help', '/?']]):
         print("Usage:", sys.argv[0], "[Options]")
@@ -572,14 +576,28 @@ def main():
 
         product_line = dev.get_info(rs.camera_info.product_line)
 
+        if product_line == 'L500':
+            print('checking minimum firmware requirement ...')
+            fw_version = dev.get_info(rs.camera_info.firmware_version)
+            if fw_version < L515_FW_VER_REQUIRED:
+                raise Exception('L515 requires firmware ' + L515_FW_VER_REQUIRED + " or later to support IMU calibration. Please upgrade firmware and try again.")
+            else:
+                print('  firmware ' + fw_version + ' passed check.')
+
         buckets = [[0, -g,  0], [ g,  0, 0],
                 [0,  g,  0], [-g,  0, 0],
                 [0,  0, -g], [ 0,  0, g]]
 
-        buckets_labels = ["Upright facing out", "USB cable up facing out", "Upside down facing out", "USB cable pointed down", "Viewing direction facing down", "Viewing direction facing up"]
-
-        if product_line == 'L500':
-            buckets_labels = ["Mounting Screw Down facing out", "Mounting Screw Right facing out", "Mounting Screw Up facing out", "Mounting Screw Left facing out", "Viewing direction facing up", "Viewing direction facing down"]
+        # all D400 and L500 cameras with IMU equipped with a mounting screw at the bottom of the device
+        # when device is in normal use position upright facing out, mount screw is pointing down, aligned with positive Y direction in depth coordinate system
+        # IMU output on each of these devices is transformed into the depth coordinate system, i.e.,
+        # looking from back of the camera towards front, the positive x-axis points to the right, the positive y-axis points down, and the positive z-axis points forward.
+        # output of motion data is consistent with convention that positive direction aligned with gravity leads to -1g and opposite direction leads to +1g, for example,
+        # positive z_aixs points forward away from front glass of the device,
+        #  1) if place the device flat on a table, facing up, positive z-axis points up, z-axis acceleration is around +1g
+        #  2) facing down, positive z-axis points down, z-axis accleration would be around -1g
+        #
+        buckets_labels = ["Mounting screw pointing down, device facing out", "Mounting screw pointing left, device facing out", "Mounting screw pointing up, device facing out", "Mounting screw pointing right, device facing out", "Viewing direction facing down", "Viewing direction facing up"]
 
         gyro_bais = np.zeros(3, np.float32)
         old_settings = None
@@ -723,7 +741,7 @@ def main():
             print('Abort writing to device')
 
     except Exception as e:
-        print ('\nDone. %s' % e)
+        print ('\nError: %s' % e)
     finally:
         if os.name == 'posix' and old_settings is not None:
             termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)
diff --git a/unit-tests/CMakeLists.txt b/unit-tests/CMakeLists.txt
index 0b4b5fd..794edb5 100644
--- a/unit-tests/CMakeLists.txt
+++ b/unit-tests/CMakeLists.txt
@@ -29,6 +29,8 @@ set (unit_tests_sources
     unit-tests-main.cpp
     unit-tests-common.h
     unit-tests-post-processing-from-bag.cpp
+    catch.h
+    approx.h
 )
 
 add_executable(live-test ${unit_tests_sources})
@@ -136,14 +138,17 @@ endfunction()
 
 function(is_file_empty empty filename)
     set (data "")
-    if(EXISTS ${filename})
-        file(STRINGS  ${filename} data)
-    endif()
-    string(LENGTH "${data}" data_length)
-    #message(STATUS "Read ${data_length}  bytes from  ${filename}")
     set(res TRUE)
-    if (NOT ${data_length} STREQUAL "0")
-        set(res FALSE)
+    if(EXISTS ${filename})
+    	# Travis has CMake 3.5.1... no SIZE support!
+        #file(SIZE ${filename} data_length)
+        file(READ ${filename} data LIMIT 2 HEX)
+        string(LENGTH "${data}" data_length)
+        if (NOT ${data_length} STREQUAL "0")
+            set(res FALSE)
+	#else()
+        #    message(STATUS "${data_length}  bytes from  ${filename}")
+        endif()
     endif()
     set(empty ${res} PARENT_SCOPE)
 endfunction()
@@ -207,3 +212,6 @@ endforeach(i)
 if(NOT ${BUILD_SHARED_LIBS} AND ${BUILD_INTERNAL_UNIT_TESTS})
     add_subdirectory(internal)
 endif()
+
+include(algo/CMakeLists.txt)
+
diff --git a/unit-tests/algo/CMakeLists.txt b/unit-tests/algo/CMakeLists.txt
new file mode 100644
index 0000000..06f22af
--- /dev/null
+++ b/unit-tests/algo/CMakeLists.txt
@@ -0,0 +1,4 @@
+
+include(algo/dl_algo_file.cmake)
+#include(algo/d2rgb/CMakeLists.txt)
+
diff --git a/unit-tests/algo/algo-common.h b/unit-tests/algo/algo-common.h
new file mode 100644
index 0000000..0897069
--- /dev/null
+++ b/unit-tests/algo/algo-common.h
@@ -0,0 +1,27 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+//#include <librealsense2/rs.hpp>   // Include RealSense Cross Platform API
+
+#if ! defined( NO_CATCH_CONFIG_MAIN )
+#define CATCH_CONFIG_MAIN
+#endif
+#include "../catch.h"
+
+#include <easylogging++.h>
+#ifdef BUILD_SHARED_LIBS
+// With static linkage, ELPP is initialized by librealsense, so doing it here will
+// create errors. When we're using the shared .so/.dll, the two are separate and we have
+// to initialize ours if we want to use the APIs!
+INITIALIZE_EASYLOGGINGPP
+#endif
+
+#if defined( __ALGO_EPSILON )
+#define __EPSILON __ALGO_EPSILON
+// #else leave default
+#endif
+#include "../approx.h"
+
+#include "../trace.h"
diff --git a/unit-tests/algo/d2rgb/CMakeLists.txt b/unit-tests/algo/d2rgb/CMakeLists.txt
new file mode 100644
index 0000000..f832171
--- /dev/null
+++ b/unit-tests/algo/d2rgb/CMakeLists.txt
@@ -0,0 +1,391 @@
+
+set(D2RGB "depth-to-rgb-calibration/19.2.20")
+
+# F9440687
+set(F9440687 "${D2RGB}/F9440687/LongRange_D_768x1024_RGB_1920x1080")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yuy_prev_z_i.files" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/metadata" "" )
+
+dl_algo_file( "${F9440687}/2/YUY2_YUY2_1920x1080_00.00.26.6355_F9440687_0000.raw" "7e5fec4f8a3c50e8fe3d94f81778d816088af286" )
+dl_algo_file( "${F9440687}/2/YUY2_YUY2_1920x1080_00.00.26.7683_F9440687_0001.raw" "cf306ef25f934bce4694fda69c8b646efd9b7127" )
+dl_algo_file( "${F9440687}/2/Z_GrayScale_1024x768_00.00.26.7119_F9440687_0000.raw" "fefaae459cb9facae7362f44a66e865e0dc9967f" )
+dl_algo_file( "${F9440687}/2/I_GrayScale_1024x768_00.00.26.7119_F9440687_0000.raw" "ccbb7f8803414a89522f182ab04bc7d28b1b3281" )
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/depthEdgeWeightDistributionPerSectionDepth_4x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/edgeWeightDistributionPerSectionRgb_4x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/edgeWeightsPerDir_1x4_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/dilatedIm_1080x1920_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/IDiffMasked_1080x1920_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/ixMoveSuspect_1080x1920_uint8_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/logicEdges_1080x1920_uint8_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/diffIm_01_1080x1920_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/diffIm_1080x1920_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/costDiffPerSection_1x4_double_00.bin" "" )
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_10_1x12_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/p_matrix_iteration_13_1x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_1_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_2_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_3_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_4_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_5_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_6_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_7_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_8_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_9_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_10_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_11_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_12_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/cost_iteration_13_1x1_double_00.bin" "")
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_1_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_2_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_3_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_4_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_5_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_6_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_7_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_8_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_9_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_10_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_11_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_12_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uvmap_iteration_13_2506x2_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_1_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_2_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_3_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_4_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_5_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_6_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_7_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_8_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_9_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_10_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_11_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_12_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DVals_iteration_13_2506x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_1_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_2_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_3_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_4_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_5_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_6_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_7_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_8_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_9_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_10_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_11_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_12_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DxVals_iteration_13_2506x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_1_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_2_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_3_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_4_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_5_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_6_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_7_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_8_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_9_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_10_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_11_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_12_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DyVals_iteration_13_2506x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_1_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_2_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_3_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_4_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_5_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_6_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_7_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_8_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_9_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_10_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_11_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_12_2506x2_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xy_iteration_13_2506x2_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_1_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_2_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_3_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_4_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_5_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_6_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_7_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_8_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_9_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_10_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_11_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_12_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/rc_iteration_13_2506x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_1_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_2_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_3_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_4_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_5_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_6_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_7_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_8_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_9_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_10_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_11_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_12_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xCoeff_P_iteration_13_2506x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_1_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_2_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_3_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_4_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_5_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_6_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_7_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_8_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_9_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_10_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_11_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_12_2506x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yCoeff_P_iteration_13_2506x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_10_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_iteration_13_1x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_1_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_2_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_3_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_4_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_5_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_6_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_7_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_8_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_9_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_10_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_11_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_12_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grad_norma_iteration_13_1x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_10_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/grads_norm_iteration_13_1x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_10_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/normalized_grads_iteration_13_1x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_10_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/unit_grad_iteration_13_1x12_double_00.bin" "" )
+
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_1_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_2_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_3_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_4_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_5_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_6_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_7_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_8_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_9_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_10_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_11_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_12_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/t_iteration_13_1x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_1_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_2_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_3_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_4_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_5_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_6_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_7_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_8_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_9_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_10_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_11_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_12_1x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/back_tracking_line_iter_count_iteration_13_1x1_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_1_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_2_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_3_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_4_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_5_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_6_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_7_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_8_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_9_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_10_1x12_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_11_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_12_1x12_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_p_matrix_iteration_13_1x12_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_1_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_2_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_3_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_4_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_5_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_6_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_7_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_8_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_9_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_10_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_11_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_12_1x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/next_cost_iteration_13_1x1_double_00.bin" "")
+
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/new_calib_1x17_double_00.bin" "" )
+
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/camera_params" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Zx_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Zy_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Ix_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Iy_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/iEdge_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/zEdge_768x1024_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/sectionMapDepth_768x1024_uint8_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/sectionMapDepthInside_2506x1_uint8_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validEdgePixelsByIR_768x1024_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/gridXValid_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/gridYValid_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/locRC_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/sectionMapValid_105794x1_uint8_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/IxValid_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/IyValid_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/directionInDeg_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/dirPerPixel_105794x2_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validdirPerPixel_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_105794x2_double_01.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_105794x2_double_02.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_105794x2_double_03.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_x_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_x_105794x1_double_01.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_x_105794x1_double_02.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_x_105794x1_double_03.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_y_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_y_105794x1_double_01.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_y_105794x1_double_02.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localRegion_y_105794x1_double_03.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localEdges_105794x4_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/isSupressed_105794x1_uint8_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/fraqStep_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/locRCsub_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localZx_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localZy_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/zGrad_105794x2_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validzGradInDirection_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/localZvalues_105794x4_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/edgeSubPixel_105794x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validzValuesForSubEdges_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validEdgePixels_105794x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validsectionMapDepth_4259x1_uint8_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validdirectionIndex_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/validedgeSubPixel_4259x2_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/xim_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/yim_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/subPoints_4259x3_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/uv_4259x2_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/isInside_4259x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Z_xim_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/Z_yim_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/zValuesForSubEdges_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/zGradInDirection_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/directionIndexInside_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/weights_2506x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/vertices_2506x3_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/svm_edgeWeightDistributionPerSectionDepth_4x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/svm_edgeWeightDistributionPerSectionRgb_4x1_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/svm_edgeWeightsPerDir_1x4_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/svm_featuresMat_1x10_double_00.bin" "")
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/svm_improvementPerSection_1x4_double_00.bin" "")
+
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/dsmRegsOrig_1x4_single_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/relevantPixelsImage_768x1024_uint8_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/round_xim_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/round_yim_2506x1_double_00.bin" "" )
+dl_algo_file( "${F9440687}/2/binFiles/ac1x/DSM_params" "" )
diff --git a/unit-tests/algo/d2rgb/ac-logger.h b/unit-tests/algo/d2rgb/ac-logger.h
new file mode 100644
index 0000000..872cd2c
--- /dev/null
+++ b/unit-tests/algo/d2rgb/ac-logger.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include <librealsense2/h/rs_types.h>  // rs2_log_severity
+#include <string>
+#include <iostream>
+#include <easylogging++.h>
+#include "../../../src/algo/depth-to-rgb-calibration/debug.h"
+
+
+// This logger will catch all the realsense logs and output them to the
+// screen
+class ac_logger
+{
+    struct dispatch : public el::LogDispatchCallback
+    {
+        bool * _p_on;
+        
+        void handle( const el::LogDispatchData* data ) noexcept override
+        {
+            if( !*_p_on )
+                return;
+            char const * raw = data->logMessage()->message().data();
+            if( !strncmp( AC_LOG_PREFIX, raw, AC_LOG_PREFIX_LEN ) )
+            {
+                std::cout << "-" << *el::LevelHelper::convertToString( data->logMessage()->level() ) << "- ";
+                std::cout << (raw + AC_LOG_PREFIX_LEN) << std::endl;
+            }
+        }
+    };
+
+    bool _on;
+
+public:
+    explicit ac_logger( bool on = true )
+        : _on( on )
+    {
+        el::Loggers::getLogger( "librealsense" );
+
+        el::Helpers::installLogDispatchCallback< dispatch >( "our_dispatch" );
+        auto dispatcher = el::Helpers::logDispatchCallback< dispatch >( "our_dispatch" );
+        dispatcher->_p_on = &_on;
+        el::Helpers::uninstallLogDispatchCallback< el::base::DefaultLogDispatchCallback >( "DefaultLogDispatchCallback" );
+    }
+
+    void enable( bool on = true ) { _on = on; }
+
+};
diff --git a/unit-tests/algo/d2rgb/compare-scene.h b/unit-tests/algo/d2rgb/compare-scene.h
new file mode 100644
index 0000000..e6c59a6
--- /dev/null
+++ b/unit-tests/algo/d2rgb/compare-scene.h
@@ -0,0 +1,742 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+
+struct scene_stats
+{
+    size_t n_valid_scene, n_valid_scene_diff;
+    size_t n_valid_result, n_valid_result_diff;
+    size_t n_converged, n_converged_diff;
+    double cost, d_cost;
+    double movement, d_movement;
+};
+
+void compare_vertices_to_los_data( std::string const & scene_dir,
+                                   size_t num_of_vertices,
+                                   size_t cycle,
+                                   std::string const & time,
+                                   algo::convert_norm_vertices_to_los_data const & data )
+{
+
+    CHECK(compare_to_bin_file< algo::double3 >(
+        data.laser_incident,
+        scene_dir,
+        bin_file(time + "laserIncidentDirection", cycle, 3, 1, "double_00.bin")));
+
+    CHECK(compare_to_bin_file< algo::double3 >(
+        data.fovex_indicent_direction,
+        scene_dir,
+        bin_file(time + "fovexIndicentDirection", cycle, 3, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< algo::double3 >(
+        data.mirror_normal_direction,
+        scene_dir,
+        bin_file(time + "mirrorNormalDirection", cycle, 3, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.ang_x,
+        scene_dir,
+        bin_file(time + "angX", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.ang_y,
+        scene_dir,
+        bin_file(time + "angY", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.dsm_x_corr,
+        scene_dir,
+        bin_file(time + "dsmXcorr", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.dsm_y_corr,
+        scene_dir,
+        bin_file(time + "dsmYcorr", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.dsm_x,
+        scene_dir,
+        bin_file(time + "dsmX", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+
+    CHECK(compare_to_bin_file< double >(
+        data.dsm_y,
+        scene_dir,
+        bin_file(time + "dsmY", cycle, 1, num_of_vertices, "double_00") + ".bin",
+        num_of_vertices, 1,
+        compare_same_vectors));
+}
+
+void compare_scene( std::string const & scene_dir, scene_stats * stats = nullptr )
+{
+    TRACE( "Loading " << scene_dir << " ..." );
+
+    camera_params ci = read_camera_params( scene_dir, "camera_params" );
+    dsm_params dsm = read_dsm_params(scene_dir, "DSM_params");
+    ci.dsm_params = dsm.dsm_params;
+    ci.cal_info = dsm.regs;
+    ci.cal_regs = dsm.algo_calibration_registers;
+
+    scene_metadata md( scene_dir );
+
+    algo::optimizer cal;
+
+    /*std::vector<double> in = { 1,2,3,4 };
+    std::vector<double>out(4);
+
+    algo::direct_inv(in,out,2);*/
+
+    init_algo( cal, scene_dir,
+        md.rgb_file,
+        md.rgb_prev_file,
+        md.ir_file,
+        md.z_file,
+        ci );
+
+    auto& z_data = cal.get_z_data();
+    auto& ir_data = cal.get_ir_data();
+    auto& yuy_data = cal.get_yuy_data();
+    auto& depth_data = cal.get_z_data();
+    auto& decision_params = cal.get_decision_params();
+    auto& svm_features = cal.get_extracted_features();
+    
+    auto rgb_h = ci.rgb.height;
+    auto rgb_w = ci.rgb.width;
+    auto z_h = ci.z.height;
+    auto z_w = ci.z.width;
+    auto num_of_calib_elements = 22;
+    auto num_of_p_matrix_elements = sizeof(algo::p_matrix) / sizeof(double);
+    auto num_of_k_matrix_elements = sizeof(algo::k_matrix) / sizeof(double);
+
+    //---
+    CHECK(compare_to_bin_file< uint8_t >(yuy_data.lum_frame, scene_dir, "YUY2_lum", rgb_w, rgb_h, "uint8_00", compare_same_vectors));
+    CHECK( compare_to_bin_file< double >( yuy_data.edges, scene_dir, "YUY2_edge", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDT, scene_dir, "YUY2_IDT", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTx, scene_dir, "YUY2_IDTx", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTy, scene_dir, "YUY2_IDTy", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+
+    // smearing
+    CHECK(compare_to_bin_file< double >(depth_data.gradient_x, scene_dir, "Zx", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.gradient_y, scene_dir, "Zy", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.gradient_x, scene_dir, "Ix", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.gradient_y, scene_dir, "Iy", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.edges, scene_dir, "iEdge", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.edges, scene_dir, "zedge", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(depth_data.section_map_depth, scene_dir, "sectionMapDepth", z_w, z_h, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_edge_pixels_by_ir, scene_dir, "validEdgePixelsByIR", z_w, z_h, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc_x, scene_dir, "gridXValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc_y, scene_dir, "gridYValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc, scene_dir, "locRC", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(ir_data.valid_section_map, scene_dir, "sectionMapValid", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_gradient_x, scene_dir, "IxValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.valid_gradient_y, scene_dir, "IyValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.direction_deg, scene_dir, "directionInDeg", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.direction_per_pixel, scene_dir, "dirPerPixel", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region[0], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region[1], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_01", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region[2], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_02", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region[3], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_03", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[0], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[1], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_01", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[2], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_02", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[3], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_03", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[0], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[1], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_01", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[2], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_02", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[3], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_03", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.local_edges, scene_dir, "localEdges", 4, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(ir_data.is_supressed, scene_dir, "isSupressed", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(ir_data.fraq_step, scene_dir, "fraqStep", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.local_rc_subpixel, scene_dir, "locRCsub", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.local_x, scene_dir, "localZx", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.local_y, scene_dir, "localZy", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.gradient, scene_dir, "zGrad", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.grad_in_direction, scene_dir, "zGradInDirection", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.local_values, scene_dir, "localZvalues", 4, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.closest, scene_dir, "zValuesForSubEdges", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.edge_sub_pixel, scene_dir, "edgeSubPixel", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
+    
+    CHECK(compare_to_bin_file< byte >(depth_data.supressed_edges, scene_dir, "validEdgePixels", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.grad_in_direction_valid, scene_dir, "validzGradInDirection", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >( depth_data.valid_edge_sub_pixel, scene_dir, "validedgeSubPixel", 2, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >( depth_data.values_for_subedges, scene_dir, "validzValuesForSubEdges", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.valid_direction_per_pixel, scene_dir, "validdirPerPixel", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(depth_data.valid_section_map, scene_dir, "validsectionMapDepth", 1, md.n_valid_pixels, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.valid_directions, scene_dir, "validdirectionIndex", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    
+    //CHECK(compare_to_bin_file< double >(depth_data.valid_edge_sub_pixel_x, scene_dir, "xim", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    //CHECK(compare_to_bin_file< double >(depth_data.valid_edge_sub_pixel_y, scene_dir, "yim", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double>(depth_data.sub_points, scene_dir, "subPoints", 3, md.n_valid_pixels, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< algo::double2 >(depth_data.uvmap, scene_dir, bin_file("uv", 2, md.n_valid_pixels, "double_00") + ".bin", md.n_valid_pixels, 1, compare_same_vectors));
+    CHECK(compare_to_bin_file< byte >(depth_data.is_inside, scene_dir, "isInside", 1, md.n_valid_pixels, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.subpixels_x, scene_dir, "Z_xim", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.subpixels_y, scene_dir, "Z_yim", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.directions, scene_dir, "directionIndexInside", 1, md.n_edges, "double_00", compare_same_vectors));
+    
+    CHECK(compare_to_bin_file< double >(depth_data.subpixels_x_round, scene_dir, "round_xim", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.subpixels_y_round, scene_dir, "round_yim", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(depth_data.weights, scene_dir, "weights", 1, md.n_edges, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(depth_data.relevant_pixels_image, scene_dir, "relevantPixelsImage", z_w, z_h, "uint8_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< algo::double3 >(depth_data.vertices, scene_dir, bin_file("vertices", 3, md.n_edges, "double_00") + ".bin", md.n_edges, 1, compare_same_vectors));
+    CHECK(compare_to_bin_file< uint8_t >(depth_data.section_map_depth_inside, scene_dir, "sectionMapDepthInside", 1, md.n_edges, "uint8_00", compare_same_vectors));
+
+
+    // ---
+    TRACE( "\nChecking scene validity:" );
+
+    bool const is_scene_valid = cal.is_scene_valid();
+    bool const matlab_scene_valid = md.is_scene_valid;
+    CHECK( is_scene_valid == matlab_scene_valid );
+    if( stats )
+    {
+        stats->n_valid_scene = is_scene_valid;
+        stats->n_valid_scene_diff = is_scene_valid != matlab_scene_valid;
+    }
+
+    // edge distribution
+    CHECK( compare_to_bin_file< double >( z_data.sum_weights_per_section, scene_dir, "depthEdgeWeightDistributionPerSectionDepth", 1, 4, "double_00", compare_same_vectors ) );
+
+    //CHECK( compare_to_bin_file< byte >( z_data.section_map, scene_dir, "sectionMapDepth_trans", 1, md.n_edges, "uint8_00", compare_same_vectors ) );
+    //CHECK( compare_to_bin_file< byte >( yuy_data.section_map, scene_dir, "sectionMapRgb_trans", 1, rgb_w*rgb_h, "uint8_00", compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >( yuy_data.sum_weights_per_section, scene_dir, "edgeWeightDistributionPerSectionRgb", 1, 4, "double_00", compare_same_vectors ) );
+
+    // gradient balanced
+    // TODO NOHA
+    CHECK(compare_to_bin_file< double >(z_data.sum_weights_per_direction, scene_dir, "edgeWeightsPerDir", 4, 1, "double_00", compare_same_vectors));
+
+    // movment check
+    // 1. dilation
+    CHECK( compare_to_bin_file< uint8_t >( yuy_data.prev_logic_edges, scene_dir, "logicEdges", rgb_w, rgb_h, "uint8_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.dilated_image, scene_dir, "dilatedIm", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+
+    // 2. gausssian
+    CHECK( compare_to_bin_file< double >( yuy_data.yuy_diff, scene_dir, "diffIm_01", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.gaussian_filtered_image, scene_dir, "diffIm", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+
+    // 3. movement
+    CHECK( compare_to_bin_file< double >( yuy_data.gaussian_diff_masked, scene_dir, "IDiffMasked", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( yuy_data.move_suspect, scene_dir, "ixMoveSuspect", rgb_w, rgb_h, "uint8_00", compare_same_vectors ) );
+
+    //--
+    TRACE( "\nOptimizing:" );
+
+    auto cb = [&]( algo::data_collect const & data )
+    {
+        // data.iteration_data_p is 0-based!
+        //REQUIRE( data.iteration_data_p < md.n_iterations );
+
+        //REQUIRE( data.cycle <= md.n_cycles );
+
+        if (data.type == algo::k_to_dsm_data)
+        {
+            std::cout << std::endl << "COMPARING K_TO_DSM DATA " << data.cycle_data_p.cycle << std::endl;
+            algo::k_matrix old_k = data.k2dsm_data_p.inputs.old_k;
+            algo::k_matrix new_k = data.k2dsm_data_p.inputs.new_k;
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(old_k.k_mat.rot),
+                    std::end(old_k.k_mat.rot)),
+                scene_dir,
+                bin_file("k2dsm_inpus_oldKdepth",
+                    data.cycle_data_p.cycle,
+                    num_of_k_matrix_elements,
+                    1,
+                    "double_00.bin"),
+                num_of_k_matrix_elements, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(new_k.k_mat.rot),
+                    std::end(new_k.k_mat.rot)),
+                scene_dir,
+                bin_file("k2dsm_inpus_newKdepth",
+                    data.cycle_data_p.cycle,
+                    num_of_k_matrix_elements,
+                    1,
+                    "double_00.bin"),
+                num_of_k_matrix_elements, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double3 >(
+                data.k2dsm_data_p.inputs.z.vertices,
+                scene_dir,
+                bin_file("k2dsm_inpus_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                std::vector< algo::double2 >(1, { data.k2dsm_data_p.inputs.previous_dsm_params.h_scale, data.k2dsm_data_p.inputs.previous_dsm_params.v_scale }),
+                scene_dir,
+                bin_file("k2dsm_inpus_acData", data.cycle_data_p.cycle, 2, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+
+            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
+                data.k2dsm_data_p.inputs.new_dsm_regs,
+                scene_dir,
+                bin_file("k2dsm_inpus_dsmRegs", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
+
+
+            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
+                data.k2dsm_data_p.dsm_regs_orig,
+                scene_dir,
+                bin_file("dsmRegsOrig", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< uint8_t >(
+                data.k2dsm_data_p.relevant_pixels_image_rot,
+                scene_dir,
+                bin_file("relevantPixelnImage_rot", data.cycle_data_p.cycle, z_w, z_h, "uint8_00") + ".bin",
+                z_w, z_h,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::los_shift_scaling >(
+                data.k2dsm_data_p.dsm_pre_process_data.last_los_error,
+                scene_dir,
+                bin_file("dsm_los_error_orig", data.cycle_data_p.cycle, 1, 4, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< algo::double3 >(
+                data.k2dsm_data_p.dsm_pre_process_data.vertices_orig,
+                scene_dir,
+                bin_file("verticesOrig", data.cycle_data_p.cycle, 3, md.n_relevant_pixels, "double_00") + ".bin",
+                md.n_relevant_pixels, 1, compare_same_vectors));
+
+
+            compare_vertices_to_los_data(scene_dir, md.n_relevant_pixels, data.cycle_data_p.cycle, "first_", data.k2dsm_data_p.first_norm_vertices_to_los_data);
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.dsm_pre_process_data.los_orig,
+                scene_dir,
+                bin_file("losOrig", data.cycle_data_p.cycle, 2, md.n_relevant_pixels, "double_00") + ".bin",
+                md.n_relevant_pixels, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.k2dsm_data_p.errL2,
+                scene_dir,
+                bin_file("errL2", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.errL2.size(), "double_00") + ".bin",
+                data.k2dsm_data_p.errL2.size(), 1, compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.focal_scaling,
+                scene_dir,
+                bin_file("focalScaling", data.cycle_data_p.cycle, 2, 1, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< std::vector<double>>(
+                data.k2dsm_data_p.sg_mat,
+                scene_dir,
+                bin_file("sgMat", data.cycle_data_p.cycle, data.k2dsm_data_p.sg_mat[0].size(), data.k2dsm_data_p.sg_mat.size(), "double_00") + ".bin",
+                data.k2dsm_data_p.sg_mat.size(), data.k2dsm_data_p.sg_mat[0].size(),
+                data.k2dsm_data_p.sg_mat.size(),
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.k2dsm_data_p.sg_mat_tag_x_sg_mat,
+                scene_dir,
+                bin_file("sg_mat_tag_x_sg_mat", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(), "double_00") + ".bin",
+                data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(), 1, compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.k2dsm_data_p.sg_mat_tag_x_err_l2,
+                scene_dir,
+                bin_file("sg_mat_tag_x_err_l2", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(), "double_00") + ".bin",
+                data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(), 1, compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.k2dsm_data_p.quad_coef,
+                scene_dir,
+                bin_file("quadCoef", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.quad_coef.size(), "double_00") + ".bin",
+                data.k2dsm_data_p.quad_coef.size(), 1, compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.opt_scaling,
+                scene_dir,
+                bin_file("optScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.new_los_scaling,
+                scene_dir,
+                bin_file("newlosScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                std::vector< algo::double2 >(1, { data.k2dsm_data_p.dsm_params_cand.h_scale, data.k2dsm_data_p.dsm_params_cand.v_scale }),
+                scene_dir,
+                bin_file("acDataCand", data.cycle_data_p.cycle, 2, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
+                 data.k2dsm_data_p.dsm_regs_cand,
+                 scene_dir,
+                 bin_file("dsmRegsCand", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
+
+            compare_vertices_to_los_data(scene_dir, md.n_edges, data.cycle_data_p.cycle, "second_", data.k2dsm_data_p.second_norm_vertices_to_los_data);
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.los_orig,
+                scene_dir,
+                bin_file("orig_los", data.cycle_data_p.cycle, 2, md.n_edges, "double_00") + ".bin",
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.dsm,
+                scene_dir,
+                bin_file("dsm", data.cycle_data_p.cycle, 2, md.n_edges, "double_00") + ".bin",
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double3 >(
+                data.k2dsm_data_p.vertices,
+                scene_dir,
+                bin_file("new_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            TRACE("\nSet next cycle data from Matlab:");
+        }
+        else if (data.type == algo::cycle_data)
+        {
+            std::cout << std::endl << "COMPARING CYCLE DATA " << data.cycle_data_p.cycle << std::endl;
+
+            algo::k_matrix k_depth;
+            k_depth.k_mat.rot[0] = data.cycle_data_p.new_k_depth.fx;
+            k_depth.k_mat.rot[2] = data.cycle_data_p.new_k_depth.ppx;
+            k_depth.k_mat.rot[4] = data.cycle_data_p.new_k_depth.fy;
+            k_depth.k_mat.rot[5] = data.cycle_data_p.new_k_depth.ppy;
+
+            CHECK(compare_to_bin_file< algo::k_matrix >(
+                k_depth,
+                scene_dir,
+                bin_file("end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin")));
+
+            CHECK(compare_to_bin_file< algo::p_matrix >(
+                data.cycle_data_p.new_params.curr_p_mat,
+                scene_dir,
+                bin_file("end_cycle_p_matrix", data.cycle_data_p.cycle, num_of_p_matrix_elements, 1, "double_00.bin")));
+
+            try
+            {
+
+               /* auto vertices = read_vector_from<algo::double3>(bin_file(bin_dir(scene_dir) + "end_cycle_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"));
+
+                algo::p_matrix p_mat;
+
+                auto p_vec = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_cycle_p_matrix",
+                    data.cycle_data_p.cycle,
+                    num_of_p_matrix_elements, 1,
+                    "double_00.bin"));
+                std::copy(p_vec.begin(), p_vec.end(), p_mat.vals);
+
+                auto dsm_regs_vec = read_vector_from< algo::algo_calibration_registers >(
+                    bin_file(bin_dir(scene_dir) + "end_cycle_dsmRegsCand", data.cycle_data_p.cycle, 4, 1, "double_00.bin"));
+
+                algo::algo_calibration_registers dsm_regs = *(algo::algo_calibration_registers*)(dsm_regs_vec.data());
+                auto ac_data_vec = read_vector_from< algo::double2 >(bin_file(bin_dir(scene_dir) + "end_cycle_acData", data.cycle_data_p.cycle, 2, 1, "double_00.bin"));
+                
+                algo::rs2_dsm_params_double dsm_params;
+                dsm_params.h_scale = ac_data_vec[0].x;
+                dsm_params.v_scale = ac_data_vec[0].y;
+                dsm_params.model = RS2_DSM_CORRECTION_AOT;*/
+
+                //auto Kdepth = read_vector_from<algo::matrix_3x3>(bin_file(bin_dir(scene_dir) + "end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin"));
+                //cal.set_cycle_data(vertices, k_depth, p_mat, dsm_regs, dsm_params);
+            }
+            catch (std::runtime_error &e) {
+                // if device isn't calibrated, get_extrinsics must error out (according to old comment. Might not be true under new API)
+                WARN(e.what());
+            }
+        }
+        else if(data.type == algo::iteration_data)
+        {
+            std::cout << std::endl << "COMPARING ITERATION DATA " << data.cycle_data_p.cycle <<" "<< data.iteration_data_p.iteration + 1 << std::endl;
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(data.iteration_data_p.params.curr_p_mat.vals),
+                    std::end(data.iteration_data_p.params.curr_p_mat.vals)),
+                scene_dir,
+                bin_file("p_matrix_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements,
+                    1,
+                    "double_00.bin"),
+                num_of_p_matrix_elements, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(1, data.iteration_data_p.params.cost),
+                scene_dir,
+                bin_file("cost_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.iteration_data_p.uvmap,
+                scene_dir,
+                bin_file("uvmap_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 2, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.iteration_data_p.d_vals,
+                scene_dir,
+                bin_file("DVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.iteration_data_p.d_vals_x,
+                scene_dir,
+                bin_file("DxVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.iteration_data_p.d_vals_y,
+                scene_dir,
+                bin_file("DyVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::double2 >(
+                data.iteration_data_p.xy,
+                scene_dir,
+                bin_file("xy_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 2, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                data.iteration_data_p.rc,
+                scene_dir,
+                bin_file("rc_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::p_matrix >(data.iteration_data_p.coeffs_p.x_coeffs,
+                scene_dir,
+                bin_file("xCoeff_P_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, md.n_edges,
+                    "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< algo::p_matrix >(data.iteration_data_p.coeffs_p.y_coeffs,
+                scene_dir,
+                bin_file("yCoeff_P_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, md.n_edges,
+                    "double_00.bin"),
+                md.n_edges, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(data.iteration_data_p.params.calib_gradients.vals),
+                    std::end(data.iteration_data_p.params.calib_gradients.vals)),
+                scene_dir,
+                bin_file("grad_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, 1,
+                    "double_00.bin"),
+                num_of_p_matrix_elements, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(1, data.iteration_data_p.grads_norma),
+                scene_dir,
+                bin_file("grad_norma_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(data.iteration_data_p.grads_norm.vals),
+                    std::end(data.iteration_data_p.grads_norm.vals)),
+                scene_dir,
+                bin_file("grads_norm_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, 1,
+                    "double_00.bin"),
+                num_of_p_matrix_elements, 1,
+                compare_same_vectors));
+
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(data.iteration_data_p.normalized_grads.vals),
+                    std::end(data.iteration_data_p.normalized_grads.vals)),
+                scene_dir,
+                bin_file("normalized_grads_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, 1,
+                    "double_00.bin"),
+                num_of_p_matrix_elements, 1,
+                compare_same_vectors));
+
+
+            CHECK(
+                compare_to_bin_file< double >(std::vector< double >(std::begin(data.iteration_data_p.unit_grad.vals),
+                    std::end(data.iteration_data_p.unit_grad.vals)),
+                    scene_dir,
+                    bin_file("unit_grad_iteration",
+                        data.cycle_data_p.cycle,
+                        data.iteration_data_p.iteration + 1,
+                        num_of_p_matrix_elements, 1,
+                        "double_00.bin"),
+                    num_of_p_matrix_elements, 1,
+                    compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(1, data.iteration_data_p.t),
+                scene_dir,
+                bin_file("t_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(1, data.iteration_data_p.back_tracking_line_search_iters),
+                scene_dir,
+                bin_file("back_tracking_line_iter_count_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    1, 1,
+                    "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(std::begin(data.iteration_data_p.next_params.curr_p_mat.vals),
+                    std::end(data.iteration_data_p.next_params.curr_p_mat.vals)),
+                scene_dir,
+                bin_file("next_p_matrix_iteration",
+                    data.cycle_data_p.cycle,
+                    data.iteration_data_p.iteration + 1,
+                    num_of_p_matrix_elements, 1,
+                    "double_00.bin"),
+                num_of_p_matrix_elements, 1,
+                compare_same_vectors));
+
+            CHECK(compare_to_bin_file< double >(
+                std::vector< double >(1, data.iteration_data_p.next_params.cost),
+                scene_dir,
+                bin_file("next_cost_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
+                1, 1,
+                compare_same_vectors));
+        }
+       
+    };
+
+    // Our code doesn't count the first iteration; the Matlab code starts at 1 even if it doesn't do anything...
+    //REQUIRE( cal.optimize( cb ) + 1 == md.n_iterations );
+    cal.optimize( cb );
+
+    
+    auto new_calibration = cal.get_calibration();
+    auto cost = cal.get_cost();
+    
+    auto filename = bin_file( "new_calib", num_of_calib_elements, 1, "double_00" ) + ".bin";
+    TRACE( "Comparing " << filename << " ..." );
+    algo::calib matlab_calib;
+    double matlab_cost = 0;
+    CHECK( get_calib_from_raw_data( matlab_calib, matlab_cost, scene_dir, filename ) );
+    CHECK( compare_calib( new_calibration, cost, matlab_calib, matlab_cost ));
+    new_calibration.copy_coefs(matlab_calib);
+    if( stats )
+    {
+        stats->cost = cost;
+        stats->d_cost = cost - matlab_cost;
+    }
+
+
+#if 1
+    auto vertices = read_vector_from<algo::double3>(bin_file(bin_dir(scene_dir) + "end_vertices", 3, md.n_edges, "double_00.bin"));
+
+
+    if( stats )
+    {
+        auto our_uvmap = algo::get_texture_map( depth_data.vertices, new_calibration, new_calibration.calc_p_mat() );
+        auto matlab_uvmap = algo::get_texture_map( vertices, matlab_calib, matlab_calib.calc_p_mat() );
+
+        stats->d_movement = cal.calc_correction_in_pixels( our_uvmap, matlab_uvmap );
+    }
+
+
+    algo::p_matrix p_mat;
+
+    auto p_vec = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_p_matrix",
+        num_of_p_matrix_elements, 1,
+        "double_00.bin"));
+
+    std::copy(p_vec.begin(), p_vec.end(), p_mat.vals);
+
+    algo::p_matrix p_mat_opt;
+
+    auto p_vec_opt = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_p_matrix_opt",
+        num_of_p_matrix_elements, 1,
+        "double_00.bin"));
+
+    std::copy(p_vec_opt.begin(), p_vec_opt.end(), p_mat_opt.vals);
+
+    cal.set_final_data(vertices, p_mat, p_mat_opt);
+    //--
+    TRACE( "\nChecking output validity:" );
+    // Pixel movement is OK, but some sections have negative cost
+    bool const is_valid_results = cal.is_valid_results();
+    bool const matlab_valid_results = md.is_output_valid;
+    CHECK( is_valid_results == matlab_valid_results );
+    if( stats )
+    {
+        stats->n_valid_result = is_valid_results;
+        stats->n_valid_result_diff = is_valid_results != matlab_valid_results;
+
+        stats->n_converged = is_valid_results && is_scene_valid;
+        bool const matlab_converged = matlab_valid_results && matlab_scene_valid;
+        stats->n_converged_diff = bool(stats->n_converged) != matlab_converged;
+    }
+
+    double const movement_in_pixels = cal.calc_correction_in_pixels(new_calibration);
+    double const matlab_movement_in_pixels = md.correction_in_pixels;
+    CHECK( movement_in_pixels == approx( matlab_movement_in_pixels ) );
+    if( stats )
+    {
+        stats->movement = movement_in_pixels;
+        //stats->d_movement = movement_in_pixels - matlab_movement_in_pixels;
+    }
+
+    CHECK( compare_to_bin_file< double >( z_data.cost_diff_per_section, scene_dir, "costDiffPerSection", 4, 1, "double_00", compare_same_vectors ) );
+
+    //svm - remove xyMovementFromOrigin because its still not implemented
+    auto svm_features_mat = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "svm_featuresMat",
+        10, 1,
+        "double_00.bin"));
+
+    svm_features_mat.erase(svm_features_mat.begin() + 7);
+    auto svm_mat = svm_features;
+    svm_mat.erase(svm_mat.begin()+7);
+   
+    CHECK(compare_same_vectors(svm_features_mat, svm_mat));
+
+    //CHECK(compare_to_bin_file< double >(svm_features, scene_dir, "svm_featuresMat", 10, 1, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(decision_params.distribution_per_section_depth, scene_dir, "svm_edgeWeightDistributionPerSectionDepth", 1, 4, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(decision_params.distribution_per_section_rgb, scene_dir, "svm_edgeWeightDistributionPerSectionRgb", 1, 4, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(decision_params.edge_weights_per_dir, scene_dir, "svm_edgeWeightsPerDir", 4, 1, "double_00", compare_same_vectors));
+    CHECK(compare_to_bin_file< double >(decision_params.improvement_per_section, scene_dir, "svm_improvementPerSection", 4, 1, "double_00", compare_same_vectors));
+#endif
+}
diff --git a/unit-tests/algo/d2rgb/compare-to-bin-file.h b/unit-tests/algo/d2rgb/compare-to-bin-file.h
new file mode 100644
index 0000000..ed63013
--- /dev/null
+++ b/unit-tests/algo/d2rgb/compare-to-bin-file.h
@@ -0,0 +1,415 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <type_traits>
+
+
+//
+// In all the following:
+//     F = the type in the bin files, i.e. the "golden" value that we compare to
+//     D = the type in memory, i.e. the result of our own computations
+// Since approx compares approximately to a "golden", the golden needs to go to
+// approx!
+//
+
+
+template< typename F, typename D >
+bool is_equal_approximetly( F fx, D dx, bool print = true)
+{
+    return dx == approx( fx );
+}
+
+template< typename D>
+bool compare_and_trace(D val_matlab, D val_cpp, std::string const & compared)
+{
+    if (val_cpp != approx(val_matlab))
+    {
+        AC_LOG(DEBUG, "... " << std::setprecision(16) << compared << ":  {matlab} " << val_matlab << " !~ " << val_cpp << " {cpp}");
+        return false;
+    }
+    return true;
+}
+
+template<>
+bool is_equal_approximetly<algo::k_matrix, algo::k_matrix>( algo::k_matrix fx, algo::k_matrix dx, bool print)
+{
+    bool ok = true;
+
+    ok = compare_and_trace(dx.get_fx(), fx.get_fx(), "fx");
+    ok = compare_and_trace(dx.get_fy(), fx.get_fy(), "fy");
+    ok = compare_and_trace(dx.get_ppx(), fx.get_ppx(), "ppx");
+    ok = compare_and_trace(dx.get_ppy(), fx.get_ppy(), "ppy");
+
+    return ok;
+}
+
+template<>
+bool is_equal_approximetly<algo::rotation_in_angles, algo::rotation_in_angles>( algo::rotation_in_angles fx, algo::rotation_in_angles dx, bool print)
+{
+    return dx.alpha == approx( fx.alpha ) &&
+        dx.beta == approx( fx.beta ) &&
+        dx.gamma == approx( fx.gamma );
+}
+
+template<>
+bool is_equal_approximetly<algo::p_matrix, algo::p_matrix>( algo::p_matrix fx, algo::p_matrix dx, bool print)
+{
+    for( auto i = 0; i < 12; i++ )
+    {
+        if( dx.vals[i] != approx( fx.vals[i] ) )
+            return false;
+    }
+    return true;
+}
+
+template<>
+bool is_equal_approximetly<std::vector<double>, std::vector<double>>(std::vector<double> fx, std::vector<double> dx, bool print)
+{
+    if(fx.size() != dx.size())
+        return false;
+
+    for (auto i = 0; i < fx.size(); i++)
+    {
+        if (dx[i] != approx(fx[i]))
+            return false;
+    }
+    return true;
+}
+
+template<>
+bool is_equal_approximetly<algo::double2, algo::double2>(algo::double2 f, algo::double2 d, bool print)
+{
+    if (print)
+    {
+        bool ok = true;
+        ok &= compare_and_trace(d.x, f.x, "x");
+        ok &= compare_and_trace(d.y, f.y, "y");
+
+        return ok;
+    }
+
+    return d.x == approx(f.x) && d.y == approx(f.y);
+}
+
+template<>
+bool is_equal_approximetly<algo::double3, algo::double3>(algo::double3 f, algo::double3 d, bool print)
+{
+    if (print)
+    {
+        bool ok = true;
+        ok &= compare_and_trace(d.x, f.x, "x");
+        ok &= compare_and_trace(d.y, f.y, "y");
+        ok &= compare_and_trace(d.z, f.z, "z");
+
+        return ok;
+    }
+
+    return d.x == approx(f.x) && d.y == approx(f.y) && d.z == approx(f.z);
+}
+
+template<>
+bool is_equal_approximetly<algo::algo_calibration_registers, algo::algo_calibration_registers>(algo::algo_calibration_registers f, algo::algo_calibration_registers d, bool print)
+{
+    bool ok = true;
+
+    ok &= compare_and_trace(d.EXTLdsmXoffset, f.EXTLdsmXoffset, "Xoffset");
+    ok &= compare_and_trace(d.EXTLdsmXscale, f.EXTLdsmXscale, "Xscale");
+    ok &= compare_and_trace(d.EXTLdsmYoffset, f.EXTLdsmYoffset, "Yoffset");
+    ok &= compare_and_trace(d.EXTLdsmYscale, f.EXTLdsmYscale, "Yscale");
+
+    return ok;
+}
+
+template<>
+bool is_equal_approximetly<algo::los_shift_scaling, algo::los_shift_scaling>(algo::los_shift_scaling f, algo::los_shift_scaling d, bool print)
+{
+    bool ok = true;
+
+    ok &= compare_and_trace(d.los_scaling_x, f.los_scaling_x, "los_scaling_x");
+    ok &= compare_and_trace(d.los_scaling_y, f.los_scaling_y, "los_scaling_y");
+    ok &= compare_and_trace(d.los_shift_x, f.los_shift_x, "los_shift_x");
+    ok &= compare_and_trace(d.los_shift_y, f.los_shift_y, "los_shift_y");
+
+    return ok;
+}
+template< typename F, typename D >
+void print( size_t x, F f, D d, bool is_approx = false )
+{
+    // bytes will be written to stdout as characters, which we never want... hence '+fx'
+    AC_LOG( DEBUG, "... " << AC_D_PREC << x << ": {matlab}" << +f << (is_approx ? " !~ " : " != ") << +d << "{c++}" );
+}
+
+template<>
+void print<algo::k_matrix, algo::k_matrix>( size_t x, algo::k_matrix f, algo::k_matrix d, bool is_approx )
+{
+    // bytes will be written to stdout as characters, which we never want... hence '+fx'
+    AC_LOG( DEBUG, "... " << AC_D_PREC << std::fixed << x << ": {matlab}" << f.get_fx() << " " << f.get_fy() << " " << f.get_ppx() << " " << f.get_ppy() << (is_approx ? " !~ " : " != ")
+        << d.get_fx() << " " << d.get_fy() << " " << d.get_ppx() << " " << d.get_ppy() << "{c++}" );
+}
+
+template<>
+void print<algo::double2, algo::double2>( size_t x, algo::double2 f, algo::double2 d, bool is_approx )
+{
+    // bytes will be written to stdout as characters, which we never want... hence '+fx'
+    AC_LOG( DEBUG, "... " << AC_D_PREC << std::fixed << x << ": {matlab}" << f.x << " " << f.y << (is_approx ? " !~ " : " != ")
+        << d.x << " " << d.y << "{c++}" );
+}
+
+template<>
+void print<algo::double3, algo::double3>( size_t x, algo::double3 f, algo::double3 d, bool is_approx )
+{
+    // bytes will be written to stdout as characters, which we never want... hence '+fx'
+    AC_LOG( DEBUG, "... " << std::setprecision( 15 ) << std::fixed << x << ": {matlab}" << f.x << " " << f.y << " " << f.z << (is_approx ? " !~ " : " != ")
+        << d.x << " " << d.y << " " << d.z << "{c++}" );
+}
+
+template<>
+void print<algo::rotation_in_angles, algo::rotation_in_angles>( size_t x, algo::rotation_in_angles f, algo::rotation_in_angles d, bool is_approx )
+{
+    // bytes will be written to stdout as characters, which we never want... hence '+fx'
+    AC_LOG( DEBUG, "... " << std::setprecision( 15 ) << x << ": {matlab}" << f.alpha << " " << f.beta << " " << f.gamma << (is_approx ? " !~ " : " != ")
+        << d.alpha << " " << d.beta << " " << d.gamma << "{c++}" );
+}
+
+template<>
+void print<algo::p_matrix, algo::p_matrix>( size_t x, algo::p_matrix f, algo::p_matrix d, bool is_approx )
+{
+    std::ostringstream s;
+
+    for( auto i = 0; i < 12; i++ )
+    {
+        if( !is_equal_approximetly( f.vals[i], d.vals[i] ) )
+        {
+            s << i << ": " << std::setprecision( 15 ) << std::fixed << ": {matlab}" << f.vals[i] << (is_approx ? " !~ " : " != ");
+            s << std::setprecision( 15 ) << "{c++}" << d.vals[i] << "\n";
+        }
+
+    }
+
+    AC_LOG( DEBUG, "... " << std::setprecision( 15 ) << std::fixed << x << " " << s.str() );
+}
+
+template<>
+void print<std::vector<double>, std::vector<double>>(size_t x, std::vector<double> f, std::vector<double> d, bool is_approx)
+{
+    std::ostringstream s;
+
+    for (auto i = 0; i < f.size(); i++)
+    {
+        if (!is_equal_approximetly(f[i], d[i]))
+        {
+            s << i << ": " << std::setprecision(15) << std::fixed << ": {matlab}" << f[i] << (is_approx ? " !~ " : " != ");
+            s << std::setprecision(15) << "{c++}" << d[i] << "\n";
+        }
+
+    }
+
+    AC_LOG(DEBUG, "... " << std::setprecision(15) << std::fixed << x << " " << s.str());
+}
+
+template<
+    typename F, typename D,
+    typename std::enable_if< !std::numeric_limits< D >::is_exact && !std::is_enum< D >::value, int >::type = 0
+>
+bool compare_t( F f, D d , bool print = true)
+{
+    return is_equal_approximetly( f, d, print);
+}
+
+template< typename F, typename D,
+    typename std::enable_if< std::numeric_limits< D >::is_exact || std::is_enum< D >::value, int >::type = 0
+>
+bool compare_t( F f, D d, bool print = false)
+{
+    return f == d;
+}
+
+
+template< typename F, typename D >
+bool compare_same_vectors( std::vector< F > const & matlab, std::vector< D > const & cpp )
+{
+    assert( matlab.size() == cpp.size() );
+    size_t n_mismatches = 0;
+    size_t size = matlab.size();
+    for( size_t x = 0; x < size; ++x )
+    {
+        F fx = matlab[x];
+        D dx = cpp[x];
+        if( !compare_t( fx, dx, false ) )
+        {
+            if( ++n_mismatches <= 5 )
+                print( x, fx, dx, std::is_floating_point< F >::value );
+        }
+    }
+    if( n_mismatches )
+        AC_LOG( DEBUG, "... " << n_mismatches << " mismatched values of " << size );
+    return (n_mismatches == 0);
+}
+
+template< typename F, typename D >  // F=in bin; D=in memory
+bool compare_to_bin_file(
+    std::vector< D > const & vec,
+    std::string const & scene_dir,
+    std::string const & filename,
+    size_t width, size_t height,
+    size_t size,
+    bool( *compare_vectors )(std::vector< F > const &, std::vector< D > const &) = nullptr
+)
+{
+    TRACE( "Comparing " << filename << " ..." );
+    bool ok = true;
+    auto bin = read_vector_from< F >(bin_dir(scene_dir) + filename, width, height);
+    if( bin.size() != size)
+        TRACE( filename << ": {matlab size}" << bin.size() << " != {width}" << width << "x" << height << "{height}" ), ok = false;
+    if( vec.size() != bin.size() )
+        TRACE( filename << ": {c++ size}" << vec.size() << " != " << bin.size() << "{matlab size}" ), ok = false;
+    else
+    {
+        auto v = vec;
+        auto b = bin;
+
+        if( compare_vectors && !(*compare_vectors)(b, v) )
+            ok = false;
+        if( !ok )
+        {
+            //dump_vec( vec, bin, filename, width, height );
+            //AC_LOG( DEBUG, "... dump of file written to: " << filename << ".dump" );
+        }
+    }
+    return ok;
+}
+
+template< typename F, typename D >  // F=in bin; D=in memory
+bool compare_to_bin_file(
+    std::vector< D > const & vec,
+    std::string const & scene_dir,
+    std::string const & filename,
+    size_t width, size_t height,
+    bool(*compare_vectors)(std::vector< F > const &, std::vector< D > const &) = nullptr
+)
+{
+    return compare_to_bin_file(vec, scene_dir, filename, width, height, width*height, compare_vectors);
+}
+
+template< typename F, typename D >  // F=in bin; D=in memory
+bool compare_to_bin_file(
+    std::vector< D > const & vec,
+    std::string const & scene_dir,
+    const char * prefix,
+    size_t width, size_t height,
+    const char * suffix,
+    bool( *compare_vectors )(std::vector< F > const &, std::vector< D > const &) = nullptr
+   
+)
+{
+    return compare_to_bin_file< F, D >( vec,
+        scene_dir, bin_file( prefix, width, height, suffix ) + ".bin",
+        height, width,
+        compare_vectors);
+}
+
+
+bool get_calib_from_raw_data(
+    algo::calib& calib,
+    double& cost,
+    std::string const & scene_dir,
+    std::string const & filename
+)
+{
+    auto data_size = sizeof( algo::matrix_3x3 ) +
+        sizeof( algo::translation ) +
+        sizeof( algo::matrix_3x3 ) +
+        sizeof( double ); // cost
+
+    auto bin = read_vector_from< double >( bin_dir( scene_dir ) + filename );
+    if( bin.size() * sizeof( double ) != data_size )
+    {
+        AC_LOG( DEBUG, "... " << filename << ": {matlab size}" << bin.size() * sizeof(double) << " != " << data_size );
+        return false;
+    }
+
+    auto data = bin.data();
+
+    algo::matrix_3x3 k = *(algo::matrix_3x3*)(data);
+    data += sizeof( algo::matrix_3x3) / sizeof( double );
+    auto r = *(algo::matrix_3x3*)(data);
+    data += sizeof( algo::matrix_3x3 ) / sizeof( double );
+    auto t = *(algo::translation*)(data);
+    data += sizeof( algo::translation ) / sizeof( double );
+    cost = *(double*)(data);
+
+    calib.k_mat = algo::k_matrix( k );
+    calib.rot = r;
+    calib.trans = t;
+    
+    return true;
+}
+
+bool compare_calib( algo::calib const & calib,
+                    double cost,
+                    algo::calib calib_from_file,
+                    double cost_matlab )
+{
+    auto intr_matlab = calib_from_file.get_intrinsics();
+    auto extr_matlab = calib_from_file.get_extrinsics();
+    
+    auto intr_cpp = calib.get_intrinsics();
+    auto extr_cpp = calib.get_extrinsics();
+    
+    bool ok = true;
+
+    ok &= compare_and_trace( cost_matlab, cost, "cost" );
+
+    ok &= compare_and_trace( intr_matlab.fx, intr_cpp.fx, "fx" );
+    ok &= compare_and_trace( intr_matlab.fy, intr_cpp.fy, "fy" );
+    ok &= compare_and_trace( intr_matlab.ppx, intr_cpp.ppx, "ppx" );
+    ok &= compare_and_trace( intr_matlab.ppy, intr_cpp.ppy, "ppy" );
+
+    for( auto i = 0; i < 9; i++ )
+        ok &= compare_and_trace( extr_matlab.rotation[i], extr_cpp.rotation[i], "rotation[" + std::to_string( i ) + "]" );
+
+    for( auto i = 0; i < 3; i++ )
+        ok &= compare_and_trace( extr_matlab.translation[i], extr_cpp.translation[i], "translation[" + std::to_string( i ) + "]" );
+
+    return ok;
+}
+
+
+bool operator==(const algo::algo_calibration_registers& first, const algo::algo_calibration_registers& second)
+{
+    bool ok = true;
+
+    ok &= compare_and_trace(first.EXTLdsmXoffset, second.EXTLdsmXoffset, "dsm_x_offset");
+    ok &= compare_and_trace(first.EXTLdsmYoffset, second.EXTLdsmYoffset, "dsm_y_offset");
+    ok &= compare_and_trace(first.EXTLdsmXscale, second.EXTLdsmXscale, "dsm_x_scale");
+    ok &= compare_and_trace(first.EXTLdsmYscale, second.EXTLdsmYscale, "dsm_y_scale");
+
+    return ok;
+}
+
+bool operator==(const algo::los_shift_scaling& first, const algo::los_shift_scaling& second)
+{
+    bool ok = true;
+
+    ok &= compare_and_trace(first.los_scaling_x, second.los_scaling_x, "los_scaling_x");
+    ok &= compare_and_trace(first.los_scaling_y, second.los_scaling_y, "los_scaling_y");
+    ok &= compare_and_trace(first.los_shift_x, second.los_shift_x, "los_shift_x");
+    ok &= compare_and_trace(first.los_shift_y, second.los_shift_y, "los_shift_x");
+
+    return ok;
+}
+template< typename D>  // F=in bin; D=in memory
+bool compare_to_bin_file(
+    D const & obj_cpp,
+    std::string const & scene_dir,
+    std::string const & filename
+)
+{
+    TRACE("Comparing " << filename << " ...");
+    bool ok = true;
+    auto obj_matlab = read_from< D >(bin_dir(scene_dir) + filename);
+
+    return compare_t(obj_matlab, obj_cpp);
+}
\ No newline at end of file
diff --git a/unit-tests/algo/d2rgb/d2rgb-common.h b/unit-tests/algo/d2rgb/d2rgb-common.h
new file mode 100644
index 0000000..e21232e
--- /dev/null
+++ b/unit-tests/algo/d2rgb/d2rgb-common.h
@@ -0,0 +1,49 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include "../algo-common.h"
+#include "../../../src/algo/depth-to-rgb-calibration/optimizer.h"
+#include "scene-data.h"
+#include "../../../src/algo/depth-to-rgb-calibration/k-to-dsm.h"
+#include "../../../src/algo/depth-to-rgb-calibration/utils.h"
+#include "../../../src/algo/depth-to-rgb-calibration/uvmap.h"
+
+
+#include "ac-logger.h"
+ac_logger LOG_TO_STDOUT;
+
+
+namespace algo = librealsense::algo::depth_to_rgb_calibration;
+using librealsense::to_string;
+
+
+
+void init_algo( algo::optimizer & cal,
+    std::string const & dir,
+    std::string const & yuy,
+    std::string const & yuy_prev,
+    std::string const & ir,
+    std::string const & z,
+    camera_params const & camera
+)
+{
+    algo::calib calibration( camera.rgb, camera.extrinsics );
+
+    cal.set_yuy_data(
+        read_image_file< algo::yuy_t >( dir + yuy, camera.rgb.width, camera.rgb.height ),
+        read_image_file< algo::yuy_t >( dir + yuy_prev, camera.rgb.width, camera.rgb.height ),
+        calibration
+    );
+
+    cal.set_ir_data(
+        read_image_file< algo::ir_t >( dir + ir, camera.z.width, camera.z.height ),
+        camera.z.width, camera.z.height
+    );
+
+    cal.set_z_data(
+        read_image_file< algo::z_t >( dir + z, camera.z.width, camera.z.height ),
+        camera.z, camera.dsm_params, camera.cal_info, camera.cal_regs, camera.z_units
+    );
+}
diff --git a/unit-tests/algo/d2rgb/scene-data.h b/unit-tests/algo/d2rgb/scene-data.h
new file mode 100644
index 0000000..58813b6
--- /dev/null
+++ b/unit-tests/algo/d2rgb/scene-data.h
@@ -0,0 +1,337 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+// Utilities to read from/write to algo scene directories
+
+#include <fstream>
+#include <string>
+#include "../../../src/algo/depth-to-rgb-calibration/k-to-dsm.h"
+
+inline std::string bin_dir( std::string const & scene_dir )
+{
+    return scene_dir + "binFiles\\ac2\\";
+}
+
+
+std::string bin_file( std::string const &prefix, size_t cycle, size_t iteration, size_t w, size_t h, std::string const &suffix )
+{
+    return prefix + '_' + std::to_string( cycle ) + '_' + std::to_string( iteration ) + '_'
+         + std::to_string( h ) + "x" + std::to_string( w ) + "_" + suffix;
+}
+
+std::string bin_file(std::string const &prefix, size_t cycle, size_t w, size_t h, std::string const &suffix)
+{
+    return prefix + '_' + std::to_string(cycle) + '_'
+        + std::to_string(h) + "x" + std::to_string(w) + "_" + suffix;
+}
+std::string bin_file( std::string const &prefix, size_t w, size_t h, std::string const &suffix )
+{
+    return prefix + "_" + std::to_string( h ) + "x" + std::to_string( w ) + "_" + suffix;
+}
+
+
+template< typename T >
+void read_data_from( std::string const & filename, T * data )
+{
+    std::fstream f = std::fstream( filename, std::ios::in | std::ios::binary );
+    if( !f )
+        throw std::runtime_error( "failed to read file:\n" + filename );
+    f.seekg( 0, f.end );
+    size_t cb = f.tellg();
+    f.seekg( 0, f.beg );
+    if( cb != sizeof( T ) )
+        throw std::runtime_error( librealsense::to_string()
+            << "file size (" << cb << ") does not match data size (" << sizeof( T ) << "): " << filename );
+    std::vector< T > vec( cb / sizeof( T ) );
+    f.read( (char *)data, cb );
+    f.close();
+}
+
+template< typename T >
+ T read_from(std::string const & filename)
+{
+    std::fstream f = std::fstream(filename, std::ios::in | std::ios::binary);
+    if (!f)
+        throw std::runtime_error("failed to read file:\n" + filename);
+    f.seekg(0, f.end);
+    size_t cb = f.tellg();
+    f.seekg(0, f.beg);
+    if (cb % sizeof(T))
+        throw std::runtime_error("file size is not a multiple of data size");
+    T obj;
+    f.read((char *)&obj, cb);
+    f.close();
+    return obj;
+}
+
+template< typename T >
+std::vector< T > read_vector_from( std::string const & filename, size_t size_x = 0, size_t size_y = 0)
+{
+    std::fstream f = std::fstream( filename, std::ios::in | std::ios::binary );
+    if( !f )
+        throw std::runtime_error( "failed to read file:\n" + filename );
+    f.seekg( 0, f.end );
+    size_t cb = f.tellg();
+    f.seekg( 0, f.beg );
+    if( cb % sizeof( T ) )
+        throw std::runtime_error( "file size is not a multiple of data size" );
+    std::vector< T > vec( cb / sizeof( T ) );
+    f.read( (char *)vec.data(), cb );
+    f.close();
+    return vec;
+}
+
+template<>
+std::vector< std::vector<double> > read_vector_from(std::string const & filename, size_t size_x, size_t size_y)
+{
+    std::vector< std::vector<double> > res;
+    
+    std::fstream f = std::fstream(filename, std::ios::in | std::ios::binary);
+    if (!f)
+        throw std::runtime_error("failed to read file:\n" + filename);
+    f.seekg(0, f.end);
+    size_t cb = f.tellg();
+    f.seekg(0, f.beg);
+    if (cb % sizeof(double))
+        throw std::runtime_error("file size is not a multiple of data size");
+
+    res.resize(size_x);
+
+    for (size_t i = 0; i < size_x; i++)
+    {
+        res[i].resize(size_y);
+        f.read((char *)res[i].data(), size_y * sizeof(double));
+    }
+    f.close();
+    //for(auto i=0;i<)
+    return res;
+
+    /*std::fstream f = std::fstream(filename, std::ios::in | std::ios::binary);
+    if (!f)
+        throw std::runtime_error("failed to read file:\n" + filename);
+    f.seekg(0, f.end);
+    size_t cb = f.tellg();
+    f.seekg(0, f.beg);
+    if (cb % sizeof(T))
+        throw std::runtime_error("file size is not a multiple of data size");
+    std::vector< T > vec(cb / sizeof(T));
+    f.read((char *)vec.data(), cb);
+    f.close();
+    return vec;*/
+}
+template < class T >
+std::vector< T > read_image_file( std::string const &file, size_t width, size_t height )
+{
+    std::ifstream f;
+    f.open( file, std::ios::in | std::ios::binary );
+    if( !f.good() )
+        throw std::runtime_error( "invalid file: " + file );
+    f.seekg( 0, f.end );
+    size_t cb = f.tellg();
+    f.seekg( 0, f.beg );
+    if( cb != sizeof( T ) * width * height )
+        throw std::runtime_error( librealsense::to_string()
+            << "file size (" << cb << ") does not match expected size (" << sizeof( T ) * width * height << "): " << file );
+    std::vector< T > data( width * height );
+    f.read( (char *)data.data(), width * height * sizeof( T ) );
+    return data;
+}
+
+template < typename T >
+void dump_vec( std::vector< double > const & cpp, std::vector< T > const & matlab,
+    char const * basename,
+    size_t width, size_t height
+)
+{
+    std::string filename = basename;
+    filename += ".dump";
+#if 0
+    std::fstream f = std::fstream( filename, std::ios::out );
+    if( !f )
+        throw std::runtime_error( "failed to write file:\n" + filename );
+    for( size_t x = )
+        std::vector< T > vec( cb / sizeof( T ) );
+    f.read( (char*)vec.data(), cb );
+    f.close();
+    return vec;
+#endif
+}
+
+// This metadata describes what Matlab did: the files it used (sometimes there are more) and the
+// iteration data/results that we need for comparison
+struct scene_metadata
+{
+    //uint64_t n_iterations;  // how many steps through optimization, and how many iteration file sets
+    uint64_t n_cycles;            // how many cycles of optimization
+    double correction_in_pixels;  // XY movement
+    uint64_t n_edges;             // strong edges, i.e. after suppression
+    uint64_t n_valid_pixels;
+    uint64_t n_relevant_pixels;
+    uint64_t n_valid_ir_edges;
+    bool is_scene_valid;
+    bool is_output_valid;
+    std::string rgb_file;
+    std::string rgb_prev_file;  // TODO: looks like these need to be turned around!!!
+    std::string ir_file;
+    std::string z_file;
+
+    scene_metadata( std::string const &scene_dir )
+    {
+        std::ifstream( bin_dir( scene_dir ) + "yuy_prev_z_i.files" ) >> rgb_file >>
+        rgb_prev_file >> z_file >> ir_file;
+        if( rgb_file.empty() )
+            throw std::runtime_error( "failed to read file:\n" + bin_dir( scene_dir ) + "yuy_prev_z_i.files" );
+
+        std::string metadata = bin_dir( scene_dir ) + "metadata";
+        std::fstream f = std::fstream( metadata, std::ios::in | std::ios::binary );
+        if( !f )
+            throw std::runtime_error( "failed to read file:\n" + metadata );
+        f.read( (char *)&correction_in_pixels, sizeof( correction_in_pixels ) );
+        f.read( (char *)&n_edges, sizeof( n_edges ) );
+        f.read( (char *)&n_valid_ir_edges, sizeof( n_valid_ir_edges ) );
+        f.read( (char *)&n_valid_pixels, sizeof( n_valid_pixels ) );
+        f.read((char *)&n_relevant_pixels, sizeof(n_relevant_pixels));
+        f.read( (char *)&n_cycles, sizeof( n_cycles ) );
+        byte b;
+        f.read( (char *)&b, 1 );
+        is_scene_valid = b;
+        f.read( (char *)&b, 1 );
+        is_output_valid = b;
+        f.close();
+    }
+};
+
+
+// Encapsulate the calibration information for a specific camera
+// All the sample images we use are usually from the same camera. I.e., their
+// intrinsics & extrinsics are the same and can be reused via this structure
+struct camera_params
+{
+    librealsense::algo::depth_to_rgb_calibration::rs2_intrinsics_double rgb;
+    librealsense::algo::depth_to_rgb_calibration::rs2_intrinsics_double z;
+    rs2_dsm_params dsm_params;
+    librealsense::algo::depth_to_rgb_calibration::algo_calibration_info cal_info;
+    librealsense::algo::depth_to_rgb_calibration::algo_calibration_registers cal_regs;
+    librealsense::algo::depth_to_rgb_calibration::rs2_extrinsics_double extrinsics;
+    float z_units = 0.25;
+};
+
+camera_params read_camera_params( std::string const &scene_dir, std::string const &filename )
+{
+    struct params_bin
+    {
+        // Some units are supposed to be int but we made matlab write out doubles....
+        double depth_width;
+        double depth_height;
+        double depth_units;
+        librealsense::algo::depth_to_rgb_calibration::matrix_3x3 k_depth;
+        double rgb_width;
+        double rgb_height;
+        librealsense::algo::depth_to_rgb_calibration::matrix_3x3 k_rgb;
+        double coeffs[5];
+        double matrix_3x3[9];
+        double translation[3];
+        double p_mat[12];
+    };
+
+    params_bin param;
+    read_data_from( bin_dir( scene_dir ) + filename, &param );
+
+    double coeffs[5] = { 0 };
+    camera_params ci;
+    ci.rgb =
+    {
+        int( param.rgb_width ), int( param.rgb_height ),
+        param.k_rgb,
+        RS2_DISTORTION_BROWN_CONRADY,
+        param.coeffs
+    };
+    ci.z =
+    {
+        int( param.depth_width ), int( param.depth_height ),
+        param.k_depth,
+        RS2_DISTORTION_NONE, coeffs
+    };
+    ci.extrinsics =
+    {
+        { param.matrix_3x3[0], param.matrix_3x3[1], param.matrix_3x3[2],
+            param.matrix_3x3[3], param.matrix_3x3[4], param.matrix_3x3[5],
+            param.matrix_3x3[6], param.matrix_3x3[7], param.matrix_3x3[8] },
+        { param.translation[0], param.translation[1], param.translation[2] }
+    };
+    return ci;
+}
+
+struct dsm_params
+{
+    rs2_dsm_params dsm_params;
+    librealsense::algo::depth_to_rgb_calibration::algo_calibration_registers algo_calibration_registers;
+    librealsense::algo::depth_to_rgb_calibration::algo_calibration_info regs;
+};
+
+dsm_params read_dsm_params(std::string const &scene_dir, std::string const &filename)
+{
+    dsm_params res;
+
+#pragma pack(push, 1)
+    struct algo_calibration
+    {
+        uint8_t fovexExistenceFlag;
+        float fovexNominal[4];
+        float laserangleH;
+        float laserangleV;
+        float xfov[5];
+        float yfov[5];
+        float polyVars[3];
+        float undistAngHorz[4];
+        float pitchFixFactor;
+
+    };
+#pragma pack(pop)
+
+    rs2_dsm_params dsm_params;
+    librealsense::algo::depth_to_rgb_calibration::algo_calibration_registers algo_calibration_registers;
+    algo_calibration algo_calib;
+
+    std::string dsmparams = bin_dir( scene_dir ) + filename;
+    std::fstream f = std::fstream(dsmparams, std::ios::in | std::ios::binary );
+    if( !f )
+        throw std::runtime_error( "failed to read file:\n" + dsmparams);
+    f.read( (char *)&dsm_params, sizeof(rs2_dsm_params) );
+    f.read((char *)&algo_calibration_registers, sizeof(librealsense::algo::depth_to_rgb_calibration::algo_calibration_registers));
+    f.read((char *)&algo_calib, sizeof(algo_calibration));
+
+    f.close();
+
+    res.dsm_params = dsm_params;
+    res.algo_calibration_registers = algo_calibration_registers;
+
+
+    res.regs.FRMWfovexExistenceFlag = algo_calib.fovexExistenceFlag;
+
+    for (auto i = 0; i < 4; i++)
+    {
+        res.regs.FRMWfovexNominal[i] = algo_calib.fovexNominal[i];
+        res.regs.FRMWundistAngHorz[i] = algo_calib.undistAngHorz[i];
+    }
+    
+    res.regs.FRMWlaserangleH = algo_calib.laserangleH;
+    res.regs.FRMWlaserangleV = algo_calib.laserangleV;
+
+    for (auto i = 0; i < 5; i++)
+    {
+        res.regs.FRMWxfov[i] = algo_calib.xfov[i];
+        res.regs.FRMWyfov[i] = algo_calib.yfov[i];
+    }
+   
+    for (auto i = 0; i < 3; i++)
+    {
+        res.regs.FRMWpolyVars[i] = algo_calib.polyVars[i];
+    }
+   
+    res.regs.FRMWpitchFixFactor = algo_calib.pitchFixFactor;
+
+    return res;
+}
diff --git a/unit-tests/algo/d2rgb/test-reproduction.cpp b/unit-tests/algo/d2rgb/test-reproduction.cpp
new file mode 100644
index 0000000..f9eb2ef
--- /dev/null
+++ b/unit-tests/algo/d2rgb/test-reproduction.cpp
@@ -0,0 +1,173 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+//#cmake:add-file ../../../src/algo/depth-to-rgb-calibration/*.cpp
+
+
+#ifndef BUILD_SHARED_LIBS
+#include <easylogging++.h>
+INITIALIZE_EASYLOGGINGPP
+#endif
+
+
+// We have our own main
+#define NO_CATCH_CONFIG_MAIN
+//#define CATCH_CONFIG_RUNNER
+
+#include "d2rgb-common.h"
+
+//INITIALIZE_EASYLOGGINGPP
+
+
+template< typename T >
+void read_binary_file( char const * dir, char const * bin, T * data )
+{
+    std::string filename = dir;
+    filename += "\\";
+    filename += bin;
+    AC_LOG( DEBUG, "... " << filename );
+    std::fstream f = std::fstream( filename, std::ios::in | std::ios::binary );
+    if( ! f )
+        throw std::runtime_error( "failed to read file:\n" + filename );
+    f.seekg( 0, f.end );
+    size_t cb = f.tellg();
+    f.seekg( 0, f.beg );
+    if( cb != sizeof( T ) )
+        throw std::runtime_error( to_string()
+            << "file size (" << cb << ") does not match data size (" << sizeof(T) << "): " << filename );
+    std::vector< T > vec( cb / sizeof( T ));
+    f.read( (char*) data, cb );
+    f.close();
+}
+
+struct old_algo_calib
+{
+    algo::matrix_3x3 rot;
+    algo::translation trans;
+    double __fx, __fy, __ppx, __ppy;  // not in new calib!
+    algo::k_matrix k_mat;
+    int           width, height;
+    rs2_distortion model;
+    double         coeffs[5];
+
+    operator algo::calib() const
+    {
+        algo::calib c;
+        c.rot = rot;
+        c.trans = trans;
+        c.k_mat = k_mat;
+        c.width = width;
+        c.height = height;
+        c.model = model;
+        for( auto x = 0; x < 5; ++x )
+            c.coeffs[x] = coeffs[x];
+        return c;
+    }
+};
+
+int main( int argc, char * argv[] )
+{
+    bool ok = true;
+    // Each of the arguments is the path to a directory to simulate
+    // We skip argv[0] which is the path to the executable
+    // We don't complain if no arguments -- that's how we'll run as part of unit-testing
+    for( int i = 1; i < argc; ++i )
+    {
+        try
+        {
+            char const * dir = argv[i];
+            if( !strcmp( dir, "--version" ) )
+            {
+                // The build number is only available within Jenkins and so we have to hard-
+                // code it ><
+                std::cout << RS2_API_VERSION_STR << ".1973" << std::endl;
+                continue;
+            }
+            std::cout << "Processing: " << dir << " ..." << std::endl;
+
+            algo::calib calibration;
+            try
+            {
+                read_binary_file( dir, "rgb.calib", &calibration );
+            }
+            catch( std::exception const & e )
+            {
+                std::cout << "!! failed: " << e.what() << std::endl;
+                old_algo_calib old_calibration;
+                read_binary_file( dir, "rgb.calib", &old_calibration );
+                calibration = old_calibration;
+            }
+
+            camera_params camera;
+            camera.rgb = calibration.get_intrinsics();
+            camera.extrinsics = calibration.get_extrinsics();
+            algo::rs2_intrinsics_double d_intr;  // intrinsics written in double!
+            read_binary_file( dir, "depth.intrinsics", &d_intr );
+            camera.z = d_intr;
+            read_binary_file( dir, "depth.units", &camera.z_units );
+            read_binary_file( dir, "cal.info", &camera.cal_info );
+            read_binary_file( dir, "cal.registers", &camera.cal_regs );
+            read_binary_file( dir, "dsm.params", &camera.dsm_params );
+
+            algo::optimizer cal;
+            init_algo( cal, dir, "\\rgb.raw", "\\rgb_prev.raw", "\\ir.raw", "\\depth.raw", camera );
+
+            std::string status;
+
+            TRACE( "\n___\nis_scene_valid" );
+            if( !cal.is_scene_valid() )
+            {
+                TRACE("NOT VALID\n");
+                status += "SCENE_INVALID ";
+            }
+
+            TRACE( "\n___\noptimize" );
+            size_t n_iteration = cal.optimize(
+                []( algo::data_collect const & data )
+                {
+                } );
+
+            TRACE( "\n___\nis_valid_results" );
+            if( !cal.is_valid_results() )
+            {
+                TRACE("NOT VALID\n");
+                status += "BAD_RESULT";
+            }
+            else
+            {
+                status += "SUCCESSFUL";
+            }
+            TRACE( "\n___\nRESULTS:  (" << RS2_API_VERSION_STR << " build 1973)" );
+
+            auto intr = cal.get_calibration().get_intrinsics();
+            auto extr = cal.get_calibration().get_extrinsics();
+            AC_LOG( DEBUG, AC_D_PREC
+                << "intr[ "
+                << intr.width << "x" << intr.height
+                << "  ppx: " << intr.ppx << ", ppy: " << intr.ppy << ", fx: " << intr.fx
+                << ", fy: " << intr.fy << ", model: " << int( intr.model ) << " coeffs["
+                << intr.coeffs[0] << ", " << intr.coeffs[1] << ", " << intr.coeffs[2]
+                << ", " << intr.coeffs[3] << ", " << intr.coeffs[4] << "] ]" );
+            AC_LOG( DEBUG, AC_D_PREC << "extr" << (rs2_extrinsics) extr );
+            AC_LOG( DEBUG, AC_D_PREC << "dsm" << cal.get_dsm_params() );
+
+            TRACE( "\n___\nVS:" );
+            AC_LOG( DEBUG, AC_D_PREC << "dsm" << camera.dsm_params );
+         
+            TRACE( "\n___\nSTATUS: " + status );
+        }
+        catch( std::exception const & e )
+        {
+            std::cerr << "\n___\ncaught exception: " << e.what() << std::endl;
+            ok = false;
+        }
+        catch( ... )
+        {
+            std::cerr << "\n___\ncaught unknown exception!" << std::endl;
+            ok = false;
+        }
+    }
+    
+    return ! ok;
+}
+
diff --git a/unit-tests/algo/d2rgb/test-scene-2.cpp b/unit-tests/algo/d2rgb/test-scene-2.cpp
new file mode 100644
index 0000000..a9e82ba
--- /dev/null
+++ b/unit-tests/algo/d2rgb/test-scene-2.cpp
@@ -0,0 +1,23 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+//#cmake:add-file ../../../src/algo/depth-to-rgb-calibration/*.cpp
+
+#include "d2rgb-common.h"
+#include "compare-to-bin-file.h"
+#include "compare-scene.h"
+
+
+TEST_CASE("Scene 2", "[d2rgb]")
+{
+    // TODO so Travis passes, until we fix the test-case
+    //std::string scene_dir("..\\unit-tests\\algo\\depth-to-rgb-calibration\\19.2.20");
+    std::string scene_dir( "C:\\work\\autocal" );
+    scene_dir += "\\F9440687\\LongRange_D_768x1024_RGB_1920x1080\\2\\";
+
+    std::ifstream f( bin_dir( scene_dir ) + "camera_params" );
+    if( f.good() )
+        compare_scene( scene_dir );
+    else
+        std::cout << "-I- skipping scene-2 test for now" << std::endl;
+}
diff --git a/unit-tests/algo/d2rgb/test-scenes.cpp b/unit-tests/algo/d2rgb/test-scenes.cpp
new file mode 100644
index 0000000..7fe5304
--- /dev/null
+++ b/unit-tests/algo/d2rgb/test-scenes.cpp
@@ -0,0 +1,218 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+//#cmake:add-file ../../../src/algo/depth-to-rgb-calibration/*.cpp
+
+// We have our own main
+#define NO_CATCH_CONFIG_MAIN
+#define CATCH_CONFIG_RUNNER
+
+#include "d2rgb-common.h"
+#include "compare-to-bin-file.h"
+
+#include "compare-scene.h"
+#include "../../filesystem.h"
+
+#ifdef _WIN32
+#include <io.h>
+#else
+#include <unistd.h>
+#define _log log
+#define _close close
+#define _fileno fileno
+#define _dup dup
+#define _dup2 dup2
+#endif
+
+
+class redirect_file
+{
+    int _no;
+    int _old_no;
+
+public:
+    redirect_file( FILE * f = stdout )
+        : _no( _fileno( f ))
+        , _old_no( _dup( _no ))
+    {
+        std::freopen( std::tmpnam( nullptr ), "w", f );
+    }
+    ~redirect_file()
+    {
+        _dup2( _old_no, _no );
+        _close( _old_no );
+    }
+};
+
+
+void print_dividers()
+{
+    std::cout << std::right << std::setw( 7 ) << "------ ";
+    std::cout << std::left << std::setw( 70 ) << "-----";
+    std::cout << std::left << std::setw( 10 ) << "----------";
+    std::cout << std::right << std::setw( 10 ) << "-----";
+    std::cout << std::right << std::setw( 10 ) << "-------";
+    std::cout << std::right << std::setw( 6 ) << "---";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 4 ) << "---";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 4 ) << "---";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 7 ) << "-----";
+    std::cout << std::endl;
+}
+
+void print_headers()
+{
+    std::cout << std::right << std::setw( 7 ) << "Failed ";
+    std::cout << std::left << std::setw( 70 ) << "Name";
+    std::cout << std::left << std::setw( 10 ) << "Cost";
+    std::cout << std::right << std::setw( 10 ) << "%diff";
+    std::cout << std::right << std::setw( 10 ) << "Pixels";
+    std::cout << std::right << std::setw( 6 ) << "SV";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 4 ) << "OV";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 4 ) << "Con";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 7 ) << "dPix";
+    std::cout << std::endl;
+
+    print_dividers();
+}
+
+void print_scene_stats( std::string const & name, size_t n_failed, scene_stats const & scene )
+{
+    std::cout << std::right << std::setw( 6 ) << n_failed << ' ';
+
+    std::cout << std::left << std::setw( 70 ) << name;
+
+    std::cout << std::right << std::setw( 10 ) << std::fixed << std::setprecision( 2 ) << scene.cost;
+    double matlab_cost = scene.cost - scene.d_cost;
+    double d_cost_pct = abs( scene.d_cost ) * 100. / matlab_cost;
+    std::cout << std::right << std::setw( 10 ) << d_cost_pct;
+
+    std::cout << std::right << std::setw( 10 ) << scene.movement;
+
+    std::cout << std::right << std::setw( 6 ) << scene.n_valid_scene;
+    std::cout << std::left << std::setw( 2 ) << ( scene.n_valid_scene_diff ? "!" : "" );
+    std::cout << std::right << std::setw( 4 ) << scene.n_valid_result;
+    std::cout << std::left << std::setw( 2 ) << (scene.n_valid_result_diff ? "!" : "");
+    std::cout << std::right << std::setw( 4 ) << scene.n_converged;
+    std::cout << std::left << std::setw( 2 ) << (scene.n_converged_diff ? "!" : "");
+
+    std::cout << std::right << std::setw( 7 ) << scene.d_movement;
+
+    std::cout << std::endl;
+}
+
+
+int main( int argc, char * argv[] )
+{
+    Catch::Session session;
+    LOG_TO_STDOUT.enable( false );
+
+    Catch::ConfigData config;
+    config.verbosity = Catch::Verbosity::Normal;
+
+    bool ok = true;
+    bool verbose = false;
+    bool stats = false;
+    // Each of the arguments is the path to a directory to simulate
+    // We skip argv[0] which is the path to the executable
+    // We don't complain if no arguments -- that's how we'll run as part of unit-testing
+    for( int i = 1; i < argc; ++i )
+    {
+        try
+        {
+            char const * dir = argv[i];
+            if( !strcmp( dir, "-v" ) )
+            {
+                LOG_TO_STDOUT.enable( verbose = true );
+                continue;
+            }
+            if( !strcmp( dir, "--stats" ) )
+            {
+                stats = true;
+                //config.outputFilename = "%debug";
+                continue;
+            }
+            TRACE( "\n\nProcessing: " << dir << " ..." );
+            Catch::CustomRunContext ctx( config );
+            ctx.set_redirection( !verbose );
+            scene_stats total = { 0 };
+            size_t n_failed = 0;
+            size_t n_scenes = 0;
+
+            if( stats )
+                print_headers();
+
+            glob( dir, "yuy_prev_z_i.files",
+                [&]( std::string const & match )
+                {
+                    // <scene_dir>/binFiles/ac2/<match>
+                    std::string scene_dir = get_parent( join( dir, match ) );  // .../ac2
+                    std::string ac2;
+                    scene_dir = get_parent( scene_dir, &ac2 );  // .../binFiles
+                    if( ac2 != "ac2" )
+                        return;
+                    std::string binFiles;
+                    scene_dir = get_parent( scene_dir, &binFiles );
+                    if( binFiles != "binFiles" )
+                        return;
+                    std::string test_name = scene_dir.substr( strlen( dir ) + 1 );
+                    scene_dir += native_separator;
+
+                    scene_stats scene;
+                    
+                    Catch::Totals catch_total;
+                    {
+                        redirect_file no( stats ? stdout : stderr );
+                        catch_total = ctx.run_test( test_name, [&]() {
+                            REQUIRE_NOTHROW( compare_scene( scene_dir, &scene ) );
+                        } );
+                    }
+                    
+                    n_failed += catch_total.testCases.failed;
+                    ++n_scenes;
+                    total.cost += scene.cost;
+                    total.d_cost += abs(scene.d_cost);
+                    total.movement += scene.movement;
+                    total.d_movement += abs(scene.d_movement);
+                    total.n_valid_scene += scene.n_valid_scene;
+                    total.n_valid_scene_diff += scene.n_valid_scene_diff;
+                    total.n_valid_result += scene.n_valid_result;
+                    total.n_valid_result_diff += scene.n_valid_result_diff;
+                    total.n_converged += scene.n_converged;
+                    total.n_converged_diff += scene.n_converged_diff;
+
+                    if( stats )
+                        print_scene_stats( test_name, catch_total.assertions.failed, scene );
+                } );
+
+            if( stats )
+            {
+                print_dividers();
+                print_scene_stats( to_string()
+                                       << "                                             " << n_scenes << " scene totals:",
+                                   n_failed,
+                                   total );
+            }
+
+            TRACE( "done!\n\n" );
+            ok &= ! n_failed;
+        }
+        catch( std::exception const & e )
+        {
+            std::cerr << "caught exception: " << e.what() << std::endl;
+            ok = false;
+        }
+        catch( ... )
+        {
+            std::cerr << "caught unknown exception!" << std::endl;
+            ok = false;
+        }
+    }
+
+    return !ok;
+}
diff --git a/unit-tests/algo/dl_algo_file.cmake b/unit-tests/algo/dl_algo_file.cmake
new file mode 100644
index 0000000..0a12682
--- /dev/null
+++ b/unit-tests/algo/dl_algo_file.cmake
@@ -0,0 +1,29 @@
+
+# Image files are not included in our distribution. Define a function for easy downloading at CMake time:
+#realsense-hw-public/rs-tests/algo/depth-to-rgb-calibration/19.2.20/F9440687/Snapshots/LongRange 768X1024 (RGB 1920X1080)
+set(ALGO_SRC_URL "http://realsense-hw-public.s3-eu-west-1.amazonaws.com/rs-tests/algo")
+
+function(dl_algo_file filename sha1)
+    set(path "${CMAKE_CURRENT_BINARY_DIR}/algo/${filename}")
+    set( empty FALSE )
+    is_file_empty( empty ${path} )
+    #message(STATUS "from= ${ALGO_SRC_URL}/${filename}")
+    #message(STATUS "empty= ${empty}")
+    if( NOT EXISTS "${path}" OR ${empty} )
+        message(STATUS "Downloading '${filename}' into '${CMAKE_CURRENT_BINARY_DIR}/algo'")
+        if( NOT sha1 )
+            file(DOWNLOAD "${ALGO_SRC_URL}/${filename}" "${path}"
+                STATUS status)
+            list(GET status 0 code)
+            list(GET status 1 message)
+            if( code )
+                message( SEND_ERROR " ${message}")
+            endif()
+        else()
+            file(DOWNLOAD "${ALGO_SRC_URL}/${filename}" "${path}"
+                EXPECTED_HASH SHA1=${sha1}
+                STATUS status)
+        endif()
+    endif()
+endfunction()
+
diff --git a/unit-tests/approx.h b/unit-tests/approx.h
new file mode 100644
index 0000000..69797a6
--- /dev/null
+++ b/unit-tests/approx.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "catch.h"
+#include <limits>
+#include <sstream>
+#include <iomanip>
+
+
+/*
+
+We need to compare floating point values, therefore we need an approximation
+function, which Catch provides for us:
+    REQUIRE( performComputation() == Approx( 2.1 ));
+(see https://github.com/catchorg/Catch2/blob/master/docs/assertions.md)
+For example (with the default epsilon):
+    2.61007666588 ~= 2.61007662723
+This may not be good enough for us...
+
+Three controls exist for the comparison:
+  - margin (absolute difference)
+    |a-b| <= margin
+  - scale - ignored for now; see below
+  - epsilon (relative difference)
+    |a-b| <= epsilon * |b|
+
+
+Catch v1 vs v2
+----------------
+
+In v1, the formula for approx was:
+    |a-b| <= epsilon * (scale + max( |a|, |b| ))
+With the default for scale being 1.
+With v2, this changed to:
+    |a-b| <= margin  ||  |a-b| <= epsilon * (scale + b )
+(it's really slightly different, but the gist is the above)
+The scale has changed to 0!
+Note that it's now only relative to the "golden" number to which we're comparing!
+
+
+Absolute vs relative comparisons
+----------------------------------
+
+Absolute and relative tolerances are tested as:
+    |a-b| <= MARGIN
+and:
+    |a-b| <= EPSILON * max(|a|, |b|)
+
+The absolute tolerance test fails when x and y become large, and the relative
+tolerance test fails when they become small. It is therefore best to combine
+the two tests together in a single test.
+
+But this is always subject to context: generalizing here is convenient, that's all...
+
+
+Approx to 0
+-------------
+
+Because the scale is 0 in v2, and the margin defaults to 0, there is essentially no
+approximate comparison to 0! We must use a margin if we want to do this.
+
+Which value to choose is a good question, though. Because most of our math is in
+floats, we choose to use the float epsilon: any two numbers are deemed equal if their
+difference is less than the smallest float number representable:
+*/
+#if ! defined( __APPROX_MARGIN )
+#define __APPROX_MARGIN std::numeric_limits<float>::epsilon()
+#endif
+template< typename F > struct __approx_margin {};
+template<> struct __approx_margin< double > { static constexpr double value() { return __APPROX_MARGIN; } };
+template<> struct __approx_margin< float  > { static constexpr float  value() { return __APPROX_MARGIN * 4; } };
+template< typename F > F approx_margin( F ) { return __approx_margin< F >::value(); }
+
+/*
+But note that for floats, this number is scaled up!
+
+
+Epsilon
+---------
+Approx sets its epsilon to:
+    std::numeric_limits<float>::epsilon()*100
+This might be too big.
+
+Instead, we set the epsilon to the same as the margin, by default:
+*/
+#if ! defined( __APPROX_EPSILON )
+#define __APPROX_EPSILON __APPROX_MARGIN
+#endif
+template< typename F > struct __approx_epsilon {};
+template<> struct __approx_epsilon< double > { static constexpr double value() { return __APPROX_EPSILON; } };
+template<> struct __approx_epsilon< float  > { static constexpr float  value() { return __APPROX_EPSILON * 4; } };
+template< typename F > F approx_epsilon( F ) { return __approx_epsilon< F >::value(); }
+/*
+Note that this is still way smaller than the default!
+
+
+How?
+------
+
+We provide our own functions to do approximate comparison:
+    REQUIRE( performComputation() == approx( 2.1 ));
+*/
+
+// Custom version of Approx, ==> better replaced by matchers <== for more control,
+// but provides LRS defaults that should closely (but not exactly) match them
+template< typename F >
+inline Approx approx( F f )
+{
+    return Approx( f )
+        .margin( __approx_margin< F >::value() )
+        .epsilon( __approx_epsilon< F >::value() );
+}
+
+/*
+
+Literals
+----------
+
+Note that Catch has literals that make the syntax nice:
+    using namespace Catch::literals;
+    REQUIRE( performComputation() == 2.1_a );
+Because we have our own implementatin (and because it's more verbose) we do NOT want
+to use the literal that Catch supplies.
+
+
+Matchers
+----------
+
+The above are good, but if you want more control, matchers provide a customizable
+comparison:
+    REQUIRE_THAT( performComputation(), approx_equals( 2.1 ));
+Or, for more control:
+    REQUIRE_THAT( performComputation(), approx_abs( 2.1 ));
+    REQUIRE_THAT( performComputation(), approx_rel( 2.1 ));
+Or, with the Catch matchers, even more:
+    REQUIRE_THAT( performComputation(), WithinAbs( 2.1, 0.1 ));   // 2.0  ->  2.2
+    REQUIRE_THAT( performComputation(), WithinRel( 2.1, 0.05 ));  // 5% from 2.1
+    REQUIRE_THAT( performComputation(), WithinUlps( 2.1, 2 ));    // two epsilons from 2.1
+These matchers are type-sensitive (float vs. double).
+*/
+#define approx_abs(D) \
+    Catch::WithinAbs( (D), approx_margin((D)) )
+#define approx_rel(D) \
+    Catch::WithinRel( (D), approx_epsilon((D)) )
+#define approx_equals(D) \
+    ( approx_abs(D)  ||  approx_rel(D) )
+
+
+// Utility function to help debug precision errors:
+//         INFO( full_precision( d ) );
+//         REQUIRE( 0.0 == d );
+template< class T >
+std::string full_precision( T const d )
+{
+    std::ostringstream s;
+    s << std::setprecision( std::numeric_limits< T >::max_digits10 ) << d;
+    return s.str();
+}
+
diff --git a/unit-tests/catch.h b/unit-tests/catch.h
new file mode 100644
index 0000000..210209a
--- /dev/null
+++ b/unit-tests/catch.h
@@ -0,0 +1,75 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+
+// Catch defines CHECK() and so does EL++, and so we have to undefine it or we get compilation errors!
+#undef CHECK
+// Otherwise, don't let it define its own:
+#define ELPP_NO_CHECK_MACROS
+
+#include "catch/catch.hpp"
+
+
+#if defined(CATCH_CONFIG_RUNNER)
+
+namespace Catch
+{
+
+    // Allow custom test-cases on the fly
+    class CustomRunContext : public RunContext
+    {
+    public:
+        CustomRunContext( CustomRunContext const& ) = delete;
+        CustomRunContext & operator=( CustomRunContext const& ) = delete;
+
+        // RunContext ctor, but you need to give details...
+        explicit CustomRunContext( IStreamingReporterPtr&& reporter, IConfigPtr const& cfg )
+            : RunContext( cfg, std::move( reporter ))
+        {
+        }
+
+        // Easy way to instantiate, using the compact reporter by default
+        explicit CustomRunContext( std::string const & reporter_type = "compact", IConfigPtr const & cfg = IConfigPtr( new Config ) )
+            : CustomRunContext( getRegistryHub().getReporterRegistry().create( reporter_type, cfg ), cfg )
+        {
+        }
+
+        // Easy way to instantiate, using config data first
+        explicit CustomRunContext( Catch::ConfigData const & cfg, std::string const & reporter_type = "compact" )
+            : CustomRunContext( reporter_type, IConfigPtr( new Config( cfg ) ) )
+        {
+        }
+
+        // Allow changing the redirection for the reporter by force (the compact reporter does
+        // not allow changing via the Config's verbosity)
+        void set_redirection( bool on )
+        {
+            auto r = dynamic_cast<Catch::CompactReporter *>(&reporter());
+            if( r )
+                r->m_reporterPrefs.shouldRedirectStdOut = on;
+        }
+
+        template< class T >
+        Totals run_test( std::string const & name, T test )
+        {
+            struct invoker : ITestInvoker
+            {
+                T _test;
+                invoker( T t ) : _test( t ) {}
+                void invoke() const override
+                {
+                    _test();
+                }
+            };
+            TestCase test_case( new invoker( test ),
+                TestCaseInfo( name, {}, {}, {}, {"",0} )
+            );
+            return runTest( test_case );
+        }
+    };
+
+}  // namespace Catch
+
+#endif // CATCH_CONFIG_RUNNER
diff --git a/unit-tests/catch/catch.hpp b/unit-tests/catch/catch.hpp
dissimilarity index 70%
index de61226..6beb0ea 100644
--- a/unit-tests/catch/catch.hpp
+++ b/unit-tests/catch/catch.hpp
@@ -1,9416 +1,17698 @@
-/*
- *  Catch v1.2.1
- *  Generated: 2015-06-30 18:23:27.961086
- *  ----------------------------------------------------------
- *  This file has been merged from multiple headers. Please don't edit it directly
- *  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.
- *
- *  Distributed under the Boost Software License, Version 1.0. (See accompanying
- *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
- */
-#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
-#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
-
-#define TWOBLUECUBES_CATCH_HPP_INCLUDED
-
-#ifdef __clang__
-#    pragma clang system_header
-#elif defined __GNUC__
-#    pragma GCC system_header
-#endif
-
-// #included from: internal/catch_suppress_warnings.h
-
-#define TWOBLUECUBES_CATCH_SUPPRESS_WARNINGS_H_INCLUDED
-
-#ifdef __clang__
-#   ifdef __ICC // icpc defines the __clang__ macro
-#       pragma warning(push)
-#       pragma warning(disable: 161 1682)
-#   else // __ICC
-#       pragma clang diagnostic ignored "-Wglobal-constructors"
-#       pragma clang diagnostic ignored "-Wvariadic-macros"
-#       pragma clang diagnostic ignored "-Wc99-extensions"
-#       pragma clang diagnostic ignored "-Wunused-variable"
-#       pragma clang diagnostic push
-#       pragma clang diagnostic ignored "-Wpadded"
-#       pragma clang diagnostic ignored "-Wc++98-compat"
-#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
-#       pragma clang diagnostic ignored "-Wswitch-enum"
-#    endif
-#elif defined __GNUC__
-#    pragma GCC diagnostic ignored "-Wvariadic-macros"
-#    pragma GCC diagnostic ignored "-Wunused-variable"
-#    pragma GCC diagnostic push
-#    pragma GCC diagnostic ignored "-Wpadded"
-#endif
-
-#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
-#  define CATCH_IMPL
-#endif
-
-#ifdef CATCH_IMPL
-#  ifndef CLARA_CONFIG_MAIN
-#    define CLARA_CONFIG_MAIN_NOT_DEFINED
-#    define CLARA_CONFIG_MAIN
-#  endif
-#endif
-
-// #included from: internal/catch_notimplemented_exception.h
-#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED
-
-// #included from: catch_common.h
-#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED
-
-#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
-#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
-#define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
-
-#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr
-#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )
-
-#include <sstream>
-#include <stdexcept>
-#include <algorithm>
-
-// #included from: catch_compiler_capabilities.h
-#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
-
-// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
-// The following features are defined:
-//
-// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?
-// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
-// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
-// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
-// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported
-
-// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?
-
-// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?
-
-// In general each macro has a _NO_<feature name> form
-// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
-// Many features, at point of detection, define an _INTERNAL_ macro, so they
-// can be combined, en-mass, with the _NO_ forms later.
-
-// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11
-
-#ifdef __clang__
-
-#  if __has_feature(cxx_nullptr)
-#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
-#  endif
-
-#  if __has_feature(cxx_noexcept)
-#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
-#  endif
-
-#endif // __clang__
-
-////////////////////////////////////////////////////////////////////////////////
-// Borland
-#ifdef __BORLANDC__
-
-#endif // __BORLANDC__
-
-////////////////////////////////////////////////////////////////////////////////
-// EDG
-#ifdef __EDG_VERSION__
-
-#endif // __EDG_VERSION__
-
-////////////////////////////////////////////////////////////////////////////////
-// Digital Mars
-#ifdef __DMC__
-
-#endif // __DMC__
-
-////////////////////////////////////////////////////////////////////////////////
-// GCC
-#ifdef __GNUC__
-
-#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__) )
-#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
-#endif
-
-#endif // __GNUC__
-
-////////////////////////////////////////////////////////////////////////////////
-// Visual C++
-#ifdef _MSC_VER
-
-#if (_MSC_VER >= 1600)
-#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
-#endif
-
-#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
-#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
-#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
-#endif
-
-#endif // _MSC_VER
-
-// Use variadic macros if the compiler supports them
-#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
-    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
-    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
-    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )
-
-#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
-
-#endif
-
-////////////////////////////////////////////////////////////////////////////////
-// C++ language feature support
-
-// catch all support for C++11
-#if (__cplusplus >= 201103L)
-
-#  define CATCH_CPP11_OR_GREATER
-
-#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)
-#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
-#  endif
-
-#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
-#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
-#  endif
-
-#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
-#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
-#  endif
-
-#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
-#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
-#  endif
-
-#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE
-#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE
-#  endif
-
-#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
-#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
-#  endif
-
-#endif // __cplusplus >= 201103L
-
-// Now set the actual defines based on the above + anything the user has configured
-#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)
-#   define CATCH_CONFIG_CPP11_NULLPTR
-#endif
-#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)
-#   define CATCH_CONFIG_CPP11_NOEXCEPT
-#endif
-#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)
-#   define CATCH_CONFIG_CPP11_GENERATED_METHODS
-#endif
-#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)
-#   define CATCH_CONFIG_CPP11_IS_ENUM
-#endif
-#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)
-#   define CATCH_CONFIG_CPP11_TUPLE
-#endif
-#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)
-#define CATCH_CONFIG_VARIADIC_MACROS
-#endif
-
-// noexcept support:
-#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)
-#  define CATCH_NOEXCEPT noexcept
-#  define CATCH_NOEXCEPT_IS(x) noexcept(x)
-#else
-#  define CATCH_NOEXCEPT throw()
-#  define CATCH_NOEXCEPT_IS(x)
-#endif
-
-namespace Catch {
-
-    class NonCopyable {
-#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        NonCopyable( NonCopyable const& )              = delete;
-        NonCopyable( NonCopyable && )                  = delete;
-        NonCopyable& operator = ( NonCopyable const& ) = delete;
-        NonCopyable& operator = ( NonCopyable && )     = delete;
-#else
-        NonCopyable( NonCopyable const& info );
-        NonCopyable& operator = ( NonCopyable const& );
-#endif
-
-    protected:
-        NonCopyable() {}
-        virtual ~NonCopyable();
-    };
-
-    class SafeBool {
-    public:
-        typedef void (SafeBool::*type)() const;
-
-        static type makeSafe( bool value ) {
-            return value ? &SafeBool::trueValue : 0;
-        }
-    private:
-        void trueValue() const {}
-    };
-
-    template<typename ContainerT>
-    inline void deleteAll( ContainerT& container ) {
-        typename ContainerT::const_iterator it = container.begin();
-        typename ContainerT::const_iterator itEnd = container.end();
-        for(; it != itEnd; ++it )
-            delete *it;
-    }
-    template<typename AssociativeContainerT>
-    inline void deleteAllValues( AssociativeContainerT& container ) {
-        typename AssociativeContainerT::const_iterator it = container.begin();
-        typename AssociativeContainerT::const_iterator itEnd = container.end();
-        for(; it != itEnd; ++it )
-            delete it->second;
-    }
-
-    bool startsWith( std::string const& s, std::string const& prefix );
-    bool endsWith( std::string const& s, std::string const& suffix );
-    bool contains( std::string const& s, std::string const& infix );
-    void toLowerInPlace( std::string& s );
-    std::string toLower( std::string const& s );
-    std::string trim( std::string const& str );
-    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
-
-    struct pluralise {
-        pluralise( std::size_t count, std::string const& label );
-
-        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
-
-        std::size_t m_count;
-        std::string m_label;
-    };
-
-    struct SourceLineInfo {
-
-        SourceLineInfo();
-        SourceLineInfo( char const* _file, std::size_t _line );
-        SourceLineInfo( SourceLineInfo const& other );
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        SourceLineInfo( SourceLineInfo && )                  = default;
-        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
-        SourceLineInfo& operator = ( SourceLineInfo && )     = default;
-#  endif
-        bool empty() const;
-        bool operator == ( SourceLineInfo const& other ) const;
-        bool operator < ( SourceLineInfo const& other ) const;
-
-        std::string file;
-        std::size_t line;
-    };
-
-    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
-
-    // This is just here to avoid compiler warnings with macro constants and boolean literals
-    inline bool isTrue( bool value ){ return value; }
-    inline bool alwaysTrue() { return true; }
-    inline bool alwaysFalse() { return false; }
-
-    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );
-
-    // Use this in variadic streaming macros to allow
-    //    >> +StreamEndStop
-    // as well as
-    //    >> stuff +StreamEndStop
-    struct StreamEndStop {
-        std::string operator+() {
-            return std::string();
-        }
-    };
-    template<typename T>
-    T const& operator + ( T const& value, StreamEndStop ) {
-        return value;
-    }
-}
-
-#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
-#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );
-
-#include <ostream>
-
-namespace Catch {
-
-    class NotImplementedException : public std::exception
-    {
-    public:
-        NotImplementedException( SourceLineInfo const& lineInfo );
-        NotImplementedException( NotImplementedException const& ) {}
-
-        virtual ~NotImplementedException() CATCH_NOEXCEPT {}
-
-        virtual const char* what() const CATCH_NOEXCEPT;
-
-    private:
-        std::string m_what;
-        SourceLineInfo m_lineInfo;
-    };
-
-} // end namespace Catch
-
-///////////////////////////////////////////////////////////////////////////////
-#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )
-
-// #included from: internal/catch_context.h
-#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED
-
-// #included from: catch_interfaces_generators.h
-#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    struct IGeneratorInfo {
-        virtual ~IGeneratorInfo();
-        virtual bool moveNext() = 0;
-        virtual std::size_t getCurrentIndex() const = 0;
-    };
-
-    struct IGeneratorsForTest {
-        virtual ~IGeneratorsForTest();
-
-        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;
-        virtual bool moveNext() = 0;
-    };
-
-    IGeneratorsForTest* createGeneratorsForTest();
-
-} // end namespace Catch
-
-// #included from: catch_ptr.hpp
-#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-namespace Catch {
-
-    // An intrusive reference counting smart pointer.
-    // T must implement addRef() and release() methods
-    // typically implementing the IShared interface
-    template<typename T>
-    class Ptr {
-    public:
-        Ptr() : m_p( NULL ){}
-        Ptr( T* p ) : m_p( p ){
-            if( m_p )
-                m_p->addRef();
-        }
-        Ptr( Ptr const& other ) : m_p( other.m_p ){
-            if( m_p )
-                m_p->addRef();
-        }
-        ~Ptr(){
-            if( m_p )
-                m_p->release();
-        }
-        void reset() {
-            if( m_p )
-                m_p->release();
-            m_p = NULL;
-        }
-        Ptr& operator = ( T* p ){
-            Ptr temp( p );
-            swap( temp );
-            return *this;
-        }
-        Ptr& operator = ( Ptr const& other ){
-            Ptr temp( other );
-            swap( temp );
-            return *this;
-        }
-        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
-        T* get() { return m_p; }
-        const T* get() const{ return m_p; }
-        T& operator*() const { return *m_p; }
-        T* operator->() const { return m_p; }
-        bool operator !() const { return m_p == NULL; }
-        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != NULL ); }
-
-    private:
-        T* m_p;
-    };
-
-    struct IShared : NonCopyable {
-        virtual ~IShared();
-        virtual void addRef() const = 0;
-        virtual void release() const = 0;
-    };
-
-    template<typename T = IShared>
-    struct SharedImpl : T {
-
-        SharedImpl() : m_rc( 0 ){}
-
-        virtual void addRef() const {
-            ++m_rc;
-        }
-        virtual void release() const {
-            if( --m_rc == 0 )
-                delete this;
-        }
-
-        mutable unsigned int m_rc;
-    };
-
-} // end namespace Catch
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-#include <memory>
-#include <vector>
-#include <stdlib.h>
-
-namespace Catch {
-
-    class TestCase;
-    class Stream;
-    struct IResultCapture;
-    struct IRunner;
-    struct IGeneratorsForTest;
-    struct IConfig;
-
-    struct IContext
-    {
-        virtual ~IContext();
-
-        virtual IResultCapture* getResultCapture() = 0;
-        virtual IRunner* getRunner() = 0;
-        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;
-        virtual bool advanceGeneratorsForCurrentTest() = 0;
-        virtual Ptr<IConfig const> getConfig() const = 0;
-    };
-
-    struct IMutableContext : IContext
-    {
-        virtual ~IMutableContext();
-        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
-        virtual void setRunner( IRunner* runner ) = 0;
-        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;
-    };
-
-    IContext& getCurrentContext();
-    IMutableContext& getCurrentMutableContext();
-    void cleanUpContext();
-    Stream createStream( std::string const& streamName );
-
-}
-
-// #included from: internal/catch_test_registry.hpp
-#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED
-
-// #included from: catch_interfaces_testcase.h
-#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED
-
-#include <vector>
-
-namespace Catch {
-
-    class TestSpec;
-
-    struct ITestCase : IShared {
-        virtual void invoke () const = 0;
-    protected:
-        virtual ~ITestCase();
-    };
-
-    class TestCase;
-    struct IConfig;
-
-    struct ITestCaseRegistry {
-        virtual ~ITestCaseRegistry();
-        virtual std::vector<TestCase> const& getAllTests() const = 0;
-        virtual void getFilteredTests( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const = 0;
-
-    };
-}
-
-namespace Catch {
-
-template<typename C>
-class MethodTestCase : public SharedImpl<ITestCase> {
-
-public:
-    MethodTestCase( void (C::*method)() ) : m_method( method ) {}
-
-    virtual void invoke() const {
-        C obj;
-        (obj.*m_method)();
-    }
-
-private:
-    virtual ~MethodTestCase() {}
-
-    void (C::*m_method)();
-};
-
-typedef void(*TestFunction)();
-
-struct NameAndDesc {
-    NameAndDesc( const char* _name = "", const char* _description= "" )
-    : name( _name ), description( _description )
-    {}
-
-    const char* name;
-    const char* description;
-};
-
-struct AutoReg {
-
-    AutoReg(    TestFunction function,
-                SourceLineInfo const& lineInfo,
-                NameAndDesc const& nameAndDesc );
-
-    template<typename C>
-    AutoReg(    void (C::*method)(),
-                char const* className,
-                NameAndDesc const& nameAndDesc,
-                SourceLineInfo const& lineInfo ) {
-        registerTestCase(   new MethodTestCase<C>( method ),
-                            className,
-                            nameAndDesc,
-                            lineInfo );
-    }
-
-    void registerTestCase(  ITestCase* testCase,
-                            char const* className,
-                            NameAndDesc const& nameAndDesc,
-                            SourceLineInfo const& lineInfo );
-
-    ~AutoReg();
-
-private:
-    AutoReg( AutoReg const& );
-    void operator= ( AutoReg const& );
-};
-
-} // end namespace Catch
-
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_TESTCASE( ... ) \
-        static void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )(); \
-        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &INTERNAL_CATCH_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ ), CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); }\
-        static void INTERNAL_CATCH_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ )()
-
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
-        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); }
-
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... )\
-        namespace{ \
-            struct INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) : ClassName{ \
-                void test(); \
-            }; \
-            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); \
-        } \
-        void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test()
-
-#else
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_TESTCASE( Name, Desc ) \
-        static void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )(); \
-        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &INTERNAL_CATCH_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ ), CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); }\
-        static void INTERNAL_CATCH_UNIQUE_NAME(  ____C_A_T_C_H____T_E_S_T____ )()
-
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
-        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); }
-
-    ///////////////////////////////////////////////////////////////////////////////
-    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\
-        namespace{ \
-            struct INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) : ClassName{ \
-                void test(); \
-            }; \
-            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); \
-        } \
-        void INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ )::test()
-
-#endif
-
-// #included from: internal/catch_capture.hpp
-#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED
-
-// #included from: catch_result_builder.h
-#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED
-
-// #included from: catch_result_type.h
-#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED
-
-namespace Catch {
-
-    // ResultWas::OfType enum
-    struct ResultWas { enum OfType {
-        Unknown = -1,
-        Ok = 0,
-        Info = 1,
-        Warning = 2,
-
-        FailureBit = 0x10,
-
-        ExpressionFailed = FailureBit | 1,
-        ExplicitFailure = FailureBit | 2,
-
-        Exception = 0x100 | FailureBit,
-
-        ThrewException = Exception | 1,
-        DidntThrowException = Exception | 2,
-
-        FatalErrorCondition = 0x200 | FailureBit
-
-    }; };
-
-    inline bool isOk( ResultWas::OfType resultType ) {
-        return ( resultType & ResultWas::FailureBit ) == 0;
-    }
-    inline bool isJustInfo( int flags ) {
-        return flags == ResultWas::Info;
-    }
-
-    // ResultDisposition::Flags enum
-    struct ResultDisposition { enum Flags {
-        Normal = 0x01,
-
-        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
-        FalseTest = 0x04,           // Prefix expression with !
-        SuppressFail = 0x08         // Failures are reported but do not fail the test
-    }; };
-
-    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
-        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
-    }
-
-    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
-    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }
-    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
-
-} // end namespace Catch
-
-// #included from: catch_assertionresult.h
-#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    struct AssertionInfo
-    {
-        AssertionInfo() {}
-        AssertionInfo(  std::string const& _macroName,
-                        SourceLineInfo const& _lineInfo,
-                        std::string const& _capturedExpression,
-                        ResultDisposition::Flags _resultDisposition );
-
-        std::string macroName;
-        SourceLineInfo lineInfo;
-        std::string capturedExpression;
-        ResultDisposition::Flags resultDisposition;
-    };
-
-    struct AssertionResultData
-    {
-        AssertionResultData() : resultType( ResultWas::Unknown ) {}
-
-        std::string reconstructedExpression;
-        std::string message;
-        ResultWas::OfType resultType;
-    };
-
-    class AssertionResult {
-    public:
-        AssertionResult();
-        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
-        ~AssertionResult();
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-         AssertionResult( AssertionResult const& )              = default;
-         AssertionResult( AssertionResult && )                  = default;
-         AssertionResult& operator = ( AssertionResult const& ) = default;
-         AssertionResult& operator = ( AssertionResult && )     = default;
-#  endif
-
-        bool isOk() const;
-        bool succeeded() const;
-        ResultWas::OfType getResultType() const;
-        bool hasExpression() const;
-        bool hasMessage() const;
-        std::string getExpression() const;
-        std::string getExpressionInMacro() const;
-        bool hasExpandedExpression() const;
-        std::string getExpandedExpression() const;
-        std::string getMessage() const;
-        SourceLineInfo getSourceInfo() const;
-        std::string getTestMacroName() const;
-
-    protected:
-        AssertionInfo m_info;
-        AssertionResultData m_resultData;
-    };
-
-} // end namespace Catch
-
-namespace Catch {
-
-    struct TestFailureException{};
-
-    template<typename T> class ExpressionLhs;
-
-    struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;
-
-    struct CopyableStream {
-        CopyableStream() {}
-        CopyableStream( CopyableStream const& other ) {
-            oss << other.oss.str();
-        }
-        CopyableStream& operator=( CopyableStream const& other ) {
-            oss.str("");
-            oss << other.oss.str();
-            return *this;
-        }
-        std::ostringstream oss;
-    };
-
-    class ResultBuilder {
-    public:
-        ResultBuilder(  char const* macroName,
-                        SourceLineInfo const& lineInfo,
-                        char const* capturedExpression,
-                        ResultDisposition::Flags resultDisposition );
-
-        template<typename T>
-        ExpressionLhs<T const&> operator <= ( T const& operand );
-        ExpressionLhs<bool> operator <= ( bool value );
-
-        template<typename T>
-        ResultBuilder& operator << ( T const& value ) {
-            m_stream.oss << value;
-            return *this;
-        }
-
-        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
-        template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );
-
-        ResultBuilder& setResultType( ResultWas::OfType result );
-        ResultBuilder& setResultType( bool result );
-        ResultBuilder& setLhs( std::string const& lhs );
-        ResultBuilder& setRhs( std::string const& rhs );
-        ResultBuilder& setOp( std::string const& op );
-
-        void endExpression();
-
-        std::string reconstructExpression() const;
-        AssertionResult build() const;
-
-        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );
-        void captureResult( ResultWas::OfType resultType );
-        void captureExpression();
-        void react();
-        bool shouldDebugBreak() const;
-        bool allowThrows() const;
-
-    private:
-        AssertionInfo m_assertionInfo;
-        AssertionResultData m_data;
-        struct ExprComponents {
-            ExprComponents() : testFalse( false ) {}
-            bool testFalse;
-            std::string lhs, rhs, op;
-        } m_exprComponents;
-        CopyableStream m_stream;
-
-        bool m_shouldDebugBreak;
-        bool m_shouldThrow;
-    };
-
-} // namespace Catch
-
-// Include after due to circular dependency:
-// #included from: catch_expression_lhs.hpp
-#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED
-
-// #included from: catch_evaluate.hpp
-#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED
-
-#ifdef _MSC_VER
-#pragma warning(push)
-#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
-#endif
-
-#include <cstddef>
-
-namespace Catch {
-namespace Internal {
-
-    enum Operator {
-        IsEqualTo,
-        IsNotEqualTo,
-        IsLessThan,
-        IsGreaterThan,
-        IsLessThanOrEqualTo,
-        IsGreaterThanOrEqualTo
-    };
-
-    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };
-    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };
-    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };
-    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };
-    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };
-    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };
-    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };
-
-    template<typename T>
-    inline T& opCast(T const& t) { return const_cast<T&>(t); }
-
-// nullptr_t support based on pull request #154 from Konstantin Baumann
-#ifdef CATCH_CONFIG_CPP11_NULLPTR
-    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
-#endif // CATCH_CONFIG_CPP11_NULLPTR
-
-    // So the compare overloads can be operator agnostic we convey the operator as a template
-    // enum, which is used to specialise an Evaluator for doing the comparison.
-    template<typename T1, typename T2, Operator Op>
-    class Evaluator{};
-
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsEqualTo> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs) {
-            return opCast( lhs ) ==  opCast( rhs );
-        }
-    };
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsNotEqualTo> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
-            return opCast( lhs ) != opCast( rhs );
-        }
-    };
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsLessThan> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
-            return opCast( lhs ) < opCast( rhs );
-        }
-    };
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsGreaterThan> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
-            return opCast( lhs ) > opCast( rhs );
-        }
-    };
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
-            return opCast( lhs ) >= opCast( rhs );
-        }
-    };
-    template<typename T1, typename T2>
-    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
-        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
-            return opCast( lhs ) <= opCast( rhs );
-        }
-    };
-
-    template<Operator Op, typename T1, typename T2>
-    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {
-        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
-    }
-
-    // This level of indirection allows us to specialise for integer types
-    // to avoid signed/ unsigned warnings
-
-    // "base" overload
-    template<Operator Op, typename T1, typename T2>
-    bool compare( T1 const& lhs, T2 const& rhs ) {
-        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
-    }
-
-    // unsigned X to int
-    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
-    }
-    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
-    }
-    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
-    }
-
-    // unsigned X to long
-    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
-    }
-    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
-    }
-    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {
-        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
-    }
-
-    // int to unsigned X
-    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
-    }
-    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
-    }
-    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
-    }
-
-    // long to unsigned X
-    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
-    }
-    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
-    }
-    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {
-        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
-    }
-
-    // pointer to long (when comparing against NULL)
-    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {
-        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
-    }
-    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {
-        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
-    }
-
-    // pointer to int (when comparing against NULL)
-    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {
-        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
-    }
-    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {
-        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
-    }
-
-#ifdef CATCH_CONFIG_CPP11_NULLPTR
-    // pointer to nullptr_t (when comparing against nullptr)
-    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {
-        return Evaluator<T*, T*, Op>::evaluate( NULL, rhs );
-    }
-    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {
-        return Evaluator<T*, T*, Op>::evaluate( lhs, NULL );
-    }
-#endif // CATCH_CONFIG_CPP11_NULLPTR
-
-} // end of namespace Internal
-} // end of namespace Catch
-
-#ifdef _MSC_VER
-#pragma warning(pop)
-#endif
-
-// #included from: catch_tostring.h
-#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED
-
-#include <sstream>
-#include <iomanip>
-#include <limits>
-#include <vector>
-#include <cstddef>
-
-#ifdef __OBJC__
-// #included from: catch_objc_arc.hpp
-#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED
-
-#import <Foundation/Foundation.h>
-
-#ifdef __has_feature
-#define CATCH_ARC_ENABLED __has_feature(objc_arc)
-#else
-#define CATCH_ARC_ENABLED 0
-#endif
-
-void arcSafeRelease( NSObject* obj );
-id performOptionalSelector( id obj, SEL sel );
-
-#if !CATCH_ARC_ENABLED
-inline void arcSafeRelease( NSObject* obj ) {
-    [obj release];
-}
-inline id performOptionalSelector( id obj, SEL sel ) {
-    if( [obj respondsToSelector: sel] )
-        return [obj performSelector: sel];
-    return nil;
-}
-#define CATCH_UNSAFE_UNRETAINED
-#define CATCH_ARC_STRONG
-#else
-inline void arcSafeRelease( NSObject* ){}
-inline id performOptionalSelector( id obj, SEL sel ) {
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
-#endif
-    if( [obj respondsToSelector: sel] )
-        return [obj performSelector: sel];
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-    return nil;
-}
-#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
-#define CATCH_ARC_STRONG __strong
-#endif
-
-#endif
-
-#ifdef CATCH_CONFIG_CPP11_TUPLE
-#include <tuple>
-#endif
-
-#ifdef CATCH_CONFIG_CPP11_IS_ENUM
-#include <type_traits>
-#endif
-
-namespace Catch {
-
-// Why we're here.
-template<typename T>
-std::string toString( T const& value );
-
-// Built in overloads
-
-std::string toString( std::string const& value );
-std::string toString( std::wstring const& value );
-std::string toString( const char* const value );
-std::string toString( char* const value );
-std::string toString( const wchar_t* const value );
-std::string toString( wchar_t* const value );
-std::string toString( int value );
-std::string toString( unsigned long value );
-std::string toString( unsigned int value );
-std::string toString( const double value );
-std::string toString( const float value );
-std::string toString( bool value );
-std::string toString( char value );
-std::string toString( signed char value );
-std::string toString( unsigned char value );
-
-#ifdef CATCH_CONFIG_CPP11_NULLPTR
-std::string toString( std::nullptr_t );
-#endif
-
-#ifdef __OBJC__
-    std::string toString( NSString const * const& nsstring );
-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring );
-    std::string toString( NSObject* const& nsObject );
-#endif
-
-namespace Detail {
-
-    extern std::string unprintableString;
-
-    struct BorgType {
-        template<typename T> BorgType( T const& );
-    };
-
-    struct TrueType { char sizer[1]; };
-    struct FalseType { char sizer[2]; };
-
-    TrueType& testStreamable( std::ostream& );
-    FalseType testStreamable( FalseType );
-
-    FalseType operator<<( std::ostream const&, BorgType const& );
-
-    template<typename T>
-    struct IsStreamInsertable {
-        static std::ostream &s;
-        static T  const&t;
-        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };
-    };
-
-#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
-    template<typename T,
-             bool IsEnum = std::is_enum<T>::value
-             >
-    struct EnumStringMaker
-    {
-        static std::string convert( T const& ) { return unprintableString; }
-    };
-
-    template<typename T>
-    struct EnumStringMaker<T,true>
-    {
-        static std::string convert( T const& v )
-        {
-            return ::Catch::toString(
-                static_cast<typename std::underlying_type<T>::type>(v)
-                );
-        }
-    };
-#endif
-    template<bool C>
-    struct StringMakerBase {
-#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
-        template<typename T>
-        static std::string convert( T const& v )
-        {
-            return EnumStringMaker<T>::convert( v );
-        }
-#else
-        template<typename T>
-        static std::string convert( T const& ) { return unprintableString; }
-#endif
-    };
-
-    template<>
-    struct StringMakerBase<true> {
-        template<typename T>
-        static std::string convert( T const& _value ) {
-            std::ostringstream oss;
-            oss << _value;
-            return oss.str();
-        }
-    };
-
-    std::string rawMemoryToString( const void *object, std::size_t size );
-
-    template<typename T>
-    inline std::string rawMemoryToString( const T& object ) {
-      return rawMemoryToString( &object, sizeof(object) );
-    }
-
-} // end namespace Detail
-
-template<typename T>
-struct StringMaker :
-    Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};
-
-template<typename T>
-struct StringMaker<T*> {
-    template<typename U>
-    static std::string convert( U* p ) {
-        if( !p )
-            return INTERNAL_CATCH_STRINGIFY( NULL );
-        else
-            return Detail::rawMemoryToString( p );
-    }
-};
-
-template<typename R, typename C>
-struct StringMaker<R C::*> {
-    static std::string convert( R C::* p ) {
-        if( !p )
-            return INTERNAL_CATCH_STRINGIFY( NULL );
-        else
-            return Detail::rawMemoryToString( p );
-    }
-};
-
-namespace Detail {
-    template<typename InputIterator>
-    std::string rangeToString( InputIterator first, InputIterator last );
-}
-
-//template<typename T, typename Allocator>
-//struct StringMaker<std::vector<T, Allocator> > {
-//    static std::string convert( std::vector<T,Allocator> const& v ) {
-//        return Detail::rangeToString( v.begin(), v.end() );
-//    }
-//};
-
-template<typename T, typename Allocator>
-std::string toString( std::vector<T,Allocator> const& v ) {
-    return Detail::rangeToString( v.begin(), v.end() );
-}
-
-#ifdef CATCH_CONFIG_CPP11_TUPLE
-
-// toString for tuples
-namespace TupleDetail {
-  template<
-      typename Tuple,
-      std::size_t N = 0,
-      bool = (N < std::tuple_size<Tuple>::value)
-      >
-  struct ElementPrinter {
-      static void print( const Tuple& tuple, std::ostream& os )
-      {
-          os << ( N ? ", " : " " )
-             << Catch::toString(std::get<N>(tuple));
-          ElementPrinter<Tuple,N+1>::print(tuple,os);
-      }
-  };
-
-  template<
-      typename Tuple,
-      std::size_t N
-      >
-  struct ElementPrinter<Tuple,N,false> {
-      static void print( const Tuple&, std::ostream& ) {}
-  };
-
-}
-
-template<typename ...Types>
-struct StringMaker<std::tuple<Types...>> {
-
-    static std::string convert( const std::tuple<Types...>& tuple )
-    {
-        std::ostringstream os;
-        os << '{';
-        TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );
-        os << " }";
-        return os.str();
-    }
-};
-#endif // CATCH_CONFIG_CPP11_TUPLE
-
-namespace Detail {
-    template<typename T>
-    std::string makeString( T const& value ) {
-        return StringMaker<T>::convert( value );
-    }
-} // end namespace Detail
-
-/// \brief converts any type to a string
-///
-/// The default template forwards on to ostringstream - except when an
-/// ostringstream overload does not exist - in which case it attempts to detect
-/// that and writes {?}.
-/// Overload (not specialise) this template for custom typs that you don't want
-/// to provide an ostream overload for.
-template<typename T>
-std::string toString( T const& value ) {
-    return StringMaker<T>::convert( value );
-}
-
-    namespace Detail {
-    template<typename InputIterator>
-    std::string rangeToString( InputIterator first, InputIterator last ) {
-        std::ostringstream oss;
-        oss << "{ ";
-        if( first != last ) {
-            oss << Catch::toString( *first );
-            for( ++first ; first != last ; ++first )
-                oss << ", " << Catch::toString( *first );
-        }
-        oss << " }";
-        return oss.str();
-    }
-}
-
-} // end namespace Catch
-
-namespace Catch {
-
-// Wraps the LHS of an expression and captures the operator and RHS (if any) -
-// wrapping them all in a ResultBuilder object
-template<typename T>
-class ExpressionLhs {
-    ExpressionLhs& operator = ( ExpressionLhs const& );
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-    ExpressionLhs& operator = ( ExpressionLhs && ) = delete;
-#  endif
-
-public:
-    ExpressionLhs( ResultBuilder& rb, T lhs ) : m_rb( rb ), m_lhs( lhs ) {}
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-    ExpressionLhs( ExpressionLhs const& ) = default;
-    ExpressionLhs( ExpressionLhs && )     = default;
-#  endif
-
-    template<typename RhsT>
-    ResultBuilder& operator == ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsEqualTo>( rhs );
-    }
-
-    template<typename RhsT>
-    ResultBuilder& operator != ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsNotEqualTo>( rhs );
-    }
-
-    template<typename RhsT>
-    ResultBuilder& operator < ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsLessThan>( rhs );
-    }
-
-    template<typename RhsT>
-    ResultBuilder& operator > ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsGreaterThan>( rhs );
-    }
-
-    template<typename RhsT>
-    ResultBuilder& operator <= ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
-    }
-
-    template<typename RhsT>
-    ResultBuilder& operator >= ( RhsT const& rhs ) {
-        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
-    }
-
-    ResultBuilder& operator == ( bool rhs ) {
-        return captureExpression<Internal::IsEqualTo>( rhs );
-    }
-
-    ResultBuilder& operator != ( bool rhs ) {
-        return captureExpression<Internal::IsNotEqualTo>( rhs );
-    }
-
-    void endExpression() {
-        bool value = m_lhs ? true : false;
-        m_rb
-            .setLhs( Catch::toString( value ) )
-            .setResultType( value )
-            .endExpression();
-    }
-
-    // Only simple binary expressions are allowed on the LHS.
-    // If more complex compositions are required then place the sub expression in parentheses
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + ( RhsT const& );
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - ( RhsT const& );
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / ( RhsT const& );
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * ( RhsT const& );
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( RhsT const& );
-    template<typename RhsT> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( RhsT const& );
-
-private:
-    template<Internal::Operator Op, typename RhsT>
-    ResultBuilder& captureExpression( RhsT const& rhs ) {
-        return m_rb
-            .setResultType( Internal::compare<Op>( m_lhs, rhs ) )
-            .setLhs( Catch::toString( m_lhs ) )
-            .setRhs( Catch::toString( rhs ) )
-            .setOp( Internal::OperatorTraits<Op>::getName() );
-    }
-
-private:
-    ResultBuilder& m_rb;
-    T m_lhs;
-};
-
-} // end namespace Catch
-
-
-namespace Catch {
-
-    template<typename T>
-    inline ExpressionLhs<T const&> ResultBuilder::operator <= ( T const& operand ) {
-        return ExpressionLhs<T const&>( *this, operand );
-    }
-
-    inline ExpressionLhs<bool> ResultBuilder::operator <= ( bool value ) {
-        return ExpressionLhs<bool>( *this, value );
-    }
-
-} // namespace Catch
-
-// #included from: catch_message.h
-#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    struct MessageInfo {
-        MessageInfo(    std::string const& _macroName,
-                        SourceLineInfo const& _lineInfo,
-                        ResultWas::OfType _type );
-
-        std::string macroName;
-        SourceLineInfo lineInfo;
-        ResultWas::OfType type;
-        std::string message;
-        unsigned int sequence;
-
-        bool operator == ( MessageInfo const& other ) const {
-            return sequence == other.sequence;
-        }
-        bool operator < ( MessageInfo const& other ) const {
-            return sequence < other.sequence;
-        }
-    private:
-        static unsigned int globalCount;
-    };
-
-    struct MessageBuilder {
-        MessageBuilder( std::string const& macroName,
-                        SourceLineInfo const& lineInfo,
-                        ResultWas::OfType type )
-        : m_info( macroName, lineInfo, type )
-        {}
-
-        template<typename T>
-        MessageBuilder& operator << ( T const& value ) {
-            m_stream << value;
-            return *this;
-        }
-
-        MessageInfo m_info;
-        std::ostringstream m_stream;
-    };
-
-    class ScopedMessage {
-    public:
-        ScopedMessage( MessageBuilder const& builder );
-        ScopedMessage( ScopedMessage const& other );
-        ~ScopedMessage();
-
-        MessageInfo m_info;
-    };
-
-} // end namespace Catch
-
-// #included from: catch_interfaces_capture.h
-#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    class TestCase;
-    class AssertionResult;
-    struct AssertionInfo;
-    struct SectionInfo;
-    struct MessageInfo;
-    class ScopedMessageBuilder;
-    struct Counts;
-
-    struct IResultCapture {
-
-        virtual ~IResultCapture();
-
-        virtual void assertionEnded( AssertionResult const& result ) = 0;
-        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
-                                        Counts& assertions ) = 0;
-        virtual void sectionEnded( SectionInfo const& name, Counts const& assertions, double _durationInSeconds ) = 0;
-        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
-        virtual void popScopedMessage( MessageInfo const& message ) = 0;
-
-        virtual std::string getCurrentTestName() const = 0;
-        virtual const AssertionResult* getLastResult() const = 0;
-
-        virtual void handleFatalErrorCondition( std::string const& message ) = 0;
-    };
-
-    IResultCapture& getResultCapture();
-}
-
-// #included from: catch_debugger.h
-#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED
-
-// #included from: catch_platform.h
-#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED
-
-#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
-#define CATCH_PLATFORM_MAC
-#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
-#define CATCH_PLATFORM_IPHONE
-#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
-#define CATCH_PLATFORM_WINDOWS
-#endif
-
-#include <string>
-
-namespace Catch{
-
-    bool isDebuggerActive();
-    void writeToDebugConsole( std::string const& text );
-}
-
-#ifdef CATCH_PLATFORM_MAC
-
-    // The following code snippet based on:
-    // http://cocoawithlove.com/2008/03/break-into-debugger.html
-    #ifdef DEBUG
-        #if defined(__ppc64__) || defined(__ppc__)
-            #define CATCH_BREAK_INTO_DEBUGGER() \
-                if( Catch::isDebuggerActive() ) { \
-                    __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
-                    : : : "memory","r0","r3","r4" ); \
-                }
-        #else
-            #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) {__asm__("int $3\n" : : );}
-        #endif
-    #endif
-
-#elif defined(_MSC_VER)
-    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { __debugbreak(); }
-#elif defined(__MINGW32__)
-    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
-    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { DebugBreak(); }
-#endif
-
-#ifndef CATCH_BREAK_INTO_DEBUGGER
-#define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();
-#endif
-
-// #included from: catch_interfaces_runner.h
-#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED
-
-namespace Catch {
-    class TestCase;
-
-    struct IRunner {
-        virtual ~IRunner();
-        virtual bool aborting() const = 0;
-    };
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// In the event of a failure works out if the debugger needs to be invoked
-// and/or an exception thrown and takes appropriate action.
-// This needs to be done as a macro so the debugger will stop in the user
-// source code rather than in Catch library code
-#define INTERNAL_CATCH_REACT( resultBuilder ) \
-    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \
-    resultBuilder.react();
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ) \
-    do { \
-        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
-        try { \
-            ( __catchResult <= expr ).endExpression(); \
-        } \
-        catch( ... ) { \
-            __catchResult.useActiveException( Catch::ResultDisposition::Normal ); \
-        } \
-        INTERNAL_CATCH_REACT( __catchResult ) \
-    } while( Catch::isTrue( false && (expr) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_IF( expr, resultDisposition, macroName ) \
-    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
-    if( Catch::getResultCapture().getLastResult()->succeeded() )
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_ELSE( expr, resultDisposition, macroName ) \
-    INTERNAL_CATCH_TEST( expr, resultDisposition, macroName ); \
-    if( !Catch::getResultCapture().getLastResult()->succeeded() )
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_NO_THROW( expr, resultDisposition, macroName ) \
-    do { \
-        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
-        try { \
-            expr; \
-            __catchResult.captureResult( Catch::ResultWas::Ok ); \
-        } \
-        catch( ... ) { \
-            __catchResult.useActiveException( resultDisposition ); \
-        } \
-        INTERNAL_CATCH_REACT( __catchResult ) \
-    } while( Catch::alwaysFalse() )
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_THROWS( expr, resultDisposition, macroName ) \
-    do { \
-        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
-        if( __catchResult.allowThrows() ) \
-            try { \
-                expr; \
-                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
-            } \
-            catch( ... ) { \
-                __catchResult.captureResult( Catch::ResultWas::Ok ); \
-            } \
-        else \
-            __catchResult.captureResult( Catch::ResultWas::Ok ); \
-        INTERNAL_CATCH_REACT( __catchResult ) \
-    } while( Catch::alwaysFalse() )
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_THROWS_AS( expr, exceptionType, resultDisposition, macroName ) \
-    do { \
-        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #expr, resultDisposition ); \
-        if( __catchResult.allowThrows() ) \
-            try { \
-                expr; \
-                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
-            } \
-            catch( exceptionType ) { \
-                __catchResult.captureResult( Catch::ResultWas::Ok ); \
-            } \
-            catch( ... ) { \
-                __catchResult.useActiveException( resultDisposition ); \
-            } \
-        else \
-            __catchResult.captureResult( Catch::ResultWas::Ok ); \
-        INTERNAL_CATCH_REACT( __catchResult ) \
-    } while( Catch::alwaysFalse() )
-
-///////////////////////////////////////////////////////////////////////////////
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-    #define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, ... ) \
-        do { \
-            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
-            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \
-            __catchResult.captureResult( messageType ); \
-            INTERNAL_CATCH_REACT( __catchResult ) \
-        } while( Catch::alwaysFalse() )
-#else
-    #define INTERNAL_CATCH_MSG( messageType, resultDisposition, macroName, log ) \
-        do { \
-            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
-            __catchResult << log + ::Catch::StreamEndStop(); \
-            __catchResult.captureResult( messageType ); \
-            INTERNAL_CATCH_REACT( __catchResult ) \
-        } while( Catch::alwaysFalse() )
-#endif
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_INFO( log, macroName ) \
-    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CHECK_THAT( arg, matcher, resultDisposition, macroName ) \
-    do { \
-        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, #arg " " #matcher, resultDisposition ); \
-        try { \
-            std::string matcherAsString = ::Catch::Matchers::matcher.toString(); \
-            __catchResult \
-                .setLhs( Catch::toString( arg ) ) \
-                .setRhs( matcherAsString == Catch::Detail::unprintableString ? #matcher : matcherAsString ) \
-                .setOp( "matches" ) \
-                .setResultType( ::Catch::Matchers::matcher.match( arg ) ); \
-            __catchResult.captureExpression(); \
-        } catch( ... ) { \
-            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \
-        } \
-        INTERNAL_CATCH_REACT( __catchResult ) \
-    } while( Catch::alwaysFalse() )
-
-// #included from: internal/catch_section.h
-#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED
-
-// #included from: catch_section_info.h
-#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED
-
-namespace Catch {
-
-    struct SectionInfo {
-        SectionInfo
-            (   SourceLineInfo const& _lineInfo,
-                std::string const& _name,
-                std::string const& _description = std::string() );
-
-        std::string name;
-        std::string description;
-        SourceLineInfo lineInfo;
-    };
-
-} // end namespace Catch
-
-// #included from: catch_totals.hpp
-#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED
-
-#include <cstddef>
-
-namespace Catch {
-
-    struct Counts {
-        Counts() : passed( 0 ), failed( 0 ), failedButOk( 0 ) {}
-
-        Counts operator - ( Counts const& other ) const {
-            Counts diff;
-            diff.passed = passed - other.passed;
-            diff.failed = failed - other.failed;
-            diff.failedButOk = failedButOk - other.failedButOk;
-            return diff;
-        }
-        Counts& operator += ( Counts const& other ) {
-            passed += other.passed;
-            failed += other.failed;
-            failedButOk += other.failedButOk;
-            return *this;
-        }
-
-        std::size_t total() const {
-            return passed + failed + failedButOk;
-        }
-        bool allPassed() const {
-            return failed == 0 && failedButOk == 0;
-        }
-        bool allOk() const {
-            return failed == 0;
-        }
-
-        std::size_t passed;
-        std::size_t failed;
-        std::size_t failedButOk;
-    };
-
-    struct Totals {
-
-        Totals operator - ( Totals const& other ) const {
-            Totals diff;
-            diff.assertions = assertions - other.assertions;
-            diff.testCases = testCases - other.testCases;
-            return diff;
-        }
-
-        Totals delta( Totals const& prevTotals ) const {
-            Totals diff = *this - prevTotals;
-            if( diff.assertions.failed > 0 )
-                ++diff.testCases.failed;
-            else if( diff.assertions.failedButOk > 0 )
-                ++diff.testCases.failedButOk;
-            else
-                ++diff.testCases.passed;
-            return diff;
-        }
-
-        Totals& operator += ( Totals const& other ) {
-            assertions += other.assertions;
-            testCases += other.testCases;
-            return *this;
-        }
-
-        Counts assertions;
-        Counts testCases;
-    };
-}
-
-// #included from: catch_timer.h
-#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED
-
-#ifdef CATCH_PLATFORM_WINDOWS
-typedef unsigned long long uint64_t;
-#else
-#include <stdint.h>
-#endif
-
-namespace Catch {
-
-    class Timer {
-    public:
-        Timer() : m_ticks( 0 ) {}
-        void start();
-        unsigned int getElapsedMicroseconds() const;
-        unsigned int getElapsedMilliseconds() const;
-        double getElapsedSeconds() const;
-
-    private:
-        uint64_t m_ticks;
-    };
-
-} // namespace Catch
-
-#include <string>
-
-namespace Catch {
-
-    class Section : NonCopyable {
-    public:
-        Section( SectionInfo const& info );
-        ~Section();
-
-        // This indicates whether the section should be executed or not
-        operator bool() const;
-
-    private:
-        SectionInfo m_info;
-
-        std::string m_name;
-        Counts m_assertions;
-        bool m_sectionIncluded;
-        Timer m_timer;
-    };
-
-} // end namespace Catch
-
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-    #define INTERNAL_CATCH_SECTION( ... ) \
-        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
-#else
-    #define INTERNAL_CATCH_SECTION( name, desc ) \
-        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )
-#endif
-
-// #included from: internal/catch_generators.hpp
-#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED
-
-#include <iterator>
-#include <vector>
-#include <string>
-#include <stdlib.h>
-
-namespace Catch {
-
-template<typename T>
-struct IGenerator {
-    virtual ~IGenerator() {}
-    virtual T getValue( std::size_t index ) const = 0;
-    virtual std::size_t size () const = 0;
-};
-
-template<typename T>
-class BetweenGenerator : public IGenerator<T> {
-public:
-    BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}
-
-    virtual T getValue( std::size_t index ) const {
-        return m_from+static_cast<int>( index );
-    }
-
-    virtual std::size_t size() const {
-        return static_cast<std::size_t>( 1+m_to-m_from );
-    }
-
-private:
-
-    T m_from;
-    T m_to;
-};
-
-template<typename T>
-class ValuesGenerator : public IGenerator<T> {
-public:
-    ValuesGenerator(){}
-
-    void add( T value ) {
-        m_values.push_back( value );
-    }
-
-    virtual T getValue( std::size_t index ) const {
-        return m_values[index];
-    }
-
-    virtual std::size_t size() const {
-        return m_values.size();
-    }
-
-private:
-    std::vector<T> m_values;
-};
-
-template<typename T>
-class CompositeGenerator {
-public:
-    CompositeGenerator() : m_totalSize( 0 ) {}
-
-    // *** Move semantics, similar to auto_ptr ***
-    CompositeGenerator( CompositeGenerator& other )
-    :   m_fileInfo( other.m_fileInfo ),
-        m_totalSize( 0 )
-    {
-        move( other );
-    }
-
-    CompositeGenerator& setFileInfo( const char* fileInfo ) {
-        m_fileInfo = fileInfo;
-        return *this;
-    }
-
-    ~CompositeGenerator() {
-        deleteAll( m_composed );
-    }
-
-    operator T () const {
-        size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );
-
-        typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
-        typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
-        for( size_t index = 0; it != itEnd; ++it )
-        {
-            const IGenerator<T>* generator = *it;
-            if( overallIndex >= index && overallIndex < index + generator->size() )
-            {
-                return generator->getValue( overallIndex-index );
-            }
-            index += generator->size();
-        }
-        CATCH_INTERNAL_ERROR( "Indexed past end of generated range" );
-        return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
-    }
-
-    void add( const IGenerator<T>* generator ) {
-        m_totalSize += generator->size();
-        m_composed.push_back( generator );
-    }
-
-    CompositeGenerator& then( CompositeGenerator& other ) {
-        move( other );
-        return *this;
-    }
-
-    CompositeGenerator& then( T value ) {
-        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
-        valuesGen->add( value );
-        add( valuesGen );
-        return *this;
-    }
-
-private:
-
-    void move( CompositeGenerator& other ) {
-        std::copy( other.m_composed.begin(), other.m_composed.end(), std::back_inserter( m_composed ) );
-        m_totalSize += other.m_totalSize;
-        other.m_composed.clear();
-    }
-
-    std::vector<const IGenerator<T>*> m_composed;
-    std::string m_fileInfo;
-    size_t m_totalSize;
-};
-
-namespace Generators
-{
-    template<typename T>
-    CompositeGenerator<T> between( T from, T to ) {
-        CompositeGenerator<T> generators;
-        generators.add( new BetweenGenerator<T>( from, to ) );
-        return generators;
-    }
-
-    template<typename T>
-    CompositeGenerator<T> values( T val1, T val2 ) {
-        CompositeGenerator<T> generators;
-        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
-        valuesGen->add( val1 );
-        valuesGen->add( val2 );
-        generators.add( valuesGen );
-        return generators;
-    }
-
-    template<typename T>
-    CompositeGenerator<T> values( T val1, T val2, T val3 ){
-        CompositeGenerator<T> generators;
-        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
-        valuesGen->add( val1 );
-        valuesGen->add( val2 );
-        valuesGen->add( val3 );
-        generators.add( valuesGen );
-        return generators;
-    }
-
-    template<typename T>
-    CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) {
-        CompositeGenerator<T> generators;
-        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
-        valuesGen->add( val1 );
-        valuesGen->add( val2 );
-        valuesGen->add( val3 );
-        valuesGen->add( val4 );
-        generators.add( valuesGen );
-        return generators;
-    }
-
-} // end namespace Generators
-
-using namespace Generators;
-
-} // end namespace Catch
-
-#define INTERNAL_CATCH_LINESTR2( line ) #line
-#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )
-
-#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_CATCH_LINESTR( __LINE__ ) ")" )
-
-// #included from: internal/catch_interfaces_exception.h
-#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED
-
-#include <string>
-// #included from: catch_interfaces_registry_hub.h
-#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    class TestCase;
-    struct ITestCaseRegistry;
-    struct IExceptionTranslatorRegistry;
-    struct IExceptionTranslator;
-    struct IReporterRegistry;
-    struct IReporterFactory;
-
-    struct IRegistryHub {
-        virtual ~IRegistryHub();
-
-        virtual IReporterRegistry const& getReporterRegistry() const = 0;
-        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
-        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
-    };
-
-    struct IMutableRegistryHub {
-        virtual ~IMutableRegistryHub();
-        virtual void registerReporter( std::string const& name, IReporterFactory* factory ) = 0;
-        virtual void registerTest( TestCase const& testInfo ) = 0;
-        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
-    };
-
-    IRegistryHub& getRegistryHub();
-    IMutableRegistryHub& getMutableRegistryHub();
-    void cleanUp();
-    std::string translateActiveException();
-
-}
-
-
-namespace Catch {
-
-    typedef std::string(*exceptionTranslateFunction)();
-
-    struct IExceptionTranslator {
-        virtual ~IExceptionTranslator();
-        virtual std::string translate() const = 0;
-    };
-
-    struct IExceptionTranslatorRegistry {
-        virtual ~IExceptionTranslatorRegistry();
-
-        virtual std::string translateActiveException() const = 0;
-    };
-
-    class ExceptionTranslatorRegistrar {
-        template<typename T>
-        class ExceptionTranslator : public IExceptionTranslator {
-        public:
-
-            ExceptionTranslator( std::string(*translateFunction)( T& ) )
-            : m_translateFunction( translateFunction )
-            {}
-
-            virtual std::string translate() const {
-                try {
-                    throw;
-                }
-                catch( T& ex ) {
-                    return m_translateFunction( ex );
-                }
-            }
-
-        protected:
-            std::string(*m_translateFunction)( T& );
-        };
-
-    public:
-        template<typename T>
-        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
-            getMutableRegistryHub().registerTranslator
-                ( new ExceptionTranslator<T>( translateFunction ) );
-        }
-    };
-}
-
-///////////////////////////////////////////////////////////////////////////////
-#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) \
-    static std::string INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator )( signature ); \
-    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ) ); }\
-    static std::string INTERNAL_CATCH_UNIQUE_NAME(  catch_internal_ExceptionTranslator )( signature )
-
-// #included from: internal/catch_approx.hpp
-#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED
-
-#include <cmath>
-#include <limits>
-
-namespace Catch {
-namespace Detail {
-
-    class Approx {
-    public:
-        explicit Approx ( double value )
-        :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
-            m_scale( 1.0 ),
-            m_value( value )
-        {}
-
-        Approx( Approx const& other )
-        :   m_epsilon( other.m_epsilon ),
-            m_scale( other.m_scale ),
-            m_value( other.m_value )
-        {}
-
-        static Approx custom() {
-            return Approx( 0 );
-        }
-
-        Approx operator()( double value ) {
-            Approx approx( value );
-            approx.epsilon( m_epsilon );
-            approx.scale( m_scale );
-            return approx;
-        }
-
-        friend bool operator == ( double lhs, Approx const& rhs ) {
-            // Thanks to Richard Harris for his help refining this formula
-            return fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( fabs(lhs), fabs(rhs.m_value) ) );
-        }
-
-        friend bool operator == ( Approx const& lhs, double rhs ) {
-            return operator==( rhs, lhs );
-        }
-
-        friend bool operator != ( double lhs, Approx const& rhs ) {
-            return !operator==( lhs, rhs );
-        }
-
-        friend bool operator != ( Approx const& lhs, double rhs ) {
-            return !operator==( rhs, lhs );
-        }
-
-        Approx& epsilon( double newEpsilon ) {
-            m_epsilon = newEpsilon;
-            return *this;
-        }
-
-        Approx& scale( double newScale ) {
-            m_scale = newScale;
-            return *this;
-        }
-
-        std::string toString() const {
-            std::ostringstream oss;
-            oss << "Approx( " << Catch::toString( m_value ) << " )";
-            return oss.str();
-        }
-
-    private:
-        double m_epsilon;
-        double m_scale;
-        double m_value;
-    };
-}
-
-template<>
-inline std::string toString<Detail::Approx>( Detail::Approx const& value ) {
-    return value.toString();
-}
-
-} // end namespace Catch
-
-// #included from: internal/catch_matchers.hpp
-#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED
-
-namespace Catch {
-namespace Matchers {
-    namespace Impl {
-
-    template<typename ExpressionT>
-    struct Matcher : SharedImpl<IShared>
-    {
-        typedef ExpressionT ExpressionType;
-
-        virtual ~Matcher() {}
-        virtual Ptr<Matcher> clone() const = 0;
-        virtual bool match( ExpressionT const& expr ) const = 0;
-        virtual std::string toString() const = 0;
-    };
-
-    template<typename DerivedT, typename ExpressionT>
-    struct MatcherImpl : Matcher<ExpressionT> {
-
-        virtual Ptr<Matcher<ExpressionT> > clone() const {
-            return Ptr<Matcher<ExpressionT> >( new DerivedT( static_cast<DerivedT const&>( *this ) ) );
-        }
-    };
-
-    namespace Generic {
-
-        template<typename ExpressionT>
-        class AllOf : public MatcherImpl<AllOf<ExpressionT>, ExpressionT> {
-        public:
-
-            AllOf() {}
-            AllOf( AllOf const& other ) : m_matchers( other.m_matchers ) {}
-
-            AllOf& add( Matcher<ExpressionT> const& matcher ) {
-                m_matchers.push_back( matcher.clone() );
-                return *this;
-            }
-            virtual bool match( ExpressionT const& expr ) const
-            {
-                for( std::size_t i = 0; i < m_matchers.size(); ++i )
-                    if( !m_matchers[i]->match( expr ) )
-                        return false;
-                return true;
-            }
-            virtual std::string toString() const {
-                std::ostringstream oss;
-                oss << "( ";
-                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
-                    if( i != 0 )
-                        oss << " and ";
-                    oss << m_matchers[i]->toString();
-                }
-                oss << " )";
-                return oss.str();
-            }
-
-        private:
-            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
-        };
-
-        template<typename ExpressionT>
-        class AnyOf : public MatcherImpl<AnyOf<ExpressionT>, ExpressionT> {
-        public:
-
-            AnyOf() {}
-            AnyOf( AnyOf const& other ) : m_matchers( other.m_matchers ) {}
-
-            AnyOf& add( Matcher<ExpressionT> const& matcher ) {
-                m_matchers.push_back( matcher.clone() );
-                return *this;
-            }
-            virtual bool match( ExpressionT const& expr ) const
-            {
-                for( std::size_t i = 0; i < m_matchers.size(); ++i )
-                    if( m_matchers[i]->match( expr ) )
-                        return true;
-                return false;
-            }
-            virtual std::string toString() const {
-                std::ostringstream oss;
-                oss << "( ";
-                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
-                    if( i != 0 )
-                        oss << " or ";
-                    oss << m_matchers[i]->toString();
-                }
-                oss << " )";
-                return oss.str();
-            }
-
-        private:
-            std::vector<Ptr<Matcher<ExpressionT> > > m_matchers;
-        };
-
-    }
-
-    namespace StdString {
-
-        inline std::string makeString( std::string const& str ) { return str; }
-        inline std::string makeString( const char* str ) { return str ? std::string( str ) : std::string(); }
-
-        struct Equals : MatcherImpl<Equals, std::string> {
-            Equals( std::string const& str ) : m_str( str ){}
-            Equals( Equals const& other ) : m_str( other.m_str ){}
-
-            virtual ~Equals();
-
-            virtual bool match( std::string const& expr ) const {
-                return m_str == expr;
-            }
-            virtual std::string toString() const {
-                return "equals: \"" + m_str + "\"";
-            }
-
-            std::string m_str;
-        };
-
-        struct Contains : MatcherImpl<Contains, std::string> {
-            Contains( std::string const& substr ) : m_substr( substr ){}
-            Contains( Contains const& other ) : m_substr( other.m_substr ){}
-
-            virtual ~Contains();
-
-            virtual bool match( std::string const& expr ) const {
-                return expr.find( m_substr ) != std::string::npos;
-            }
-            virtual std::string toString() const {
-                return "contains: \"" + m_substr + "\"";
-            }
-
-            std::string m_substr;
-        };
-
-        struct StartsWith : MatcherImpl<StartsWith, std::string> {
-            StartsWith( std::string const& substr ) : m_substr( substr ){}
-            StartsWith( StartsWith const& other ) : m_substr( other.m_substr ){}
-
-            virtual ~StartsWith();
-
-            virtual bool match( std::string const& expr ) const {
-                return expr.find( m_substr ) == 0;
-            }
-            virtual std::string toString() const {
-                return "starts with: \"" + m_substr + "\"";
-            }
-
-            std::string m_substr;
-        };
-
-        struct EndsWith : MatcherImpl<EndsWith, std::string> {
-            EndsWith( std::string const& substr ) : m_substr( substr ){}
-            EndsWith( EndsWith const& other ) : m_substr( other.m_substr ){}
-
-            virtual ~EndsWith();
-
-            virtual bool match( std::string const& expr ) const {
-                return expr.find( m_substr ) == expr.size() - m_substr.size();
-            }
-            virtual std::string toString() const {
-                return "ends with: \"" + m_substr + "\"";
-            }
-
-            std::string m_substr;
-        };
-    } // namespace StdString
-    } // namespace Impl
-
-    // The following functions create the actual matcher objects.
-    // This allows the types to be inferred
-    template<typename ExpressionT>
-    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
-                                                    Impl::Matcher<ExpressionT> const& m2 ) {
-        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 );
-    }
-    template<typename ExpressionT>
-    inline Impl::Generic::AllOf<ExpressionT> AllOf( Impl::Matcher<ExpressionT> const& m1,
-                                                    Impl::Matcher<ExpressionT> const& m2,
-                                                    Impl::Matcher<ExpressionT> const& m3 ) {
-        return Impl::Generic::AllOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
-    }
-    template<typename ExpressionT>
-    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
-                                                    Impl::Matcher<ExpressionT> const& m2 ) {
-        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 );
-    }
-    template<typename ExpressionT>
-    inline Impl::Generic::AnyOf<ExpressionT> AnyOf( Impl::Matcher<ExpressionT> const& m1,
-                                                    Impl::Matcher<ExpressionT> const& m2,
-                                                    Impl::Matcher<ExpressionT> const& m3 ) {
-        return Impl::Generic::AnyOf<ExpressionT>().add( m1 ).add( m2 ).add( m3 );
-    }
-
-    inline Impl::StdString::Equals      Equals( std::string const& str ) {
-        return Impl::StdString::Equals( str );
-    }
-    inline Impl::StdString::Equals      Equals( const char* str ) {
-        return Impl::StdString::Equals( Impl::StdString::makeString( str ) );
-    }
-    inline Impl::StdString::Contains    Contains( std::string const& substr ) {
-        return Impl::StdString::Contains( substr );
-    }
-    inline Impl::StdString::Contains    Contains( const char* substr ) {
-        return Impl::StdString::Contains( Impl::StdString::makeString( substr ) );
-    }
-    inline Impl::StdString::StartsWith  StartsWith( std::string const& substr ) {
-        return Impl::StdString::StartsWith( substr );
-    }
-    inline Impl::StdString::StartsWith  StartsWith( const char* substr ) {
-        return Impl::StdString::StartsWith( Impl::StdString::makeString( substr ) );
-    }
-    inline Impl::StdString::EndsWith    EndsWith( std::string const& substr ) {
-        return Impl::StdString::EndsWith( substr );
-    }
-    inline Impl::StdString::EndsWith    EndsWith( const char* substr ) {
-        return Impl::StdString::EndsWith( Impl::StdString::makeString( substr ) );
-    }
-
-} // namespace Matchers
-
-using namespace Matchers;
-
-} // namespace Catch
-
-// #included from: internal/catch_interfaces_tag_alias_registry.h
-#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED
-
-// #included from: catch_tag_alias.h
-#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED
-
-#include <string>
-
-namespace Catch {
-
-    struct TagAlias {
-        TagAlias( std::string _tag, SourceLineInfo _lineInfo ) : tag( _tag ), lineInfo( _lineInfo ) {}
-
-        std::string tag;
-        SourceLineInfo lineInfo;
-    };
-
-    struct RegistrarForTagAliases {
-        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
-    };
-
-} // end namespace Catch
-
-#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }
-// #included from: catch_option.hpp
-#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED
-
-namespace Catch {
-
-    // An optional type
-    template<typename T>
-    class Option {
-    public:
-        Option() : nullableValue( NULL ) {}
-        Option( T const& _value )
-        : nullableValue( new( storage ) T( _value ) )
-        {}
-        Option( Option const& _other )
-        : nullableValue( _other ? new( storage ) T( *_other ) : NULL )
-        {}
-
-        ~Option() {
-            reset();
-        }
-
-        Option& operator= ( Option const& _other ) {
-            if( &_other != this ) {
-                reset();
-                if( _other )
-                    nullableValue = new( storage ) T( *_other );
-            }
-            return *this;
-        }
-        Option& operator = ( T const& _value ) {
-            reset();
-            nullableValue = new( storage ) T( _value );
-            return *this;
-        }
-
-        void reset() {
-            if( nullableValue )
-                nullableValue->~T();
-            nullableValue = NULL;
-        }
-
-        T& operator*() { return *nullableValue; }
-        T const& operator*() const { return *nullableValue; }
-        T* operator->() { return nullableValue; }
-        const T* operator->() const { return nullableValue; }
-
-        T valueOr( T const& defaultValue ) const {
-            return nullableValue ? *nullableValue : defaultValue;
-        }
-
-        bool some() const { return nullableValue != NULL; }
-        bool none() const { return nullableValue == NULL; }
-
-        bool operator !() const { return nullableValue == NULL; }
-        operator SafeBool::type() const {
-            return SafeBool::makeSafe( some() );
-        }
-
-    private:
-        T* nullableValue;
-        char storage[sizeof(T)];
-    };
-
-} // end namespace Catch
-
-namespace Catch {
-
-    struct ITagAliasRegistry {
-        virtual ~ITagAliasRegistry();
-        virtual Option<TagAlias> find( std::string const& alias ) const = 0;
-        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
-
-        static ITagAliasRegistry const& get();
-    };
-
-} // end namespace Catch
-
-// These files are included here so the single_include script doesn't put them
-// in the conditionally compiled sections
-// #included from: internal/catch_test_case_info.h
-#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED
-
-#include <string>
-#include <set>
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-namespace Catch {
-
-    struct ITestCase;
-
-    struct TestCaseInfo {
-        enum SpecialProperties{
-            None = 0,
-            IsHidden = 1 << 1,
-            ShouldFail = 1 << 2,
-            MayFail = 1 << 3,
-            Throws = 1 << 4
-        };
-
-        TestCaseInfo(   std::string const& _name,
-                        std::string const& _className,
-                        std::string const& _description,
-                        std::set<std::string> const& _tags,
-                        SourceLineInfo const& _lineInfo );
-
-        TestCaseInfo( TestCaseInfo const& other );
-
-        bool isHidden() const;
-        bool throws() const;
-        bool okToFail() const;
-        bool expectedToFail() const;
-
-        std::string name;
-        std::string className;
-        std::string description;
-        std::set<std::string> tags;
-        std::set<std::string> lcaseTags;
-        std::string tagsAsString;
-        SourceLineInfo lineInfo;
-        SpecialProperties properties;
-    };
-
-    class TestCase : public TestCaseInfo {
-    public:
-
-        TestCase( ITestCase* testCase, TestCaseInfo const& info );
-        TestCase( TestCase const& other );
-
-        TestCase withName( std::string const& _newName ) const;
-
-        void invoke() const;
-
-        TestCaseInfo const& getTestCaseInfo() const;
-
-        void swap( TestCase& other );
-        bool operator == ( TestCase const& other ) const;
-        bool operator < ( TestCase const& other ) const;
-        TestCase& operator = ( TestCase const& other );
-
-    private:
-        Ptr<ITestCase> test;
-    };
-
-    TestCase makeTestCase(  ITestCase* testCase,
-                            std::string const& className,
-                            std::string const& name,
-                            std::string const& description,
-                            SourceLineInfo const& lineInfo );
-}
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-
-#ifdef __OBJC__
-// #included from: internal/catch_objc.hpp
-#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED
-
-#import <objc/runtime.h>
-
-#include <string>
-
-// NB. Any general catch headers included here must be included
-// in catch.hpp first to make sure they are included by the single
-// header for non obj-usage
-
-///////////////////////////////////////////////////////////////////////////////
-// This protocol is really only here for (self) documenting purposes, since
-// all its methods are optional.
-@protocol OcFixture
-
-@optional
-
--(void) setUp;
--(void) tearDown;
-
-@end
-
-namespace Catch {
-
-    class OcMethod : public SharedImpl<ITestCase> {
-
-    public:
-        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
-
-        virtual void invoke() const {
-            id obj = [[m_cls alloc] init];
-
-            performOptionalSelector( obj, @selector(setUp)  );
-            performOptionalSelector( obj, m_sel );
-            performOptionalSelector( obj, @selector(tearDown)  );
-
-            arcSafeRelease( obj );
-        }
-    private:
-        virtual ~OcMethod() {}
-
-        Class m_cls;
-        SEL m_sel;
-    };
-
-    namespace Detail{
-
-        inline std::string getAnnotation(   Class cls,
-                                            std::string const& annotationName,
-                                            std::string const& testCaseName ) {
-            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
-            SEL sel = NSSelectorFromString( selStr );
-            arcSafeRelease( selStr );
-            id value = performOptionalSelector( cls, sel );
-            if( value )
-                return [(NSString*)value UTF8String];
-            return "";
-        }
-    }
-
-    inline size_t registerTestMethods() {
-        size_t noTestMethods = 0;
-        int noClasses = objc_getClassList( NULL, 0 );
-
-        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
-        objc_getClassList( classes, noClasses );
-
-        for( int c = 0; c < noClasses; c++ ) {
-            Class cls = classes[c];
-            {
-                u_int count;
-                Method* methods = class_copyMethodList( cls, &count );
-                for( u_int m = 0; m < count ; m++ ) {
-                    SEL selector = method_getName(methods[m]);
-                    std::string methodName = sel_getName(selector);
-                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
-                        std::string testCaseName = methodName.substr( 15 );
-                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
-                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
-                        const char* className = class_getName( cls );
-
-                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );
-                        noTestMethods++;
-                    }
-                }
-                free(methods);
-            }
-        }
-        return noTestMethods;
-    }
-
-    namespace Matchers {
-        namespace Impl {
-        namespace NSStringMatchers {
-
-            template<typename MatcherT>
-            struct StringHolder : MatcherImpl<MatcherT, NSString*>{
-                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
-                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
-                StringHolder() {
-                    arcSafeRelease( m_substr );
-                }
-
-                NSString* m_substr;
-            };
-
-            struct Equals : StringHolder<Equals> {
-                Equals( NSString* substr ) : StringHolder( substr ){}
-
-                virtual bool match( ExpressionType const& str ) const {
-                    return  (str != nil || m_substr == nil ) &&
-                            [str isEqualToString:m_substr];
-                }
-
-                virtual std::string toString() const {
-                    return "equals string: " + Catch::toString( m_substr );
-                }
-            };
-
-            struct Contains : StringHolder<Contains> {
-                Contains( NSString* substr ) : StringHolder( substr ){}
-
-                virtual bool match( ExpressionType const& str ) const {
-                    return  (str != nil || m_substr == nil ) &&
-                            [str rangeOfString:m_substr].location != NSNotFound;
-                }
-
-                virtual std::string toString() const {
-                    return "contains string: " + Catch::toString( m_substr );
-                }
-            };
-
-            struct StartsWith : StringHolder<StartsWith> {
-                StartsWith( NSString* substr ) : StringHolder( substr ){}
-
-                virtual bool match( ExpressionType const& str ) const {
-                    return  (str != nil || m_substr == nil ) &&
-                            [str rangeOfString:m_substr].location == 0;
-                }
-
-                virtual std::string toString() const {
-                    return "starts with: " + Catch::toString( m_substr );
-                }
-            };
-            struct EndsWith : StringHolder<EndsWith> {
-                EndsWith( NSString* substr ) : StringHolder( substr ){}
-
-                virtual bool match( ExpressionType const& str ) const {
-                    return  (str != nil || m_substr == nil ) &&
-                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
-                }
-
-                virtual std::string toString() const {
-                    return "ends with: " + Catch::toString( m_substr );
-                }
-            };
-
-        } // namespace NSStringMatchers
-        } // namespace Impl
-
-        inline Impl::NSStringMatchers::Equals
-            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
-
-        inline Impl::NSStringMatchers::Contains
-            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
-
-        inline Impl::NSStringMatchers::StartsWith
-            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
-
-        inline Impl::NSStringMatchers::EndsWith
-            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
-
-    } // namespace Matchers
-
-    using namespace Matchers;
-
-} // namespace Catch
-
-///////////////////////////////////////////////////////////////////////////////
-#define OC_TEST_CASE( name, desc )\
-+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \
-{\
-return @ name; \
-}\
-+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \
-{ \
-return @ desc; \
-} \
--(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )
-
-#endif
-
-#ifdef CATCH_IMPL
-// #included from: internal/catch_impl.hpp
-#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED
-
-// Collect all the implementation files together here
-// These are the equivalent of what would usually be cpp files
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wweak-vtables"
-#endif
-
-// #included from: ../catch_runner.hpp
-#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED
-
-// #included from: internal/catch_commandline.hpp
-#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED
-
-// #included from: catch_config.hpp
-#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED
-
-// #included from: catch_test_spec_parser.hpp
-#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-// #included from: catch_test_spec.hpp
-#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-#include <string>
-#include <vector>
-
-namespace Catch {
-
-    class TestSpec {
-        struct Pattern : SharedImpl<> {
-            virtual ~Pattern();
-            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
-        };
-        class NamePattern : public Pattern {
-            enum WildcardPosition {
-                NoWildcard = 0,
-                WildcardAtStart = 1,
-                WildcardAtEnd = 2,
-                WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
-            };
-
-        public:
-            NamePattern( std::string const& name ) : m_name( toLower( name ) ), m_wildcard( NoWildcard ) {
-                if( startsWith( m_name, "*" ) ) {
-                    m_name = m_name.substr( 1 );
-                    m_wildcard = WildcardAtStart;
-                }
-                if( endsWith( m_name, "*" ) ) {
-                    m_name = m_name.substr( 0, m_name.size()-1 );
-                    m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
-                }
-            }
-            virtual ~NamePattern();
-            virtual bool matches( TestCaseInfo const& testCase ) const {
-                switch( m_wildcard ) {
-                    case NoWildcard:
-                        return m_name == toLower( testCase.name );
-                    case WildcardAtStart:
-                        return endsWith( toLower( testCase.name ), m_name );
-                    case WildcardAtEnd:
-                        return startsWith( toLower( testCase.name ), m_name );
-                    case WildcardAtBothEnds:
-                        return contains( toLower( testCase.name ), m_name );
-                }
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wunreachable-code"
-#endif
-                throw std::logic_error( "Unknown enum" );
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-            }
-        private:
-            std::string m_name;
-            WildcardPosition m_wildcard;
-        };
-        class TagPattern : public Pattern {
-        public:
-            TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}
-            virtual ~TagPattern();
-            virtual bool matches( TestCaseInfo const& testCase ) const {
-                return testCase.lcaseTags.find( m_tag ) != testCase.lcaseTags.end();
-            }
-        private:
-            std::string m_tag;
-        };
-        class ExcludedPattern : public Pattern {
-        public:
-            ExcludedPattern( Ptr<Pattern> const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}
-            virtual ~ExcludedPattern();
-            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
-        private:
-            Ptr<Pattern> m_underlyingPattern;
-        };
-
-        struct Filter {
-            std::vector<Ptr<Pattern> > m_patterns;
-
-            bool matches( TestCaseInfo const& testCase ) const {
-                // All patterns in a filter must match for the filter to be a match
-                for( std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it )
-                    if( !(*it)->matches( testCase ) )
-                        return false;
-                    return true;
-            }
-        };
-
-    public:
-        bool hasFilters() const {
-            return !m_filters.empty();
-        }
-        bool matches( TestCaseInfo const& testCase ) const {
-            // A TestSpec matches if any filter matches
-            for( std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it )
-                if( it->matches( testCase ) )
-                    return true;
-            return false;
-        }
-
-    private:
-        std::vector<Filter> m_filters;
-
-        friend class TestSpecParser;
-    };
-}
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-namespace Catch {
-
-    class TestSpecParser {
-        enum Mode{ None, Name, QuotedName, Tag };
-        Mode m_mode;
-        bool m_exclusion;
-        std::size_t m_start, m_pos;
-        std::string m_arg;
-        TestSpec::Filter m_currentFilter;
-        TestSpec m_testSpec;
-        ITagAliasRegistry const* m_tagAliases;
-
-    public:
-        TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
-
-        TestSpecParser& parse( std::string const& arg ) {
-            m_mode = None;
-            m_exclusion = false;
-            m_start = std::string::npos;
-            m_arg = m_tagAliases->expandAliases( arg );
-            for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
-                visitChar( m_arg[m_pos] );
-            if( m_mode == Name )
-                addPattern<TestSpec::NamePattern>();
-            return *this;
-        }
-        TestSpec testSpec() {
-            addFilter();
-            return m_testSpec;
-        }
-    private:
-        void visitChar( char c ) {
-            if( m_mode == None ) {
-                switch( c ) {
-                case ' ': return;
-                case '~': m_exclusion = true; return;
-                case '[': return startNewMode( Tag, ++m_pos );
-                case '"': return startNewMode( QuotedName, ++m_pos );
-                default: startNewMode( Name, m_pos ); break;
-                }
-            }
-            if( m_mode == Name ) {
-                if( c == ',' ) {
-                    addPattern<TestSpec::NamePattern>();
-                    addFilter();
-                }
-                else if( c == '[' ) {
-                    if( subString() == "exclude:" )
-                        m_exclusion = true;
-                    else
-                        addPattern<TestSpec::NamePattern>();
-                    startNewMode( Tag, ++m_pos );
-                }
-            }
-            else if( m_mode == QuotedName && c == '"' )
-                addPattern<TestSpec::NamePattern>();
-            else if( m_mode == Tag && c == ']' )
-                addPattern<TestSpec::TagPattern>();
-        }
-        void startNewMode( Mode mode, std::size_t start ) {
-            m_mode = mode;
-            m_start = start;
-        }
-        std::string subString() const { return m_arg.substr( m_start, m_pos - m_start ); }
-        template<typename T>
-        void addPattern() {
-            std::string token = subString();
-            if( startsWith( token, "exclude:" ) ) {
-                m_exclusion = true;
-                token = token.substr( 8 );
-            }
-            if( !token.empty() ) {
-                Ptr<TestSpec::Pattern> pattern = new T( token );
-                if( m_exclusion )
-                    pattern = new TestSpec::ExcludedPattern( pattern );
-                m_currentFilter.m_patterns.push_back( pattern );
-            }
-            m_exclusion = false;
-            m_mode = None;
-        }
-        void addFilter() {
-            if( !m_currentFilter.m_patterns.empty() ) {
-                m_testSpec.m_filters.push_back( m_currentFilter );
-                m_currentFilter = TestSpec::Filter();
-            }
-        }
-    };
-    inline TestSpec parseTestSpec( std::string const& arg ) {
-        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
-    }
-
-} // namespace Catch
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-// #included from: catch_interfaces_config.h
-#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED
-
-#include <iostream>
-#include <string>
-#include <vector>
-
-namespace Catch {
-
-    struct Verbosity { enum Level {
-        NoOutput = 0,
-        Quiet,
-        Normal
-    }; };
-
-    struct WarnAbout { enum What {
-        Nothing = 0x00,
-        NoAssertions = 0x01
-    }; };
-
-    struct ShowDurations { enum OrNot {
-        DefaultForReporter,
-        Always,
-        Never
-    }; };
-    struct RunTests { enum InWhatOrder {
-        InDeclarationOrder,
-        InLexicographicalOrder,
-        InRandomOrder
-    }; };
-
-    class TestSpec;
-
-    struct IConfig : IShared {
-
-        virtual ~IConfig();
-
-        virtual bool allowThrows() const = 0;
-        virtual std::ostream& stream() const = 0;
-        virtual std::string name() const = 0;
-        virtual bool includeSuccessfulResults() const = 0;
-        virtual bool shouldDebugBreak() const = 0;
-        virtual bool warnAboutMissingAssertions() const = 0;
-        virtual int abortAfter() const = 0;
-        virtual bool showInvisibles() const = 0;
-        virtual ShowDurations::OrNot showDurations() const = 0;
-        virtual TestSpec const& testSpec() const = 0;
-        virtual RunTests::InWhatOrder runOrder() const = 0;
-        virtual unsigned int rngSeed() const = 0;
-        virtual bool forceColour() const = 0;
-    };
-}
-
-// #included from: catch_stream.h
-#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED
-
-#include <streambuf>
-
-#ifdef __clang__
-#pragma clang diagnostic ignored "-Wpadded"
-#endif
-
-namespace Catch {
-
-    class Stream {
-    public:
-        Stream();
-        Stream( std::streambuf* _streamBuf, bool _isOwned );
-        void release();
-
-        std::streambuf* streamBuf;
-
-    private:
-        bool isOwned;
-    };
-
-    std::ostream& cout();
-    std::ostream& cerr();
-}
-
-#include <memory>
-#include <vector>
-#include <string>
-#include <iostream>
-#include <ctime>
-
-#ifndef CATCH_CONFIG_CONSOLE_WIDTH
-#define CATCH_CONFIG_CONSOLE_WIDTH 80
-#endif
-
-namespace Catch {
-
-    struct ConfigData {
-
-        ConfigData()
-        :   listTests( false ),
-            listTags( false ),
-            listReporters( false ),
-            listTestNamesOnly( false ),
-            showSuccessfulTests( false ),
-            shouldDebugBreak( false ),
-            noThrow( false ),
-            showHelp( false ),
-            showInvisibles( false ),
-            forceColour( false ),
-            abortAfter( -1 ),
-            rngSeed( 0 ),
-            verbosity( Verbosity::Normal ),
-            warnings( WarnAbout::Nothing ),
-            showDurations( ShowDurations::DefaultForReporter ),
-            runOrder( RunTests::InDeclarationOrder )
-        {}
-
-        bool listTests;
-        bool listTags;
-        bool listReporters;
-        bool listTestNamesOnly;
-
-        bool showSuccessfulTests;
-        bool shouldDebugBreak;
-        bool noThrow;
-        bool showHelp;
-        bool showInvisibles;
-        bool forceColour;
-
-        int abortAfter;
-        unsigned int rngSeed;
-
-        Verbosity::Level verbosity;
-        WarnAbout::What warnings;
-        ShowDurations::OrNot showDurations;
-        RunTests::InWhatOrder runOrder;
-
-        std::string reporterName;
-        std::string outputFilename;
-        std::string name;
-        std::string processName;
-
-        std::vector<std::string> testsOrTags;
-    };
-
-    class Config : public SharedImpl<IConfig> {
-    private:
-        Config( Config const& other );
-        Config& operator = ( Config const& other );
-        virtual void dummy();
-    public:
-
-        Config()
-        :   m_os( Catch::cout().rdbuf() )
-        {}
-
-        Config( ConfigData const& data )
-        :   m_data( data ),
-            m_os( Catch::cout().rdbuf() )
-        {
-            if( !data.testsOrTags.empty() ) {
-                TestSpecParser parser( ITagAliasRegistry::get() );
-                for( std::size_t i = 0; i < data.testsOrTags.size(); ++i )
-                    parser.parse( data.testsOrTags[i] );
-                m_testSpec = parser.testSpec();
-            }
-        }
-
-        virtual ~Config() {
-            m_os.rdbuf( Catch::cout().rdbuf() );
-            m_stream.release();
-        }
-
-        void setFilename( std::string const& filename ) {
-            m_data.outputFilename = filename;
-        }
-
-        std::string const& getFilename() const {
-            return m_data.outputFilename ;
-        }
-
-        bool listTests() const { return m_data.listTests; }
-        bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }
-        bool listTags() const { return m_data.listTags; }
-        bool listReporters() const { return m_data.listReporters; }
-
-        std::string getProcessName() const { return m_data.processName; }
-
-        bool shouldDebugBreak() const { return m_data.shouldDebugBreak; }
-
-        void setStreamBuf( std::streambuf* buf ) {
-            m_os.rdbuf( buf ? buf : Catch::cout().rdbuf() );
-        }
-
-        void useStream( std::string const& streamName ) {
-            Stream stream = createStream( streamName );
-            setStreamBuf( stream.streamBuf );
-            m_stream.release();
-            m_stream = stream;
-        }
-
-        std::string getReporterName() const { return m_data.reporterName; }
-
-        int abortAfter() const { return m_data.abortAfter; }
-
-        TestSpec const& testSpec() const { return m_testSpec; }
-
-        bool showHelp() const { return m_data.showHelp; }
-        bool showInvisibles() const { return m_data.showInvisibles; }
-
-        // IConfig interface
-        virtual bool allowThrows() const        { return !m_data.noThrow; }
-        virtual std::ostream& stream() const    { return m_os; }
-        virtual std::string name() const        { return m_data.name.empty() ? m_data.processName : m_data.name; }
-        virtual bool includeSuccessfulResults() const   { return m_data.showSuccessfulTests; }
-        virtual bool warnAboutMissingAssertions() const { return m_data.warnings & WarnAbout::NoAssertions; }
-        virtual ShowDurations::OrNot showDurations() const { return m_data.showDurations; }
-        virtual RunTests::InWhatOrder runOrder() const  { return m_data.runOrder; }
-        virtual unsigned int rngSeed() const    { return m_data.rngSeed; }
-        virtual bool forceColour() const { return m_data.forceColour; }
-
-    private:
-        ConfigData m_data;
-
-        Stream m_stream;
-        mutable std::ostream m_os;
-        TestSpec m_testSpec;
-    };
-
-} // end namespace Catch
-
-// #included from: catch_clara.h
-#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED
-
-// Use Catch's value for console width (store Clara's off to the side, if present)
-#ifdef CLARA_CONFIG_CONSOLE_WIDTH
-#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH
-#undef CLARA_CONFIG_CONSOLE_WIDTH
-#endif
-#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
-
-// Declare Clara inside the Catch namespace
-#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {
-// #included from: ../external/clara.h
-
-// Only use header guard if we are not using an outer namespace
-#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)
-
-#ifndef STITCH_CLARA_OPEN_NAMESPACE
-#define TWOBLUECUBES_CLARA_H_INCLUDED
-#define STITCH_CLARA_OPEN_NAMESPACE
-#define STITCH_CLARA_CLOSE_NAMESPACE
-#else
-#define STITCH_CLARA_CLOSE_NAMESPACE }
-#endif
-
-#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE
-
-// ----------- #included from tbc_text_format.h -----------
-
-// Only use header guard if we are not using an outer namespace
-#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)
-#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-#define TBC_TEXT_FORMAT_H_INCLUDED
-#endif
-
-#include <string>
-#include <vector>
-#include <sstream>
-
-// Use optional outer namespace
-#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
-#endif
-
-namespace Tbc {
-
-#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
-    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
-#else
-    const unsigned int consoleWidth = 80;
-#endif
-
-    struct TextAttributes {
-        TextAttributes()
-        :   initialIndent( std::string::npos ),
-            indent( 0 ),
-            width( consoleWidth-1 ),
-            tabChar( '\t' )
-        {}
-
-        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
-        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
-        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
-        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }
-
-        std::size_t initialIndent;  // indent of first line, or npos
-        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
-        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
-        char tabChar;               // If this char is seen the indent is changed to current pos
-    };
-
-    class Text {
-    public:
-        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
-        : attr( _attr )
-        {
-            std::string wrappableChars = " [({.,/|\\-";
-            std::size_t indent = _attr.initialIndent != std::string::npos
-                ? _attr.initialIndent
-                : _attr.indent;
-            std::string remainder = _str;
-
-            while( !remainder.empty() ) {
-                if( lines.size() >= 1000 ) {
-                    lines.push_back( "... message truncated due to excessive size" );
-                    return;
-                }
-                std::size_t tabPos = std::string::npos;
-                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );
-                std::size_t pos = remainder.find_first_of( '\n' );
-                if( pos <= width ) {
-                    width = pos;
-                }
-                pos = remainder.find_last_of( _attr.tabChar, width );
-                if( pos != std::string::npos ) {
-                    tabPos = pos;
-                    if( remainder[width] == '\n' )
-                        width--;
-                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
-                }
-
-                if( width == remainder.size() ) {
-                    spliceLine( indent, remainder, width );
-                }
-                else if( remainder[width] == '\n' ) {
-                    spliceLine( indent, remainder, width );
-                    if( width <= 1 || remainder.size() != 1 )
-                        remainder = remainder.substr( 1 );
-                    indent = _attr.indent;
-                }
-                else {
-                    pos = remainder.find_last_of( wrappableChars, width );
-                    if( pos != std::string::npos && pos > 0 ) {
-                        spliceLine( indent, remainder, pos );
-                        if( remainder[0] == ' ' )
-                            remainder = remainder.substr( 1 );
-                    }
-                    else {
-                        spliceLine( indent, remainder, width-1 );
-                        lines.back() += "-";
-                    }
-                    if( lines.size() == 1 )
-                        indent = _attr.indent;
-                    if( tabPos != std::string::npos )
-                        indent += tabPos;
-                }
-            }
-        }
-
-        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {
-            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );
-            _remainder = _remainder.substr( _pos );
-        }
-
-        typedef std::vector<std::string>::const_iterator const_iterator;
-
-        const_iterator begin() const { return lines.begin(); }
-        const_iterator end() const { return lines.end(); }
-        std::string const& last() const { return lines.back(); }
-        std::size_t size() const { return lines.size(); }
-        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
-        std::string toString() const {
-            std::ostringstream oss;
-            oss << *this;
-            return oss.str();
-        }
-
-        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
-            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
-                it != itEnd; ++it ) {
-                if( it != _text.begin() )
-                    _stream << "\n";
-                _stream << *it;
-            }
-            return _stream;
-        }
-
-    private:
-        std::string str;
-        TextAttributes attr;
-        std::vector<std::string> lines;
-    };
-
-} // end namespace Tbc
-
-#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-} // end outer namespace
-#endif
-
-#endif // TBC_TEXT_FORMAT_H_INCLUDED
-
-// ----------- end of #include from tbc_text_format.h -----------
-// ........... back in /Users/philnash/Dev/OSS/Clara/srcs/clara.h
-
-#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE
-
-#include <map>
-#include <algorithm>
-#include <stdexcept>
-#include <memory>
-
-// Use optional outer namespace
-#ifdef STITCH_CLARA_OPEN_NAMESPACE
-STITCH_CLARA_OPEN_NAMESPACE
-#endif
-
-namespace Clara {
-
-    struct UnpositionalTag {};
-
-    extern UnpositionalTag _;
-
-#ifdef CLARA_CONFIG_MAIN
-    UnpositionalTag _;
-#endif
-
-    namespace Detail {
-
-#ifdef CLARA_CONSOLE_WIDTH
-    const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;
-#else
-    const unsigned int consoleWidth = 80;
-#endif
-
-        using namespace Tbc;
-
-        inline bool startsWith( std::string const& str, std::string const& prefix ) {
-            return str.size() >= prefix.size() && str.substr( 0, prefix.size() ) == prefix;
-        }
-
-        template<typename T> struct RemoveConstRef{ typedef T type; };
-        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };
-        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };
-        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };
-
-        template<typename T>    struct IsBool       { static const bool value = false; };
-        template<>              struct IsBool<bool> { static const bool value = true; };
-
-        template<typename T>
-        void convertInto( std::string const& _source, T& _dest ) {
-            std::stringstream ss;
-            ss << _source;
-            ss >> _dest;
-            if( ss.fail() )
-                throw std::runtime_error( "Unable to convert " + _source + " to destination type" );
-        }
-        inline void convertInto( std::string const& _source, std::string& _dest ) {
-            _dest = _source;
-        }
-        inline void convertInto( std::string const& _source, bool& _dest ) {
-            std::string sourceLC = _source;
-            std::transform( sourceLC.begin(), sourceLC.end(), sourceLC.begin(), ::tolower );
-            if( sourceLC == "y" || sourceLC == "1" || sourceLC == "true" || sourceLC == "yes" || sourceLC == "on" )
-                _dest = true;
-            else if( sourceLC == "n" || sourceLC == "0" || sourceLC == "false" || sourceLC == "no" || sourceLC == "off" )
-                _dest = false;
-            else
-                throw std::runtime_error( "Expected a boolean value but did not recognise:\n  '" + _source + "'" );
-        }
-        inline void convertInto( bool _source, bool& _dest ) {
-            _dest = _source;
-        }
-        template<typename T>
-        inline void convertInto( bool, T& ) {
-            throw std::runtime_error( "Invalid conversion" );
-        }
-
-        template<typename ConfigT>
-        struct IArgFunction {
-            virtual ~IArgFunction() {}
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-            IArgFunction()                      = default;
-            IArgFunction( IArgFunction const& ) = default;
-#  endif
-            virtual void set( ConfigT& config, std::string const& value ) const = 0;
-            virtual void setFlag( ConfigT& config ) const = 0;
-            virtual bool takesArg() const = 0;
-            virtual IArgFunction* clone() const = 0;
-        };
-
-        template<typename ConfigT>
-        class BoundArgFunction {
-        public:
-            BoundArgFunction() : functionObj( NULL ) {}
-            BoundArgFunction( IArgFunction<ConfigT>* _functionObj ) : functionObj( _functionObj ) {}
-            BoundArgFunction( BoundArgFunction const& other ) : functionObj( other.functionObj ? other.functionObj->clone() : NULL ) {}
-            BoundArgFunction& operator = ( BoundArgFunction const& other ) {
-                IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : NULL;
-                delete functionObj;
-                functionObj = newFunctionObj;
-                return *this;
-            }
-            ~BoundArgFunction() { delete functionObj; }
-
-            void set( ConfigT& config, std::string const& value ) const {
-                functionObj->set( config, value );
-            }
-            void setFlag( ConfigT& config ) const {
-                functionObj->setFlag( config );
-            }
-            bool takesArg() const { return functionObj->takesArg(); }
-
-            bool isSet() const {
-                return functionObj != NULL;
-            }
-        private:
-            IArgFunction<ConfigT>* functionObj;
-        };
-
-        template<typename C>
-        struct NullBinder : IArgFunction<C>{
-            virtual void set( C&, std::string const& ) const {}
-            virtual void setFlag( C& ) const {}
-            virtual bool takesArg() const { return true; }
-            virtual IArgFunction<C>* clone() const { return new NullBinder( *this ); }
-        };
-
-        template<typename C, typename M>
-        struct BoundDataMember : IArgFunction<C>{
-            BoundDataMember( M C::* _member ) : member( _member ) {}
-            virtual void set( C& p, std::string const& stringValue ) const {
-                convertInto( stringValue, p.*member );
-            }
-            virtual void setFlag( C& p ) const {
-                convertInto( true, p.*member );
-            }
-            virtual bool takesArg() const { return !IsBool<M>::value; }
-            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }
-            M C::* member;
-        };
-        template<typename C, typename M>
-        struct BoundUnaryMethod : IArgFunction<C>{
-            BoundUnaryMethod( void (C::*_member)( M ) ) : member( _member ) {}
-            virtual void set( C& p, std::string const& stringValue ) const {
-                typename RemoveConstRef<M>::type value;
-                convertInto( stringValue, value );
-                (p.*member)( value );
-            }
-            virtual void setFlag( C& p ) const {
-                typename RemoveConstRef<M>::type value;
-                convertInto( true, value );
-                (p.*member)( value );
-            }
-            virtual bool takesArg() const { return !IsBool<M>::value; }
-            virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod( *this ); }
-            void (C::*member)( M );
-        };
-        template<typename C>
-        struct BoundNullaryMethod : IArgFunction<C>{
-            BoundNullaryMethod( void (C::*_member)() ) : member( _member ) {}
-            virtual void set( C& p, std::string const& stringValue ) const {
-                bool value;
-                convertInto( stringValue, value );
-                if( value )
-                    (p.*member)();
-            }
-            virtual void setFlag( C& p ) const {
-                (p.*member)();
-            }
-            virtual bool takesArg() const { return false; }
-            virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod( *this ); }
-            void (C::*member)();
-        };
-
-        template<typename C>
-        struct BoundUnaryFunction : IArgFunction<C>{
-            BoundUnaryFunction( void (*_function)( C& ) ) : function( _function ) {}
-            virtual void set( C& obj, std::string const& stringValue ) const {
-                bool value;
-                convertInto( stringValue, value );
-                if( value )
-                    function( obj );
-            }
-            virtual void setFlag( C& p ) const {
-                function( p );
-            }
-            virtual bool takesArg() const { return false; }
-            virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }
-            void (*function)( C& );
-        };
-
-        template<typename C, typename T>
-        struct BoundBinaryFunction : IArgFunction<C>{
-            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
-            virtual void set( C& obj, std::string const& stringValue ) const {
-                typename RemoveConstRef<T>::type value;
-                convertInto( stringValue, value );
-                function( obj, value );
-            }
-            virtual void setFlag( C& obj ) const {
-                typename RemoveConstRef<T>::type value;
-                convertInto( true, value );
-                function( obj, value );
-            }
-            virtual bool takesArg() const { return !IsBool<T>::value; }
-            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
-            void (*function)( C&, T );
-        };
-
-    } // namespace Detail
-
-    struct Parser {
-        Parser() : separators( " \t=:" ) {}
-
-        struct Token {
-            enum Type { Positional, ShortOpt, LongOpt };
-            Token( Type _type, std::string const& _data ) : type( _type ), data( _data ) {}
-            Type type;
-            std::string data;
-        };
-
-        void parseIntoTokens( int argc, char const * const * argv, std::vector<Parser::Token>& tokens ) const {
-            const std::string doubleDash = "--";
-            for( int i = 1; i < argc && argv[i] != doubleDash; ++i )
-                parseIntoTokens( argv[i] , tokens);
-        }
-        void parseIntoTokens( std::string arg, std::vector<Parser::Token>& tokens ) const {
-            while( !arg.empty() ) {
-                Parser::Token token( Parser::Token::Positional, arg );
-                arg = "";
-                if( token.data[0] == '-' ) {
-                    if( token.data.size() > 1 && token.data[1] == '-' ) {
-                        token = Parser::Token( Parser::Token::LongOpt, token.data.substr( 2 ) );
-                    }
-                    else {
-                        token = Parser::Token( Parser::Token::ShortOpt, token.data.substr( 1 ) );
-                        if( token.data.size() > 1 && separators.find( token.data[1] ) == std::string::npos ) {
-                            arg = "-" + token.data.substr( 1 );
-                            token.data = token.data.substr( 0, 1 );
-                        }
-                    }
-                }
-                if( token.type != Parser::Token::Positional ) {
-                    std::size_t pos = token.data.find_first_of( separators );
-                    if( pos != std::string::npos ) {
-                        arg = token.data.substr( pos+1 );
-                        token.data = token.data.substr( 0, pos );
-                    }
-                }
-                tokens.push_back( token );
-            }
-        }
-        std::string separators;
-    };
-
-    template<typename ConfigT>
-    struct CommonArgProperties {
-        CommonArgProperties() {}
-        CommonArgProperties( Detail::BoundArgFunction<ConfigT> const& _boundField ) : boundField( _boundField ) {}
-
-        Detail::BoundArgFunction<ConfigT> boundField;
-        std::string description;
-        std::string detail;
-        std::string placeholder; // Only value if boundField takes an arg
-
-        bool takesArg() const {
-            return !placeholder.empty();
-        }
-        void validate() const {
-            if( !boundField.isSet() )
-                throw std::logic_error( "option not bound" );
-        }
-    };
-    struct OptionArgProperties {
-        std::vector<std::string> shortNames;
-        std::string longName;
-
-        bool hasShortName( std::string const& shortName ) const {
-            return std::find( shortNames.begin(), shortNames.end(), shortName ) != shortNames.end();
-        }
-        bool hasLongName( std::string const& _longName ) const {
-            return _longName == longName;
-        }
-    };
-    struct PositionalArgProperties {
-        PositionalArgProperties() : position( -1 ) {}
-        int position; // -1 means non-positional (floating)
-
-        bool isFixedPositional() const {
-            return position != -1;
-        }
-    };
-
-    template<typename ConfigT>
-    class CommandLine {
-
-        struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {
-            Arg() {}
-            Arg( Detail::BoundArgFunction<ConfigT> const& _boundField ) : CommonArgProperties<ConfigT>( _boundField ) {}
-
-            using CommonArgProperties<ConfigT>::placeholder; // !TBD
-
-            std::string dbgName() const {
-                if( !longName.empty() )
-                    return "--" + longName;
-                if( !shortNames.empty() )
-                    return "-" + shortNames[0];
-                return "positional args";
-            }
-            std::string commands() const {
-                std::ostringstream oss;
-                bool first = true;
-                std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();
-                for(; it != itEnd; ++it ) {
-                    if( first )
-                        first = false;
-                    else
-                        oss << ", ";
-                    oss << "-" << *it;
-                }
-                if( !longName.empty() ) {
-                    if( !first )
-                        oss << ", ";
-                    oss << "--" << longName;
-                }
-                if( !placeholder.empty() )
-                    oss << " <" << placeholder << ">";
-                return oss.str();
-            }
-        };
-
-        // NOTE: std::auto_ptr is deprecated in c++11/c++0x
-#if defined(__cplusplus) && __cplusplus > 199711L
-        typedef std::unique_ptr<Arg> ArgAutoPtr;
-#else
-        typedef std::auto_ptr<Arg> ArgAutoPtr;
-#endif
-
-        friend void addOptName( Arg& arg, std::string const& optName )
-        {
-            if( optName.empty() )
-                return;
-            if( Detail::startsWith( optName, "--" ) ) {
-                if( !arg.longName.empty() )
-                    throw std::logic_error( "Only one long opt may be specified. '"
-                        + arg.longName
-                        + "' already specified, now attempting to add '"
-                        + optName + "'" );
-                arg.longName = optName.substr( 2 );
-            }
-            else if( Detail::startsWith( optName, "-" ) )
-                arg.shortNames.push_back( optName.substr( 1 ) );
-            else
-                throw std::logic_error( "option must begin with - or --. Option was: '" + optName + "'" );
-        }
-        friend void setPositionalArg( Arg& arg, int position )
-        {
-            arg.position = position;
-        }
-
-        class ArgBuilder {
-        public:
-            ArgBuilder( Arg* arg ) : m_arg( arg ) {}
-
-            // Bind a non-boolean data member (requires placeholder string)
-            template<typename C, typename M>
-            void bind( M C::* field, std::string const& placeholder ) {
-                m_arg->boundField = new Detail::BoundDataMember<C,M>( field );
-                m_arg->placeholder = placeholder;
-            }
-            // Bind a boolean data member (no placeholder required)
-            template<typename C>
-            void bind( bool C::* field ) {
-                m_arg->boundField = new Detail::BoundDataMember<C,bool>( field );
-            }
-
-            // Bind a method taking a single, non-boolean argument (requires a placeholder string)
-            template<typename C, typename M>
-            void bind( void (C::* unaryMethod)( M ), std::string const& placeholder ) {
-                m_arg->boundField = new Detail::BoundUnaryMethod<C,M>( unaryMethod );
-                m_arg->placeholder = placeholder;
-            }
-
-            // Bind a method taking a single, boolean argument (no placeholder string required)
-            template<typename C>
-            void bind( void (C::* unaryMethod)( bool ) ) {
-                m_arg->boundField = new Detail::BoundUnaryMethod<C,bool>( unaryMethod );
-            }
-
-            // Bind a method that takes no arguments (will be called if opt is present)
-            template<typename C>
-            void bind( void (C::* nullaryMethod)() ) {
-                m_arg->boundField = new Detail::BoundNullaryMethod<C>( nullaryMethod );
-            }
-
-            // Bind a free function taking a single argument - the object to operate on (no placeholder string required)
-            template<typename C>
-            void bind( void (* unaryFunction)( C& ) ) {
-                m_arg->boundField = new Detail::BoundUnaryFunction<C>( unaryFunction );
-            }
-
-            // Bind a free function taking a single argument - the object to operate on (requires a placeholder string)
-            template<typename C, typename T>
-            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
-                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
-                m_arg->placeholder = placeholder;
-            }
-
-            ArgBuilder& describe( std::string const& description ) {
-                m_arg->description = description;
-                return *this;
-            }
-            ArgBuilder& detail( std::string const& detail ) {
-                m_arg->detail = detail;
-                return *this;
-            }
-
-        protected:
-            Arg* m_arg;
-        };
-
-        class OptBuilder : public ArgBuilder {
-        public:
-            OptBuilder( Arg* arg ) : ArgBuilder( arg ) {}
-            OptBuilder( OptBuilder& other ) : ArgBuilder( other ) {}
-
-            OptBuilder& operator[]( std::string const& optName ) {
-                addOptName( *ArgBuilder::m_arg, optName );
-                return *this;
-            }
-        };
-
-    public:
-
-        CommandLine()
-        :   m_boundProcessName( new Detail::NullBinder<ConfigT>() ),
-            m_highestSpecifiedArgPosition( 0 ),
-            m_throwOnUnrecognisedTokens( false )
-        {}
-        CommandLine( CommandLine const& other )
-        :   m_boundProcessName( other.m_boundProcessName ),
-            m_options ( other.m_options ),
-            m_positionalArgs( other.m_positionalArgs ),
-            m_highestSpecifiedArgPosition( other.m_highestSpecifiedArgPosition ),
-            m_throwOnUnrecognisedTokens( other.m_throwOnUnrecognisedTokens )
-        {
-            if( other.m_floatingArg.get() )
-                m_floatingArg.reset( new Arg( *other.m_floatingArg ) );
-        }
-
-        CommandLine& setThrowOnUnrecognisedTokens( bool shouldThrow = true ) {
-            m_throwOnUnrecognisedTokens = shouldThrow;
-            return *this;
-        }
-
-        OptBuilder operator[]( std::string const& optName ) {
-            m_options.push_back( Arg() );
-            addOptName( m_options.back(), optName );
-            OptBuilder builder( &m_options.back() );
-            return builder;
-        }
-
-        ArgBuilder operator[]( int position ) {
-            m_positionalArgs.insert( std::make_pair( position, Arg() ) );
-            if( position > m_highestSpecifiedArgPosition )
-                m_highestSpecifiedArgPosition = position;
-            setPositionalArg( m_positionalArgs[position], position );
-            ArgBuilder builder( &m_positionalArgs[position] );
-            return builder;
-        }
-
-        // Invoke this with the _ instance
-        ArgBuilder operator[]( UnpositionalTag ) {
-            if( m_floatingArg.get() )
-                throw std::logic_error( "Only one unpositional argument can be added" );
-            m_floatingArg.reset( new Arg() );
-            ArgBuilder builder( m_floatingArg.get() );
-            return builder;
-        }
-
-        template<typename C, typename M>
-        void bindProcessName( M C::* field ) {
-            m_boundProcessName = new Detail::BoundDataMember<C,M>( field );
-        }
-        template<typename C, typename M>
-        void bindProcessName( void (C::*_unaryMethod)( M ) ) {
-            m_boundProcessName = new Detail::BoundUnaryMethod<C,M>( _unaryMethod );
-        }
-
-        void optUsage( std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth ) const {
-            typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;
-            std::size_t maxWidth = 0;
-            for( it = itBegin; it != itEnd; ++it )
-                maxWidth = (std::max)( maxWidth, it->commands().size() );
-
-            for( it = itBegin; it != itEnd; ++it ) {
-                Detail::Text usage( it->commands(), Detail::TextAttributes()
-                                                        .setWidth( maxWidth+indent )
-                                                        .setIndent( indent ) );
-                Detail::Text desc( it->description, Detail::TextAttributes()
-                                                        .setWidth( width - maxWidth - 3 ) );
-
-                for( std::size_t i = 0; i < (std::max)( usage.size(), desc.size() ); ++i ) {
-                    std::string usageCol = i < usage.size() ? usage[i] : "";
-                    os << usageCol;
-
-                    if( i < desc.size() && !desc[i].empty() )
-                        os  << std::string( indent + 2 + maxWidth - usageCol.size(), ' ' )
-                            << desc[i];
-                    os << "\n";
-                }
-            }
-        }
-        std::string optUsage() const {
-            std::ostringstream oss;
-            optUsage( oss );
-            return oss.str();
-        }
-
-        void argSynopsis( std::ostream& os ) const {
-            for( int i = 1; i <= m_highestSpecifiedArgPosition; ++i ) {
-                if( i > 1 )
-                    os << " ";
-                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( i );
-                if( it != m_positionalArgs.end() )
-                    os << "<" << it->second.placeholder << ">";
-                else if( m_floatingArg.get() )
-                    os << "<" << m_floatingArg->placeholder << ">";
-                else
-                    throw std::logic_error( "non consecutive positional arguments with no floating args" );
-            }
-            // !TBD No indication of mandatory args
-            if( m_floatingArg.get() ) {
-                if( m_highestSpecifiedArgPosition > 1 )
-                    os << " ";
-                os << "[<" << m_floatingArg->placeholder << "> ...]";
-            }
-        }
-        std::string argSynopsis() const {
-            std::ostringstream oss;
-            argSynopsis( oss );
-            return oss.str();
-        }
-
-        void usage( std::ostream& os, std::string const& procName ) const {
-            validate();
-            os << "usage:\n  " << procName << " ";
-            argSynopsis( os );
-            if( !m_options.empty() ) {
-                os << " [options]\n\nwhere options are: \n";
-                optUsage( os, 2 );
-            }
-            os << "\n";
-        }
-        std::string usage( std::string const& procName ) const {
-            std::ostringstream oss;
-            usage( oss, procName );
-            return oss.str();
-        }
-
-        ConfigT parse( int argc, char const * const * argv ) const {
-            ConfigT config;
-            parseInto( argc, argv, config );
-            return config;
-        }
-
-        std::vector<Parser::Token> parseInto( int argc, char const * const * argv, ConfigT& config ) const {
-            std::string processName = argv[0];
-            std::size_t lastSlash = processName.find_last_of( "/\\" );
-            if( lastSlash != std::string::npos )
-                processName = processName.substr( lastSlash+1 );
-            m_boundProcessName.set( config, processName );
-            std::vector<Parser::Token> tokens;
-            Parser parser;
-            parser.parseIntoTokens( argc, argv, tokens );
-            return populate( tokens, config );
-        }
-
-        std::vector<Parser::Token> populate( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
-            validate();
-            std::vector<Parser::Token> unusedTokens = populateOptions( tokens, config );
-            unusedTokens = populateFixedArgs( unusedTokens, config );
-            unusedTokens = populateFloatingArgs( unusedTokens, config );
-            return unusedTokens;
-        }
-
-        std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
-            std::vector<Parser::Token> unusedTokens;
-            std::vector<std::string> errors;
-            for( std::size_t i = 0; i < tokens.size(); ++i ) {
-                Parser::Token const& token = tokens[i];
-                typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
-                for(; it != itEnd; ++it ) {
-                    Arg const& arg = *it;
-
-                    try {
-                        if( ( token.type == Parser::Token::ShortOpt && arg.hasShortName( token.data ) ) ||
-                            ( token.type == Parser::Token::LongOpt && arg.hasLongName( token.data ) ) ) {
-                            if( arg.takesArg() ) {
-                                if( i == tokens.size()-1 || tokens[i+1].type != Parser::Token::Positional )
-                                    errors.push_back( "Expected argument to option: " + token.data );
-                                else
-                                    arg.boundField.set( config, tokens[++i].data );
-                            }
-                            else {
-                                arg.boundField.setFlag( config );
-                            }
-                            break;
-                        }
-                    }
-                    catch( std::exception& ex ) {
-                        errors.push_back( std::string( ex.what() ) + "\n- while parsing: (" + arg.commands() + ")" );
-                    }
-                }
-                if( it == itEnd ) {
-                    if( token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens )
-                        unusedTokens.push_back( token );
-                    else if( errors.empty() && m_throwOnUnrecognisedTokens )
-                        errors.push_back( "unrecognised option: " + token.data );
-                }
-            }
-            if( !errors.empty() ) {
-                std::ostringstream oss;
-                for( std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();
-                        it != itEnd;
-                        ++it ) {
-                    if( it != errors.begin() )
-                        oss << "\n";
-                    oss << *it;
-                }
-                throw std::runtime_error( oss.str() );
-            }
-            return unusedTokens;
-        }
-        std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
-            std::vector<Parser::Token> unusedTokens;
-            int position = 1;
-            for( std::size_t i = 0; i < tokens.size(); ++i ) {
-                Parser::Token const& token = tokens[i];
-                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( position );
-                if( it != m_positionalArgs.end() )
-                    it->second.boundField.set( config, token.data );
-                else
-                    unusedTokens.push_back( token );
-                if( token.type == Parser::Token::Positional )
-                    position++;
-            }
-            return unusedTokens;
-        }
-        std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
-            if( !m_floatingArg.get() )
-                return tokens;
-            std::vector<Parser::Token> unusedTokens;
-            for( std::size_t i = 0; i < tokens.size(); ++i ) {
-                Parser::Token const& token = tokens[i];
-                if( token.type == Parser::Token::Positional )
-                    m_floatingArg->boundField.set( config, token.data );
-                else
-                    unusedTokens.push_back( token );
-            }
-            return unusedTokens;
-        }
-
-        void validate() const
-        {
-            if( m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get() )
-                throw std::logic_error( "No options or arguments specified" );
-
-            for( typename std::vector<Arg>::const_iterator  it = m_options.begin(),
-                                                            itEnd = m_options.end();
-                    it != itEnd; ++it )
-                it->validate();
-        }
-
-    private:
-        Detail::BoundArgFunction<ConfigT> m_boundProcessName;
-        std::vector<Arg> m_options;
-        std::map<int, Arg> m_positionalArgs;
-        ArgAutoPtr m_floatingArg;
-        int m_highestSpecifiedArgPosition;
-        bool m_throwOnUnrecognisedTokens;
-    };
-
-} // end namespace Clara
-
-STITCH_CLARA_CLOSE_NAMESPACE
-#undef STITCH_CLARA_OPEN_NAMESPACE
-#undef STITCH_CLARA_CLOSE_NAMESPACE
-
-#endif // TWOBLUECUBES_CLARA_H_INCLUDED
-#undef STITCH_CLARA_OPEN_NAMESPACE
-
-// Restore Clara's value for console width, if present
-#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
-#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
-#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
-#endif
-
-#include <fstream>
-
-namespace Catch {
-
-    inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }
-    inline void abortAfterX( ConfigData& config, int x ) {
-        if( x < 1 )
-            throw std::runtime_error( "Value after -x or --abortAfter must be greater than zero" );
-        config.abortAfter = x;
-    }
-    inline void addTestOrTags( ConfigData& config, std::string const& _testSpec ) { config.testsOrTags.push_back( _testSpec ); }
-
-    inline void addWarning( ConfigData& config, std::string const& _warning ) {
-        if( _warning == "NoAssertions" )
-            config.warnings = static_cast<WarnAbout::What>( config.warnings | WarnAbout::NoAssertions );
-        else
-            throw std::runtime_error( "Unrecognised warning: '" + _warning + "'" );
-    }
-    inline void setOrder( ConfigData& config, std::string const& order ) {
-        if( startsWith( "declared", order ) )
-            config.runOrder = RunTests::InDeclarationOrder;
-        else if( startsWith( "lexical", order ) )
-            config.runOrder = RunTests::InLexicographicalOrder;
-        else if( startsWith( "random", order ) )
-            config.runOrder = RunTests::InRandomOrder;
-        else
-            throw std::runtime_error( "Unrecognised ordering: '" + order + "'" );
-    }
-    inline void setRngSeed( ConfigData& config, std::string const& seed ) {
-        if( seed == "time" ) {
-            config.rngSeed = static_cast<unsigned int>( std::time(0) );
-        }
-        else {
-            std::stringstream ss;
-            ss << seed;
-            ss >> config.rngSeed;
-            if( ss.fail() )
-                throw std::runtime_error( "Argment to --rng-seed should be the word 'time' or a number" );
-        }
-    }
-    inline void setVerbosity( ConfigData& config, int level ) {
-        // !TBD: accept strings?
-        config.verbosity = static_cast<Verbosity::Level>( level );
-    }
-    inline void setShowDurations( ConfigData& config, bool _showDurations ) {
-        config.showDurations = _showDurations
-            ? ShowDurations::Always
-            : ShowDurations::Never;
-    }
-    inline void loadTestNamesFromFile( ConfigData& config, std::string const& _filename ) {
-        std::ifstream f( _filename.c_str() );
-        if( !f.is_open() )
-            throw std::domain_error( "Unable to load input file: " + _filename );
-
-        std::string line;
-        while( std::getline( f, line ) ) {
-            line = trim(line);
-            if( !line.empty() && !startsWith( line, "#" ) )
-                addTestOrTags( config, "\"" + line + "\"," );
-        }
-    }
-
-    inline Clara::CommandLine<ConfigData> makeCommandLineParser() {
-
-        using namespace Clara;
-        CommandLine<ConfigData> cli;
-
-        cli.bindProcessName( &ConfigData::processName );
-
-        cli["-?"]["-h"]["--help"]
-            .describe( "display usage information" )
-            .bind( &ConfigData::showHelp );
-
-        cli["-l"]["--list-tests"]
-            .describe( "list all/matching test cases" )
-            .bind( &ConfigData::listTests );
-
-        cli["-t"]["--list-tags"]
-            .describe( "list all/matching tags" )
-            .bind( &ConfigData::listTags );
-
-        cli["-s"]["--success"]
-            .describe( "include successful tests in output" )
-            .bind( &ConfigData::showSuccessfulTests );
-
-        cli["-b"]["--break"]
-            .describe( "break into debugger on failure" )
-            .bind( &ConfigData::shouldDebugBreak );
-
-        cli["-e"]["--nothrow"]
-            .describe( "skip exception tests" )
-            .bind( &ConfigData::noThrow );
-
-        cli["-i"]["--invisibles"]
-            .describe( "show invisibles (tabs, newlines)" )
-            .bind( &ConfigData::showInvisibles );
-
-        cli["-o"]["--out"]
-            .describe( "output filename" )
-            .bind( &ConfigData::outputFilename, "filename" );
-
-        cli["-r"]["--reporter"]
-//            .placeholder( "name[:filename]" )
-            .describe( "reporter to use (defaults to console)" )
-            .bind( &ConfigData::reporterName, "name" );
-
-        cli["-n"]["--name"]
-            .describe( "suite name" )
-            .bind( &ConfigData::name, "name" );
-
-        cli["-a"]["--abort"]
-            .describe( "abort at first failure" )
-            .bind( &abortAfterFirst );
-
-        cli["-x"]["--abortx"]
-            .describe( "abort after x failures" )
-            .bind( &abortAfterX, "no. failures" );
-
-        cli["-w"]["--warn"]
-            .describe( "enable warnings" )
-            .bind( &addWarning, "warning name" );
-
-// - needs updating if reinstated
-//        cli.into( &setVerbosity )
-//            .describe( "level of verbosity (0=no output)" )
-//            .shortOpt( "v")
-//            .longOpt( "verbosity" )
-//            .placeholder( "level" );
-
-        cli[_]
-            .describe( "which test or tests to use" )
-            .bind( &addTestOrTags, "test name, pattern or tags" );
-
-        cli["-d"]["--durations"]
-            .describe( "show test durations" )
-            .bind( &setShowDurations, "yes/no" );
-
-        cli["-f"]["--input-file"]
-            .describe( "load test names to run from a file" )
-            .bind( &loadTestNamesFromFile, "filename" );
-
-        // Less common commands which don't have a short form
-        cli["--list-test-names-only"]
-            .describe( "list all/matching test cases names only" )
-            .bind( &ConfigData::listTestNamesOnly );
-
-        cli["--list-reporters"]
-            .describe( "list all reporters" )
-            .bind( &ConfigData::listReporters );
-
-        cli["--order"]
-            .describe( "test case order (defaults to decl)" )
-            .bind( &setOrder, "decl|lex|rand" );
-
-        cli["--rng-seed"]
-            .describe( "set a specific seed for random numbers" )
-            .bind( &setRngSeed, "'time'|number" );
-
-        cli["--force-colour"]
-            .describe( "force colourised output" )
-            .bind( &ConfigData::forceColour );
-
-        return cli;
-    }
-
-} // end namespace Catch
-
-// #included from: internal/catch_list.hpp
-#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED
-
-// #included from: catch_text.h
-#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED
-
-#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
-
-#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch
-// #included from: ../external/tbc_text_format.h
-// Only use header guard if we are not using an outer namespace
-#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
-#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
-#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
-#  endif
-# else
-#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
-# endif
-#endif
-#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
-#include <string>
-#include <vector>
-#include <sstream>
-
-// Use optional outer namespace
-#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
-#endif
-
-namespace Tbc {
-
-#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
-    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
-#else
-    const unsigned int consoleWidth = 80;
-#endif
-
-    struct TextAttributes {
-        TextAttributes()
-        :   initialIndent( std::string::npos ),
-            indent( 0 ),
-            width( consoleWidth-1 ),
-            tabChar( '\t' )
-        {}
-
-        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
-        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
-        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
-        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }
-
-        std::size_t initialIndent;  // indent of first line, or npos
-        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
-        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
-        char tabChar;               // If this char is seen the indent is changed to current pos
-    };
-
-    class Text {
-    public:
-        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
-        : attr( _attr )
-        {
-            std::string wrappableChars = " [({.,/|\\-";
-            std::size_t indent = _attr.initialIndent != std::string::npos
-                ? _attr.initialIndent
-                : _attr.indent;
-            std::string remainder = _str;
-
-            while( !remainder.empty() ) {
-                if( lines.size() >= 1000 ) {
-                    lines.push_back( "... message truncated due to excessive size" );
-                    return;
-                }
-                std::size_t tabPos = std::string::npos;
-                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );
-                std::size_t pos = remainder.find_first_of( '\n' );
-                if( pos <= width ) {
-                    width = pos;
-                }
-                pos = remainder.find_last_of( _attr.tabChar, width );
-                if( pos != std::string::npos ) {
-                    tabPos = pos;
-                    if( remainder[width] == '\n' )
-                        width--;
-                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
-                }
-
-                if( width == remainder.size() ) {
-                    spliceLine( indent, remainder, width );
-                }
-                else if( remainder[width] == '\n' ) {
-                    spliceLine( indent, remainder, width );
-                    if( width <= 1 || remainder.size() != 1 )
-                        remainder = remainder.substr( 1 );
-                    indent = _attr.indent;
-                }
-                else {
-                    pos = remainder.find_last_of( wrappableChars, width );
-                    if( pos != std::string::npos && pos > 0 ) {
-                        spliceLine( indent, remainder, pos );
-                        if( remainder[0] == ' ' )
-                            remainder = remainder.substr( 1 );
-                    }
-                    else {
-                        spliceLine( indent, remainder, width-1 );
-                        lines.back() += "-";
-                    }
-                    if( lines.size() == 1 )
-                        indent = _attr.indent;
-                    if( tabPos != std::string::npos )
-                        indent += tabPos;
-                }
-            }
-        }
-
-        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {
-            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );
-            _remainder = _remainder.substr( _pos );
-        }
-
-        typedef std::vector<std::string>::const_iterator const_iterator;
-
-        const_iterator begin() const { return lines.begin(); }
-        const_iterator end() const { return lines.end(); }
-        std::string const& last() const { return lines.back(); }
-        std::size_t size() const { return lines.size(); }
-        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
-        std::string toString() const {
-            std::ostringstream oss;
-            oss << *this;
-            return oss.str();
-        }
-
-        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
-            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
-                it != itEnd; ++it ) {
-                if( it != _text.begin() )
-                    _stream << "\n";
-                _stream << *it;
-            }
-            return _stream;
-        }
-
-    private:
-        std::string str;
-        TextAttributes attr;
-        std::vector<std::string> lines;
-    };
-
-} // end namespace Tbc
-
-#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-} // end outer namespace
-#endif
-
-#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
-#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
-
-namespace Catch {
-    using Tbc::Text;
-    using Tbc::TextAttributes;
-}
-
-// #included from: catch_console_colour.hpp
-#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED
-
-namespace Catch {
-
-    struct Colour {
-        enum Code {
-            None = 0,
-
-            White,
-            Red,
-            Green,
-            Blue,
-            Cyan,
-            Yellow,
-            Grey,
-
-            Bright = 0x10,
-
-            BrightRed = Bright | Red,
-            BrightGreen = Bright | Green,
-            LightGrey = Bright | Grey,
-            BrightWhite = Bright | White,
-
-            // By intention
-            FileName = LightGrey,
-            Warning = Yellow,
-            ResultError = BrightRed,
-            ResultSuccess = BrightGreen,
-            ResultExpectedFailure = Warning,
-
-            Error = BrightRed,
-            Success = Green,
-
-            OriginalExpression = Cyan,
-            ReconstructedExpression = Yellow,
-
-            SecondaryText = LightGrey,
-            Headers = White
-        };
-
-        // Use constructed object for RAII guard
-        Colour( Code _colourCode );
-        Colour( Colour const& other );
-        ~Colour();
-
-        // Use static method for one-shot changes
-        static void use( Code _colourCode );
-
-    private:
-        bool m_moved;
-    };
-
-    inline std::ostream& operator << ( std::ostream& os, Colour const& ) { return os; }
-
-} // end namespace Catch
-
-// #included from: catch_interfaces_reporter.h
-#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED
-
-#include <string>
-#include <ostream>
-#include <map>
-#include <assert.h>
-
-namespace Catch
-{
-    struct ReporterConfig {
-        explicit ReporterConfig( Ptr<IConfig> const& _fullConfig )
-        :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
-
-        ReporterConfig( Ptr<IConfig> const& _fullConfig, std::ostream& _stream )
-        :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
-
-        std::ostream& stream() const    { return *m_stream; }
-        Ptr<IConfig> fullConfig() const { return m_fullConfig; }
-
-    private:
-        std::ostream* m_stream;
-        Ptr<IConfig> m_fullConfig;
-    };
-
-    struct ReporterPreferences {
-        ReporterPreferences()
-        : shouldRedirectStdOut( false )
-        {}
-
-        bool shouldRedirectStdOut;
-    };
-
-    template<typename T>
-    struct LazyStat : Option<T> {
-        LazyStat() : used( false ) {}
-        LazyStat& operator=( T const& _value ) {
-            Option<T>::operator=( _value );
-            used = false;
-            return *this;
-        }
-        void reset() {
-            Option<T>::reset();
-            used = false;
-        }
-        bool used;
-    };
-
-    struct TestRunInfo {
-        TestRunInfo( std::string const& _name ) : name( _name ) {}
-        std::string name;
-    };
-    struct GroupInfo {
-        GroupInfo(  std::string const& _name,
-                    std::size_t _groupIndex,
-                    std::size_t _groupsCount )
-        :   name( _name ),
-            groupIndex( _groupIndex ),
-            groupsCounts( _groupsCount )
-        {}
-
-        std::string name;
-        std::size_t groupIndex;
-        std::size_t groupsCounts;
-    };
-
-    struct AssertionStats {
-        AssertionStats( AssertionResult const& _assertionResult,
-                        std::vector<MessageInfo> const& _infoMessages,
-                        Totals const& _totals )
-        :   assertionResult( _assertionResult ),
-            infoMessages( _infoMessages ),
-            totals( _totals )
-        {
-            if( assertionResult.hasMessage() ) {
-                // Copy message into messages list.
-                // !TBD This should have been done earlier, somewhere
-                MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
-                builder << assertionResult.getMessage();
-                builder.m_info.message = builder.m_stream.str();
-
-                infoMessages.push_back( builder.m_info );
-            }
-        }
-        virtual ~AssertionStats();
-
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        AssertionStats( AssertionStats const& )              = default;
-        AssertionStats( AssertionStats && )                  = default;
-        AssertionStats& operator = ( AssertionStats const& ) = default;
-        AssertionStats& operator = ( AssertionStats && )     = default;
-#  endif
-
-        AssertionResult assertionResult;
-        std::vector<MessageInfo> infoMessages;
-        Totals totals;
-    };
-
-    struct SectionStats {
-        SectionStats(   SectionInfo const& _sectionInfo,
-                        Counts const& _assertions,
-                        double _durationInSeconds,
-                        bool _missingAssertions )
-        :   sectionInfo( _sectionInfo ),
-            assertions( _assertions ),
-            durationInSeconds( _durationInSeconds ),
-            missingAssertions( _missingAssertions )
-        {}
-        virtual ~SectionStats();
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        SectionStats( SectionStats const& )              = default;
-        SectionStats( SectionStats && )                  = default;
-        SectionStats& operator = ( SectionStats const& ) = default;
-        SectionStats& operator = ( SectionStats && )     = default;
-#  endif
-
-        SectionInfo sectionInfo;
-        Counts assertions;
-        double durationInSeconds;
-        bool missingAssertions;
-    };
-
-    struct TestCaseStats {
-        TestCaseStats(  TestCaseInfo const& _testInfo,
-                        Totals const& _totals,
-                        std::string const& _stdOut,
-                        std::string const& _stdErr,
-                        bool _aborting )
-        : testInfo( _testInfo ),
-            totals( _totals ),
-            stdOut( _stdOut ),
-            stdErr( _stdErr ),
-            aborting( _aborting )
-        {}
-        virtual ~TestCaseStats();
-
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        TestCaseStats( TestCaseStats const& )              = default;
-        TestCaseStats( TestCaseStats && )                  = default;
-        TestCaseStats& operator = ( TestCaseStats const& ) = default;
-        TestCaseStats& operator = ( TestCaseStats && )     = default;
-#  endif
-
-        TestCaseInfo testInfo;
-        Totals totals;
-        std::string stdOut;
-        std::string stdErr;
-        bool aborting;
-    };
-
-    struct TestGroupStats {
-        TestGroupStats( GroupInfo const& _groupInfo,
-                        Totals const& _totals,
-                        bool _aborting )
-        :   groupInfo( _groupInfo ),
-            totals( _totals ),
-            aborting( _aborting )
-        {}
-        TestGroupStats( GroupInfo const& _groupInfo )
-        :   groupInfo( _groupInfo ),
-            aborting( false )
-        {}
-        virtual ~TestGroupStats();
-
-#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        TestGroupStats( TestGroupStats const& )              = default;
-        TestGroupStats( TestGroupStats && )                  = default;
-        TestGroupStats& operator = ( TestGroupStats const& ) = default;
-        TestGroupStats& operator = ( TestGroupStats && )     = default;
-#  endif
-
-        GroupInfo groupInfo;
-        Totals totals;
-        bool aborting;
-    };
-
-    struct TestRunStats {
-        TestRunStats(   TestRunInfo const& _runInfo,
-                        Totals const& _totals,
-                        bool _aborting )
-        :   runInfo( _runInfo ),
-            totals( _totals ),
-            aborting( _aborting )
-        {}
-        virtual ~TestRunStats();
-
-#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS
-        TestRunStats( TestRunStats const& _other )
-        :   runInfo( _other.runInfo ),
-            totals( _other.totals ),
-            aborting( _other.aborting )
-        {}
-#  else
-        TestRunStats( TestRunStats const& )              = default;
-        TestRunStats( TestRunStats && )                  = default;
-        TestRunStats& operator = ( TestRunStats const& ) = default;
-        TestRunStats& operator = ( TestRunStats && )     = default;
-#  endif
-
-        TestRunInfo runInfo;
-        Totals totals;
-        bool aborting;
-    };
-
-    struct IStreamingReporter : IShared {
-        virtual ~IStreamingReporter();
-
-        // Implementing class must also provide the following static method:
-        // static std::string getDescription();
-
-        virtual ReporterPreferences getPreferences() const = 0;
-
-        virtual void noMatchingTestCases( std::string const& spec ) = 0;
-
-        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
-        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
-
-        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
-        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
-
-        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
-
-        // The return value indicates if the messages buffer should be cleared:
-        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
-        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
-        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
-        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
-        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
-
-        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
-    };
-
-    struct IReporterFactory {
-        virtual ~IReporterFactory();
-        virtual IStreamingReporter* create( ReporterConfig const& config ) const = 0;
-        virtual std::string getDescription() const = 0;
-    };
-
-    struct IReporterRegistry {
-        typedef std::map<std::string, IReporterFactory*> FactoryMap;
-
-        virtual ~IReporterRegistry();
-        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig> const& config ) const = 0;
-        virtual FactoryMap const& getFactories() const = 0;
-    };
-
-}
-
-#include <limits>
-#include <algorithm>
-
-namespace Catch {
-
-    inline std::size_t listTests( Config const& config ) {
-
-        TestSpec testSpec = config.testSpec();
-        if( config.testSpec().hasFilters() )
-            Catch::cout() << "Matching test cases:\n";
-        else {
-            Catch::cout() << "All available test cases:\n";
-            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
-        }
-
-        std::size_t matchedTests = 0;
-        TextAttributes nameAttr, tagsAttr;
-        nameAttr.setInitialIndent( 2 ).setIndent( 4 );
-        tagsAttr.setIndent( 6 );
-
-        std::vector<TestCase> matchedTestCases;
-        getRegistryHub().getTestCaseRegistry().getFilteredTests( testSpec, config, matchedTestCases );
-        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
-                it != itEnd;
-                ++it ) {
-            matchedTests++;
-            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
-            Colour::Code colour = testCaseInfo.isHidden()
-                ? Colour::SecondaryText
-                : Colour::None;
-            Colour colourGuard( colour );
-
-            Catch::cout() << Text( testCaseInfo.name, nameAttr ) << std::endl;
-            if( !testCaseInfo.tags.empty() )
-                Catch::cout() << Text( testCaseInfo.tagsAsString, tagsAttr ) << std::endl;
-        }
-
-        if( !config.testSpec().hasFilters() )
-            Catch::cout() << pluralise( matchedTests, "test case" ) << "\n" << std::endl;
-        else
-            Catch::cout() << pluralise( matchedTests, "matching test case" ) << "\n" << std::endl;
-        return matchedTests;
-    }
-
-    inline std::size_t listTestsNamesOnly( Config const& config ) {
-        TestSpec testSpec = config.testSpec();
-        if( !config.testSpec().hasFilters() )
-            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
-        std::size_t matchedTests = 0;
-        std::vector<TestCase> matchedTestCases;
-        getRegistryHub().getTestCaseRegistry().getFilteredTests( testSpec, config, matchedTestCases );
-        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
-                it != itEnd;
-                ++it ) {
-            matchedTests++;
-            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
-            Catch::cout() << testCaseInfo.name << std::endl;
-        }
-        return matchedTests;
-    }
-
-    struct TagInfo {
-        TagInfo() : count ( 0 ) {}
-        void add( std::string const& spelling ) {
-            ++count;
-            spellings.insert( spelling );
-        }
-        std::string all() const {
-            std::string out;
-            for( std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();
-                        it != itEnd;
-                        ++it )
-                out += "[" + *it + "]";
-            return out;
-        }
-        std::set<std::string> spellings;
-        std::size_t count;
-    };
-
-    inline std::size_t listTags( Config const& config ) {
-        TestSpec testSpec = config.testSpec();
-        if( config.testSpec().hasFilters() )
-            Catch::cout() << "Tags for matching test cases:\n";
-        else {
-            Catch::cout() << "All available tags:\n";
-            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
-        }
-
-        std::map<std::string, TagInfo> tagCounts;
-
-        std::vector<TestCase> matchedTestCases;
-        getRegistryHub().getTestCaseRegistry().getFilteredTests( testSpec, config, matchedTestCases );
-        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
-                it != itEnd;
-                ++it ) {
-            for( std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),
-                                                        tagItEnd = it->getTestCaseInfo().tags.end();
-                    tagIt != tagItEnd;
-                    ++tagIt ) {
-                std::string tagName = *tagIt;
-                std::string lcaseTagName = toLower( tagName );
-                std::map<std::string, TagInfo>::iterator countIt = tagCounts.find( lcaseTagName );
-                if( countIt == tagCounts.end() )
-                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
-                countIt->second.add( tagName );
-            }
-        }
-
-        for( std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),
-                                                            countItEnd = tagCounts.end();
-                countIt != countItEnd;
-                ++countIt ) {
-            std::ostringstream oss;
-            oss << "  " << std::setw(2) << countIt->second.count << "  ";
-            Text wrapper( countIt->second.all(), TextAttributes()
-                                                    .setInitialIndent( 0 )
-                                                    .setIndent( oss.str().size() )
-                                                    .setWidth( CATCH_CONFIG_CONSOLE_WIDTH-10 ) );
-            Catch::cout() << oss.str() << wrapper << "\n";
-        }
-        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << "\n" << std::endl;
-        return tagCounts.size();
-    }
-
-    inline std::size_t listReporters( Config const& /*config*/ ) {
-        Catch::cout() << "Available reporters:\n";
-        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
-        IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;
-        std::size_t maxNameLen = 0;
-        for(it = itBegin; it != itEnd; ++it )
-            maxNameLen = (std::max)( maxNameLen, it->first.size() );
-
-        for(it = itBegin; it != itEnd; ++it ) {
-            Text wrapper( it->second->getDescription(), TextAttributes()
-                                                        .setInitialIndent( 0 )
-                                                        .setIndent( 7+maxNameLen )
-                                                        .setWidth( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 ) );
-            Catch::cout() << "  "
-                    << it->first
-                    << ":"
-                    << std::string( maxNameLen - it->first.size() + 2, ' ' )
-                    << wrapper << "\n";
-        }
-        Catch::cout() << std::endl;
-        return factories.size();
-    }
-
-    inline Option<std::size_t> list( Config const& config ) {
-        Option<std::size_t> listedCount;
-        if( config.listTests() )
-            listedCount = listedCount.valueOr(0) + listTests( config );
-        if( config.listTestNamesOnly() )
-            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );
-        if( config.listTags() )
-            listedCount = listedCount.valueOr(0) + listTags( config );
-        if( config.listReporters() )
-            listedCount = listedCount.valueOr(0) + listReporters( config );
-        return listedCount;
-    }
-
-} // end namespace Catch
-
-// #included from: internal/catch_runner_impl.hpp
-#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED
-
-// #included from: catch_test_case_tracker.hpp
-#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
-
-#include <map>
-#include <string>
-#include <assert.h>
-
-namespace Catch {
-namespace SectionTracking {
-
-    class TrackedSection {
-
-        typedef std::map<std::string, TrackedSection> TrackedSections;
-
-    public:
-        enum RunState {
-            NotStarted,
-            Executing,
-            ExecutingChildren,
-            Completed
-        };
-
-        TrackedSection( std::string const& name, TrackedSection* parent )
-        :   m_name( name ), m_runState( NotStarted ), m_parent( parent )
-        {}
-
-        RunState runState() const { return m_runState; }
-
-        TrackedSection* findChild( std::string const& childName );
-        TrackedSection* acquireChild( std::string const& childName );
-
-        void enter() {
-            if( m_runState == NotStarted )
-                m_runState = Executing;
-        }
-        void leave();
-
-        TrackedSection* getParent() {
-            return m_parent;
-        }
-        bool hasChildren() const {
-            return !m_children.empty();
-        }
-
-    private:
-        std::string m_name;
-        RunState m_runState;
-        TrackedSections m_children;
-        TrackedSection* m_parent;
-    };
-
-    inline TrackedSection* TrackedSection::findChild( std::string const& childName ) {
-        TrackedSections::iterator it = m_children.find( childName );
-        return it != m_children.end()
-            ? &it->second
-            : NULL;
-    }
-    inline TrackedSection* TrackedSection::acquireChild( std::string const& childName ) {
-        if( TrackedSection* child = findChild( childName ) )
-            return child;
-        m_children.insert( std::make_pair( childName, TrackedSection( childName, this ) ) );
-        return findChild( childName );
-    }
-    inline void TrackedSection::leave() {
-        for( TrackedSections::const_iterator it = m_children.begin(), itEnd = m_children.end();
-                it != itEnd;
-                ++it )
-            if( it->second.runState() != Completed ) {
-                m_runState = ExecutingChildren;
-                return;
-            }
-        m_runState = Completed;
-    }
-
-    class TestCaseTracker {
-    public:
-        TestCaseTracker( std::string const& testCaseName )
-        :   m_testCase( testCaseName, NULL ),
-            m_currentSection( &m_testCase ),
-            m_completedASectionThisRun( false )
-        {}
-
-        bool enterSection( std::string const& name ) {
-            TrackedSection* child = m_currentSection->acquireChild( name );
-            if( m_completedASectionThisRun || child->runState() == TrackedSection::Completed )
-                return false;
-
-            m_currentSection = child;
-            m_currentSection->enter();
-            return true;
-        }
-        void leaveSection() {
-            m_currentSection->leave();
-            m_currentSection = m_currentSection->getParent();
-            assert( m_currentSection != NULL );
-            m_completedASectionThisRun = true;
-        }
-
-        bool currentSectionHasChildren() const {
-            return m_currentSection->hasChildren();
-        }
-        bool isCompleted() const {
-            return m_testCase.runState() == TrackedSection::Completed;
-        }
-
-        class Guard {
-        public:
-            Guard( TestCaseTracker& tracker ) : m_tracker( tracker ) {
-                m_tracker.enterTestCase();
-            }
-            ~Guard() {
-                m_tracker.leaveTestCase();
-            }
-        private:
-            Guard( Guard const& );
-            void operator = ( Guard const& );
-            TestCaseTracker& m_tracker;
-        };
-
-    private:
-        void enterTestCase() {
-            m_currentSection = &m_testCase;
-            m_completedASectionThisRun = false;
-            m_testCase.enter();
-        }
-        void leaveTestCase() {
-            m_testCase.leave();
-        }
-
-        TrackedSection m_testCase;
-        TrackedSection* m_currentSection;
-        bool m_completedASectionThisRun;
-    };
-
-} // namespace SectionTracking
-
-using SectionTracking::TestCaseTracker;
-
-} // namespace Catch
-
-// #included from: catch_fatal_condition.hpp
-#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED
-
-namespace Catch {
-
-    // Report the error condition then exit the process
-    inline void fatal( std::string const& message, int exitCode ) {
-        IContext& context = Catch::getCurrentContext();
-        IResultCapture* resultCapture = context.getResultCapture();
-        resultCapture->handleFatalErrorCondition( message );
-
-		if( Catch::alwaysTrue() ) // avoids "no return" warnings
-            exit( exitCode );
-    }
-
-} // namespace Catch
-
-#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////
-
-namespace Catch {
-
-    struct FatalConditionHandler {
-		void reset() {}
-	};
-
-} // namespace Catch
-
-#else // Not Windows - assumed to be POSIX compatible //////////////////////////
-
-#include <signal.h>
-
-namespace Catch {
-
-    struct SignalDefs { int id; const char* name; };
-    extern SignalDefs signalDefs[];
-    SignalDefs signalDefs[] = {
-            { SIGINT,  "SIGINT - Terminal interrupt signal" },
-            { SIGILL,  "SIGILL - Illegal instruction signal" },
-            { SIGFPE,  "SIGFPE - Floating point error signal" },
-            { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
-            { SIGTERM, "SIGTERM - Termination request signal" },
-            { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
-        };
-
-    struct FatalConditionHandler {
-
-        static void handleSignal( int sig ) {
-            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
-                if( sig == signalDefs[i].id )
-                    fatal( signalDefs[i].name, -sig );
-            fatal( "<unknown signal>", -sig );
-        }
-
-        FatalConditionHandler() : m_isSet( true ) {
-            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
-                signal( signalDefs[i].id, handleSignal );
-        }
-        ~FatalConditionHandler() {
-            reset();
-        }
-        void reset() {
-            if( m_isSet ) {
-                for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i )
-                    signal( signalDefs[i].id, SIG_DFL );
-                m_isSet = false;
-            }
-        }
-
-        bool m_isSet;
-    };
-
-} // namespace Catch
-
-#endif // not Windows
-
-#include <set>
-#include <string>
-
-namespace Catch {
-
-    class StreamRedirect {
-
-    public:
-        StreamRedirect( std::ostream& stream, std::string& targetString )
-        :   m_stream( stream ),
-            m_prevBuf( stream.rdbuf() ),
-            m_targetString( targetString )
-        {
-            stream.rdbuf( m_oss.rdbuf() );
-        }
-
-        ~StreamRedirect() {
-            m_targetString += m_oss.str();
-            m_stream.rdbuf( m_prevBuf );
-        }
-
-    private:
-        std::ostream& m_stream;
-        std::streambuf* m_prevBuf;
-        std::ostringstream m_oss;
-        std::string& m_targetString;
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-
-    class RunContext : public IResultCapture, public IRunner {
-
-        RunContext( RunContext const& );
-        void operator =( RunContext const& );
-
-    public:
-
-        explicit RunContext( Ptr<IConfig const> const& config, Ptr<IStreamingReporter> const& reporter )
-        :   m_runInfo( config->name() ),
-            m_context( getCurrentMutableContext() ),
-            m_activeTestCase( NULL ),
-            m_config( config ),
-            m_reporter( reporter ),
-            m_prevRunner( m_context.getRunner() ),
-            m_prevResultCapture( m_context.getResultCapture() ),
-            m_prevConfig( m_context.getConfig() )
-        {
-            m_context.setRunner( this );
-            m_context.setConfig( m_config );
-            m_context.setResultCapture( this );
-            m_reporter->testRunStarting( m_runInfo );
-        }
-
-        virtual ~RunContext() {
-            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
-            m_context.setRunner( m_prevRunner );
-            m_context.setConfig( NULL );
-            m_context.setResultCapture( m_prevResultCapture );
-            m_context.setConfig( m_prevConfig );
-        }
-
-        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount ) {
-            m_reporter->testGroupStarting( GroupInfo( testSpec, groupIndex, groupsCount ) );
-        }
-        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount ) {
-            m_reporter->testGroupEnded( TestGroupStats( GroupInfo( testSpec, groupIndex, groupsCount ), totals, aborting() ) );
-        }
-
-        Totals runTest( TestCase const& testCase ) {
-            Totals prevTotals = m_totals;
-
-            std::string redirectedCout;
-            std::string redirectedCerr;
-
-            TestCaseInfo testInfo = testCase.getTestCaseInfo();
-
-            m_reporter->testCaseStarting( testInfo );
-
-            m_activeTestCase = &testCase;
-            m_testCaseTracker = TestCaseTracker( testInfo.name );
-
-            do {
-                do {
-                    runCurrentTest( redirectedCout, redirectedCerr );
-                }
-                while( !m_testCaseTracker->isCompleted() && !aborting() );
-            }
-            while( getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting() );
-
-            Totals deltaTotals = m_totals.delta( prevTotals );
-            m_totals.testCases += deltaTotals.testCases;
-            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
-                                                        deltaTotals,
-                                                        redirectedCout,
-                                                        redirectedCerr,
-                                                        aborting() ) );
-
-            m_activeTestCase = NULL;
-            m_testCaseTracker.reset();
-
-            return deltaTotals;
-        }
-
-        Ptr<IConfig const> config() const {
-            return m_config;
-        }
-
-    private: // IResultCapture
-
-        virtual void assertionEnded( AssertionResult const& result ) {
-            if( result.getResultType() == ResultWas::Ok ) {
-                m_totals.assertions.passed++;
-            }
-            else if( !result.isOk() ) {
-                m_totals.assertions.failed++;
-            }
-
-            if( m_reporter->assertionEnded( AssertionStats( result, m_messages, m_totals ) ) )
-                m_messages.clear();
-
-            // Reset working state
-            m_lastAssertionInfo = AssertionInfo( "", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}" , m_lastAssertionInfo.resultDisposition );
-            m_lastResult = result;
-        }
-
-        virtual bool sectionStarted (
-            SectionInfo const& sectionInfo,
-            Counts& assertions
-        )
-        {
-            std::ostringstream oss;
-            oss << sectionInfo.name << "@" << sectionInfo.lineInfo;
-
-            if( !m_testCaseTracker->enterSection( oss.str() ) )
-                return false;
-
-            m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
-
-            m_reporter->sectionStarting( sectionInfo );
-
-            assertions = m_totals.assertions;
-
-            return true;
-        }
-        bool testForMissingAssertions( Counts& assertions ) {
-            if( assertions.total() != 0 ||
-                    !m_config->warnAboutMissingAssertions() ||
-                    m_testCaseTracker->currentSectionHasChildren() )
-                return false;
-            m_totals.assertions.failed++;
-            assertions.failed++;
-            return true;
-        }
-
-        virtual void sectionEnded( SectionInfo const& info, Counts const& prevAssertions, double _durationInSeconds ) {
-            if( std::uncaught_exception() ) {
-                m_unfinishedSections.push_back( UnfinishedSections( info, prevAssertions, _durationInSeconds ) );
-                return;
-            }
-
-            Counts assertions = m_totals.assertions - prevAssertions;
-            bool missingAssertions = testForMissingAssertions( assertions );
-
-            m_testCaseTracker->leaveSection();
-
-            m_reporter->sectionEnded( SectionStats( info, assertions, _durationInSeconds, missingAssertions ) );
-            m_messages.clear();
-        }
-
-        virtual void pushScopedMessage( MessageInfo const& message ) {
-            m_messages.push_back( message );
-        }
-
-        virtual void popScopedMessage( MessageInfo const& message ) {
-            m_messages.erase( std::remove( m_messages.begin(), m_messages.end(), message ), m_messages.end() );
-        }
-
-        virtual std::string getCurrentTestName() const {
-            return m_activeTestCase
-                ? m_activeTestCase->getTestCaseInfo().name
-                : "";
-        }
-
-        virtual const AssertionResult* getLastResult() const {
-            return &m_lastResult;
-        }
-
-        virtual void handleFatalErrorCondition( std::string const& message ) {
-            ResultBuilder resultBuilder = makeUnexpectedResultBuilder();
-            resultBuilder.setResultType( ResultWas::FatalErrorCondition );
-            resultBuilder << message;
-            resultBuilder.captureExpression();
-
-            handleUnfinishedSections();
-
-            // Recreate section for test case (as we will lose the one that was in scope)
-            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
-            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
-
-            Counts assertions;
-            assertions.failed = 1;
-            SectionStats testCaseSectionStats( testCaseSection, assertions, 0, false );
-            m_reporter->sectionEnded( testCaseSectionStats );
-
-            TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();
-
-            Totals deltaTotals;
-            deltaTotals.testCases.failed = 1;
-            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
-                                                        deltaTotals,
-                                                        "",
-                                                        "",
-                                                        false ) );
-            m_totals.testCases.failed++;
-            testGroupEnded( "", m_totals, 1, 1 );
-            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, false ) );
-        }
-
-    public:
-        // !TBD We need to do this another way!
-        bool aborting() const {
-            return m_totals.assertions.failed == static_cast<std::size_t>( m_config->abortAfter() );
-        }
-
-    private:
-
-        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr ) {
-            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
-            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
-            m_reporter->sectionStarting( testCaseSection );
-            Counts prevAssertions = m_totals.assertions;
-            double duration = 0;
-            try {
-                m_lastAssertionInfo = AssertionInfo( "TEST_CASE", testCaseInfo.lineInfo, "", ResultDisposition::Normal );
-                TestCaseTracker::Guard guard( *m_testCaseTracker );
-
-                Timer timer;
-                timer.start();
-                if( m_reporter->getPreferences().shouldRedirectStdOut ) {
-                    StreamRedirect coutRedir( Catch::cout(), redirectedCout );
-                    StreamRedirect cerrRedir( Catch::cerr(), redirectedCerr );
-                    invokeActiveTestCase();
-                }
-                else {
-                    invokeActiveTestCase();
-                }
-                duration = timer.getElapsedSeconds();
-            }
-            catch( TestFailureException& ) {
-                // This just means the test was aborted due to failure
-            }
-            catch(...) {
-                makeUnexpectedResultBuilder().useActiveException();
-            }
-            handleUnfinishedSections();
-            m_messages.clear();
-
-            Counts assertions = m_totals.assertions - prevAssertions;
-            bool missingAssertions = testForMissingAssertions( assertions );
-
-            if( testCaseInfo.okToFail() ) {
-                std::swap( assertions.failedButOk, assertions.failed );
-                m_totals.assertions.failed -= assertions.failedButOk;
-                m_totals.assertions.failedButOk += assertions.failedButOk;
-            }
-
-            SectionStats testCaseSectionStats( testCaseSection, assertions, duration, missingAssertions );
-            m_reporter->sectionEnded( testCaseSectionStats );
-        }
-
-        void invokeActiveTestCase() {
-            FatalConditionHandler fatalConditionHandler; // Handle signals
-            m_activeTestCase->invoke();
-            fatalConditionHandler.reset();
-        }
-
-    private:
-
-        ResultBuilder makeUnexpectedResultBuilder() const {
-            return ResultBuilder(   m_lastAssertionInfo.macroName.c_str(),
-                                    m_lastAssertionInfo.lineInfo,
-                                    m_lastAssertionInfo.capturedExpression.c_str(),
-                                    m_lastAssertionInfo.resultDisposition );
-        }
-
-        void handleUnfinishedSections() {
-            // If sections ended prematurely due to an exception we stored their
-            // infos here so we can tear them down outside the unwind process.
-            for( std::vector<UnfinishedSections>::const_reverse_iterator it = m_unfinishedSections.rbegin(),
-                        itEnd = m_unfinishedSections.rend();
-                    it != itEnd;
-                    ++it )
-                sectionEnded( it->info, it->prevAssertions, it->durationInSeconds );
-            m_unfinishedSections.clear();
-        }
-
-        struct UnfinishedSections {
-            UnfinishedSections( SectionInfo const& _info, Counts const& _prevAssertions, double _durationInSeconds )
-            : info( _info ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )
-            {}
-
-            SectionInfo info;
-            Counts prevAssertions;
-            double durationInSeconds;
-        };
-
-        TestRunInfo m_runInfo;
-        IMutableContext& m_context;
-        TestCase const* m_activeTestCase;
-        Option<TestCaseTracker> m_testCaseTracker;
-        AssertionResult m_lastResult;
-
-        Ptr<IConfig const> m_config;
-        Totals m_totals;
-        Ptr<IStreamingReporter> m_reporter;
-        std::vector<MessageInfo> m_messages;
-        IRunner* m_prevRunner;
-        IResultCapture* m_prevResultCapture;
-        Ptr<IConfig const> m_prevConfig;
-        AssertionInfo m_lastAssertionInfo;
-        std::vector<UnfinishedSections> m_unfinishedSections;
-    };
-
-    IResultCapture& getResultCapture() {
-        if( IResultCapture* capture = getCurrentContext().getResultCapture() )
-            return *capture;
-        else
-            throw std::logic_error( "No result capture instance" );
-    }
-
-} // end namespace Catch
-
-// #included from: internal/catch_version.h
-#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED
-
-namespace Catch {
-
-    // Versioning information
-    struct Version {
-        Version(    unsigned int _majorVersion,
-                    unsigned int _minorVersion,
-                    unsigned int _patchNumber,
-                    std::string const& _branchName,
-                    unsigned int _buildNumber );
-
-        unsigned int const majorVersion;
-        unsigned int const minorVersion;
-        unsigned int const patchNumber;
-
-        // buildNumber is only used if branchName is not null
-        std::string const branchName;
-        unsigned int const buildNumber;
-
-        friend std::ostream& operator << ( std::ostream& os, Version const& version );
-
-    private:
-        void operator=( Version const& );
-    };
-
-    extern Version libraryVersion;
-}
-
-#include <fstream>
-#include <stdlib.h>
-#include <limits>
-
-namespace Catch {
-
-    class Runner {
-
-    public:
-        Runner( Ptr<Config> const& config )
-        :   m_config( config )
-        {
-            openStream();
-            makeReporter();
-        }
-
-        Totals runTests() {
-
-            RunContext context( m_config.get(), m_reporter );
-
-            Totals totals;
-
-            context.testGroupStarting( "all tests", 1, 1 ); // deprecated?
-
-            TestSpec testSpec = m_config->testSpec();
-            if( !testSpec.hasFilters() )
-                testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "~[.]" ).testSpec(); // All not hidden tests
-
-            std::vector<TestCase> testCases;
-            getRegistryHub().getTestCaseRegistry().getFilteredTests( testSpec, *m_config, testCases );
-
-            int testsRunForGroup = 0;
-            for( std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();
-                    it != itEnd;
-                    ++it ) {
-                testsRunForGroup++;
-                if( m_testsAlreadyRun.find( *it ) == m_testsAlreadyRun.end() ) {
-
-                    if( context.aborting() )
-                        break;
-
-                    totals += context.runTest( *it );
-                    m_testsAlreadyRun.insert( *it );
-                }
-            }
-            std::vector<TestCase> skippedTestCases;
-            getRegistryHub().getTestCaseRegistry().getFilteredTests( testSpec, *m_config, skippedTestCases, true );
-
-            for( std::vector<TestCase>::const_iterator it = skippedTestCases.begin(), itEnd = skippedTestCases.end();
-                    it != itEnd;
-                    ++it )
-                m_reporter->skipTest( *it );
-
-            context.testGroupEnded( "all tests", totals, 1, 1 );
-            return totals;
-        }
-
-    private:
-        void openStream() {
-            // Open output file, if specified
-            if( !m_config->getFilename().empty() ) {
-                m_ofs.open( m_config->getFilename().c_str() );
-                if( m_ofs.fail() ) {
-                    std::ostringstream oss;
-                    oss << "Unable to open file: '" << m_config->getFilename() << "'";
-                    throw std::domain_error( oss.str() );
-                }
-                m_config->setStreamBuf( m_ofs.rdbuf() );
-            }
-        }
-        void makeReporter() {
-            std::string reporterName = m_config->getReporterName().empty()
-                ? "console"
-                : m_config->getReporterName();
-
-            m_reporter = getRegistryHub().getReporterRegistry().create( reporterName, m_config.get() );
-            if( !m_reporter ) {
-                std::ostringstream oss;
-                oss << "No reporter registered with name: '" << reporterName << "'";
-                throw std::domain_error( oss.str() );
-            }
-        }
-
-    private:
-        Ptr<Config> m_config;
-        std::ofstream m_ofs;
-        Ptr<IStreamingReporter> m_reporter;
-        std::set<TestCase> m_testsAlreadyRun;
-    };
-
-    class Session : NonCopyable {
-        static bool alreadyInstantiated;
-
-    public:
-
-        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };
-
-        Session()
-        : m_cli( makeCommandLineParser() ) {
-            if( alreadyInstantiated ) {
-                std::string msg = "Only one instance of Catch::Session can ever be used";
-                Catch::cerr() << msg << std::endl;
-                throw std::logic_error( msg );
-            }
-            alreadyInstantiated = true;
-        }
-        ~Session() {
-            Catch::cleanUp();
-        }
-
-        void showHelp( std::string const& processName ) {
-            Catch::cout() << "\nCatch v" << libraryVersion << "\n";
-
-            m_cli.usage( Catch::cout(), processName );
-            Catch::cout() << "For more detail usage please see the project docs\n" << std::endl;
-        }
-
-        int applyCommandLine( int argc, char* const argv[], OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) {
-            try {
-                m_cli.setThrowOnUnrecognisedTokens( unusedOptionBehaviour == OnUnusedOptions::Fail );
-                m_unusedTokens = m_cli.parseInto( argc, argv, m_configData );
-                if( m_configData.showHelp )
-                    showHelp( m_configData.processName );
-                m_config.reset();
-            }
-            catch( std::exception& ex ) {
-                {
-                    Colour colourGuard( Colour::Red );
-                    Catch::cerr()
-                        << "\nError(s) in input:\n"
-                        << Text( ex.what(), TextAttributes().setIndent(2) )
-                        << "\n\n";
-                }
-                m_cli.usage( Catch::cout(), m_configData.processName );
-                return (std::numeric_limits<int>::max)();
-            }
-            return 0;
-        }
-
-        void useConfigData( ConfigData const& _configData ) {
-            m_configData = _configData;
-            m_config.reset();
-        }
-
-        int run( int argc, char* const argv[] ) {
-
-            int returnCode = applyCommandLine( argc, argv );
-            if( returnCode == 0 )
-                returnCode = run();
-            return returnCode;
-        }
-
-        int run() {
-            if( m_configData.showHelp )
-                return 0;
-
-            try
-            {
-                config(); // Force config to be constructed
-
-                std::srand( m_configData.rngSeed );
-
-                Runner runner( m_config );
-
-                // Handle list request
-                if( Option<std::size_t> listed = list( config() ) )
-                    return static_cast<int>( *listed );
-
-                return static_cast<int>( runner.runTests().assertions.failed );
-            }
-            catch( std::exception& ex ) {
-                Catch::cerr() << ex.what() << std::endl;
-                return (std::numeric_limits<int>::max)();
-            }
-        }
-
-        Clara::CommandLine<ConfigData> const& cli() const {
-            return m_cli;
-        }
-        std::vector<Clara::Parser::Token> const& unusedTokens() const {
-            return m_unusedTokens;
-        }
-        ConfigData& configData() {
-            return m_configData;
-        }
-        Config& config() {
-            if( !m_config )
-                m_config = new Config( m_configData );
-            return *m_config;
-        }
-
-    private:
-        Clara::CommandLine<ConfigData> m_cli;
-        std::vector<Clara::Parser::Token> m_unusedTokens;
-        ConfigData m_configData;
-        Ptr<Config> m_config;
-    };
-
-    bool Session::alreadyInstantiated = false;
-
-} // end namespace Catch
-
-// #included from: catch_registry_hub.hpp
-#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED
-
-// #included from: catch_test_case_registry_impl.hpp
-#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
-
-#include <vector>
-#include <set>
-#include <sstream>
-#include <iostream>
-#include <algorithm>
-
-namespace Catch {
-
-    class TestRegistry : public ITestCaseRegistry {
-        struct LexSort {
-            bool operator() (TestCase i,TestCase j) const { return (i<j);}
-        };
-        struct RandomNumberGenerator {
-            int operator()( int n ) const { return std::rand() % n; }
-        };
-
-    public:
-        TestRegistry() : m_unnamedCount( 0 ) {}
-        virtual ~TestRegistry();
-
-        virtual void registerTest( TestCase const& testCase ) {
-            std::string name = testCase.getTestCaseInfo().name;
-            if( name == "" ) {
-                std::ostringstream oss;
-                oss << "Anonymous test case " << ++m_unnamedCount;
-                return registerTest( testCase.withName( oss.str() ) );
-            }
-
-            if( m_functions.find( testCase ) == m_functions.end() ) {
-                m_functions.insert( testCase );
-                m_functionsInOrder.push_back( testCase );
-                if( !testCase.isHidden() )
-                    m_nonHiddenFunctions.push_back( testCase );
-            }
-            else {
-                TestCase const& prev = *m_functions.find( testCase );
-                {
-                    Colour colourGuard( Colour::Red );
-                    Catch::cerr()   << "error: TEST_CASE( \"" << name << "\" ) already defined.\n"
-                                << "\tFirst seen at " << prev.getTestCaseInfo().lineInfo << "\n"
-                                << "\tRedefined at " << testCase.getTestCaseInfo().lineInfo << std::endl;
-                }
-                exit(1);
-            }
-        }
-
-        virtual std::vector<TestCase> const& getAllTests() const {
-            return m_functionsInOrder;
-        }
-
-        virtual std::vector<TestCase> const& getAllNonHiddenTests() const {
-            return m_nonHiddenFunctions;
-        }
-
-        virtual void getFilteredTests( TestSpec const& testSpec, IConfig const& config, std::vector<TestCase>& matchingTestCases, bool negated = false ) const {
-
-            for( std::vector<TestCase>::const_iterator  it = m_functionsInOrder.begin(),
-                                                        itEnd = m_functionsInOrder.end();
-                    it != itEnd;
-                    ++it ) {
-                bool includeTest = testSpec.matches( *it ) && ( config.allowThrows() || !it->throws() );
-                if( includeTest != negated )
-                    matchingTestCases.push_back( *it );
-            }
-            sortTests( config, matchingTestCases );
-        }
-
-    private:
-
-        static void sortTests( IConfig const& config, std::vector<TestCase>& matchingTestCases ) {
-
-            switch( config.runOrder() ) {
-                case RunTests::InLexicographicalOrder:
-                    std::sort( matchingTestCases.begin(), matchingTestCases.end(), LexSort() );
-                    break;
-                case RunTests::InRandomOrder:
-                {
-                    RandomNumberGenerator rng;
-                    std::random_shuffle( matchingTestCases.begin(), matchingTestCases.end(), rng );
-                }
-                    break;
-                case RunTests::InDeclarationOrder:
-                    // already in declaration order
-                    break;
-            }
-        }
-        std::set<TestCase> m_functions;
-        std::vector<TestCase> m_functionsInOrder;
-        std::vector<TestCase> m_nonHiddenFunctions;
-        size_t m_unnamedCount;
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-
-    class FreeFunctionTestCase : public SharedImpl<ITestCase> {
-    public:
-
-        FreeFunctionTestCase( TestFunction fun ) : m_fun( fun ) {}
-
-        virtual void invoke() const {
-            m_fun();
-        }
-
-    private:
-        virtual ~FreeFunctionTestCase();
-
-        TestFunction m_fun;
-    };
-
-    inline std::string extractClassName( std::string const& classOrQualifiedMethodName ) {
-        std::string className = classOrQualifiedMethodName;
-        if( startsWith( className, "&" ) )
-        {
-            std::size_t lastColons = className.rfind( "::" );
-            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
-            if( penultimateColons == std::string::npos )
-                penultimateColons = 1;
-            className = className.substr( penultimateColons, lastColons-penultimateColons );
-        }
-        return className;
-    }
-
-    ///////////////////////////////////////////////////////////////////////////
-
-    AutoReg::AutoReg(   TestFunction function,
-                        SourceLineInfo const& lineInfo,
-                        NameAndDesc const& nameAndDesc ) {
-        registerTestCase( new FreeFunctionTestCase( function ), "", nameAndDesc, lineInfo );
-    }
-
-    AutoReg::~AutoReg() {}
-
-    void AutoReg::registerTestCase( ITestCase* testCase,
-                                    char const* classOrQualifiedMethodName,
-                                    NameAndDesc const& nameAndDesc,
-                                    SourceLineInfo const& lineInfo ) {
-
-        getMutableRegistryHub().registerTest
-            ( makeTestCase( testCase,
-                            extractClassName( classOrQualifiedMethodName ),
-                            nameAndDesc.name,
-                            nameAndDesc.description,
-                            lineInfo ) );
-    }
-
-} // end namespace Catch
-
-// #included from: catch_reporter_registry.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED
-
-#include <map>
-
-namespace Catch {
-
-    class ReporterRegistry : public IReporterRegistry {
-
-    public:
-
-        virtual ~ReporterRegistry() {
-            deleteAllValues( m_factories );
-        }
-
-        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig> const& config ) const {
-            FactoryMap::const_iterator it =  m_factories.find( name );
-            if( it == m_factories.end() )
-                return NULL;
-            return it->second->create( ReporterConfig( config ) );
-        }
-
-        void registerReporter( std::string const& name, IReporterFactory* factory ) {
-            m_factories.insert( std::make_pair( name, factory ) );
-        }
-
-        FactoryMap const& getFactories() const {
-            return m_factories;
-        }
-
-    private:
-        FactoryMap m_factories;
-    };
-}
-
-// #included from: catch_exception_translator_registry.hpp
-#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
-
-#ifdef __OBJC__
-#import "Foundation/Foundation.h"
-#endif
-
-namespace Catch {
-
-    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
-    public:
-        ~ExceptionTranslatorRegistry() {
-            deleteAll( m_translators );
-        }
-
-        virtual void registerTranslator( const IExceptionTranslator* translator ) {
-            m_translators.push_back( translator );
-        }
-
-        virtual std::string translateActiveException() const {
-            try {
-#ifdef __OBJC__
-                // In Objective-C try objective-c exceptions first
-                @try {
-                    throw;
-                }
-                @catch (NSException *exception) {
-                    return Catch::toString( [exception description] );
-                }
-#else
-                throw;
-#endif
-            }
-            catch( TestFailureException& ) {
-                throw;
-            }
-            catch( std::exception& ex ) {
-                return ex.what();
-            }
-            catch( std::string& msg ) {
-                return msg;
-            }
-            catch( const char* msg ) {
-                return msg;
-            }
-            catch(...) {
-                return tryTranslators( m_translators.begin() );
-            }
-        }
-
-        std::string tryTranslators( std::vector<const IExceptionTranslator*>::const_iterator it ) const {
-            if( it == m_translators.end() )
-                return "Unknown exception";
-
-            try {
-                return (*it)->translate();
-            }
-            catch(...) {
-                return tryTranslators( it+1 );
-            }
-        }
-
-    private:
-        std::vector<const IExceptionTranslator*> m_translators;
-    };
-}
-
-namespace Catch {
-
-    namespace {
-
-        class RegistryHub : public IRegistryHub, public IMutableRegistryHub {
-
-            RegistryHub( RegistryHub const& );
-            void operator=( RegistryHub const& );
-
-        public: // IRegistryHub
-            RegistryHub() {
-            }
-            virtual IReporterRegistry const& getReporterRegistry() const {
-                return m_reporterRegistry;
-            }
-            virtual ITestCaseRegistry const& getTestCaseRegistry() const {
-                return m_testCaseRegistry;
-            }
-            virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() {
-                return m_exceptionTranslatorRegistry;
-            }
-
-        public: // IMutableRegistryHub
-            virtual void registerReporter( std::string const& name, IReporterFactory* factory ) {
-                m_reporterRegistry.registerReporter( name, factory );
-            }
-            virtual void registerTest( TestCase const& testInfo ) {
-                m_testCaseRegistry.registerTest( testInfo );
-            }
-            virtual void registerTranslator( const IExceptionTranslator* translator ) {
-                m_exceptionTranslatorRegistry.registerTranslator( translator );
-            }
-
-        private:
-            TestRegistry m_testCaseRegistry;
-            ReporterRegistry m_reporterRegistry;
-            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
-        };
-
-        // Single, global, instance
-        inline RegistryHub*& getTheRegistryHub() {
-            static RegistryHub* theRegistryHub = NULL;
-            if( !theRegistryHub )
-                theRegistryHub = new RegistryHub();
-            return theRegistryHub;
-        }
-    }
-
-    IRegistryHub& getRegistryHub() {
-        return *getTheRegistryHub();
-    }
-    IMutableRegistryHub& getMutableRegistryHub() {
-        return *getTheRegistryHub();
-    }
-    void cleanUp() {
-        delete getTheRegistryHub();
-        getTheRegistryHub() = NULL;
-        cleanUpContext();
-    }
-    std::string translateActiveException() {
-        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
-    }
-
-} // end namespace Catch
-
-// #included from: catch_notimplemented_exception.hpp
-#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED
-
-#include <ostream>
-
-namespace Catch {
-
-    NotImplementedException::NotImplementedException( SourceLineInfo const& lineInfo )
-    :   m_lineInfo( lineInfo ) {
-        std::ostringstream oss;
-        oss << lineInfo << ": function ";
-        oss << "not implemented";
-        m_what = oss.str();
-    }
-
-    const char* NotImplementedException::what() const CATCH_NOEXCEPT {
-        return m_what.c_str();
-    }
-
-} // end namespace Catch
-
-// #included from: catch_context_impl.hpp
-#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED
-
-// #included from: catch_stream.hpp
-#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED
-
-// #included from: catch_streambuf.h
-#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED
-
-#include <streambuf>
-
-namespace Catch {
-
-    class StreamBufBase : public std::streambuf {
-    public:
-        virtual ~StreamBufBase() CATCH_NOEXCEPT;
-    };
-}
-
-#include <stdexcept>
-#include <cstdio>
-#include <iostream>
-
-namespace Catch {
-
-    template<typename WriterF, size_t bufferSize=256>
-    class StreamBufImpl : public StreamBufBase {
-        char data[bufferSize];
-        WriterF m_writer;
-
-    public:
-        StreamBufImpl() {
-            setp( data, data + sizeof(data) );
-        }
-
-        ~StreamBufImpl() CATCH_NOEXCEPT {
-            sync();
-        }
-
-    private:
-        int overflow( int c ) {
-            sync();
-
-            if( c != EOF ) {
-                if( pbase() == epptr() )
-                    m_writer( std::string( 1, static_cast<char>( c ) ) );
-                else
-                    sputc( static_cast<char>( c ) );
-            }
-            return 0;
-        }
-
-        int sync() {
-            if( pbase() != pptr() ) {
-                m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
-                setp( pbase(), epptr() );
-            }
-            return 0;
-        }
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-
-    struct OutputDebugWriter {
-
-        void operator()( std::string const&str ) {
-            writeToDebugConsole( str );
-        }
-    };
-
-    Stream::Stream()
-    : streamBuf( NULL ), isOwned( false )
-    {}
-
-    Stream::Stream( std::streambuf* _streamBuf, bool _isOwned )
-    : streamBuf( _streamBuf ), isOwned( _isOwned )
-    {}
-
-    void Stream::release() {
-        if( isOwned ) {
-            delete streamBuf;
-            streamBuf = NULL;
-            isOwned = false;
-        }
-    }
-
-#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement this functions
-    std::ostream& cout() {
-        return std::cout;
-    }
-    std::ostream& cerr() {
-        return std::cerr;
-    }
-#endif
-}
-
-namespace Catch {
-
-    class Context : public IMutableContext {
-
-        Context() : m_config( NULL ), m_runner( NULL ), m_resultCapture( NULL ) {}
-        Context( Context const& );
-        void operator=( Context const& );
-
-    public: // IContext
-        virtual IResultCapture* getResultCapture() {
-            return m_resultCapture;
-        }
-        virtual IRunner* getRunner() {
-            return m_runner;
-        }
-        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) {
-            return getGeneratorsForCurrentTest()
-            .getGeneratorInfo( fileInfo, totalSize )
-            .getCurrentIndex();
-        }
-        virtual bool advanceGeneratorsForCurrentTest() {
-            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
-            return generators && generators->moveNext();
-        }
-
-        virtual Ptr<IConfig const> getConfig() const {
-            return m_config;
-        }
-
-    public: // IMutableContext
-        virtual void setResultCapture( IResultCapture* resultCapture ) {
-            m_resultCapture = resultCapture;
-        }
-        virtual void setRunner( IRunner* runner ) {
-            m_runner = runner;
-        }
-        virtual void setConfig( Ptr<IConfig const> const& config ) {
-            m_config = config;
-        }
-
-        friend IMutableContext& getCurrentMutableContext();
-
-    private:
-        IGeneratorsForTest* findGeneratorsForCurrentTest() {
-            std::string testName = getResultCapture()->getCurrentTestName();
-
-            std::map<std::string, IGeneratorsForTest*>::const_iterator it =
-                m_generatorsByTestName.find( testName );
-            return it != m_generatorsByTestName.end()
-                ? it->second
-                : NULL;
-        }
-
-        IGeneratorsForTest& getGeneratorsForCurrentTest() {
-            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
-            if( !generators ) {
-                std::string testName = getResultCapture()->getCurrentTestName();
-                generators = createGeneratorsForTest();
-                m_generatorsByTestName.insert( std::make_pair( testName, generators ) );
-            }
-            return *generators;
-        }
-
-    private:
-        Ptr<IConfig const> m_config;
-        IRunner* m_runner;
-        IResultCapture* m_resultCapture;
-        std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
-    };
-
-    namespace {
-        Context* currentContext = NULL;
-    }
-    IMutableContext& getCurrentMutableContext() {
-        if( !currentContext )
-            currentContext = new Context();
-        return *currentContext;
-    }
-    IContext& getCurrentContext() {
-        return getCurrentMutableContext();
-    }
-
-    Stream createStream( std::string const& streamName ) {
-        if( streamName == "stdout" ) return Stream( Catch::cout().rdbuf(), false );
-        if( streamName == "stderr" ) return Stream( Catch::cerr().rdbuf(), false );
-        if( streamName == "debug" ) return Stream( new StreamBufImpl<OutputDebugWriter>, true );
-
-        throw std::domain_error( "Unknown stream: " + streamName );
-    }
-
-    void cleanUpContext() {
-        delete currentContext;
-        currentContext = NULL;
-    }
-}
-
-// #included from: catch_console_colour_impl.hpp
-#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED
-
-namespace Catch {
-    namespace {
-
-        struct IColourImpl {
-            virtual ~IColourImpl() {}
-            virtual void use( Colour::Code _colourCode ) = 0;
-        };
-
-        struct NoColourImpl : IColourImpl {
-            void use( Colour::Code ) {}
-
-            static IColourImpl* instance() {
-                static NoColourImpl s_instance;
-                return &s_instance;
-            }
-        };
-
-    } // anon namespace
-} // namespace Catch
-
-#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
-#   ifdef CATCH_PLATFORM_WINDOWS
-#       define CATCH_CONFIG_COLOUR_WINDOWS
-#   else
-#       define CATCH_CONFIG_COLOUR_ANSI
-#   endif
-#endif
-
-#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
-
-#ifndef NOMINMAX
-#define NOMINMAX
-#endif
-
-#ifdef __AFXDLL
-#include <AfxWin.h>
-#else
-#include <windows.h>
-#endif
-
-namespace Catch {
-namespace {
-
-    class Win32ColourImpl : public IColourImpl {
-    public:
-        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
-        {
-            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
-            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
-            originalAttributes = csbiInfo.wAttributes;
-        }
-
-        virtual void use( Colour::Code _colourCode ) {
-            switch( _colourCode ) {
-                case Colour::None:      return setTextAttribute( originalAttributes );
-                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
-                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
-                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
-                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
-                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
-                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
-                case Colour::Grey:      return setTextAttribute( 0 );
-
-                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
-                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
-                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
-                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
-
-                case Colour::Bright: throw std::logic_error( "not a colour" );
-            }
-        }
-
-    private:
-        void setTextAttribute( WORD _textAttribute ) {
-            SetConsoleTextAttribute( stdoutHandle, _textAttribute );
-        }
-        HANDLE stdoutHandle;
-        WORD originalAttributes;
-    };
-
-    IColourImpl* platformColourInstance() {
-        static Win32ColourImpl s_instance;
-        return &s_instance;
-    }
-
-} // end anon namespace
-} // end namespace Catch
-
-#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
-
-#include <unistd.h>
-
-namespace Catch {
-namespace {
-
-    // use POSIX/ ANSI console terminal codes
-    // Thanks to Adam Strzelecki for original contribution
-    // (http://github.com/nanoant)
-    // https://github.com/philsquared/Catch/pull/131
-    class PosixColourImpl : public IColourImpl {
-    public:
-        virtual void use( Colour::Code _colourCode ) {
-            switch( _colourCode ) {
-                case Colour::None:
-                case Colour::White:     return setColour( "[0m" );
-                case Colour::Red:       return setColour( "[0;31m" );
-                case Colour::Green:     return setColour( "[0;32m" );
-                case Colour::Blue:      return setColour( "[0:34m" );
-                case Colour::Cyan:      return setColour( "[0;36m" );
-                case Colour::Yellow:    return setColour( "[0;33m" );
-                case Colour::Grey:      return setColour( "[1;30m" );
-
-                case Colour::LightGrey:     return setColour( "[0;37m" );
-                case Colour::BrightRed:     return setColour( "[1;31m" );
-                case Colour::BrightGreen:   return setColour( "[1;32m" );
-                case Colour::BrightWhite:   return setColour( "[1;37m" );
-
-                case Colour::Bright: throw std::logic_error( "not a colour" );
-            }
-        }
-        static IColourImpl* instance() {
-            static PosixColourImpl s_instance;
-            return &s_instance;
-        }
-
-    private:
-        void setColour( const char* _escapeCode ) {
-            Catch::cout() << '\033' << _escapeCode;
-        }
-    };
-
-    IColourImpl* platformColourInstance() {
-        Ptr<IConfig const> config = getCurrentContext().getConfig();
-        return (config && config->forceColour()) || isatty(STDOUT_FILENO)
-            ? PosixColourImpl::instance()
-            : NoColourImpl::instance();
-    }
-
-} // end anon namespace
-} // end namespace Catch
-
-#else  // not Windows or ANSI ///////////////////////////////////////////////
-
-namespace Catch {
-
-    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
-
-} // end namespace Catch
-
-#endif // Windows/ ANSI/ None
-
-namespace Catch {
-
-    Colour::Colour( Code _colourCode ) : m_moved( false ) { use( _colourCode ); }
-    Colour::Colour( Colour const& _other ) : m_moved( false ) { const_cast<Colour&>( _other ).m_moved = true; }
-    Colour::~Colour(){ if( !m_moved ) use( None ); }
-
-    void Colour::use( Code _colourCode ) {
-        static IColourImpl* impl = isDebuggerActive()
-            ? NoColourImpl::instance()
-            : platformColourInstance();
-        impl->use( _colourCode );
-    }
-
-} // end namespace Catch
-
-// #included from: catch_generators_impl.hpp
-#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED
-
-#include <vector>
-#include <string>
-#include <map>
-
-namespace Catch {
-
-    struct GeneratorInfo : IGeneratorInfo {
-
-        GeneratorInfo( std::size_t size )
-        :   m_size( size ),
-            m_currentIndex( 0 )
-        {}
-
-        bool moveNext() {
-            if( ++m_currentIndex == m_size ) {
-                m_currentIndex = 0;
-                return false;
-            }
-            return true;
-        }
-
-        std::size_t getCurrentIndex() const {
-            return m_currentIndex;
-        }
-
-        std::size_t m_size;
-        std::size_t m_currentIndex;
-    };
-
-    ///////////////////////////////////////////////////////////////////////////
-
-    class GeneratorsForTest : public IGeneratorsForTest {
-
-    public:
-        ~GeneratorsForTest() {
-            deleteAll( m_generatorsInOrder );
-        }
-
-        IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {
-            std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find( fileInfo );
-            if( it == m_generatorsByName.end() ) {
-                IGeneratorInfo* info = new GeneratorInfo( size );
-                m_generatorsByName.insert( std::make_pair( fileInfo, info ) );
-                m_generatorsInOrder.push_back( info );
-                return *info;
-            }
-            return *it->second;
-        }
-
-        bool moveNext() {
-            std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
-            std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
-            for(; it != itEnd; ++it ) {
-                if( (*it)->moveNext() )
-                    return true;
-            }
-            return false;
-        }
-
-    private:
-        std::map<std::string, IGeneratorInfo*> m_generatorsByName;
-        std::vector<IGeneratorInfo*> m_generatorsInOrder;
-    };
-
-    IGeneratorsForTest* createGeneratorsForTest()
-    {
-        return new GeneratorsForTest();
-    }
-
-} // end namespace Catch
-
-// #included from: catch_assertionresult.hpp
-#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED
-
-namespace Catch {
-
-    AssertionInfo::AssertionInfo(   std::string const& _macroName,
-                                    SourceLineInfo const& _lineInfo,
-                                    std::string const& _capturedExpression,
-                                    ResultDisposition::Flags _resultDisposition )
-    :   macroName( _macroName ),
-        lineInfo( _lineInfo ),
-        capturedExpression( _capturedExpression ),
-        resultDisposition( _resultDisposition )
-    {}
-
-    AssertionResult::AssertionResult() {}
-
-    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
-    :   m_info( info ),
-        m_resultData( data )
-    {}
-
-    AssertionResult::~AssertionResult() {}
-
-    // Result was a success
-    bool AssertionResult::succeeded() const {
-        return Catch::isOk( m_resultData.resultType );
-    }
-
-    // Result was a success, or failure is suppressed
-    bool AssertionResult::isOk() const {
-        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
-    }
-
-    ResultWas::OfType AssertionResult::getResultType() const {
-        return m_resultData.resultType;
-    }
-
-    bool AssertionResult::hasExpression() const {
-        return !m_info.capturedExpression.empty();
-    }
-
-    bool AssertionResult::hasMessage() const {
-        return !m_resultData.message.empty();
-    }
-
-    std::string AssertionResult::getExpression() const {
-        if( isFalseTest( m_info.resultDisposition ) )
-            return "!" + m_info.capturedExpression;
-        else
-            return m_info.capturedExpression;
-    }
-    std::string AssertionResult::getExpressionInMacro() const {
-        if( m_info.macroName.empty() )
-            return m_info.capturedExpression;
-        else
-            return m_info.macroName + "( " + m_info.capturedExpression + " )";
-    }
-
-    bool AssertionResult::hasExpandedExpression() const {
-        return hasExpression() && getExpandedExpression() != getExpression();
-    }
-
-    std::string AssertionResult::getExpandedExpression() const {
-        return m_resultData.reconstructedExpression;
-    }
-
-    std::string AssertionResult::getMessage() const {
-        return m_resultData.message;
-    }
-    SourceLineInfo AssertionResult::getSourceInfo() const {
-        return m_info.lineInfo;
-    }
-
-    std::string AssertionResult::getTestMacroName() const {
-        return m_info.macroName;
-    }
-
-} // end namespace Catch
-
-// #included from: catch_test_case_info.hpp
-#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED
-
-namespace Catch {
-
-    inline TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
-        if( startsWith( tag, "." ) ||
-            tag == "hide" ||
-            tag == "!hide" )
-            return TestCaseInfo::IsHidden;
-        else if( tag == "!throws" )
-            return TestCaseInfo::Throws;
-        else if( tag == "!shouldfail" )
-            return TestCaseInfo::ShouldFail;
-        else if( tag == "!mayfail" )
-            return TestCaseInfo::MayFail;
-        else
-            return TestCaseInfo::None;
-    }
-    inline bool isReservedTag( std::string const& tag ) {
-        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !isalnum( tag[0] );
-    }
-    inline void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
-        if( isReservedTag( tag ) ) {
-            {
-                Colour colourGuard( Colour::Red );
-                Catch::cerr()
-                    << "Tag name [" << tag << "] not allowed.\n"
-                    << "Tag names starting with non alpha-numeric characters are reserved\n";
-            }
-            {
-                Colour colourGuard( Colour::FileName );
-                Catch::cerr() << _lineInfo << std::endl;
-            }
-            exit(1);
-        }
-    }
-
-    TestCase makeTestCase(  ITestCase* _testCase,
-                            std::string const& _className,
-                            std::string const& _name,
-                            std::string const& _descOrTags,
-                            SourceLineInfo const& _lineInfo )
-    {
-        bool isHidden( startsWith( _name, "./" ) ); // Legacy support
-
-        // Parse out tags
-        std::set<std::string> tags;
-        std::string desc, tag;
-        bool inTag = false;
-        for( std::size_t i = 0; i < _descOrTags.size(); ++i ) {
-            char c = _descOrTags[i];
-            if( !inTag ) {
-                if( c == '[' )
-                    inTag = true;
-                else
-                    desc += c;
-            }
-            else {
-                if( c == ']' ) {
-                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
-                    if( prop == TestCaseInfo::IsHidden )
-                        isHidden = true;
-                    else if( prop == TestCaseInfo::None )
-                        enforceNotReservedTag( tag, _lineInfo );
-
-                    tags.insert( tag );
-                    tag.clear();
-                    inTag = false;
-                }
-                else
-                    tag += c;
-            }
-        }
-        if( isHidden ) {
-            tags.insert( "hide" );
-            tags.insert( "." );
-        }
-
-        TestCaseInfo info( _name, _className, desc, tags, _lineInfo );
-        return TestCase( _testCase, info );
-    }
-
-    TestCaseInfo::TestCaseInfo( std::string const& _name,
-                                std::string const& _className,
-                                std::string const& _description,
-                                std::set<std::string> const& _tags,
-                                SourceLineInfo const& _lineInfo )
-    :   name( _name ),
-        className( _className ),
-        description( _description ),
-        tags( _tags ),
-        lineInfo( _lineInfo ),
-        properties( None )
-    {
-        std::ostringstream oss;
-        for( std::set<std::string>::const_iterator it = _tags.begin(), itEnd = _tags.end(); it != itEnd; ++it ) {
-            oss << "[" << *it << "]";
-            std::string lcaseTag = toLower( *it );
-            properties = static_cast<SpecialProperties>( properties | parseSpecialTag( lcaseTag ) );
-            lcaseTags.insert( lcaseTag );
-        }
-        tagsAsString = oss.str();
-    }
-
-    TestCaseInfo::TestCaseInfo( TestCaseInfo const& other )
-    :   name( other.name ),
-        className( other.className ),
-        description( other.description ),
-        tags( other.tags ),
-        lcaseTags( other.lcaseTags ),
-        tagsAsString( other.tagsAsString ),
-        lineInfo( other.lineInfo ),
-        properties( other.properties )
-    {}
-
-    bool TestCaseInfo::isHidden() const {
-        return ( properties & IsHidden ) != 0;
-    }
-    bool TestCaseInfo::throws() const {
-        return ( properties & Throws ) != 0;
-    }
-    bool TestCaseInfo::okToFail() const {
-        return ( properties & (ShouldFail | MayFail ) ) != 0;
-    }
-    bool TestCaseInfo::expectedToFail() const {
-        return ( properties & (ShouldFail ) ) != 0;
-    }
-
-    TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), test( testCase ) {}
-
-    TestCase::TestCase( TestCase const& other )
-    :   TestCaseInfo( other ),
-        test( other.test )
-    {}
-
-    TestCase TestCase::withName( std::string const& _newName ) const {
-        TestCase other( *this );
-        other.name = _newName;
-        return other;
-    }
-
-    void TestCase::swap( TestCase& other ) {
-        test.swap( other.test );
-        name.swap( other.name );
-        className.swap( other.className );
-        description.swap( other.description );
-        tags.swap( other.tags );
-        lcaseTags.swap( other.lcaseTags );
-        tagsAsString.swap( other.tagsAsString );
-        std::swap( TestCaseInfo::properties, static_cast<TestCaseInfo&>( other ).properties );
-        std::swap( lineInfo, other.lineInfo );
-    }
-
-    void TestCase::invoke() const {
-        test->invoke();
-    }
-
-    bool TestCase::operator == ( TestCase const& other ) const {
-        return  test.get() == other.test.get() &&
-                name == other.name &&
-                className == other.className;
-    }
-
-    bool TestCase::operator < ( TestCase const& other ) const {
-        return name < other.name;
-    }
-    TestCase& TestCase::operator = ( TestCase const& other ) {
-        TestCase temp( other );
-        swap( temp );
-        return *this;
-    }
-
-    TestCaseInfo const& TestCase::getTestCaseInfo() const
-    {
-        return *this;
-    }
-
-} // end namespace Catch
-
-// #included from: catch_version.hpp
-#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED
-
-namespace Catch {
-
-    Version::Version
-        (   unsigned int _majorVersion,
-            unsigned int _minorVersion,
-            unsigned int _patchNumber,
-            std::string const& _branchName,
-            unsigned int _buildNumber )
-    :   majorVersion( _majorVersion ),
-        minorVersion( _minorVersion ),
-        patchNumber( _patchNumber ),
-        branchName( _branchName ),
-        buildNumber( _buildNumber )
-    {}
-
-    std::ostream& operator << ( std::ostream& os, Version const& version ) {
-        os  << version.majorVersion << "."
-            << version.minorVersion << "."
-            << version.patchNumber;
-
-        if( !version.branchName.empty() ) {
-            os  << "-" << version.branchName
-                << "." << version.buildNumber;
-        }
-        return os;
-    }
-
-    Version libraryVersion( 1, 2, 1, "", 0 );
-
-}
-
-// #included from: catch_message.hpp
-#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED
-
-namespace Catch {
-
-    MessageInfo::MessageInfo(   std::string const& _macroName,
-                                SourceLineInfo const& _lineInfo,
-                                ResultWas::OfType _type )
-    :   macroName( _macroName ),
-        lineInfo( _lineInfo ),
-        type( _type ),
-        sequence( ++globalCount )
-    {}
-
-    // This may need protecting if threading support is added
-    unsigned int MessageInfo::globalCount = 0;
-
-    ////////////////////////////////////////////////////////////////////////////
-
-    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
-    : m_info( builder.m_info )
-    {
-        m_info.message = builder.m_stream.str();
-        getResultCapture().pushScopedMessage( m_info );
-    }
-    ScopedMessage::ScopedMessage( ScopedMessage const& other )
-    : m_info( other.m_info )
-    {}
-
-    ScopedMessage::~ScopedMessage() {
-        getResultCapture().popScopedMessage( m_info );
-    }
-
-} // end namespace Catch
-
-// #included from: catch_legacy_reporter_adapter.hpp
-#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED
-
-// #included from: catch_legacy_reporter_adapter.h
-#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED
-
-namespace Catch
-{
-    // Deprecated
-    struct IReporter : IShared {
-        virtual ~IReporter();
-
-        virtual bool shouldRedirectStdout() const = 0;
-
-        virtual void StartTesting() = 0;
-        virtual void EndTesting( Totals const& totals ) = 0;
-        virtual void StartGroup( std::string const& groupName ) = 0;
-        virtual void EndGroup( std::string const& groupName, Totals const& totals ) = 0;
-        virtual void StartTestCase( TestCaseInfo const& testInfo ) = 0;
-        virtual void EndTestCase( TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr ) = 0;
-        virtual void StartSection( std::string const& sectionName, std::string const& description ) = 0;
-        virtual void EndSection( std::string const& sectionName, Counts const& assertions ) = 0;
-        virtual void NoAssertionsInSection( std::string const& sectionName ) = 0;
-        virtual void NoAssertionsInTestCase( std::string const& testName ) = 0;
-        virtual void Aborted() = 0;
-        virtual void Result( AssertionResult const& result ) = 0;
-    };
-
-    class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>
-    {
-    public:
-        LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter );
-        virtual ~LegacyReporterAdapter();
-
-        virtual ReporterPreferences getPreferences() const;
-        virtual void noMatchingTestCases( std::string const& );
-        virtual void testRunStarting( TestRunInfo const& );
-        virtual void testGroupStarting( GroupInfo const& groupInfo );
-        virtual void testCaseStarting( TestCaseInfo const& testInfo );
-        virtual void sectionStarting( SectionInfo const& sectionInfo );
-        virtual void assertionStarting( AssertionInfo const& );
-        virtual bool assertionEnded( AssertionStats const& assertionStats );
-        virtual void sectionEnded( SectionStats const& sectionStats );
-        virtual void testCaseEnded( TestCaseStats const& testCaseStats );
-        virtual void testGroupEnded( TestGroupStats const& testGroupStats );
-        virtual void testRunEnded( TestRunStats const& testRunStats );
-        virtual void skipTest( TestCaseInfo const& );
-
-    private:
-        Ptr<IReporter> m_legacyReporter;
-    };
-}
-
-namespace Catch
-{
-    LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter )
-    :   m_legacyReporter( legacyReporter )
-    {}
-    LegacyReporterAdapter::~LegacyReporterAdapter() {}
-
-    ReporterPreferences LegacyReporterAdapter::getPreferences() const {
-        ReporterPreferences prefs;
-        prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();
-        return prefs;
-    }
-
-    void LegacyReporterAdapter::noMatchingTestCases( std::string const& ) {}
-    void LegacyReporterAdapter::testRunStarting( TestRunInfo const& ) {
-        m_legacyReporter->StartTesting();
-    }
-    void LegacyReporterAdapter::testGroupStarting( GroupInfo const& groupInfo ) {
-        m_legacyReporter->StartGroup( groupInfo.name );
-    }
-    void LegacyReporterAdapter::testCaseStarting( TestCaseInfo const& testInfo ) {
-        m_legacyReporter->StartTestCase( testInfo );
-    }
-    void LegacyReporterAdapter::sectionStarting( SectionInfo const& sectionInfo ) {
-        m_legacyReporter->StartSection( sectionInfo.name, sectionInfo.description );
-    }
-    void LegacyReporterAdapter::assertionStarting( AssertionInfo const& ) {
-        // Not on legacy interface
-    }
-
-    bool LegacyReporterAdapter::assertionEnded( AssertionStats const& assertionStats ) {
-        if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {
-            for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
-                    it != itEnd;
-                    ++it ) {
-                if( it->type == ResultWas::Info ) {
-                    ResultBuilder rb( it->macroName.c_str(), it->lineInfo, "", ResultDisposition::Normal );
-                    rb << it->message;
-                    rb.setResultType( ResultWas::Info );
-                    AssertionResult result = rb.build();
-                    m_legacyReporter->Result( result );
-                }
-            }
-        }
-        m_legacyReporter->Result( assertionStats.assertionResult );
-        return true;
-    }
-    void LegacyReporterAdapter::sectionEnded( SectionStats const& sectionStats ) {
-        if( sectionStats.missingAssertions )
-            m_legacyReporter->NoAssertionsInSection( sectionStats.sectionInfo.name );
-        m_legacyReporter->EndSection( sectionStats.sectionInfo.name, sectionStats.assertions );
-    }
-    void LegacyReporterAdapter::testCaseEnded( TestCaseStats const& testCaseStats ) {
-        m_legacyReporter->EndTestCase
-            (   testCaseStats.testInfo,
-                testCaseStats.totals,
-                testCaseStats.stdOut,
-                testCaseStats.stdErr );
-    }
-    void LegacyReporterAdapter::testGroupEnded( TestGroupStats const& testGroupStats ) {
-        if( testGroupStats.aborting )
-            m_legacyReporter->Aborted();
-        m_legacyReporter->EndGroup( testGroupStats.groupInfo.name, testGroupStats.totals );
-    }
-    void LegacyReporterAdapter::testRunEnded( TestRunStats const& testRunStats ) {
-        m_legacyReporter->EndTesting( testRunStats.totals );
-    }
-    void LegacyReporterAdapter::skipTest( TestCaseInfo const& ) {
-    }
-}
-
-// #included from: catch_timer.hpp
-
-#ifdef __clang__
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wc++11-long-long"
-#endif
-
-#ifdef CATCH_PLATFORM_WINDOWS
-#include <windows.h>
-#else
-#include <sys/time.h>
-#endif
-
-namespace Catch {
-
-    namespace {
-#ifdef CATCH_PLATFORM_WINDOWS
-        uint64_t getCurrentTicks() {
-            static uint64_t hz=0, hzo=0;
-            if (!hz) {
-                QueryPerformanceFrequency( reinterpret_cast<LARGE_INTEGER*>( &hz ) );
-                QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &hzo ) );
-            }
-            uint64_t t;
-            QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &t ) );
-            return ((t-hzo)*1000000)/hz;
-        }
-#else
-        uint64_t getCurrentTicks() {
-            timeval t;
-            gettimeofday(&t,NULL);
-            return static_cast<uint64_t>( t.tv_sec ) * 1000000ull + static_cast<uint64_t>( t.tv_usec );
-        }
-#endif
-    }
-
-    void Timer::start() {
-        m_ticks = getCurrentTicks();
-    }
-    unsigned int Timer::getElapsedMicroseconds() const {
-        return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
-    }
-    unsigned int Timer::getElapsedMilliseconds() const {
-        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
-    }
-    double Timer::getElapsedSeconds() const {
-        return getElapsedMicroseconds()/1000000.0;
-    }
-
-} // namespace Catch
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-// #included from: catch_common.hpp
-#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED
-
-namespace Catch {
-
-    bool startsWith( std::string const& s, std::string const& prefix ) {
-        return s.size() >= prefix.size() && s.substr( 0, prefix.size() ) == prefix;
-    }
-    bool endsWith( std::string const& s, std::string const& suffix ) {
-        return s.size() >= suffix.size() && s.substr( s.size()-suffix.size(), suffix.size() ) == suffix;
-    }
-    bool contains( std::string const& s, std::string const& infix ) {
-        return s.find( infix ) != std::string::npos;
-    }
-    void toLowerInPlace( std::string& s ) {
-        std::transform( s.begin(), s.end(), s.begin(), ::tolower );
-    }
-    std::string toLower( std::string const& s ) {
-        std::string lc = s;
-        toLowerInPlace( lc );
-        return lc;
-    }
-    std::string trim( std::string const& str ) {
-        static char const* whitespaceChars = "\n\r\t ";
-        std::string::size_type start = str.find_first_not_of( whitespaceChars );
-        std::string::size_type end = str.find_last_not_of( whitespaceChars );
-
-        return start != std::string::npos ? str.substr( start, 1+end-start ) : "";
-    }
-
-    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
-        bool replaced = false;
-        std::size_t i = str.find( replaceThis );
-        while( i != std::string::npos ) {
-            replaced = true;
-            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
-            if( i < str.size()-withThis.size() )
-                i = str.find( replaceThis, i+withThis.size() );
-            else
-                i = std::string::npos;
-        }
-        return replaced;
-    }
-
-    pluralise::pluralise( std::size_t count, std::string const& label )
-    :   m_count( count ),
-        m_label( label )
-    {}
-
-    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
-        os << pluraliser.m_count << " " << pluraliser.m_label;
-        if( pluraliser.m_count != 1 )
-            os << "s";
-        return os;
-    }
-
-    SourceLineInfo::SourceLineInfo() : line( 0 ){}
-    SourceLineInfo::SourceLineInfo( char const* _file, std::size_t _line )
-    :   file( _file ),
-        line( _line )
-    {}
-    SourceLineInfo::SourceLineInfo( SourceLineInfo const& other )
-    :   file( other.file ),
-        line( other.line )
-    {}
-    bool SourceLineInfo::empty() const {
-        return file.empty();
-    }
-    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const {
-        return line == other.line && file == other.file;
-    }
-    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const {
-        return line < other.line || ( line == other.line  && file < other.file );
-    }
-
-    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
-#ifndef __GNUG__
-        os << info.file << "(" << info.line << ")";
-#else
-        os << info.file << ":" << info.line;
-#endif
-        return os;
-    }
-
-    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {
-        std::ostringstream oss;
-        oss << locationInfo << ": Internal Catch error: '" << message << "'";
-        if( alwaysTrue() )
-            throw std::logic_error( oss.str() );
-    }
-}
-
-// #included from: catch_section.hpp
-#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED
-
-namespace Catch {
-
-    SectionInfo::SectionInfo
-        (   SourceLineInfo const& _lineInfo,
-            std::string const& _name,
-            std::string const& _description )
-    :   name( _name ),
-        description( _description ),
-        lineInfo( _lineInfo )
-    {}
-
-    Section::Section( SectionInfo const& info )
-    :   m_info( info ),
-        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
-    {
-        m_timer.start();
-    }
-
-    Section::~Section() {
-        if( m_sectionIncluded )
-            getResultCapture().sectionEnded( m_info, m_assertions, m_timer.getElapsedSeconds() );
-    }
-
-    // This indicates whether the section should be executed or not
-    Section::operator bool() const {
-        return m_sectionIncluded;
-    }
-
-} // end namespace Catch
-
-// #included from: catch_debugger.hpp
-#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED
-
-#include <iostream>
-
-#ifdef CATCH_PLATFORM_MAC
-
-    #include <assert.h>
-    #include <stdbool.h>
-    #include <sys/types.h>
-    #include <unistd.h>
-    #include <sys/sysctl.h>
-
-    namespace Catch{
-
-        // The following function is taken directly from the following technical note:
-        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
-
-        // Returns true if the current process is being debugged (either
-        // running under the debugger or has a debugger attached post facto).
-        bool isDebuggerActive(){
-
-            int                 mib[4];
-            struct kinfo_proc   info;
-            size_t              size;
-
-            // Initialize the flags so that, if sysctl fails for some bizarre
-            // reason, we get a predictable result.
-
-            info.kp_proc.p_flag = 0;
-
-            // Initialize mib, which tells sysctl the info we want, in this case
-            // we're looking for information about a specific process ID.
-
-            mib[0] = CTL_KERN;
-            mib[1] = KERN_PROC;
-            mib[2] = KERN_PROC_PID;
-            mib[3] = getpid();
-
-            // Call sysctl.
-
-            size = sizeof(info);
-            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, NULL, 0) != 0 ) {
-                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
-                return false;
-            }
-
-            // We're being debugged if the P_TRACED flag is set.
-
-            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
-        }
-    } // namespace Catch
-
-#elif defined(_MSC_VER)
-    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
-    namespace Catch {
-        bool isDebuggerActive() {
-            return IsDebuggerPresent() != 0;
-        }
-    }
-#elif defined(__MINGW32__)
-    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
-    namespace Catch {
-        bool isDebuggerActive() {
-            return IsDebuggerPresent() != 0;
-        }
-    }
-#else
-    namespace Catch {
-       inline bool isDebuggerActive() { return false; }
-    }
-#endif // Platform
-
-#ifdef CATCH_PLATFORM_WINDOWS
-    extern "C" __declspec(dllimport) void __stdcall OutputDebugStringA( const char* );
-    namespace Catch {
-        void writeToDebugConsole( std::string const& text ) {
-            ::OutputDebugStringA( text.c_str() );
-        }
-    }
-#else
-    namespace Catch {
-        void writeToDebugConsole( std::string const& text ) {
-            // !TBD: Need a version for Mac/ XCode and other IDEs
-            Catch::cout() << text;
-        }
-    }
-#endif // Platform
-
-// #included from: catch_tostring.hpp
-#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED
-
-namespace Catch {
-
-namespace Detail {
-
-    std::string unprintableString = "{?}";
-
-    namespace {
-        struct Endianness {
-            enum Arch { Big, Little };
-
-            static Arch which() {
-                union _{
-                    int asInt;
-                    char asChar[sizeof (int)];
-                } u;
-
-                u.asInt = 1;
-                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;
-            }
-        };
-    }
-
-    std::string rawMemoryToString( const void *object, std::size_t size )
-    {
-        // Reverse order for little endian architectures
-        int i = 0, end = static_cast<int>( size ), inc = 1;
-        if( Endianness::which() == Endianness::Little ) {
-            i = end-1;
-            end = inc = -1;
-        }
-
-        unsigned char const *bytes = static_cast<unsigned char const *>(object);
-        std::ostringstream os;
-        os << "0x" << std::setfill('0') << std::hex;
-        for( ; i != end; i += inc )
-             os << std::setw(2) << static_cast<unsigned>(bytes[i]);
-       return os.str();
-    }
-}
-
-std::string toString( std::string const& value ) {
-    std::string s = value;
-    if( getCurrentContext().getConfig()->showInvisibles() ) {
-        for(size_t i = 0; i < s.size(); ++i ) {
-            std::string subs;
-            switch( s[i] ) {
-            case '\n': subs = "\\n"; break;
-            case '\t': subs = "\\t"; break;
-            default: break;
-            }
-            if( !subs.empty() ) {
-                s = s.substr( 0, i ) + subs + s.substr( i+1 );
-                ++i;
-            }
-        }
-    }
-    return "\"" + s + "\"";
-}
-std::string toString( std::wstring const& value ) {
-
-    std::string s;
-    s.reserve( value.size() );
-    for(size_t i = 0; i < value.size(); ++i )
-        s += value[i] <= 0xff ? static_cast<char>( value[i] ) : '?';
-    return Catch::toString( s );
-}
-
-std::string toString( const char* const value ) {
-    return value ? Catch::toString( std::string( value ) ) : std::string( "{null string}" );
-}
-
-std::string toString( char* const value ) {
-    return Catch::toString( static_cast<const char*>( value ) );
-}
-
-std::string toString( const wchar_t* const value )
-{
-	return value ? Catch::toString( std::wstring(value) ) : std::string( "{null string}" );
-}
-
-std::string toString( wchar_t* const value )
-{
-	return Catch::toString( static_cast<const wchar_t*>( value ) );
-}
-
-std::string toString( int value ) {
-    std::ostringstream oss;
-    oss << value;
-    if( value >= 255 )
-        oss << " (0x" << std::hex << value << ")";
-    return oss.str();
-}
-
-std::string toString( unsigned long value ) {
-    std::ostringstream oss;
-    oss << value;
-    if( value >= 255 )
-        oss << " (0x" << std::hex << value << ")";
-    return oss.str();
-}
-
-std::string toString( unsigned int value ) {
-    return Catch::toString( static_cast<unsigned long>( value ) );
-}
-
-template<typename T>
-std::string fpToString( T value, int precision ) {
-    std::ostringstream oss;
-    oss << std::setprecision( precision )
-        << std::fixed
-        << value;
-    std::string d = oss.str();
-    std::size_t i = d.find_last_not_of( '0' );
-    if( i != std::string::npos && i != d.size()-1 ) {
-        if( d[i] == '.' )
-            i++;
-        d = d.substr( 0, i+1 );
-    }
-    return d;
-}
-
-std::string toString( const double value ) {
-    return fpToString( value, 10 );
-}
-std::string toString( const float value ) {
-    return fpToString( value, 5 ) + "f";
-}
-
-std::string toString( bool value ) {
-    return value ? "true" : "false";
-}
-
-std::string toString( char value ) {
-    return value < ' '
-        ? toString( static_cast<unsigned int>( value ) )
-        : Detail::makeString( value );
-}
-
-std::string toString( signed char value ) {
-    return toString( static_cast<char>( value ) );
-}
-
-std::string toString( unsigned char value ) {
-    return toString( static_cast<char>( value ) );
-}
-
-#ifdef CATCH_CONFIG_CPP11_NULLPTR
-std::string toString( std::nullptr_t ) {
-    return "nullptr";
-}
-#endif
-
-#ifdef __OBJC__
-    std::string toString( NSString const * const& nsstring ) {
-        if( !nsstring )
-            return "nil";
-        return "@" + toString([nsstring UTF8String]);
-    }
-    std::string toString( NSString * CATCH_ARC_STRONG const& nsstring ) {
-        if( !nsstring )
-            return "nil";
-        return "@" + toString([nsstring UTF8String]);
-    }
-    std::string toString( NSObject* const& nsObject ) {
-        return toString( [nsObject description] );
-    }
-#endif
-
-} // end namespace Catch
-
-// #included from: catch_result_builder.hpp
-#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED
-
-namespace Catch {
-
-    ResultBuilder::ResultBuilder(   char const* macroName,
-                                    SourceLineInfo const& lineInfo,
-                                    char const* capturedExpression,
-                                    ResultDisposition::Flags resultDisposition )
-    :   m_assertionInfo( macroName, lineInfo, capturedExpression, resultDisposition ),
-        m_shouldDebugBreak( false ),
-        m_shouldThrow( false )
-    {}
-
-    ResultBuilder& ResultBuilder::setResultType( ResultWas::OfType result ) {
-        m_data.resultType = result;
-        return *this;
-    }
-    ResultBuilder& ResultBuilder::setResultType( bool result ) {
-        m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;
-        return *this;
-    }
-    ResultBuilder& ResultBuilder::setLhs( std::string const& lhs ) {
-        m_exprComponents.lhs = lhs;
-        return *this;
-    }
-    ResultBuilder& ResultBuilder::setRhs( std::string const& rhs ) {
-        m_exprComponents.rhs = rhs;
-        return *this;
-    }
-    ResultBuilder& ResultBuilder::setOp( std::string const& op ) {
-        m_exprComponents.op = op;
-        return *this;
-    }
-
-    void ResultBuilder::endExpression() {
-        m_exprComponents.testFalse = isFalseTest( m_assertionInfo.resultDisposition );
-        captureExpression();
-    }
-
-    void ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) {
-        m_assertionInfo.resultDisposition = resultDisposition;
-        m_stream.oss << Catch::translateActiveException();
-        captureResult( ResultWas::ThrewException );
-    }
-
-    void ResultBuilder::captureResult( ResultWas::OfType resultType ) {
-        setResultType( resultType );
-        captureExpression();
-    }
-
-    void ResultBuilder::captureExpression() {
-        AssertionResult result = build();
-        getResultCapture().assertionEnded( result );
-
-        if( !result.isOk() ) {
-            if( getCurrentContext().getConfig()->shouldDebugBreak() )
-                m_shouldDebugBreak = true;
-            if( getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal) )
-                m_shouldThrow = true;
-        }
-    }
-    void ResultBuilder::react() {
-        if( m_shouldThrow )
-            throw Catch::TestFailureException();
-    }
-
-    bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }
-    bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }
-
-    AssertionResult ResultBuilder::build() const
-    {
-        assert( m_data.resultType != ResultWas::Unknown );
-
-        AssertionResultData data = m_data;
-
-        // Flip bool results if testFalse is set
-        if( m_exprComponents.testFalse ) {
-            if( data.resultType == ResultWas::Ok )
-                data.resultType = ResultWas::ExpressionFailed;
-            else if( data.resultType == ResultWas::ExpressionFailed )
-                data.resultType = ResultWas::Ok;
-        }
-
-        data.message = m_stream.oss.str();
-        data.reconstructedExpression = reconstructExpression();
-        if( m_exprComponents.testFalse ) {
-            if( m_exprComponents.op == "" )
-                data.reconstructedExpression = "!" + data.reconstructedExpression;
-            else
-                data.reconstructedExpression = "!(" + data.reconstructedExpression + ")";
-        }
-        return AssertionResult( m_assertionInfo, data );
-    }
-    std::string ResultBuilder::reconstructExpression() const {
-        if( m_exprComponents.op == "" )
-            return m_exprComponents.lhs.empty() ? m_assertionInfo.capturedExpression : m_exprComponents.op + m_exprComponents.lhs;
-        else if( m_exprComponents.op == "matches" )
-            return m_exprComponents.lhs + " " + m_exprComponents.rhs;
-        else if( m_exprComponents.op != "!" ) {
-            if( m_exprComponents.lhs.size() + m_exprComponents.rhs.size() < 40 &&
-                m_exprComponents.lhs.find("\n") == std::string::npos &&
-                m_exprComponents.rhs.find("\n") == std::string::npos )
-                return m_exprComponents.lhs + " " + m_exprComponents.op + " " + m_exprComponents.rhs;
-            else
-                return m_exprComponents.lhs + "\n" + m_exprComponents.op + "\n" + m_exprComponents.rhs;
-        }
-        else
-            return "{can't expand - use " + m_assertionInfo.macroName + "_FALSE( " + m_assertionInfo.capturedExpression.substr(1) + " ) instead of " + m_assertionInfo.macroName + "( " + m_assertionInfo.capturedExpression + " ) for better diagnostics}";
-    }
-
-} // end namespace Catch
-
-// #included from: catch_tag_alias_registry.hpp
-#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
-
-// #included from: catch_tag_alias_registry.h
-#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED
-
-#include <map>
-
-namespace Catch {
-
-    class TagAliasRegistry : public ITagAliasRegistry {
-    public:
-        virtual ~TagAliasRegistry();
-        virtual Option<TagAlias> find( std::string const& alias ) const;
-        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const;
-        void add( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
-        static TagAliasRegistry& get();
-
-    private:
-        std::map<std::string, TagAlias> m_registry;
-    };
-
-} // end namespace Catch
-
-#include <map>
-#include <iostream>
-
-namespace Catch {
-
-    TagAliasRegistry::~TagAliasRegistry() {}
-
-    Option<TagAlias> TagAliasRegistry::find( std::string const& alias ) const {
-        std::map<std::string, TagAlias>::const_iterator it = m_registry.find( alias );
-        if( it != m_registry.end() )
-            return it->second;
-        else
-            return Option<TagAlias>();
-    }
-
-    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
-        std::string expandedTestSpec = unexpandedTestSpec;
-        for( std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();
-                it != itEnd;
-                ++it ) {
-            std::size_t pos = expandedTestSpec.find( it->first );
-            if( pos != std::string::npos ) {
-                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
-                                    it->second.tag +
-                                    expandedTestSpec.substr( pos + it->first.size() );
-            }
-        }
-        return expandedTestSpec;
-    }
-
-    void TagAliasRegistry::add( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {
-
-        if( !startsWith( alias, "[@" ) || !endsWith( alias, "]" ) ) {
-            std::ostringstream oss;
-            oss << "error: tag alias, \"" << alias << "\" is not of the form [@alias name].\n" << lineInfo;
-            throw std::domain_error( oss.str().c_str() );
-        }
-        if( !m_registry.insert( std::make_pair( alias, TagAlias( tag, lineInfo ) ) ).second ) {
-            std::ostringstream oss;
-            oss << "error: tag alias, \"" << alias << "\" already registered.\n"
-                << "\tFirst seen at " << find(alias)->lineInfo << "\n"
-                << "\tRedefined at " << lineInfo;
-            throw std::domain_error( oss.str().c_str() );
-        }
-    }
-
-    TagAliasRegistry& TagAliasRegistry::get() {
-        static TagAliasRegistry instance;
-        return instance;
-
-    }
-
-    ITagAliasRegistry::~ITagAliasRegistry() {}
-    ITagAliasRegistry const& ITagAliasRegistry::get() { return TagAliasRegistry::get(); }
-
-    RegistrarForTagAliases::RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {
-        try {
-            TagAliasRegistry::get().add( alias, tag, lineInfo );
-        }
-        catch( std::exception& ex ) {
-            Colour colourGuard( Colour::Red );
-            Catch::cerr() << ex.what() << std::endl;
-            exit(1);
-        }
-    }
-
-} // end namespace Catch
-
-// #included from: ../reporters/catch_reporter_xml.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED
-
-// #included from: catch_reporter_bases.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED
-
-#include <cstring>
-
-namespace Catch {
-
-    struct StreamingReporterBase : SharedImpl<IStreamingReporter> {
-
-        StreamingReporterBase( ReporterConfig const& _config )
-        :   m_config( _config.fullConfig() ),
-            stream( _config.stream() )
-        {}
-
-        virtual ~StreamingReporterBase();
-
-        virtual void noMatchingTestCases( std::string const& ) {}
-
-        virtual void testRunStarting( TestRunInfo const& _testRunInfo ) {
-            currentTestRunInfo = _testRunInfo;
-        }
-        virtual void testGroupStarting( GroupInfo const& _groupInfo ) {
-            currentGroupInfo = _groupInfo;
-        }
-
-        virtual void testCaseStarting( TestCaseInfo const& _testInfo ) {
-            currentTestCaseInfo = _testInfo;
-        }
-        virtual void sectionStarting( SectionInfo const& _sectionInfo ) {
-            m_sectionStack.push_back( _sectionInfo );
-        }
-
-        virtual void sectionEnded( SectionStats const& /* _sectionStats */ ) {
-            m_sectionStack.pop_back();
-        }
-        virtual void testCaseEnded( TestCaseStats const& /* _testCaseStats */ ) {
-            currentTestCaseInfo.reset();
-        }
-        virtual void testGroupEnded( TestGroupStats const& /* _testGroupStats */ ) {
-            currentGroupInfo.reset();
-        }
-        virtual void testRunEnded( TestRunStats const& /* _testRunStats */ ) {
-            currentTestCaseInfo.reset();
-            currentGroupInfo.reset();
-            currentTestRunInfo.reset();
-        }
-
-        virtual void skipTest( TestCaseInfo const& ) {
-            // Don't do anything with this by default.
-            // It can optionally be overridden in the derived class.
-        }
-
-        Ptr<IConfig> m_config;
-        std::ostream& stream;
-
-        LazyStat<TestRunInfo> currentTestRunInfo;
-        LazyStat<GroupInfo> currentGroupInfo;
-        LazyStat<TestCaseInfo> currentTestCaseInfo;
-
-        std::vector<SectionInfo> m_sectionStack;
-    };
-
-    struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {
-        template<typename T, typename ChildNodeT>
-        struct Node : SharedImpl<> {
-            explicit Node( T const& _value ) : value( _value ) {}
-            virtual ~Node() {}
-
-            typedef std::vector<Ptr<ChildNodeT> > ChildNodes;
-            T value;
-            ChildNodes children;
-        };
-        struct SectionNode : SharedImpl<> {
-            explicit SectionNode( SectionStats const& _stats ) : stats( _stats ) {}
-            virtual ~SectionNode();
-
-            bool operator == ( SectionNode const& other ) const {
-                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
-            }
-            bool operator == ( Ptr<SectionNode> const& other ) const {
-                return operator==( *other );
-            }
-
-            SectionStats stats;
-            typedef std::vector<Ptr<SectionNode> > ChildSections;
-            typedef std::vector<AssertionStats> Assertions;
-            ChildSections childSections;
-            Assertions assertions;
-            std::string stdOut;
-            std::string stdErr;
-        };
-
-        struct BySectionInfo {
-            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
-			BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
-            bool operator() ( Ptr<SectionNode> const& node ) const {
-                return node->stats.sectionInfo.lineInfo == m_other.lineInfo;
-            }
-        private:
-			void operator=( BySectionInfo const& );
-            SectionInfo const& m_other;
-        };
-
-        typedef Node<TestCaseStats, SectionNode> TestCaseNode;
-        typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;
-        typedef Node<TestRunStats, TestGroupNode> TestRunNode;
-
-        CumulativeReporterBase( ReporterConfig const& _config )
-        :   m_config( _config.fullConfig() ),
-            stream( _config.stream() )
-        {}
-        ~CumulativeReporterBase();
-
-        virtual void testRunStarting( TestRunInfo const& ) {}
-        virtual void testGroupStarting( GroupInfo const& ) {}
-
-        virtual void testCaseStarting( TestCaseInfo const& ) {}
-
-        virtual void sectionStarting( SectionInfo const& sectionInfo ) {
-            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
-            Ptr<SectionNode> node;
-            if( m_sectionStack.empty() ) {
-                if( !m_rootSection )
-                    m_rootSection = new SectionNode( incompleteStats );
-                node = m_rootSection;
-            }
-            else {
-                SectionNode& parentNode = *m_sectionStack.back();
-                SectionNode::ChildSections::const_iterator it =
-                    std::find_if(   parentNode.childSections.begin(),
-                                    parentNode.childSections.end(),
-                                    BySectionInfo( sectionInfo ) );
-                if( it == parentNode.childSections.end() ) {
-                    node = new SectionNode( incompleteStats );
-                    parentNode.childSections.push_back( node );
-                }
-                else
-                    node = *it;
-            }
-            m_sectionStack.push_back( node );
-            m_deepestSection = node;
-        }
-
-        virtual void assertionStarting( AssertionInfo const& ) {}
-
-        virtual bool assertionEnded( AssertionStats const& assertionStats ) {
-            assert( !m_sectionStack.empty() );
-            SectionNode& sectionNode = *m_sectionStack.back();
-            sectionNode.assertions.push_back( assertionStats );
-            return true;
-        }
-        virtual void sectionEnded( SectionStats const& sectionStats ) {
-            assert( !m_sectionStack.empty() );
-            SectionNode& node = *m_sectionStack.back();
-            node.stats = sectionStats;
-            m_sectionStack.pop_back();
-        }
-        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) {
-            Ptr<TestCaseNode> node = new TestCaseNode( testCaseStats );
-            assert( m_sectionStack.size() == 0 );
-            node->children.push_back( m_rootSection );
-            m_testCases.push_back( node );
-            m_rootSection.reset();
-
-            assert( m_deepestSection );
-            m_deepestSection->stdOut = testCaseStats.stdOut;
-            m_deepestSection->stdErr = testCaseStats.stdErr;
-        }
-        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) {
-            Ptr<TestGroupNode> node = new TestGroupNode( testGroupStats );
-            node->children.swap( m_testCases );
-            m_testGroups.push_back( node );
-        }
-        virtual void testRunEnded( TestRunStats const& testRunStats ) {
-            Ptr<TestRunNode> node = new TestRunNode( testRunStats );
-            node->children.swap( m_testGroups );
-            m_testRuns.push_back( node );
-            testRunEndedCumulative();
-        }
-        virtual void testRunEndedCumulative() = 0;
-
-        virtual void skipTest( TestCaseInfo const& ) {}
-
-        Ptr<IConfig> m_config;
-        std::ostream& stream;
-        std::vector<AssertionStats> m_assertions;
-        std::vector<std::vector<Ptr<SectionNode> > > m_sections;
-        std::vector<Ptr<TestCaseNode> > m_testCases;
-        std::vector<Ptr<TestGroupNode> > m_testGroups;
-
-        std::vector<Ptr<TestRunNode> > m_testRuns;
-
-        Ptr<SectionNode> m_rootSection;
-        Ptr<SectionNode> m_deepestSection;
-        std::vector<Ptr<SectionNode> > m_sectionStack;
-
-    };
-
-    template<char C>
-    char const* getLineOfChars() {
-        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
-        if( !*line ) {
-            memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
-            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
-        }
-        return line;
-    }
-
-} // end namespace Catch
-
-// #included from: ../internal/catch_reporter_registrars.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
-
-namespace Catch {
-
-    template<typename T>
-    class LegacyReporterRegistrar {
-
-        class ReporterFactory : public IReporterFactory {
-            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
-                return new LegacyReporterAdapter( new T( config ) );
-            }
-
-            virtual std::string getDescription() const {
-                return T::getDescription();
-            }
-        };
-
-    public:
-
-        LegacyReporterRegistrar( std::string const& name ) {
-            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
-        }
-    };
-
-    template<typename T>
-    class ReporterRegistrar {
-
-        class ReporterFactory : public IReporterFactory {
-
-            // *** Please Note ***:
-            // - If you end up here looking at a compiler error because it's trying to register
-            // your custom reporter class be aware that the native reporter interface has changed
-            // to IStreamingReporter. The "legacy" interface, IReporter, is still supported via
-            // an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.
-            // However please consider updating to the new interface as the old one is now
-            // deprecated and will probably be removed quite soon!
-            // Please contact me via github if you have any questions at all about this.
-            // In fact, ideally, please contact me anyway to let me know you've hit this - as I have
-            // no idea who is actually using custom reporters at all (possibly no-one!).
-            // The new interface is designed to minimise exposure to interface changes in the future.
-            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
-                return new T( config );
-            }
-
-            virtual std::string getDescription() const {
-                return T::getDescription();
-            }
-        };
-
-    public:
-
-        ReporterRegistrar( std::string const& name ) {
-            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
-        }
-    };
-}
-
-#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
-    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
-#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \
-    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
-
-// #included from: ../internal/catch_xmlwriter.hpp
-#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED
-
-#include <sstream>
-#include <string>
-#include <vector>
-
-namespace Catch {
-
-    class XmlWriter {
-    public:
-
-        class ScopedElement {
-        public:
-            ScopedElement( XmlWriter* writer )
-            :   m_writer( writer )
-            {}
-
-            ScopedElement( ScopedElement const& other )
-            :   m_writer( other.m_writer ){
-                other.m_writer = NULL;
-            }
-
-            ~ScopedElement() {
-                if( m_writer )
-                    m_writer->endElement();
-            }
-
-            ScopedElement& writeText( std::string const& text, bool indent = true ) {
-                m_writer->writeText( text, indent );
-                return *this;
-            }
-
-            template<typename T>
-            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
-                m_writer->writeAttribute( name, attribute );
-                return *this;
-            }
-
-        private:
-            mutable XmlWriter* m_writer;
-        };
-
-        XmlWriter()
-        :   m_tagIsOpen( false ),
-            m_needsNewline( false ),
-            m_os( &Catch::cout() )
-        {}
-
-        XmlWriter( std::ostream& os )
-        :   m_tagIsOpen( false ),
-            m_needsNewline( false ),
-            m_os( &os )
-        {}
-
-        ~XmlWriter() {
-            while( !m_tags.empty() )
-                endElement();
-        }
-
-        XmlWriter& startElement( std::string const& name ) {
-            ensureTagClosed();
-            newlineIfNecessary();
-            stream() << m_indent << "<" << name;
-            m_tags.push_back( name );
-            m_indent += "  ";
-            m_tagIsOpen = true;
-            return *this;
-        }
-
-        ScopedElement scopedElement( std::string const& name ) {
-            ScopedElement scoped( this );
-            startElement( name );
-            return scoped;
-        }
-
-        XmlWriter& endElement() {
-            newlineIfNecessary();
-            m_indent = m_indent.substr( 0, m_indent.size()-2 );
-            if( m_tagIsOpen ) {
-                stream() << "/>\n";
-                m_tagIsOpen = false;
-            }
-            else {
-                stream() << m_indent << "</" << m_tags.back() << ">\n";
-            }
-            m_tags.pop_back();
-            return *this;
-        }
-
-        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {
-            if( !name.empty() && !attribute.empty() ) {
-                stream() << " " << name << "=\"";
-                writeEncodedText( attribute );
-                stream() << "\"";
-            }
-            return *this;
-        }
-
-        XmlWriter& writeAttribute( std::string const& name, bool attribute ) {
-            stream() << " " << name << "=\"" << ( attribute ? "true" : "false" ) << "\"";
-            return *this;
-        }
-
-        template<typename T>
-        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
-            if( !name.empty() )
-                stream() << " " << name << "=\"" << attribute << "\"";
-            return *this;
-        }
-
-        XmlWriter& writeText( std::string const& text, bool indent = true ) {
-            if( !text.empty() ){
-                bool tagWasOpen = m_tagIsOpen;
-                ensureTagClosed();
-                if( tagWasOpen && indent )
-                    stream() << m_indent;
-                writeEncodedText( text );
-                m_needsNewline = true;
-            }
-            return *this;
-        }
-
-        XmlWriter& writeComment( std::string const& text ) {
-            ensureTagClosed();
-            stream() << m_indent << "<!--" << text << "-->";
-            m_needsNewline = true;
-            return *this;
-        }
-
-        XmlWriter& writeBlankLine() {
-            ensureTagClosed();
-            stream() << "\n";
-            return *this;
-        }
-
-        void setStream( std::ostream& os ) {
-            m_os = &os;
-        }
-
-    private:
-        XmlWriter( XmlWriter const& );
-        void operator=( XmlWriter const& );
-
-        std::ostream& stream() {
-            return *m_os;
-        }
-
-        void ensureTagClosed() {
-            if( m_tagIsOpen ) {
-                stream() << ">\n";
-                m_tagIsOpen = false;
-            }
-        }
-
-        void newlineIfNecessary() {
-            if( m_needsNewline ) {
-                stream() << "\n";
-                m_needsNewline = false;
-            }
-        }
-
-        void writeEncodedText( std::string const& text ) {
-            static const char* charsToEncode = "<&\"";
-            std::string mtext = text;
-            std::string::size_type pos = mtext.find_first_of( charsToEncode );
-            while( pos != std::string::npos ) {
-                stream() << mtext.substr( 0, pos );
-
-                switch( mtext[pos] ) {
-                    case '<':
-                        stream() << "&lt;";
-                        break;
-                    case '&':
-                        stream() << "&amp;";
-                        break;
-                    case '\"':
-                        stream() << "&quot;";
-                        break;
-                }
-                mtext = mtext.substr( pos+1 );
-                pos = mtext.find_first_of( charsToEncode );
-            }
-            stream() << mtext;
-        }
-
-        bool m_tagIsOpen;
-        bool m_needsNewline;
-        std::vector<std::string> m_tags;
-        std::string m_indent;
-        std::ostream* m_os;
-    };
-
-}
-namespace Catch {
-    class XmlReporter : public StreamingReporterBase {
-    public:
-        XmlReporter( ReporterConfig const& _config )
-        :   StreamingReporterBase( _config ),
-            m_sectionDepth( 0 )
-        {}
-
-        virtual ~XmlReporter();
-
-        static std::string getDescription() {
-            return "Reports test results as an XML document";
-        }
-
-    public: // StreamingReporterBase
-        virtual ReporterPreferences getPreferences() const {
-            ReporterPreferences prefs;
-            prefs.shouldRedirectStdOut = true;
-            return prefs;
-        }
-
-        virtual void noMatchingTestCases( std::string const& s ) {
-            StreamingReporterBase::noMatchingTestCases( s );
-        }
-
-        virtual void testRunStarting( TestRunInfo const& testInfo ) {
-            StreamingReporterBase::testRunStarting( testInfo );
-            m_xml.setStream( stream );
-            m_xml.startElement( "Catch" );
-            if( !m_config->name().empty() )
-                m_xml.writeAttribute( "name", m_config->name() );
-        }
-
-        virtual void testGroupStarting( GroupInfo const& groupInfo ) {
-            StreamingReporterBase::testGroupStarting( groupInfo );
-            m_xml.startElement( "Group" )
-                .writeAttribute( "name", groupInfo.name );
-        }
-
-        virtual void testCaseStarting( TestCaseInfo const& testInfo ) {
-            StreamingReporterBase::testCaseStarting(testInfo);
-            m_xml.startElement( "TestCase" ).writeAttribute( "name", trim( testInfo.name ) );
-
-            if ( m_config->showDurations() == ShowDurations::Always )
-                m_testCaseTimer.start();
-        }
-
-        virtual void sectionStarting( SectionInfo const& sectionInfo ) {
-            StreamingReporterBase::sectionStarting( sectionInfo );
-            if( m_sectionDepth++ > 0 ) {
-                m_xml.startElement( "Section" )
-                    .writeAttribute( "name", trim( sectionInfo.name ) )
-                    .writeAttribute( "description", sectionInfo.description );
-            }
-        }
-
-        virtual void assertionStarting( AssertionInfo const& ) { }
-
-        virtual bool assertionEnded( AssertionStats const& assertionStats ) {
-            const AssertionResult& assertionResult = assertionStats.assertionResult;
-
-            // Print any info messages in <Info> tags.
-            if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {
-                for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
-                        it != itEnd;
-                        ++it ) {
-                    if( it->type == ResultWas::Info ) {
-                        m_xml.scopedElement( "Info" )
-                            .writeText( it->message );
-                    } else if ( it->type == ResultWas::Warning ) {
-                        m_xml.scopedElement( "Warning" )
-                            .writeText( it->message );
-                    }
-                }
-            }
-
-            // Drop out if result was successful but we're not printing them.
-            if( !m_config->includeSuccessfulResults() && isOk(assertionResult.getResultType()) )
-                return true;
-
-            // Print the expression if there is one.
-            if( assertionResult.hasExpression() ) {
-                m_xml.startElement( "Expression" )
-                    .writeAttribute( "success", assertionResult.succeeded() )
-					.writeAttribute( "type", assertionResult.getTestMacroName() )
-                    .writeAttribute( "filename", assertionResult.getSourceInfo().file )
-                    .writeAttribute( "line", assertionResult.getSourceInfo().line );
-
-                m_xml.scopedElement( "Original" )
-                    .writeText( assertionResult.getExpression() );
-                m_xml.scopedElement( "Expanded" )
-                    .writeText( assertionResult.getExpandedExpression() );
-            }
-
-            // And... Print a result applicable to each result type.
-            switch( assertionResult.getResultType() ) {
-                case ResultWas::ThrewException:
-                    m_xml.scopedElement( "Exception" )
-                        .writeAttribute( "filename", assertionResult.getSourceInfo().file )
-                        .writeAttribute( "line", assertionResult.getSourceInfo().line )
-                        .writeText( assertionResult.getMessage() );
-                    break;
-                case ResultWas::FatalErrorCondition:
-                    m_xml.scopedElement( "Fatal Error Condition" )
-                        .writeAttribute( "filename", assertionResult.getSourceInfo().file )
-                        .writeAttribute( "line", assertionResult.getSourceInfo().line )
-                        .writeText( assertionResult.getMessage() );
-                    break;
-                case ResultWas::Info:
-                    m_xml.scopedElement( "Info" )
-                        .writeText( assertionResult.getMessage() );
-                    break;
-                case ResultWas::Warning:
-                    // Warning will already have been written
-                    break;
-                case ResultWas::ExplicitFailure:
-                    m_xml.scopedElement( "Failure" )
-                        .writeText( assertionResult.getMessage() );
-                    break;
-                default:
-                    break;
-            }
-
-            if( assertionResult.hasExpression() )
-                m_xml.endElement();
-
-            return true;
-        }
-
-        virtual void sectionEnded( SectionStats const& sectionStats ) {
-            StreamingReporterBase::sectionEnded( sectionStats );
-            if( --m_sectionDepth > 0 ) {
-                XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
-                e.writeAttribute( "successes", sectionStats.assertions.passed );
-                e.writeAttribute( "failures", sectionStats.assertions.failed );
-                e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
-
-                if ( m_config->showDurations() == ShowDurations::Always )
-                    e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
-
-                m_xml.endElement();
-            }
-        }
-
-        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) {
-            StreamingReporterBase::testCaseEnded( testCaseStats );
-            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
-            e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
-
-            if ( m_config->showDurations() == ShowDurations::Always )
-                e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
-
-            m_xml.endElement();
-        }
-
-        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) {
-            StreamingReporterBase::testGroupEnded( testGroupStats );
-            // TODO: Check testGroupStats.aborting and act accordingly.
-            m_xml.scopedElement( "OverallResults" )
-                .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
-                .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
-                .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
-            m_xml.endElement();
-        }
-
-        virtual void testRunEnded( TestRunStats const& testRunStats ) {
-            StreamingReporterBase::testRunEnded( testRunStats );
-            m_xml.scopedElement( "OverallResults" )
-                .writeAttribute( "successes", testRunStats.totals.assertions.passed )
-                .writeAttribute( "failures", testRunStats.totals.assertions.failed )
-                .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
-            m_xml.endElement();
-        }
-
-    private:
-        Timer m_testCaseTimer;
-        XmlWriter m_xml;
-        int m_sectionDepth;
-    };
-
-     INTERNAL_CATCH_REGISTER_REPORTER( "xml", XmlReporter )
-
-} // end namespace Catch
-
-// #included from: ../reporters/catch_reporter_junit.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED
-
-#include <assert.h>
-
-namespace Catch {
-
-    class JunitReporter : public CumulativeReporterBase {
-    public:
-        JunitReporter( ReporterConfig const& _config )
-        :   CumulativeReporterBase( _config ),
-            xml( _config.stream() )
-        {}
-
-        ~JunitReporter();
-
-        static std::string getDescription() {
-            return "Reports test results in an XML format that looks like Ant's junitreport target";
-        }
-
-        virtual void noMatchingTestCases( std::string const& /*spec*/ ) {}
-
-        virtual ReporterPreferences getPreferences() const {
-            ReporterPreferences prefs;
-            prefs.shouldRedirectStdOut = true;
-            return prefs;
-        }
-
-        virtual void testRunStarting( TestRunInfo const& runInfo ) {
-            CumulativeReporterBase::testRunStarting( runInfo );
-            xml.startElement( "testsuites" );
-        }
-
-        virtual void testGroupStarting( GroupInfo const& groupInfo ) {
-            suiteTimer.start();
-            stdOutForSuite.str("");
-            stdErrForSuite.str("");
-            unexpectedExceptions = 0;
-            CumulativeReporterBase::testGroupStarting( groupInfo );
-        }
-
-        virtual bool assertionEnded( AssertionStats const& assertionStats ) {
-            if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException )
-                unexpectedExceptions++;
-            return CumulativeReporterBase::assertionEnded( assertionStats );
-        }
-
-        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) {
-            stdOutForSuite << testCaseStats.stdOut;
-            stdErrForSuite << testCaseStats.stdErr;
-            CumulativeReporterBase::testCaseEnded( testCaseStats );
-        }
-
-        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) {
-            double suiteTime = suiteTimer.getElapsedSeconds();
-            CumulativeReporterBase::testGroupEnded( testGroupStats );
-            writeGroup( *m_testGroups.back(), suiteTime );
-        }
-
-        virtual void testRunEndedCumulative() {
-            xml.endElement();
-        }
-
-        void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
-            XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
-            TestGroupStats const& stats = groupNode.value;
-            xml.writeAttribute( "name", stats.groupInfo.name );
-            xml.writeAttribute( "errors", unexpectedExceptions );
-            xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
-            xml.writeAttribute( "tests", stats.totals.assertions.total() );
-            xml.writeAttribute( "hostname", "tbd" ); // !TBD
-            if( m_config->showDurations() == ShowDurations::Never )
-                xml.writeAttribute( "time", "" );
-            else
-                xml.writeAttribute( "time", suiteTime );
-            xml.writeAttribute( "timestamp", "tbd" ); // !TBD
-
-            // Write test cases
-            for( TestGroupNode::ChildNodes::const_iterator
-                    it = groupNode.children.begin(), itEnd = groupNode.children.end();
-                    it != itEnd;
-                    ++it )
-                writeTestCase( **it );
-
-            xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite.str() ), false );
-            xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite.str() ), false );
-        }
-
-        void writeTestCase( TestCaseNode const& testCaseNode ) {
-            TestCaseStats const& stats = testCaseNode.value;
-
-            // All test cases have exactly one section - which represents the
-            // test case itself. That section may have 0-n nested sections
-            assert( testCaseNode.children.size() == 1 );
-            SectionNode const& rootSection = *testCaseNode.children.front();
-
-            std::string className = stats.testInfo.className;
-
-            if( className.empty() ) {
-                if( rootSection.childSections.empty() )
-                    className = "global";
-            }
-            writeSection( className, "", rootSection );
-        }
-
-        void writeSection(  std::string const& className,
-                            std::string const& rootName,
-                            SectionNode const& sectionNode ) {
-            std::string name = trim( sectionNode.stats.sectionInfo.name );
-            if( !rootName.empty() )
-                name = rootName + "/" + name;
-
-            if( !sectionNode.assertions.empty() ||
-                !sectionNode.stdOut.empty() ||
-                !sectionNode.stdErr.empty() ) {
-                XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
-                if( className.empty() ) {
-                    xml.writeAttribute( "classname", name );
-                    xml.writeAttribute( "name", "root" );
-                }
-                else {
-                    xml.writeAttribute( "classname", className );
-                    xml.writeAttribute( "name", name );
-                }
-                xml.writeAttribute( "time", Catch::toString( sectionNode.stats.durationInSeconds ) );
-
-                writeAssertions( sectionNode );
-
-                if( !sectionNode.stdOut.empty() )
-                    xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), false );
-                if( !sectionNode.stdErr.empty() )
-                    xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), false );
-            }
-            for( SectionNode::ChildSections::const_iterator
-                    it = sectionNode.childSections.begin(),
-                    itEnd = sectionNode.childSections.end();
-                    it != itEnd;
-                    ++it )
-                if( className.empty() )
-                    writeSection( name, "", **it );
-                else
-                    writeSection( className, name, **it );
-        }
-
-        void writeAssertions( SectionNode const& sectionNode ) {
-            for( SectionNode::Assertions::const_iterator
-                    it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();
-                    it != itEnd;
-                    ++it )
-                writeAssertion( *it );
-        }
-        void writeAssertion( AssertionStats const& stats ) {
-            AssertionResult const& result = stats.assertionResult;
-            if( !result.isOk() ) {
-                std::string elementName;
-                switch( result.getResultType() ) {
-                    case ResultWas::ThrewException:
-                    case ResultWas::FatalErrorCondition:
-                        elementName = "error";
-                        break;
-                    case ResultWas::ExplicitFailure:
-                        elementName = "failure";
-                        break;
-                    case ResultWas::ExpressionFailed:
-                        elementName = "failure";
-                        break;
-                    case ResultWas::DidntThrowException:
-                        elementName = "failure";
-                        break;
-
-                    // We should never see these here:
-                    case ResultWas::Info:
-                    case ResultWas::Warning:
-                    case ResultWas::Ok:
-                    case ResultWas::Unknown:
-                    case ResultWas::FailureBit:
-                    case ResultWas::Exception:
-                        elementName = "internalError";
-                        break;
-                }
-
-                XmlWriter::ScopedElement e = xml.scopedElement( elementName );
-
-                xml.writeAttribute( "message", result.getExpandedExpression() );
-                xml.writeAttribute( "type", result.getTestMacroName() );
-
-                std::ostringstream oss;
-                if( !result.getMessage().empty() )
-                    oss << result.getMessage() << "\n";
-                for( std::vector<MessageInfo>::const_iterator
-                        it = stats.infoMessages.begin(),
-                        itEnd = stats.infoMessages.end();
-                            it != itEnd;
-                            ++it )
-                    if( it->type == ResultWas::Info )
-                        oss << it->message << "\n";
-
-                oss << "at " << result.getSourceInfo();
-                xml.writeText( oss.str(), false );
-            }
-        }
-
-        XmlWriter xml;
-        Timer suiteTimer;
-        std::ostringstream stdOutForSuite;
-        std::ostringstream stdErrForSuite;
-        unsigned int unexpectedExceptions;
-    };
-
-    INTERNAL_CATCH_REGISTER_REPORTER( "junit", JunitReporter )
-
-} // end namespace Catch
-
-// #included from: ../reporters/catch_reporter_console.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED
-
-namespace Catch {
-
-    struct ConsoleReporter : StreamingReporterBase {
-        ConsoleReporter( ReporterConfig const& _config )
-        :   StreamingReporterBase( _config ),
-            m_headerPrinted( false )
-        {}
-
-        virtual ~ConsoleReporter();
-        static std::string getDescription() {
-            return "Reports test results as plain lines of text";
-        }
-        virtual ReporterPreferences getPreferences() const {
-            ReporterPreferences prefs;
-            prefs.shouldRedirectStdOut = false;
-            return prefs;
-        }
-
-        virtual void noMatchingTestCases( std::string const& spec ) {
-            stream << "No test cases matched '" << spec << "'" << std::endl;
-        }
-
-        virtual void assertionStarting( AssertionInfo const& ) {
-        }
-
-        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {
-            AssertionResult const& result = _assertionStats.assertionResult;
-
-            bool printInfoMessages = true;
-
-            // Drop out if result was successful and we're not printing those
-            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
-                if( result.getResultType() != ResultWas::Warning )
-                    return false;
-                printInfoMessages = false;
-            }
-
-            lazyPrint();
-
-            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
-            printer.print();
-            stream << std::endl;
-            return true;
-        }
-
-        virtual void sectionStarting( SectionInfo const& _sectionInfo ) {
-            m_headerPrinted = false;
-            StreamingReporterBase::sectionStarting( _sectionInfo );
-        }
-        virtual void sectionEnded( SectionStats const& _sectionStats ) {
-            if( _sectionStats.missingAssertions ) {
-                lazyPrint();
-                Colour colour( Colour::ResultError );
-                if( m_sectionStack.size() > 1 )
-                    stream << "\nNo assertions in section";
-                else
-                    stream << "\nNo assertions in test case";
-                stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
-            }
-            if( m_headerPrinted ) {
-                if( m_config->showDurations() == ShowDurations::Always )
-                    stream << "Completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
-                m_headerPrinted = false;
-            }
-            else {
-                if( m_config->showDurations() == ShowDurations::Always )
-                    stream << _sectionStats.sectionInfo.name << " completed in " << _sectionStats.durationInSeconds << "s" << std::endl;
-            }
-            StreamingReporterBase::sectionEnded( _sectionStats );
-        }
-
-        virtual void testCaseEnded( TestCaseStats const& _testCaseStats ) {
-            StreamingReporterBase::testCaseEnded( _testCaseStats );
-            m_headerPrinted = false;
-        }
-        virtual void testGroupEnded( TestGroupStats const& _testGroupStats ) {
-            if( currentGroupInfo.used ) {
-                printSummaryDivider();
-                stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
-                printTotals( _testGroupStats.totals );
-                stream << "\n" << std::endl;
-            }
-            StreamingReporterBase::testGroupEnded( _testGroupStats );
-        }
-        virtual void testRunEnded( TestRunStats const& _testRunStats ) {
-            printTotalsDivider( _testRunStats.totals );
-            printTotals( _testRunStats.totals );
-            stream << std::endl;
-            StreamingReporterBase::testRunEnded( _testRunStats );
-        }
-
-    private:
-
-        class AssertionPrinter {
-            void operator= ( AssertionPrinter const& );
-        public:
-            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
-            :   stream( _stream ),
-                stats( _stats ),
-                result( _stats.assertionResult ),
-                colour( Colour::None ),
-                message( result.getMessage() ),
-                messages( _stats.infoMessages ),
-                printInfoMessages( _printInfoMessages )
-            {
-                switch( result.getResultType() ) {
-                    case ResultWas::Ok:
-                        colour = Colour::Success;
-                        passOrFail = "PASSED";
-                        //if( result.hasMessage() )
-                        if( _stats.infoMessages.size() == 1 )
-                            messageLabel = "with message";
-                        if( _stats.infoMessages.size() > 1 )
-                            messageLabel = "with messages";
-                        break;
-                    case ResultWas::ExpressionFailed:
-                        if( result.isOk() ) {
-                            colour = Colour::Success;
-                            passOrFail = "FAILED - but was ok";
-                        }
-                        else {
-                            colour = Colour::Error;
-                            passOrFail = "FAILED";
-                        }
-                        if( _stats.infoMessages.size() == 1 )
-                            messageLabel = "with message";
-                        if( _stats.infoMessages.size() > 1 )
-                            messageLabel = "with messages";
-                        break;
-                    case ResultWas::ThrewException:
-                        colour = Colour::Error;
-                        passOrFail = "FAILED";
-                        messageLabel = "due to unexpected exception with message";
-                        break;
-                    case ResultWas::FatalErrorCondition:
-                        colour = Colour::Error;
-                        passOrFail = "FAILED";
-                        messageLabel = "due to a fatal error condition";
-                        break;
-                    case ResultWas::DidntThrowException:
-                        colour = Colour::Error;
-                        passOrFail = "FAILED";
-                        messageLabel = "because no exception was thrown where one was expected";
-                        break;
-                    case ResultWas::Info:
-                        messageLabel = "info";
-                        break;
-                    case ResultWas::Warning:
-                        messageLabel = "warning";
-                        break;
-                    case ResultWas::ExplicitFailure:
-                        passOrFail = "FAILED";
-                        colour = Colour::Error;
-                        if( _stats.infoMessages.size() == 1 )
-                            messageLabel = "explicitly with message";
-                        if( _stats.infoMessages.size() > 1 )
-                            messageLabel = "explicitly with messages";
-                        break;
-                    // These cases are here to prevent compiler warnings
-                    case ResultWas::Unknown:
-                    case ResultWas::FailureBit:
-                    case ResultWas::Exception:
-                        passOrFail = "** internal error **";
-                        colour = Colour::Error;
-                        break;
-                }
-            }
-
-            void print() const {
-                printSourceInfo();
-                if( stats.totals.assertions.total() > 0 ) {
-                    if( result.isOk() )
-                        stream << "\n";
-                    printResultType();
-                    printOriginalExpression();
-                    printReconstructedExpression();
-                }
-                else {
-                    stream << "\n";
-                }
-                printMessage();
-            }
-
-        private:
-            void printResultType() const {
-                if( !passOrFail.empty() ) {
-                    Colour colourGuard( colour );
-                    stream << passOrFail << ":\n";
-                }
-            }
-            void printOriginalExpression() const {
-                if( result.hasExpression() ) {
-                    Colour colourGuard( Colour::OriginalExpression );
-                    stream  << "  ";
-                    stream << result.getExpressionInMacro();
-                    stream << "\n";
-                }
-            }
-            void printReconstructedExpression() const {
-                if( result.hasExpandedExpression() ) {
-                    stream << "with expansion:\n";
-                    Colour colourGuard( Colour::ReconstructedExpression );
-                    stream << Text( result.getExpandedExpression(), TextAttributes().setIndent(2) ) << "\n";
-                }
-            }
-            void printMessage() const {
-                if( !messageLabel.empty() )
-                    stream << messageLabel << ":" << "\n";
-                for( std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
-                        it != itEnd;
-                        ++it ) {
-                    // If this assertion is a warning ignore any INFO messages
-                    if( printInfoMessages || it->type != ResultWas::Info )
-                        stream << Text( it->message, TextAttributes().setIndent(2) ) << "\n";
-                }
-            }
-            void printSourceInfo() const {
-                Colour colourGuard( Colour::FileName );
-                stream << result.getSourceInfo() << ": ";
-            }
-
-            std::ostream& stream;
-            AssertionStats const& stats;
-            AssertionResult const& result;
-            Colour::Code colour;
-            std::string passOrFail;
-            std::string messageLabel;
-            std::string message;
-            std::vector<MessageInfo> messages;
-            bool printInfoMessages;
-        };
-
-        void lazyPrint() {
-
-            if( !currentTestRunInfo.used )
-                lazyPrintRunInfo();
-            if( !currentGroupInfo.used )
-                lazyPrintGroupInfo();
-
-            if( !m_headerPrinted ) {
-                printTestCaseAndSectionHeader();
-                m_headerPrinted = true;
-            }
-        }
-        void lazyPrintRunInfo() {
-            stream  << "\n" << getLineOfChars<'~'>() << "\n";
-            Colour colour( Colour::SecondaryText );
-            stream  << currentTestRunInfo->name
-                    << " is a Catch v"  << libraryVersion << " host application.\n"
-                    << "Run with -? for options\n\n";
-
-            if( m_config->rngSeed() != 0 )
-                stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
-
-            currentTestRunInfo.used = true;
-        }
-        void lazyPrintGroupInfo() {
-            if( !currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1 ) {
-                printClosedHeader( "Group: " + currentGroupInfo->name );
-                currentGroupInfo.used = true;
-            }
-        }
-        void printTestCaseAndSectionHeader() {
-            assert( !m_sectionStack.empty() );
-            printOpenHeader( currentTestCaseInfo->name );
-
-            if( m_sectionStack.size() > 1 ) {
-                Colour colourGuard( Colour::Headers );
-
-                std::vector<SectionInfo>::const_iterator
-                    it = m_sectionStack.begin()+1, // Skip first section (test case)
-                    itEnd = m_sectionStack.end();
-                for( ; it != itEnd; ++it )
-                    printHeaderString( it->name, 2 );
-            }
-
-            SourceLineInfo lineInfo = m_sectionStack.front().lineInfo;
-
-            if( !lineInfo.empty() ){
-                stream << getLineOfChars<'-'>() << "\n";
-                Colour colourGuard( Colour::FileName );
-                stream << lineInfo << "\n";
-            }
-            stream << getLineOfChars<'.'>() << "\n" << std::endl;
-        }
-
-        void printClosedHeader( std::string const& _name ) {
-            printOpenHeader( _name );
-            stream << getLineOfChars<'.'>() << "\n";
-        }
-        void printOpenHeader( std::string const& _name ) {
-            stream  << getLineOfChars<'-'>() << "\n";
-            {
-                Colour colourGuard( Colour::Headers );
-                printHeaderString( _name );
-            }
-        }
-
-        // if string has a : in first line will set indent to follow it on
-        // subsequent lines
-        void printHeaderString( std::string const& _string, std::size_t indent = 0 ) {
-            std::size_t i = _string.find( ": " );
-            if( i != std::string::npos )
-                i+=2;
-            else
-                i = 0;
-            stream << Text( _string, TextAttributes()
-                                        .setIndent( indent+i)
-                                        .setInitialIndent( indent ) ) << "\n";
-        }
-
-        struct SummaryColumn {
-
-            SummaryColumn( std::string const& _label, Colour::Code _colour )
-            :   label( _label ),
-                colour( _colour )
-            {}
-            SummaryColumn addRow( std::size_t count ) {
-                std::ostringstream oss;
-                oss << count;
-                std::string row = oss.str();
-                for( std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it ) {
-                    while( it->size() < row.size() )
-                        *it = " " + *it;
-                    while( it->size() > row.size() )
-                        row = " " + row;
-                }
-                rows.push_back( row );
-                return *this;
-            }
-
-            std::string label;
-            Colour::Code colour;
-            std::vector<std::string> rows;
-
-        };
-
-        void printTotals( Totals const& totals ) {
-            if( totals.testCases.total() == 0 ) {
-                stream << Colour( Colour::Warning ) << "No tests ran\n";
-            }
-            else if( totals.assertions.total() > 0 && totals.assertions.allPassed() ) {
-                stream << Colour( Colour::ResultSuccess ) << "All tests passed";
-                stream << " ("
-                        << pluralise( totals.assertions.passed, "assertion" ) << " in "
-                        << pluralise( totals.testCases.passed, "test case" ) << ")"
-                        << "\n";
-            }
-            else {
-
-                std::vector<SummaryColumn> columns;
-                columns.push_back( SummaryColumn( "", Colour::None )
-                                        .addRow( totals.testCases.total() )
-                                        .addRow( totals.assertions.total() ) );
-                columns.push_back( SummaryColumn( "passed", Colour::Success )
-                                        .addRow( totals.testCases.passed )
-                                        .addRow( totals.assertions.passed ) );
-                columns.push_back( SummaryColumn( "failed", Colour::ResultError )
-                                        .addRow( totals.testCases.failed )
-                                        .addRow( totals.assertions.failed ) );
-                columns.push_back( SummaryColumn( "failed as expected", Colour::ResultExpectedFailure )
-                                        .addRow( totals.testCases.failedButOk )
-                                        .addRow( totals.assertions.failedButOk ) );
-
-                printSummaryRow( "test cases", columns, 0 );
-                printSummaryRow( "assertions", columns, 1 );
-            }
-        }
-        void printSummaryRow( std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row ) {
-            for( std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it ) {
-                std::string value = it->rows[row];
-                if( it->label.empty() ) {
-                    stream << label << ": ";
-                    if( value != "0" )
-                        stream << value;
-                    else
-                        stream << Colour( Colour::Warning ) << "- none -";
-                }
-                else if( value != "0" ) {
-                    stream  << Colour( Colour::LightGrey ) << " | ";
-                    stream  << Colour( it->colour )
-                            << value << " " << it->label;
-                }
-            }
-            stream << "\n";
-        }
-
-        static std::size_t makeRatio( std::size_t number, std::size_t total ) {
-            std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number/ total : 0;
-            return ( ratio == 0 && number > 0 ) ? 1 : ratio;
-        }
-        static std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {
-            if( i > j && i > k )
-                return i;
-            else if( j > k )
-                return j;
-            else
-                return k;
-        }
-
-        void printTotalsDivider( Totals const& totals ) {
-            if( totals.testCases.total() > 0 ) {
-                std::size_t failedRatio = makeRatio( totals.testCases.failed, totals.testCases.total() );
-                std::size_t failedButOkRatio = makeRatio( totals.testCases.failedButOk, totals.testCases.total() );
-                std::size_t passedRatio = makeRatio( totals.testCases.passed, totals.testCases.total() );
-                while( failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH-1 )
-                    findMax( failedRatio, failedButOkRatio, passedRatio )++;
-                while( failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH-1 )
-                    findMax( failedRatio, failedButOkRatio, passedRatio )--;
-
-                stream << Colour( Colour::Error ) << std::string( failedRatio, '=' );
-                stream << Colour( Colour::ResultExpectedFailure ) << std::string( failedButOkRatio, '=' );
-                if( totals.testCases.allPassed() )
-                    stream << Colour( Colour::ResultSuccess ) << std::string( passedRatio, '=' );
-                else
-                    stream << Colour( Colour::Success ) << std::string( passedRatio, '=' );
-            }
-            else {
-                stream << Colour( Colour::Warning ) << std::string( CATCH_CONFIG_CONSOLE_WIDTH-1, '=' );
-            }
-            stream << "\n";
-        }
-        void printSummaryDivider() {
-            stream << getLineOfChars<'-'>() << "\n";
-        }
-
-    private:
-        bool m_headerPrinted;
-    };
-
-    INTERNAL_CATCH_REGISTER_REPORTER( "console", ConsoleReporter )
-
-} // end namespace Catch
-
-// #included from: ../reporters/catch_reporter_compact.hpp
-#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED
-
-namespace Catch {
-
-    struct CompactReporter : StreamingReporterBase {
-
-        CompactReporter( ReporterConfig const& _config )
-        : StreamingReporterBase( _config )
-        {}
-
-        virtual ~CompactReporter();
-
-        static std::string getDescription() {
-            return "Reports test results on a single line, suitable for IDEs";
-        }
-
-        virtual ReporterPreferences getPreferences() const {
-            ReporterPreferences prefs;
-            prefs.shouldRedirectStdOut = false;
-            return prefs;
-        }
-
-        virtual void noMatchingTestCases( std::string const& spec ) {
-            stream << "No test cases matched '" << spec << "'" << std::endl;
-        }
-
-        virtual void assertionStarting( AssertionInfo const& ) {
-        }
-
-        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {
-            AssertionResult const& result = _assertionStats.assertionResult;
-
-            bool printInfoMessages = true;
-
-            // Drop out if result was successful and we're not printing those
-            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
-                if( result.getResultType() != ResultWas::Warning )
-                    return false;
-                printInfoMessages = false;
-            }
-
-            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
-            printer.print();
-
-            stream << std::endl;
-            return true;
-        }
-
-        virtual void testRunEnded( TestRunStats const& _testRunStats ) {
-            printTotals( _testRunStats.totals );
-            stream << "\n" << std::endl;
-            StreamingReporterBase::testRunEnded( _testRunStats );
-        }
-
-    private:
-        class AssertionPrinter {
-            void operator= ( AssertionPrinter const& );
-        public:
-            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
-            : stream( _stream )
-            , stats( _stats )
-            , result( _stats.assertionResult )
-            , messages( _stats.infoMessages )
-            , itMessage( _stats.infoMessages.begin() )
-            , printInfoMessages( _printInfoMessages )
-            {}
-
-            void print() {
-                printSourceInfo();
-
-                itMessage = messages.begin();
-
-                switch( result.getResultType() ) {
-                    case ResultWas::Ok:
-                        printResultType( Colour::ResultSuccess, passedString() );
-                        printOriginalExpression();
-                        printReconstructedExpression();
-                        if ( ! result.hasExpression() )
-                            printRemainingMessages( Colour::None );
-                        else
-                            printRemainingMessages();
-                        break;
-                    case ResultWas::ExpressionFailed:
-                        if( result.isOk() )
-                            printResultType( Colour::ResultSuccess, failedString() + std::string( " - but was ok" ) );
-                        else
-                            printResultType( Colour::Error, failedString() );
-                        printOriginalExpression();
-                        printReconstructedExpression();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::ThrewException:
-                        printResultType( Colour::Error, failedString() );
-                        printIssue( "unexpected exception with message:" );
-                        printMessage();
-                        printExpressionWas();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::FatalErrorCondition:
-                        printResultType( Colour::Error, failedString() );
-                        printIssue( "fatal error condition with message:" );
-                        printMessage();
-                        printExpressionWas();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::DidntThrowException:
-                        printResultType( Colour::Error, failedString() );
-                        printIssue( "expected exception, got none" );
-                        printExpressionWas();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::Info:
-                        printResultType( Colour::None, "info" );
-                        printMessage();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::Warning:
-                        printResultType( Colour::None, "warning" );
-                        printMessage();
-                        printRemainingMessages();
-                        break;
-                    case ResultWas::ExplicitFailure:
-                        printResultType( Colour::Error, failedString() );
-                        printIssue( "explicitly" );
-                        printRemainingMessages( Colour::None );
-                        break;
-                    // These cases are here to prevent compiler warnings
-                    case ResultWas::Unknown:
-                    case ResultWas::FailureBit:
-                    case ResultWas::Exception:
-                        printResultType( Colour::Error, "** internal error **" );
-                        break;
-                }
-            }
-
-        private:
-            // Colour::LightGrey
-
-            static Colour::Code dimColour() { return Colour::FileName; }
-
-#ifdef CATCH_PLATFORM_MAC
-            static const char* failedString() { return "FAILED"; }
-            static const char* passedString() { return "PASSED"; }
-#else
-            static const char* failedString() { return "failed"; }
-            static const char* passedString() { return "passed"; }
-#endif
-
-            void printSourceInfo() const {
-                Colour colourGuard( Colour::FileName );
-                stream << result.getSourceInfo() << ":";
-            }
-
-            void printResultType( Colour::Code colour, std::string passOrFail ) const {
-                if( !passOrFail.empty() ) {
-                    {
-                        Colour colourGuard( colour );
-                        stream << " " << passOrFail;
-                    }
-                    stream << ":";
-                }
-            }
-
-            void printIssue( std::string issue ) const {
-                stream << " " << issue;
-            }
-
-            void printExpressionWas() {
-                if( result.hasExpression() ) {
-                    stream << ";";
-                    {
-                        Colour colour( dimColour() );
-                        stream << " expression was:";
-                    }
-                    printOriginalExpression();
-                }
-            }
-
-            void printOriginalExpression() const {
-                if( result.hasExpression() ) {
-                    stream << " " << result.getExpression();
-                }
-            }
-
-            void printReconstructedExpression() const {
-                if( result.hasExpandedExpression() ) {
-                    {
-                        Colour colour( dimColour() );
-                        stream << " for: ";
-                    }
-                    stream << result.getExpandedExpression();
-                }
-            }
-
-            void printMessage() {
-                if ( itMessage != messages.end() ) {
-                    stream << " '" << itMessage->message << "'";
-                    ++itMessage;
-                }
-            }
-
-            void printRemainingMessages( Colour::Code colour = dimColour() ) {
-                if ( itMessage == messages.end() )
-                    return;
-
-                // using messages.end() directly yields compilation error:
-                std::vector<MessageInfo>::const_iterator itEnd = messages.end();
-                const std::size_t N = static_cast<std::size_t>( std::distance( itMessage, itEnd ) );
-
-                {
-                    Colour colourGuard( colour );
-                    stream << " with " << pluralise( N, "message" ) << ":";
-                }
-
-                for(; itMessage != itEnd; ) {
-                    // If this assertion is a warning ignore any INFO messages
-                    if( printInfoMessages || itMessage->type != ResultWas::Info ) {
-                        stream << " '" << itMessage->message << "'";
-                        if ( ++itMessage != itEnd ) {
-                            Colour colourGuard( dimColour() );
-                            stream << " and";
-                        }
-                    }
-                }
-            }
-
-        private:
-            std::ostream& stream;
-            AssertionStats const& stats;
-            AssertionResult const& result;
-            std::vector<MessageInfo> messages;
-            std::vector<MessageInfo>::const_iterator itMessage;
-            bool printInfoMessages;
-        };
-
-        // Colour, message variants:
-        // - white: No tests ran.
-        // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
-        // - white: Passed [both/all] N test cases (no assertions).
-        // -   red: Failed N tests cases, failed M assertions.
-        // - green: Passed [both/all] N tests cases with M assertions.
-
-        std::string bothOrAll( std::size_t count ) const {
-            return count == 1 ? "" : count == 2 ? "both " : "all " ;
-        }
-
-        void printTotals( const Totals& totals ) const {
-            if( totals.testCases.total() == 0 ) {
-                stream << "No tests ran.";
-            }
-            else if( totals.testCases.failed == totals.testCases.total() ) {
-                Colour colour( Colour::ResultError );
-                const std::string qualify_assertions_failed =
-                    totals.assertions.failed == totals.assertions.total() ?
-                        bothOrAll( totals.assertions.failed ) : "";
-                stream <<
-                    "Failed " << bothOrAll( totals.testCases.failed )
-                              << pluralise( totals.testCases.failed, "test case"  ) << ", "
-                    "failed " << qualify_assertions_failed <<
-                                 pluralise( totals.assertions.failed, "assertion" ) << ".";
-            }
-            else if( totals.assertions.total() == 0 ) {
-                stream <<
-                    "Passed " << bothOrAll( totals.testCases.total() )
-                              << pluralise( totals.testCases.total(), "test case" )
-                              << " (no assertions).";
-            }
-            else if( totals.assertions.failed ) {
-                Colour colour( Colour::ResultError );
-                stream <<
-                    "Failed " << pluralise( totals.testCases.failed, "test case"  ) << ", "
-                    "failed " << pluralise( totals.assertions.failed, "assertion" ) << ".";
-            }
-            else {
-                Colour colour( Colour::ResultSuccess );
-                stream <<
-                    "Passed " << bothOrAll( totals.testCases.passed )
-                              << pluralise( totals.testCases.passed, "test case"  ) <<
-                    " with "  << pluralise( totals.assertions.passed, "assertion" ) << ".";
-            }
-        }
-    };
-
-    INTERNAL_CATCH_REGISTER_REPORTER( "compact", CompactReporter )
-
-} // end namespace Catch
-
-namespace Catch {
-    NonCopyable::~NonCopyable() {}
-    IShared::~IShared() {}
-    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
-    IContext::~IContext() {}
-    IResultCapture::~IResultCapture() {}
-    ITestCase::~ITestCase() {}
-    ITestCaseRegistry::~ITestCaseRegistry() {}
-    IRegistryHub::~IRegistryHub() {}
-    IMutableRegistryHub::~IMutableRegistryHub() {}
-    IExceptionTranslator::~IExceptionTranslator() {}
-    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
-    IReporter::~IReporter() {}
-    IReporterFactory::~IReporterFactory() {}
-    IReporterRegistry::~IReporterRegistry() {}
-    IStreamingReporter::~IStreamingReporter() {}
-    AssertionStats::~AssertionStats() {}
-    SectionStats::~SectionStats() {}
-    TestCaseStats::~TestCaseStats() {}
-    TestGroupStats::~TestGroupStats() {}
-    TestRunStats::~TestRunStats() {}
-    CumulativeReporterBase::SectionNode::~SectionNode() {}
-    CumulativeReporterBase::~CumulativeReporterBase() {}
-
-    StreamingReporterBase::~StreamingReporterBase() {}
-    ConsoleReporter::~ConsoleReporter() {}
-    CompactReporter::~CompactReporter() {}
-    IRunner::~IRunner() {}
-    IMutableContext::~IMutableContext() {}
-    IConfig::~IConfig() {}
-    XmlReporter::~XmlReporter() {}
-    JunitReporter::~JunitReporter() {}
-    TestRegistry::~TestRegistry() {}
-    FreeFunctionTestCase::~FreeFunctionTestCase() {}
-    IGeneratorInfo::~IGeneratorInfo() {}
-    IGeneratorsForTest::~IGeneratorsForTest() {}
-    TestSpec::Pattern::~Pattern() {}
-    TestSpec::NamePattern::~NamePattern() {}
-    TestSpec::TagPattern::~TagPattern() {}
-    TestSpec::ExcludedPattern::~ExcludedPattern() {}
-
-    Matchers::Impl::StdString::Equals::~Equals() {}
-    Matchers::Impl::StdString::Contains::~Contains() {}
-    Matchers::Impl::StdString::StartsWith::~StartsWith() {}
-    Matchers::Impl::StdString::EndsWith::~EndsWith() {}
-
-    void Config::dummy() {}
-}
-
-#ifdef __clang__
-#pragma clang diagnostic pop
-#endif
-
-#endif
-
-#ifdef CATCH_CONFIG_MAIN
-// #included from: internal/catch_default_main.hpp
-#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED
-
-#ifndef __OBJC__
-
-// Standard C/C++ main entry point
-int main (int argc, char * const argv[]) {
-    return Catch::Session().run( argc, argv );
-}
-
-#else // __OBJC__
-
-// Objective-C entry point
-int main (int argc, char * const argv[]) {
-#if !CATCH_ARC_ENABLED
-    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
-#endif
-
-    Catch::registerTestMethods();
-    int result = Catch::Session().run( argc, (char* const*)argv );
-
-#if !CATCH_ARC_ENABLED
-    [pool drain];
-#endif
-
-    return result;
-}
-
-#endif // __OBJC__
-
-#endif
-
-#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
-#  undef CLARA_CONFIG_MAIN
-#endif
-
-//////
-
-// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
-#ifdef CATCH_CONFIG_PREFIX_ALL
-
-#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE" )
-#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "CATCH_REQUIRE_FALSE" )
-
-#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THROWS" )
-#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THROWS_AS" )
-#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_NOTHROW" )
-
-#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK" )
-#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CATCH_CHECK_FALSE" )
-#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_IF" )
-#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECKED_ELSE" )
-#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CATCH_CHECK_NOFAIL" )
-
-#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS" )
-#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THROWS_AS" )
-#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_NOTHROW" )
-
-#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CATCH_CHECK_THAT" )
-#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "CATCH_REQUIRE_THAT" )
-
-#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
-#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "CATCH_WARN", msg )
-#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "CATCH_INFO" )
-#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
-#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CATCH_CAPTURE" )
-
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-    #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
-    #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
-    #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
-    #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
-    #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", __VA_ARGS__ )
-    #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", __VA_ARGS__ )
-#else
-    #define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
-    #define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
-    #define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
-    #define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
-    #define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "CATCH_FAIL", msg )
-    #define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "CATCH_SUCCEED", msg )
-#endif
-#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
-
-#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
-#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
-
-#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
-
-// "BDD-style" convenience wrappers
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
-#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
-#else
-#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( "Scenario: " name, tags )
-#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
-#endif
-#define CATCH_GIVEN( desc )    CATCH_SECTION( "Given: " desc, "" )
-#define CATCH_WHEN( desc )     CATCH_SECTION( " When: " desc, "" )
-#define CATCH_AND_WHEN( desc ) CATCH_SECTION( "  And: " desc, "" )
-#define CATCH_THEN( desc )     CATCH_SECTION( " Then: " desc, "" )
-#define CATCH_AND_THEN( desc ) CATCH_SECTION( "  And: " desc, "" )
-
-// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
-#else
-
-#define REQUIRE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal, "REQUIRE" )
-#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, "REQUIRE_FALSE" )
-
-#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::Normal, "REQUIRE_THROWS" )
-#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::Normal, "REQUIRE_THROWS_AS" )
-#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::Normal, "REQUIRE_NOTHROW" )
-
-#define CHECK( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK" )
-#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, "CHECK_FALSE" )
-#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_IF" )
-#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECKED_ELSE" )
-#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( expr, Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, "CHECK_NOFAIL" )
-
-#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THROWS" )
-#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( expr, exceptionType, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THROWS_AS" )
-#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( expr, Catch::ResultDisposition::ContinueOnFailure, "CHECK_NOTHROW" )
-
-#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::ContinueOnFailure, "CHECK_THAT" )
-#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( arg, matcher, Catch::ResultDisposition::Normal, "REQUIRE_THAT" )
-
-#define INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
-#define WARN( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, "WARN", msg )
-#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( msg, "INFO" )
-#define CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
-#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( #msg " := " << msg, "CAPTURE" )
-
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-    #define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
-    #define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
-    #define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
-    #define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
-    #define FAIL( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", __VA_ARGS__ )
-    #define SUCCEED( ... ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", __VA_ARGS__ )
-#else
-    #define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
-    #define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
-    #define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
-    #define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
-    #define FAIL( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, "FAIL", msg )
-    #define SUCCEED( msg ) INTERNAL_CATCH_MSG( Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, "SUCCEED", msg )
-#endif
-#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
-
-#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
-#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
-
-#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
-
-#endif
-
-#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
-
-// "BDD-style" convenience wrappers
-#ifdef CATCH_CONFIG_VARIADIC_MACROS
-#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
-#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
-#else
-#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
-#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
-#endif
-#define GIVEN( desc )    SECTION( "   Given: " desc, "" )
-#define WHEN( desc )     SECTION( "    When: " desc, "" )
-#define AND_WHEN( desc ) SECTION( "And when: " desc, "" )
-#define THEN( desc )     SECTION( "    Then: " desc, "" )
-#define AND_THEN( desc ) SECTION( "     And: " desc, "" )
-
-using Catch::Detail::Approx;
-
-// #included from: internal/catch_reenable_warnings.h
-
-#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED
-
-#ifdef __clang__
-#    ifdef __ICC // icpc defines the __clang__ macro
-#        pragma warning(pop)
-#    else
-#        pragma clang diagnostic pop
-#    endif
-#elif defined __GNUC__
-#    pragma GCC diagnostic pop
-#endif
-
-#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
-
+/*
+ *  Catch v2.12.1
+ *  Generated: 2020-04-21 19:29:20.964532
+ *  ----------------------------------------------------------
+ *  This file has been merged from multiple headers. Please don't edit it directly
+ *  Copyright (c) 2020 Two Blue Cubes Ltd. All rights reserved.
+ *
+ *  Distributed under the Boost Software License, Version 1.0. (See accompanying
+ *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+ */
+#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
+#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
+// start catch.hpp
+
+
+#define CATCH_VERSION_MAJOR 2
+#define CATCH_VERSION_MINOR 12
+#define CATCH_VERSION_PATCH 1
+
+#ifdef __clang__
+#    pragma clang system_header
+#elif defined __GNUC__
+#    pragma GCC system_header
+#endif
+
+// start catch_suppress_warnings.h
+
+#ifdef __clang__
+#   ifdef __ICC // icpc defines the __clang__ macro
+#       pragma warning(push)
+#       pragma warning(disable: 161 1682)
+#   else // __ICC
+#       pragma clang diagnostic push
+#       pragma clang diagnostic ignored "-Wpadded"
+#       pragma clang diagnostic ignored "-Wswitch-enum"
+#       pragma clang diagnostic ignored "-Wcovered-switch-default"
+#    endif
+#elif defined __GNUC__
+     // Because REQUIREs trigger GCC's -Wparentheses, and because still
+     // supported version of g++ have only buggy support for _Pragmas,
+     // Wparentheses have to be suppressed globally.
+#    pragma GCC diagnostic ignored "-Wparentheses" // See #674 for details
+
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wunused-variable"
+#    pragma GCC diagnostic ignored "-Wpadded"
+#endif
+// end catch_suppress_warnings.h
+#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
+#  define CATCH_IMPL
+#  define CATCH_CONFIG_ALL_PARTS
+#endif
+
+// In the impl file, we want to have access to all parts of the headers
+// Can also be used to sanely support PCHs
+#if defined(CATCH_CONFIG_ALL_PARTS)
+#  define CATCH_CONFIG_EXTERNAL_INTERFACES
+#  if defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#    undef CATCH_CONFIG_DISABLE_MATCHERS
+#  endif
+#  if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
+#    define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
+#  endif
+#endif
+
+#if !defined(CATCH_CONFIG_IMPL_ONLY)
+// start catch_platform.h
+
+#ifdef __APPLE__
+# include <TargetConditionals.h>
+# if TARGET_OS_OSX == 1
+#  define CATCH_PLATFORM_MAC
+# elif TARGET_OS_IPHONE == 1
+#  define CATCH_PLATFORM_IPHONE
+# endif
+
+#elif defined(linux) || defined(__linux) || defined(__linux__)
+#  define CATCH_PLATFORM_LINUX
+
+#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) || defined(__MINGW32__)
+#  define CATCH_PLATFORM_WINDOWS
+#endif
+
+// end catch_platform.h
+
+#ifdef CATCH_IMPL
+#  ifndef CLARA_CONFIG_MAIN
+#    define CLARA_CONFIG_MAIN_NOT_DEFINED
+#    define CLARA_CONFIG_MAIN
+#  endif
+#endif
+
+// start catch_user_interfaces.h
+
+namespace Catch {
+    unsigned int rngSeed();
+}
+
+// end catch_user_interfaces.h
+// start catch_tag_alias_autoregistrar.h
+
+// start catch_common.h
+
+// start catch_compiler_capabilities.h
+
+// Detect a number of compiler features - by compiler
+// The following features are defined:
+//
+// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
+// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
+// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
+// CATCH_CONFIG_DISABLE_EXCEPTIONS : Are exceptions enabled?
+// ****************
+// Note to maintainers: if new toggles are added please document them
+// in configuration.md, too
+// ****************
+
+// In general each macro has a _NO_<feature name> form
+// (e.g. CATCH_CONFIG_NO_POSIX_SIGNALS) which disables the feature.
+// Many features, at point of detection, define an _INTERNAL_ macro, so they
+// can be combined, en-mass, with the _NO_ forms later.
+
+#ifdef __cplusplus
+
+#  if (__cplusplus >= 201402L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201402L)
+#    define CATCH_CPP14_OR_GREATER
+#  endif
+
+#  if (__cplusplus >= 201703L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 201703L)
+#    define CATCH_CPP17_OR_GREATER
+#  endif
+
+#endif
+
+#if defined(__cpp_lib_uncaught_exceptions)
+#  define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
+#endif
+
+// We have to avoid both ICC and Clang, because they try to mask themselves
+// as gcc, and we want only GCC in this block
+#if defined(__GNUC__) && !defined(__clang__) && !defined(__ICC)
+#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "GCC diagnostic push" )
+#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "GCC diagnostic pop" )
+
+#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__)
+
+#endif
+
+#if defined(__clang__)
+
+#    define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION _Pragma( "clang diagnostic push" )
+#    define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  _Pragma( "clang diagnostic pop" )
+
+// As of this writing, IBM XL's implementation of __builtin_constant_p has a bug
+// which results in calls to destructors being emitted for each temporary,
+// without a matching initialization. In practice, this can result in something
+// like `std::string::~string` being called on an uninitialized value.
+//
+// For example, this code will likely segfault under IBM XL:
+// ```
+// REQUIRE(std::string("12") + "34" == "1234")
+// ```
+//
+// Therefore, `CATCH_INTERNAL_IGNORE_BUT_WARN` is not implemented.
+#  if !defined(__ibmxl__)
+#    define CATCH_INTERNAL_IGNORE_BUT_WARN(...) (void)__builtin_constant_p(__VA_ARGS__) /* NOLINT(cppcoreguidelines-pro-type-vararg) */
+#  endif
+
+#    define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+         _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" ) \
+         _Pragma( "clang diagnostic ignored \"-Wglobal-constructors\"")
+
+#    define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
+         _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
+
+#    define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
+         _Pragma( "clang diagnostic ignored \"-Wunused-variable\"" )
+
+#    define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
+         _Pragma( "clang diagnostic ignored \"-Wgnu-zero-variadic-macro-arguments\"" )
+
+#    define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+         _Pragma( "clang diagnostic ignored \"-Wunused-template\"" )
+
+#endif // __clang__
+
+////////////////////////////////////////////////////////////////////////////////
+// Assume that non-Windows platforms support posix signals by default
+#if !defined(CATCH_PLATFORM_WINDOWS)
+    #define CATCH_INTERNAL_CONFIG_POSIX_SIGNALS
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// We know some environments not to support full POSIX signals
+#if defined(__CYGWIN__) || defined(__QNX__) || defined(__EMSCRIPTEN__) || defined(__DJGPP__)
+    #define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
+#endif
+
+#ifdef __OS400__
+#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
+#       define CATCH_CONFIG_COLOUR_NONE
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Android somehow still does not support std::to_string
+#if defined(__ANDROID__)
+#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
+#    define CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Not all Windows environments support SEH properly
+#if defined(__MINGW32__)
+#    define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// PS4
+#if defined(__ORBIS__)
+#    define CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// Cygwin
+#ifdef __CYGWIN__
+
+// Required for some versions of Cygwin to declare gettimeofday
+// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
+#   define _BSD_SOURCE
+// some versions of cygwin (most) do not support std::to_string. Use the libstd check.
+// https://gcc.gnu.org/onlinedocs/gcc-4.8.2/libstdc++/api/a01053_source.html line 2812-2813
+# if !((__cplusplus >= 201103L) && defined(_GLIBCXX_USE_C99) \
+           && !defined(_GLIBCXX_HAVE_BROKEN_VSWPRINTF))
+
+#    define CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING
+
+# endif
+#endif // __CYGWIN__
+
+////////////////////////////////////////////////////////////////////////////////
+// Visual C++
+#if defined(_MSC_VER)
+
+#  define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION __pragma( warning(push) )
+#  define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION  __pragma( warning(pop) )
+
+#  if _MSC_VER >= 1900 // Visual Studio 2015 or newer
+#    define CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
+#  endif
+
+// Universal Windows platform does not support SEH
+// Or console colours (or console at all...)
+#  if defined(WINAPI_FAMILY) && (WINAPI_FAMILY == WINAPI_FAMILY_APP)
+#    define CATCH_CONFIG_COLOUR_NONE
+#  else
+#    define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
+#  endif
+
+// MSVC traditional preprocessor needs some workaround for __VA_ARGS__
+// _MSVC_TRADITIONAL == 0 means new conformant preprocessor
+// _MSVC_TRADITIONAL == 1 means old traditional non-conformant preprocessor
+#  if !defined(__clang__) // Handle Clang masquerading for msvc
+#    if !defined(_MSVC_TRADITIONAL) || (defined(_MSVC_TRADITIONAL) && _MSVC_TRADITIONAL)
+#      define CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#    endif // MSVC_TRADITIONAL
+#  endif // __clang__
+
+#endif // _MSC_VER
+
+#if defined(_REENTRANT) || defined(_MSC_VER)
+// Enable async processing, as -pthread is specified or no additional linking is required
+# define CATCH_INTERNAL_CONFIG_USE_ASYNC
+#endif // _MSC_VER
+
+////////////////////////////////////////////////////////////////////////////////
+// Check if we are compiled with -fno-exceptions or equivalent
+#if defined(__EXCEPTIONS) || defined(__cpp_exceptions) || defined(_CPPUNWIND)
+#  define CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+// DJGPP
+#ifdef __DJGPP__
+#  define CATCH_INTERNAL_CONFIG_NO_WCHAR
+#endif // __DJGPP__
+
+////////////////////////////////////////////////////////////////////////////////
+// Embarcadero C++Build
+#if defined(__BORLANDC__)
+    #define CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+// Use of __COUNTER__ is suppressed during code analysis in
+// CLion/AppCode 2017.2.x and former, because __COUNTER__ is not properly
+// handled by it.
+// Otherwise all supported compilers support COUNTER macro,
+// but user still might want to turn it off
+#if ( !defined(__JETBRAINS_IDE__) || __JETBRAINS_IDE__ >= 20170300L )
+    #define CATCH_INTERNAL_CONFIG_COUNTER
+#endif
+
+////////////////////////////////////////////////////////////////////////////////
+
+// RTX is a special version of Windows that is real time.
+// This means that it is detected as Windows, but does not provide
+// the same set of capabilities as real Windows does.
+#if defined(UNDER_RTSS) || defined(RTX64_BUILD)
+    #define CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH
+    #define CATCH_INTERNAL_CONFIG_NO_ASYNC
+    #define CATCH_CONFIG_COLOUR_NONE
+#endif
+
+#if !defined(_GLIBCXX_USE_C99_MATH_TR1)
+#define CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER
+#endif
+
+// Various stdlib support checks that require __has_include
+#if defined(__has_include)
+  // Check if string_view is available and usable
+  #if __has_include(<string_view>) && defined(CATCH_CPP17_OR_GREATER)
+  #    define CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW
+  #endif
+
+  // Check if optional is available and usable
+  #  if __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
+  #    define CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL
+  #  endif // __has_include(<optional>) && defined(CATCH_CPP17_OR_GREATER)
+
+  // Check if byte is available and usable
+  #  if __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
+  #    define CATCH_INTERNAL_CONFIG_CPP17_BYTE
+  #  endif // __has_include(<cstddef>) && defined(CATCH_CPP17_OR_GREATER)
+
+  // Check if variant is available and usable
+  #  if __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
+  #    if defined(__clang__) && (__clang_major__ < 8)
+         // work around clang bug with libstdc++ https://bugs.llvm.org/show_bug.cgi?id=31852
+         // fix should be in clang 8, workaround in libstdc++ 8.2
+  #      include <ciso646>
+  #      if defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
+  #        define CATCH_CONFIG_NO_CPP17_VARIANT
+  #      else
+  #        define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
+  #      endif // defined(__GLIBCXX__) && defined(_GLIBCXX_RELEASE) && (_GLIBCXX_RELEASE < 9)
+  #    else
+  #      define CATCH_INTERNAL_CONFIG_CPP17_VARIANT
+  #    endif // defined(__clang__) && (__clang_major__ < 8)
+  #  endif // __has_include(<variant>) && defined(CATCH_CPP17_OR_GREATER)
+#endif // defined(__has_include)
+
+#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
+#   define CATCH_CONFIG_COUNTER
+#endif
+#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH) && !defined(CATCH_INTERNAL_CONFIG_NO_WINDOWS_SEH)
+#   define CATCH_CONFIG_WINDOWS_SEH
+#endif
+// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
+#if defined(CATCH_INTERNAL_CONFIG_POSIX_SIGNALS) && !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
+#   define CATCH_CONFIG_POSIX_SIGNALS
+#endif
+// This is set by default, because we assume that compilers with no wchar_t support are just rare exceptions.
+#if !defined(CATCH_INTERNAL_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_NO_WCHAR) && !defined(CATCH_CONFIG_WCHAR)
+#   define CATCH_CONFIG_WCHAR
+#endif
+
+#if !defined(CATCH_INTERNAL_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_NO_CPP11_TO_STRING) && !defined(CATCH_CONFIG_CPP11_TO_STRING)
+#    define CATCH_CONFIG_CPP11_TO_STRING
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_NO_CPP17_OPTIONAL) && !defined(CATCH_CONFIG_CPP17_OPTIONAL)
+#  define CATCH_CONFIG_CPP17_OPTIONAL
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_NO_CPP17_UNCAUGHT_EXCEPTIONS) && !defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
+#  define CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_NO_CPP17_STRING_VIEW) && !defined(CATCH_CONFIG_CPP17_STRING_VIEW)
+#  define CATCH_CONFIG_CPP17_STRING_VIEW
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_CPP17_VARIANT) && !defined(CATCH_CONFIG_NO_CPP17_VARIANT) && !defined(CATCH_CONFIG_CPP17_VARIANT)
+#  define CATCH_CONFIG_CPP17_VARIANT
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_CPP17_BYTE) && !defined(CATCH_CONFIG_NO_CPP17_BYTE) && !defined(CATCH_CONFIG_CPP17_BYTE)
+#  define CATCH_CONFIG_CPP17_BYTE
+#endif
+
+#if defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
+#  define CATCH_INTERNAL_CONFIG_NEW_CAPTURE
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_NEW_CAPTURE) && !defined(CATCH_INTERNAL_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NO_NEW_CAPTURE) && !defined(CATCH_CONFIG_NEW_CAPTURE)
+#  define CATCH_CONFIG_NEW_CAPTURE
+#endif
+
+#if !defined(CATCH_INTERNAL_CONFIG_EXCEPTIONS_ENABLED) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+#  define CATCH_CONFIG_DISABLE_EXCEPTIONS
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_NO_POLYFILL_ISNAN) && !defined(CATCH_CONFIG_POLYFILL_ISNAN)
+#  define CATCH_CONFIG_POLYFILL_ISNAN
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_USE_ASYNC)  && !defined(CATCH_INTERNAL_CONFIG_NO_ASYNC) && !defined(CATCH_CONFIG_NO_USE_ASYNC) && !defined(CATCH_CONFIG_USE_ASYNC)
+#  define CATCH_CONFIG_USE_ASYNC
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_NO_ANDROID_LOGWRITE) && !defined(CATCH_CONFIG_ANDROID_LOGWRITE)
+#  define CATCH_CONFIG_ANDROID_LOGWRITE
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_NO_GLOBAL_NEXTAFTER) && !defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
+#  define CATCH_CONFIG_GLOBAL_NEXTAFTER
+#endif
+
+// Even if we do not think the compiler has that warning, we still have
+// to provide a macro that can be used by the code.
+#if !defined(CATCH_INTERNAL_START_WARNINGS_SUPPRESSION)
+#   define CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
+#endif
+#if !defined(CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION)
+#   define CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+#endif
+#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
+#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
+#endif
+#if !defined(CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS)
+#   define CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
+#endif
+#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS)
+#   define CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS
+#endif
+#if !defined(CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS)
+#   define CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS
+#endif
+
+// The goal of this macro is to avoid evaluation of the arguments, but
+// still have the compiler warn on problems inside...
+#if !defined(CATCH_INTERNAL_IGNORE_BUT_WARN)
+#   define CATCH_INTERNAL_IGNORE_BUT_WARN(...)
+#endif
+
+#if defined(__APPLE__) && defined(__apple_build_version__) && (__clang_major__ < 10)
+#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
+#elif defined(__clang__) && (__clang_major__ < 5)
+#   undef CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
+#endif
+
+#if !defined(CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS)
+#   define CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS
+#endif
+
+#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+#define CATCH_TRY if ((true))
+#define CATCH_CATCH_ALL if ((false))
+#define CATCH_CATCH_ANON(type) if ((false))
+#else
+#define CATCH_TRY try
+#define CATCH_CATCH_ALL catch (...)
+#define CATCH_CATCH_ANON(type) catch (type)
+#endif
+
+#if defined(CATCH_INTERNAL_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_NO_TRADITIONAL_MSVC_PREPROCESSOR) && !defined(CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR)
+#define CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#endif
+
+// end catch_compiler_capabilities.h
+#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
+#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
+#ifdef CATCH_CONFIG_COUNTER
+#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
+#else
+#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
+#endif
+
+#include <iosfwd>
+#include <string>
+#include <cstdint>
+
+// We need a dummy global operator<< so we can bring it into Catch namespace later
+struct Catch_global_namespace_dummy {};
+std::ostream& operator<<(std::ostream&, Catch_global_namespace_dummy);
+
+namespace Catch {
+
+    struct CaseSensitive { enum Choice {
+        Yes,
+        No
+    }; };
+
+    class NonCopyable {
+        NonCopyable( NonCopyable const& )              = delete;
+        NonCopyable( NonCopyable && )                  = delete;
+        NonCopyable& operator = ( NonCopyable const& ) = delete;
+        NonCopyable& operator = ( NonCopyable && )     = delete;
+
+    protected:
+        NonCopyable();
+        virtual ~NonCopyable();
+    };
+
+    struct SourceLineInfo {
+
+        SourceLineInfo() = delete;
+        SourceLineInfo( char const* _file, std::size_t _line ) noexcept
+        :   file( _file ),
+            line( _line )
+        {}
+
+        SourceLineInfo( SourceLineInfo const& other )            = default;
+        SourceLineInfo& operator = ( SourceLineInfo const& )     = default;
+        SourceLineInfo( SourceLineInfo&& )              noexcept = default;
+        SourceLineInfo& operator = ( SourceLineInfo&& ) noexcept = default;
+
+        bool empty() const noexcept { return file[0] == '\0'; }
+        bool operator == ( SourceLineInfo const& other ) const noexcept;
+        bool operator < ( SourceLineInfo const& other ) const noexcept;
+
+        char const* file;
+        std::size_t line;
+    };
+
+    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
+
+    // Bring in operator<< from global namespace into Catch namespace
+    // This is necessary because the overload of operator<< above makes
+    // lookup stop at namespace Catch
+    using ::operator<<;
+
+    // Use this in variadic streaming macros to allow
+    //    >> +StreamEndStop
+    // as well as
+    //    >> stuff +StreamEndStop
+    struct StreamEndStop {
+        std::string operator+() const;
+    };
+    template<typename T>
+    T const& operator + ( T const& value, StreamEndStop ) {
+        return value;
+    }
+}
+
+#define CATCH_INTERNAL_LINEINFO \
+    ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
+
+// end catch_common.h
+namespace Catch {
+
+    struct RegistrarForTagAliases {
+        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
+    };
+
+} // end namespace Catch
+
+#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+    namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); } \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+// end catch_tag_alias_autoregistrar.h
+// start catch_test_registry.h
+
+// start catch_interfaces_testcase.h
+
+#include <vector>
+
+namespace Catch {
+
+    class TestSpec;
+
+    struct ITestInvoker {
+        virtual void invoke () const = 0;
+        virtual ~ITestInvoker();
+    };
+
+    class TestCase;
+    struct IConfig;
+
+    struct ITestCaseRegistry {
+        virtual ~ITestCaseRegistry();
+        virtual std::vector<TestCase> const& getAllTests() const = 0;
+        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
+    };
+
+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );
+    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
+    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
+    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
+
+}
+
+// end catch_interfaces_testcase.h
+// start catch_stringref.h
+
+#include <cstddef>
+#include <string>
+#include <iosfwd>
+#include <cassert>
+
+namespace Catch {
+
+    /// A non-owning string class (similar to the forthcoming std::string_view)
+    /// Note that, because a StringRef may be a substring of another string,
+    /// it may not be null terminated.
+    class StringRef {
+    public:
+        using size_type = std::size_t;
+        using const_iterator = const char*;
+
+    private:
+        static constexpr char const* const s_empty = "";
+
+        char const* m_start = s_empty;
+        size_type m_size = 0;
+
+    public: // construction
+        constexpr StringRef() noexcept = default;
+
+        StringRef( char const* rawChars ) noexcept;
+
+        constexpr StringRef( char const* rawChars, size_type size ) noexcept
+        :   m_start( rawChars ),
+            m_size( size )
+        {}
+
+        StringRef( std::string const& stdString ) noexcept
+        :   m_start( stdString.c_str() ),
+            m_size( stdString.size() )
+        {}
+
+        explicit operator std::string() const {
+            return std::string(m_start, m_size);
+        }
+
+    public: // operators
+        auto operator == ( StringRef const& other ) const noexcept -> bool;
+        auto operator != (StringRef const& other) const noexcept -> bool {
+            return !(*this == other);
+        }
+
+        auto operator[] ( size_type index ) const noexcept -> char {
+            assert(index < m_size);
+            return m_start[index];
+        }
+
+    public: // named queries
+        constexpr auto empty() const noexcept -> bool {
+            return m_size == 0;
+        }
+        constexpr auto size() const noexcept -> size_type {
+            return m_size;
+        }
+
+        // Returns the current start pointer. If the StringRef is not
+        // null-terminated, throws std::domain_exception
+        auto c_str() const -> char const*;
+
+    public: // substrings and searches
+        // Returns a substring of [start, start + length).
+        // If start + length > size(), then the substring is [start, size()).
+        // If start > size(), then the substring is empty.
+        auto substr( size_type start, size_type length ) const noexcept -> StringRef;
+
+        // Returns the current start pointer. May not be null-terminated.
+        auto data() const noexcept -> char const*;
+
+        constexpr auto isNullTerminated() const noexcept -> bool {
+            return m_start[m_size] == '\0';
+        }
+
+    public: // iterators
+        constexpr const_iterator begin() const { return m_start; }
+        constexpr const_iterator end() const { return m_start + m_size; }
+    };
+
+    auto operator += ( std::string& lhs, StringRef const& sr ) -> std::string&;
+    auto operator << ( std::ostream& os, StringRef const& sr ) -> std::ostream&;
+
+    constexpr auto operator "" _sr( char const* rawChars, std::size_t size ) noexcept -> StringRef {
+        return StringRef( rawChars, size );
+    }
+} // namespace Catch
+
+constexpr auto operator "" _catch_sr( char const* rawChars, std::size_t size ) noexcept -> Catch::StringRef {
+    return Catch::StringRef( rawChars, size );
+}
+
+// end catch_stringref.h
+// start catch_preprocessor.hpp
+
+
+#define CATCH_RECURSION_LEVEL0(...) __VA_ARGS__
+#define CATCH_RECURSION_LEVEL1(...) CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(CATCH_RECURSION_LEVEL0(__VA_ARGS__)))
+#define CATCH_RECURSION_LEVEL2(...) CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(CATCH_RECURSION_LEVEL1(__VA_ARGS__)))
+#define CATCH_RECURSION_LEVEL3(...) CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(CATCH_RECURSION_LEVEL2(__VA_ARGS__)))
+#define CATCH_RECURSION_LEVEL4(...) CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(CATCH_RECURSION_LEVEL3(__VA_ARGS__)))
+#define CATCH_RECURSION_LEVEL5(...) CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(CATCH_RECURSION_LEVEL4(__VA_ARGS__)))
+
+#ifdef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define INTERNAL_CATCH_EXPAND_VARGS(...) __VA_ARGS__
+// MSVC needs more evaluations
+#define CATCH_RECURSION_LEVEL6(...) CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(CATCH_RECURSION_LEVEL5(__VA_ARGS__)))
+#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL6(CATCH_RECURSION_LEVEL6(__VA_ARGS__))
+#else
+#define CATCH_RECURSE(...)  CATCH_RECURSION_LEVEL5(__VA_ARGS__)
+#endif
+
+#define CATCH_REC_END(...)
+#define CATCH_REC_OUT
+
+#define CATCH_EMPTY()
+#define CATCH_DEFER(id) id CATCH_EMPTY()
+
+#define CATCH_REC_GET_END2() 0, CATCH_REC_END
+#define CATCH_REC_GET_END1(...) CATCH_REC_GET_END2
+#define CATCH_REC_GET_END(...) CATCH_REC_GET_END1
+#define CATCH_REC_NEXT0(test, next, ...) next CATCH_REC_OUT
+#define CATCH_REC_NEXT1(test, next) CATCH_DEFER ( CATCH_REC_NEXT0 ) ( test, next, 0)
+#define CATCH_REC_NEXT(test, next)  CATCH_REC_NEXT1(CATCH_REC_GET_END test, next)
+
+#define CATCH_REC_LIST0(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
+#define CATCH_REC_LIST1(f, x, peek, ...) , f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0) ) ( f, peek, __VA_ARGS__ )
+#define CATCH_REC_LIST2(f, x, peek, ...)   f(x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1) ) ( f, peek, __VA_ARGS__ )
+
+#define CATCH_REC_LIST0_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
+#define CATCH_REC_LIST1_UD(f, userdata, x, peek, ...) , f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST0_UD) ) ( f, userdata, peek, __VA_ARGS__ )
+#define CATCH_REC_LIST2_UD(f, userdata, x, peek, ...)   f(userdata, x) CATCH_DEFER ( CATCH_REC_NEXT(peek, CATCH_REC_LIST1_UD) ) ( f, userdata, peek, __VA_ARGS__ )
+
+// Applies the function macro `f` to each of the remaining parameters, inserts commas between the results,
+// and passes userdata as the first parameter to each invocation,
+// e.g. CATCH_REC_LIST_UD(f, x, a, b, c) evaluates to f(x, a), f(x, b), f(x, c)
+#define CATCH_REC_LIST_UD(f, userdata, ...) CATCH_RECURSE(CATCH_REC_LIST2_UD(f, userdata, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
+
+#define CATCH_REC_LIST(f, ...) CATCH_RECURSE(CATCH_REC_LIST2(f, __VA_ARGS__, ()()(), ()()(), ()()(), 0))
+
+#define INTERNAL_CATCH_EXPAND1(param) INTERNAL_CATCH_EXPAND2(param)
+#define INTERNAL_CATCH_EXPAND2(...) INTERNAL_CATCH_NO## __VA_ARGS__
+#define INTERNAL_CATCH_DEF(...) INTERNAL_CATCH_DEF __VA_ARGS__
+#define INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
+#define INTERNAL_CATCH_STRINGIZE(...) INTERNAL_CATCH_STRINGIZE2(__VA_ARGS__)
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define INTERNAL_CATCH_STRINGIZE2(...) #__VA_ARGS__
+#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param))
+#else
+// MSVC is adding extra space and needs another indirection to expand INTERNAL_CATCH_NOINTERNAL_CATCH_DEF
+#define INTERNAL_CATCH_STRINGIZE2(...) INTERNAL_CATCH_STRINGIZE3(__VA_ARGS__)
+#define INTERNAL_CATCH_STRINGIZE3(...) #__VA_ARGS__
+#define INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS(param) (INTERNAL_CATCH_STRINGIZE(INTERNAL_CATCH_REMOVE_PARENS(param)) + 1)
+#endif
+
+#define INTERNAL_CATCH_MAKE_NAMESPACE2(...) ns_##__VA_ARGS__
+#define INTERNAL_CATCH_MAKE_NAMESPACE(name) INTERNAL_CATCH_MAKE_NAMESPACE2(name)
+
+#define INTERNAL_CATCH_REMOVE_PARENS(...) INTERNAL_CATCH_EXPAND1(INTERNAL_CATCH_DEF __VA_ARGS__)
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>())
+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__))
+#else
+#define INTERNAL_CATCH_MAKE_TYPE_LIST2(...) INTERNAL_CATCH_EXPAND_VARGS(decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS_GEN(__VA_ARGS__)>()))
+#define INTERNAL_CATCH_MAKE_TYPE_LIST(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_MAKE_TYPE_LIST2(INTERNAL_CATCH_REMOVE_PARENS(__VA_ARGS__)))
+#endif
+
+#define INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(...)\
+    CATCH_REC_LIST(INTERNAL_CATCH_MAKE_TYPE_LIST,__VA_ARGS__)
+
+#define INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_0) INTERNAL_CATCH_REMOVE_PARENS(_0)
+#define INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_0, _1) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_1_ARG(_1)
+#define INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_0, _1, _2) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_2_ARG(_1, _2)
+#define INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_0, _1, _2, _3) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_3_ARG(_1, _2, _3)
+#define INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_0, _1, _2, _3, _4) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_4_ARG(_1, _2, _3, _4)
+#define INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_0, _1, _2, _3, _4, _5) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_5_ARG(_1, _2, _3, _4, _5)
+#define INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_0, _1, _2, _3, _4, _5, _6) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_6_ARG(_1, _2, _4, _5, _6)
+#define INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_0, _1, _2, _3, _4, _5, _6, _7) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_7_ARG(_1, _2, _3, _4, _5, _6, _7)
+#define INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_8_ARG(_1, _2, _3, _4, _5, _6, _7, _8)
+#define INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_9_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9)
+#define INTERNAL_CATCH_REMOVE_PARENS_11_ARG(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10) INTERNAL_CATCH_REMOVE_PARENS(_0), INTERNAL_CATCH_REMOVE_PARENS_10_ARG(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10)
+
+#define INTERNAL_CATCH_VA_NARGS_IMPL(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N
+
+#define INTERNAL_CATCH_TYPE_GEN\
+    template<typename...> struct TypeList {};\
+    template<typename...Ts>\
+    constexpr auto get_wrapper() noexcept -> TypeList<Ts...> { return {}; }\
+    template<template<typename...> class...> struct TemplateTypeList{};\
+    template<template<typename...> class...Cs>\
+    constexpr auto get_wrapper() noexcept -> TemplateTypeList<Cs...> { return {}; }\
+    template<typename...>\
+    struct append;\
+    template<typename...>\
+    struct rewrap;\
+    template<template<typename...> class, typename...>\
+    struct create;\
+    template<template<typename...> class, typename>\
+    struct convert;\
+    \
+    template<typename T> \
+    struct append<T> { using type = T; };\
+    template< template<typename...> class L1, typename...E1, template<typename...> class L2, typename...E2, typename...Rest>\
+    struct append<L1<E1...>, L2<E2...>, Rest...> { using type = typename append<L1<E1...,E2...>, Rest...>::type; };\
+    template< template<typename...> class L1, typename...E1, typename...Rest>\
+    struct append<L1<E1...>, TypeList<mpl_::na>, Rest...> { using type = L1<E1...>; };\
+    \
+    template< template<typename...> class Container, template<typename...> class List, typename...elems>\
+    struct rewrap<TemplateTypeList<Container>, List<elems...>> { using type = TypeList<Container<elems...>>; };\
+    template< template<typename...> class Container, template<typename...> class List, class...Elems, typename...Elements>\
+    struct rewrap<TemplateTypeList<Container>, List<Elems...>, Elements...> { using type = typename append<TypeList<Container<Elems...>>, typename rewrap<TemplateTypeList<Container>, Elements...>::type>::type; };\
+    \
+    template<template <typename...> class Final, template< typename...> class...Containers, typename...Types>\
+    struct create<Final, TemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<TemplateTypeList<Containers>, Types...>::type...>::type; };\
+    template<template <typename...> class Final, template <typename...> class List, typename...Ts>\
+    struct convert<Final, List<Ts...>> { using type = typename append<Final<>,TypeList<Ts>...>::type; };
+
+#define INTERNAL_CATCH_NTTP_1(signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> struct Nttp{};\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    constexpr auto get_wrapper() noexcept -> Nttp<__VA_ARGS__> { return {}; } \
+    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...> struct NttpTemplateTypeList{};\
+    template<template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Cs>\
+    constexpr auto get_wrapper() noexcept -> NttpTemplateTypeList<Cs...> { return {}; } \
+    \
+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>> { using type = TypeList<Container<__VA_ARGS__>>; };\
+    template< template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class Container, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class List, INTERNAL_CATCH_REMOVE_PARENS(signature), typename...Elements>\
+    struct rewrap<NttpTemplateTypeList<Container>, List<__VA_ARGS__>, Elements...> { using type = typename append<TypeList<Container<__VA_ARGS__>>, typename rewrap<NttpTemplateTypeList<Container>, Elements...>::type>::type; };\
+    template<template <typename...> class Final, template<INTERNAL_CATCH_REMOVE_PARENS(signature)> class...Containers, typename...Types>\
+    struct create<Final, NttpTemplateTypeList<Containers...>, TypeList<Types...>> { using type = typename append<Final<>, typename rewrap<NttpTemplateTypeList<Containers>, Types...>::type...>::type; };
+
+#define INTERNAL_CATCH_DECLARE_SIG_TEST0(TestName)
+#define INTERNAL_CATCH_DECLARE_SIG_TEST1(TestName, signature)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    static void TestName()
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_X(TestName, signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    static void TestName()
+
+#define INTERNAL_CATCH_DEFINE_SIG_TEST0(TestName)
+#define INTERNAL_CATCH_DEFINE_SIG_TEST1(TestName, signature)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    static void TestName()
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_X(TestName, signature,...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    static void TestName()
+
+#define INTERNAL_CATCH_NTTP_REGISTER0(TestFunc, signature)\
+    template<typename Type>\
+    void reg_test(TypeList<Type>, Catch::NameAndTags nameAndTags)\
+    {\
+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<Type>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
+    }
+
+#define INTERNAL_CATCH_NTTP_REGISTER(TestFunc, signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    void reg_test(Nttp<__VA_ARGS__>, Catch::NameAndTags nameAndTags)\
+    {\
+        Catch::AutoReg( Catch::makeTestInvoker(&TestFunc<__VA_ARGS__>), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), nameAndTags);\
+    }
+
+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD0(TestName, signature, ...)\
+    template<typename Type>\
+    void reg_test(TypeList<Type>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
+    {\
+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<Type>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
+    }
+
+#define INTERNAL_CATCH_NTTP_REGISTER_METHOD(TestName, signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)>\
+    void reg_test(Nttp<__VA_ARGS__>, Catch::StringRef className, Catch::NameAndTags nameAndTags)\
+    {\
+        Catch::AutoReg( Catch::makeTestInvoker(&TestName<__VA_ARGS__>::test), CATCH_INTERNAL_LINEINFO, className, nameAndTags);\
+    }
+
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0(TestName, ClassName)
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1(TestName, ClassName, signature)\
+    template<typename TestType> \
+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<TestType> { \
+        void test();\
+    }
+
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X(TestName, ClassName, signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
+    struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName)<__VA_ARGS__> { \
+        void test();\
+    }
+
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0(TestName)
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1(TestName, signature)\
+    template<typename TestType> \
+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<TestType>::test()
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X(TestName, signature, ...)\
+    template<INTERNAL_CATCH_REMOVE_PARENS(signature)> \
+    void INTERNAL_CATCH_MAKE_NAMESPACE(TestName)::TestName<__VA_ARGS__>::test()
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define INTERNAL_CATCH_NTTP_0
+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1(__VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_1( __VA_ARGS__),INTERNAL_CATCH_NTTP_1( __VA_ARGS__), INTERNAL_CATCH_NTTP_0)
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__)
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__)
+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__)
+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__)
+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__)
+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__)
+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__)
+#else
+#define INTERNAL_CATCH_NTTP_0(signature)
+#define INTERNAL_CATCH_NTTP_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_1,INTERNAL_CATCH_NTTP_1, INTERNAL_CATCH_NTTP_0)( __VA_ARGS__))
+#define INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD1, INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD0)(TestName, __VA_ARGS__))
+#define INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X,INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD_X, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD1, INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD0)(TestName, ClassName, __VA_ARGS__))
+#define INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD, INTERNAL_CATCH_NTTP_REGISTER_METHOD0, INTERNAL_CATCH_NTTP_REGISTER_METHOD0)(TestName, __VA_ARGS__))
+#define INTERNAL_CATCH_NTTP_REG_GEN(TestFunc, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER, INTERNAL_CATCH_NTTP_REGISTER0, INTERNAL_CATCH_NTTP_REGISTER0)(TestFunc, __VA_ARGS__))
+#define INTERNAL_CATCH_DEFINE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DEFINE_SIG_TEST1, INTERNAL_CATCH_DEFINE_SIG_TEST0)(TestName, __VA_ARGS__))
+#define INTERNAL_CATCH_DECLARE_SIG_TEST(TestName, ...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL( "dummy", __VA_ARGS__, INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DEFINE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X,INTERNAL_CATCH_DECLARE_SIG_TEST_X, INTERNAL_CATCH_DECLARE_SIG_TEST1, INTERNAL_CATCH_DECLARE_SIG_TEST0)(TestName, __VA_ARGS__))
+#define INTERNAL_CATCH_REMOVE_PARENS_GEN(...) INTERNAL_CATCH_EXPAND_VARGS(INTERNAL_CATCH_VA_NARGS_IMPL(__VA_ARGS__, INTERNAL_CATCH_REMOVE_PARENS_11_ARG,INTERNAL_CATCH_REMOVE_PARENS_10_ARG,INTERNAL_CATCH_REMOVE_PARENS_9_ARG,INTERNAL_CATCH_REMOVE_PARENS_8_ARG,INTERNAL_CATCH_REMOVE_PARENS_7_ARG,INTERNAL_CATCH_REMOVE_PARENS_6_ARG,INTERNAL_CATCH_REMOVE_PARENS_5_ARG,INTERNAL_CATCH_REMOVE_PARENS_4_ARG,INTERNAL_CATCH_REMOVE_PARENS_3_ARG,INTERNAL_CATCH_REMOVE_PARENS_2_ARG,INTERNAL_CATCH_REMOVE_PARENS_1_ARG)(__VA_ARGS__))
+#endif
+
+// end catch_preprocessor.hpp
+// start catch_meta.hpp
+
+
+#include <type_traits>
+
+namespace Catch {
+    template<typename T>
+    struct always_false : std::false_type {};
+
+    template <typename> struct true_given : std::true_type {};
+    struct is_callable_tester {
+        template <typename Fun, typename... Args>
+        true_given<decltype(std::declval<Fun>()(std::declval<Args>()...))> static test(int);
+        template <typename...>
+        std::false_type static test(...);
+    };
+
+    template <typename T>
+    struct is_callable;
+
+    template <typename Fun, typename... Args>
+    struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};
+
+#if defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable >= 201703
+    // std::result_of is deprecated in C++17 and removed in C++20. Hence, it is
+    // replaced with std::invoke_result here. Also *_t format is preferred over
+    // typename *::type format.
+    template <typename Func, typename U>
+    using FunctionReturnType = std::remove_reference_t<std::remove_cv_t<std::invoke_result_t<Func, U>>>;
+#else
+    template <typename Func, typename U>
+    using FunctionReturnType = typename std::remove_reference<typename std::remove_cv<typename std::result_of<Func(U)>::type>::type>::type;
+#endif
+
+} // namespace Catch
+
+namespace mpl_{
+    struct na;
+}
+
+// end catch_meta.hpp
+namespace Catch {
+
+template<typename C>
+class TestInvokerAsMethod : public ITestInvoker {
+    void (C::*m_testAsMethod)();
+public:
+    TestInvokerAsMethod( void (C::*testAsMethod)() ) noexcept : m_testAsMethod( testAsMethod ) {}
+
+    void invoke() const override {
+        C obj;
+        (obj.*m_testAsMethod)();
+    }
+};
+
+auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker*;
+
+template<typename C>
+auto makeTestInvoker( void (C::*testAsMethod)() ) noexcept -> ITestInvoker* {
+    return new(std::nothrow) TestInvokerAsMethod<C>( testAsMethod );
+}
+
+struct NameAndTags {
+    NameAndTags( StringRef const& name_ = StringRef(), StringRef const& tags_ = StringRef() ) noexcept;
+    StringRef name;
+    StringRef tags;
+};
+
+struct AutoReg : NonCopyable {
+    AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept;
+    ~AutoReg();
+};
+
+} // end namespace Catch
+
+#if defined(CATCH_CONFIG_DISABLE)
+    #define INTERNAL_CATCH_TESTCASE_NO_REGISTRATION( TestName, ... ) \
+        static void TestName()
+    #define INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION( TestName, ClassName, ... ) \
+        namespace{                        \
+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
+                void test();              \
+            };                            \
+        }                                 \
+        void TestName::test()
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( TestName, TestFunc, Name, Tags, Signature, ... )  \
+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature))
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... )    \
+        namespace{                                                                                  \
+            namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                      \
+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
+        }                                                                                           \
+        }                                                                                           \
+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
+
+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
+    #else
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(Name, Tags, ...) \
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
+    #endif
+
+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
+    #else
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(Name, Tags, Signature, ...) \
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+    #endif
+
+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
+    #else
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION( ClassName, Name, Tags,... ) \
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
+    #endif
+
+    #ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
+            INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
+    #else
+        #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION( ClassName, Name, Tags, Signature, ... ) \
+            INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
+    #endif
+#endif
+
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
+        static void TestName(); \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &TestName ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        static void TestName()
+    #define INTERNAL_CATCH_TESTCASE( ... ) \
+        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
+
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( &QualifiedMethod ), CATCH_INTERNAL_LINEINFO, "&" #QualifiedMethod, Catch::NameAndTags{ __VA_ARGS__ } ); } /* NOLINT */ \
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        namespace{ \
+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName) { \
+                void test(); \
+            }; \
+            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( Catch::makeTestInvoker( &TestName::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
+        } \
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        void TestName::test()
+    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
+        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
+
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( Catch::makeTestInvoker( Function ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ __VA_ARGS__ } ); /* NOLINT */ \
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+    ///////////////////////////////////////////////////////////////////////////////
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_2(TestName, TestFunc, Name, Tags, Signature, ... )\
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+        INTERNAL_CATCH_DECLARE_SIG_TEST(TestFunc, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
+            INTERNAL_CATCH_TYPE_GEN\
+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
+            INTERNAL_CATCH_NTTP_REG_GEN(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))\
+            template<typename...Types> \
+            struct TestName{\
+                TestName(){\
+                    int index = 0;                                    \
+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
+                    using expander = int[];\
+                    (void)expander{(reg_test(Types{}, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \
+                }\
+            };\
+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
+            TestName<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
+            return 0;\
+        }();\
+        }\
+        }\
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        INTERNAL_CATCH_DEFINE_SIG_TEST(TestFunc,INTERNAL_CATCH_REMOVE_PARENS(Signature))
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE(Name, Tags, ...) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename TestType, __VA_ARGS__ ) )
+#endif
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG(Name, Tags, Signature, ...) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+#endif
+
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(TestName, TestFuncName, Name, Tags, Signature, TmplTypes, TypesList) \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION                      \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS                      \
+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS                \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS              \
+        template<typename TestType> static void TestFuncName();       \
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName) {                                     \
+            INTERNAL_CATCH_TYPE_GEN                                                  \
+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))         \
+            template<typename... Types>                               \
+            struct TestName {                                         \
+                void reg_tests() {                                          \
+                    int index = 0;                                    \
+                    using expander = int[];                           \
+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
+                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
+                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFuncName<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++, 0)... };/* NOLINT */\
+                }                                                     \
+            };                                                        \
+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
+                using TestInit = typename create<TestName, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type; \
+                TestInit t;                                           \
+                t.reg_tests();                                        \
+                return 0;                                             \
+            }();                                                      \
+        }                                                             \
+        }                                                             \
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
+        template<typename TestType>                                   \
+        static void TestFuncName()
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T,__VA_ARGS__)
+#else
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE(Name, Tags, ...)\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, typename T, __VA_ARGS__ ) )
+#endif
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__)
+#else
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG(Name, Tags, Signature, ...)\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, Signature, __VA_ARGS__ ) )
+#endif
+
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2(TestName, TestFunc, Name, Tags, TmplList)\
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+        template<typename TestType> static void TestFunc();       \
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){\
+        INTERNAL_CATCH_TYPE_GEN\
+        template<typename... Types>                               \
+        struct TestName {                                         \
+            void reg_tests() {                                          \
+                int index = 0;                                    \
+                using expander = int[];                           \
+                (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestFunc<Types> ), CATCH_INTERNAL_LINEINFO, Catch::StringRef(), Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */\
+            }                                                     \
+        };\
+        static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){ \
+                using TestInit = typename convert<TestName, TmplList>::type; \
+                TestInit t;                                           \
+                t.reg_tests();                                        \
+                return 0;                                             \
+            }();                                                      \
+        }}\
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION                       \
+        template<typename TestType>                                   \
+        static void TestFunc()
+
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(Name, Tags, TmplList) \
+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), Name, Tags, TmplList )
+
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, Signature, ... ) \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
+            INTERNAL_CATCH_TYPE_GEN\
+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
+            INTERNAL_CATCH_DECLARE_SIG_TEST_METHOD(TestName, ClassName, INTERNAL_CATCH_REMOVE_PARENS(Signature));\
+            INTERNAL_CATCH_NTTP_REG_METHOD_GEN(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))\
+            template<typename...Types> \
+            struct TestNameClass{\
+                TestNameClass(){\
+                    int index = 0;                                    \
+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, __VA_ARGS__)};\
+                    using expander = int[];\
+                    (void)expander{(reg_test(Types{}, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index]), Tags } ), index++, 0)... };/* NOLINT */ \
+                }\
+            };\
+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
+                TestNameClass<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(__VA_ARGS__)>();\
+                return 0;\
+        }();\
+        }\
+        }\
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        INTERNAL_CATCH_DEFINE_SIG_TEST_METHOD(TestName, INTERNAL_CATCH_REMOVE_PARENS(Signature))
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( ClassName, Name, Tags,... ) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, typename T, __VA_ARGS__ ) )
+#endif
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
+        INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... ) \
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____C_L_A_S_S____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ) , ClassName, Name, Tags, Signature, __VA_ARGS__ ) )
+#endif
+
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2(TestNameClass, TestName, ClassName, Name, Tags, Signature, TmplTypes, TypesList)\
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_ZERO_VARIADIC_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+        template<typename TestType> \
+            struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
+                void test();\
+            };\
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestNameClass) {\
+            INTERNAL_CATCH_TYPE_GEN                  \
+            INTERNAL_CATCH_NTTP_GEN(INTERNAL_CATCH_REMOVE_PARENS(Signature))\
+            template<typename...Types>\
+            struct TestNameClass{\
+                void reg_tests(){\
+                    int index = 0;\
+                    using expander = int[];\
+                    constexpr char const* tmpl_types[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TmplTypes))};\
+                    constexpr char const* types_list[] = {CATCH_REC_LIST(INTERNAL_CATCH_STRINGIZE_WITHOUT_PARENS, INTERNAL_CATCH_REMOVE_PARENS(TypesList))};\
+                    constexpr auto num_types = sizeof(types_list) / sizeof(types_list[0]);\
+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(tmpl_types[index / num_types]) + "<" + std::string(types_list[index % num_types]) + ">", Tags } ), index++, 0)... };/* NOLINT */ \
+                }\
+            };\
+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
+                using TestInit = typename create<TestNameClass, decltype(get_wrapper<INTERNAL_CATCH_REMOVE_PARENS(TmplTypes)>()), TypeList<INTERNAL_CATCH_MAKE_TYPE_LISTS_FROM_TYPES(INTERNAL_CATCH_REMOVE_PARENS(TypesList))>>::type;\
+                TestInit t;\
+                t.reg_tests();\
+                return 0;\
+            }(); \
+        }\
+        }\
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        template<typename TestType> \
+        void TestName<TestType>::test()
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( ClassName, Name, Tags, ... )\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, typename T,__VA_ARGS__ ) )
+#endif
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
+        INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature, __VA_ARGS__ )
+#else
+    #define INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( ClassName, Name, Tags, Signature, ... )\
+        INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, Signature,__VA_ARGS__ ) )
+#endif
+
+    #define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( TestNameClass, TestName, ClassName, Name, Tags, TmplList) \
+        CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+        CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+        CATCH_INTERNAL_SUPPRESS_UNUSED_TEMPLATE_WARNINGS \
+        template<typename TestType> \
+        struct TestName : INTERNAL_CATCH_REMOVE_PARENS(ClassName <TestType>) { \
+            void test();\
+        };\
+        namespace {\
+        namespace INTERNAL_CATCH_MAKE_NAMESPACE(TestName){ \
+            INTERNAL_CATCH_TYPE_GEN\
+            template<typename...Types>\
+            struct TestNameClass{\
+                void reg_tests(){\
+                    int index = 0;\
+                    using expander = int[];\
+                    (void)expander{(Catch::AutoReg( Catch::makeTestInvoker( &TestName<Types>::test ), CATCH_INTERNAL_LINEINFO, #ClassName, Catch::NameAndTags{ Name " - " + std::string(INTERNAL_CATCH_STRINGIZE(TmplList)) + " - " + std::to_string(index), Tags } ), index++, 0)... };/* NOLINT */ \
+                }\
+            };\
+            static int INTERNAL_CATCH_UNIQUE_NAME( globalRegistrar ) = [](){\
+                using TestInit = typename convert<TestNameClass, TmplList>::type;\
+                TestInit t;\
+                t.reg_tests();\
+                return 0;\
+            }(); \
+        }}\
+        CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        template<typename TestType> \
+        void TestName<TestType>::test()
+
+#define INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD(ClassName, Name, Tags, TmplList) \
+        INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD_2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____ ), INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_M_P_L_A_T_E____T_E_S_T____F_U_N_C____ ), ClassName, Name, Tags, TmplList )
+
+// end catch_test_registry.h
+// start catch_capture.hpp
+
+// start catch_assertionhandler.h
+
+// start catch_assertioninfo.h
+
+// start catch_result_type.h
+
+namespace Catch {
+
+    // ResultWas::OfType enum
+    struct ResultWas { enum OfType {
+        Unknown = -1,
+        Ok = 0,
+        Info = 1,
+        Warning = 2,
+
+        FailureBit = 0x10,
+
+        ExpressionFailed = FailureBit | 1,
+        ExplicitFailure = FailureBit | 2,
+
+        Exception = 0x100 | FailureBit,
+
+        ThrewException = Exception | 1,
+        DidntThrowException = Exception | 2,
+
+        FatalErrorCondition = 0x200 | FailureBit
+
+    }; };
+
+    bool isOk( ResultWas::OfType resultType );
+    bool isJustInfo( int flags );
+
+    // ResultDisposition::Flags enum
+    struct ResultDisposition { enum Flags {
+        Normal = 0x01,
+
+        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
+        FalseTest = 0x04,           // Prefix expression with !
+        SuppressFail = 0x08         // Failures are reported but do not fail the test
+    }; };
+
+    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs );
+
+    bool shouldContinueOnFailure( int flags );
+    inline bool isFalseTest( int flags ) { return ( flags & ResultDisposition::FalseTest ) != 0; }
+    bool shouldSuppressFailure( int flags );
+
+} // end namespace Catch
+
+// end catch_result_type.h
+namespace Catch {
+
+    struct AssertionInfo
+    {
+        StringRef macroName;
+        SourceLineInfo lineInfo;
+        StringRef capturedExpression;
+        ResultDisposition::Flags resultDisposition;
+
+        // We want to delete this constructor but a compiler bug in 4.8 means
+        // the struct is then treated as non-aggregate
+        //AssertionInfo() = delete;
+    };
+
+} // end namespace Catch
+
+// end catch_assertioninfo.h
+// start catch_decomposer.h
+
+// start catch_tostring.h
+
+#include <vector>
+#include <cstddef>
+#include <type_traits>
+#include <string>
+// start catch_stream.h
+
+#include <iosfwd>
+#include <cstddef>
+#include <ostream>
+
+namespace Catch {
+
+    std::ostream& cout();
+    std::ostream& cerr();
+    std::ostream& clog();
+
+    class StringRef;
+
+    struct IStream {
+        virtual ~IStream();
+        virtual std::ostream& stream() const = 0;
+    };
+
+    auto makeStream( StringRef const &filename ) -> IStream const*;
+
+    class ReusableStringStream : NonCopyable {
+        std::size_t m_index;
+        std::ostream* m_oss;
+    public:
+        ReusableStringStream();
+        ~ReusableStringStream();
+
+        auto str() const -> std::string;
+
+        template<typename T>
+        auto operator << ( T const& value ) -> ReusableStringStream& {
+            *m_oss << value;
+            return *this;
+        }
+        auto get() -> std::ostream& { return *m_oss; }
+    };
+}
+
+// end catch_stream.h
+// start catch_interfaces_enum_values_registry.h
+
+#include <vector>
+
+namespace Catch {
+
+    namespace Detail {
+        struct EnumInfo {
+            StringRef m_name;
+            std::vector<std::pair<int, StringRef>> m_values;
+
+            ~EnumInfo();
+
+            StringRef lookup( int value ) const;
+        };
+    } // namespace Detail
+
+    struct IMutableEnumValuesRegistry {
+        virtual ~IMutableEnumValuesRegistry();
+
+        virtual Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values ) = 0;
+
+        template<typename E>
+        Detail::EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::initializer_list<E> values ) {
+            static_assert(sizeof(int) >= sizeof(E), "Cannot serialize enum to int");
+            std::vector<int> intValues;
+            intValues.reserve( values.size() );
+            for( auto enumValue : values )
+                intValues.push_back( static_cast<int>( enumValue ) );
+            return registerEnum( enumName, allEnums, intValues );
+        }
+    };
+
+} // Catch
+
+// end catch_interfaces_enum_values_registry.h
+
+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
+#include <string_view>
+#endif
+
+#ifdef __OBJC__
+// start catch_objc_arc.hpp
+
+#import <Foundation/Foundation.h>
+
+#ifdef __has_feature
+#define CATCH_ARC_ENABLED __has_feature(objc_arc)
+#else
+#define CATCH_ARC_ENABLED 0
+#endif
+
+void arcSafeRelease( NSObject* obj );
+id performOptionalSelector( id obj, SEL sel );
+
+#if !CATCH_ARC_ENABLED
+inline void arcSafeRelease( NSObject* obj ) {
+    [obj release];
+}
+inline id performOptionalSelector( id obj, SEL sel ) {
+    if( [obj respondsToSelector: sel] )
+        return [obj performSelector: sel];
+    return nil;
+}
+#define CATCH_UNSAFE_UNRETAINED
+#define CATCH_ARC_STRONG
+#else
+inline void arcSafeRelease( NSObject* ){}
+inline id performOptionalSelector( id obj, SEL sel ) {
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
+#endif
+    if( [obj respondsToSelector: sel] )
+        return [obj performSelector: sel];
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+    return nil;
+}
+#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
+#define CATCH_ARC_STRONG __strong
+#endif
+
+// end catch_objc_arc.hpp
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable:4180) // We attempt to stream a function (address) by const&, which MSVC complains about but is harmless
+#endif
+
+namespace Catch {
+    namespace Detail {
+
+        extern const std::string unprintableString;
+
+        std::string rawMemoryToString( const void *object, std::size_t size );
+
+        template<typename T>
+        std::string rawMemoryToString( const T& object ) {
+          return rawMemoryToString( &object, sizeof(object) );
+        }
+
+        template<typename T>
+        class IsStreamInsertable {
+            template<typename Stream, typename U>
+            static auto test(int)
+                -> decltype(std::declval<Stream&>() << std::declval<U>(), std::true_type());
+
+            template<typename, typename>
+            static auto test(...)->std::false_type;
+
+        public:
+            static const bool value = decltype(test<std::ostream, const T&>(0))::value;
+        };
+
+        template<typename E>
+        std::string convertUnknownEnumToString( E e );
+
+        template<typename T>
+        typename std::enable_if<
+            !std::is_enum<T>::value && !std::is_base_of<std::exception, T>::value,
+        std::string>::type convertUnstreamable( T const& ) {
+            return Detail::unprintableString;
+        }
+        template<typename T>
+        typename std::enable_if<
+            !std::is_enum<T>::value && std::is_base_of<std::exception, T>::value,
+         std::string>::type convertUnstreamable(T const& ex) {
+            return ex.what();
+        }
+
+        template<typename T>
+        typename std::enable_if<
+            std::is_enum<T>::value
+        , std::string>::type convertUnstreamable( T const& value ) {
+            return convertUnknownEnumToString( value );
+        }
+
+#if defined(_MANAGED)
+        //! Convert a CLR string to a utf8 std::string
+        template<typename T>
+        std::string clrReferenceToString( T^ ref ) {
+            if (ref == nullptr)
+                return std::string("null");
+            auto bytes = System::Text::Encoding::UTF8->GetBytes(ref->ToString());
+            cli::pin_ptr<System::Byte> p = &bytes[0];
+            return std::string(reinterpret_cast<char const *>(p), bytes->Length);
+        }
+#endif
+
+    } // namespace Detail
+
+    // If we decide for C++14, change these to enable_if_ts
+    template <typename T, typename = void>
+    struct StringMaker {
+        template <typename Fake = T>
+        static
+        typename std::enable_if<::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
+            convert(const Fake& value) {
+                ReusableStringStream rss;
+                // NB: call using the function-like syntax to avoid ambiguity with
+                // user-defined templated operator<< under clang.
+                rss.operator<<(value);
+                return rss.str();
+        }
+
+        template <typename Fake = T>
+        static
+        typename std::enable_if<!::Catch::Detail::IsStreamInsertable<Fake>::value, std::string>::type
+            convert( const Fake& value ) {
+#if !defined(CATCH_CONFIG_FALLBACK_STRINGIFIER)
+            return Detail::convertUnstreamable(value);
+#else
+            return CATCH_CONFIG_FALLBACK_STRINGIFIER(value);
+#endif
+        }
+    };
+
+    namespace Detail {
+
+        // This function dispatches all stringification requests inside of Catch.
+        // Should be preferably called fully qualified, like ::Catch::Detail::stringify
+        template <typename T>
+        std::string stringify(const T& e) {
+            return ::Catch::StringMaker<typename std::remove_cv<typename std::remove_reference<T>::type>::type>::convert(e);
+        }
+
+        template<typename E>
+        std::string convertUnknownEnumToString( E e ) {
+            return ::Catch::Detail::stringify(static_cast<typename std::underlying_type<E>::type>(e));
+        }
+
+#if defined(_MANAGED)
+        template <typename T>
+        std::string stringify( T^ e ) {
+            return ::Catch::StringMaker<T^>::convert(e);
+        }
+#endif
+
+    } // namespace Detail
+
+    // Some predefined specializations
+
+    template<>
+    struct StringMaker<std::string> {
+        static std::string convert(const std::string& str);
+    };
+
+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
+    template<>
+    struct StringMaker<std::string_view> {
+        static std::string convert(std::string_view str);
+    };
+#endif
+
+    template<>
+    struct StringMaker<char const *> {
+        static std::string convert(char const * str);
+    };
+    template<>
+    struct StringMaker<char *> {
+        static std::string convert(char * str);
+    };
+
+#ifdef CATCH_CONFIG_WCHAR
+    template<>
+    struct StringMaker<std::wstring> {
+        static std::string convert(const std::wstring& wstr);
+    };
+
+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
+    template<>
+    struct StringMaker<std::wstring_view> {
+        static std::string convert(std::wstring_view str);
+    };
+# endif
+
+    template<>
+    struct StringMaker<wchar_t const *> {
+        static std::string convert(wchar_t const * str);
+    };
+    template<>
+    struct StringMaker<wchar_t *> {
+        static std::string convert(wchar_t * str);
+    };
+#endif
+
+    // TBD: Should we use `strnlen` to ensure that we don't go out of the buffer,
+    //      while keeping string semantics?
+    template<int SZ>
+    struct StringMaker<char[SZ]> {
+        static std::string convert(char const* str) {
+            return ::Catch::Detail::stringify(std::string{ str });
+        }
+    };
+    template<int SZ>
+    struct StringMaker<signed char[SZ]> {
+        static std::string convert(signed char const* str) {
+            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
+        }
+    };
+    template<int SZ>
+    struct StringMaker<unsigned char[SZ]> {
+        static std::string convert(unsigned char const* str) {
+            return ::Catch::Detail::stringify(std::string{ reinterpret_cast<char const *>(str) });
+        }
+    };
+
+#if defined(CATCH_CONFIG_CPP17_BYTE)
+    template<>
+    struct StringMaker<std::byte> {
+        static std::string convert(std::byte value);
+    };
+#endif // defined(CATCH_CONFIG_CPP17_BYTE)
+    template<>
+    struct StringMaker<int> {
+        static std::string convert(int value);
+    };
+    template<>
+    struct StringMaker<long> {
+        static std::string convert(long value);
+    };
+    template<>
+    struct StringMaker<long long> {
+        static std::string convert(long long value);
+    };
+    template<>
+    struct StringMaker<unsigned int> {
+        static std::string convert(unsigned int value);
+    };
+    template<>
+    struct StringMaker<unsigned long> {
+        static std::string convert(unsigned long value);
+    };
+    template<>
+    struct StringMaker<unsigned long long> {
+        static std::string convert(unsigned long long value);
+    };
+
+    template<>
+    struct StringMaker<bool> {
+        static std::string convert(bool b);
+    };
+
+    template<>
+    struct StringMaker<char> {
+        static std::string convert(char c);
+    };
+    template<>
+    struct StringMaker<signed char> {
+        static std::string convert(signed char c);
+    };
+    template<>
+    struct StringMaker<unsigned char> {
+        static std::string convert(unsigned char c);
+    };
+
+    template<>
+    struct StringMaker<std::nullptr_t> {
+        static std::string convert(std::nullptr_t);
+    };
+
+    template<>
+    struct StringMaker<float> {
+        static std::string convert(float value);
+        static int precision;
+    };
+
+    template<>
+    struct StringMaker<double> {
+        static std::string convert(double value);
+        static int precision;
+    };
+
+    template <typename T>
+    struct StringMaker<T*> {
+        template <typename U>
+        static std::string convert(U* p) {
+            if (p) {
+                return ::Catch::Detail::rawMemoryToString(p);
+            } else {
+                return "nullptr";
+            }
+        }
+    };
+
+    template <typename R, typename C>
+    struct StringMaker<R C::*> {
+        static std::string convert(R C::* p) {
+            if (p) {
+                return ::Catch::Detail::rawMemoryToString(p);
+            } else {
+                return "nullptr";
+            }
+        }
+    };
+
+#if defined(_MANAGED)
+    template <typename T>
+    struct StringMaker<T^> {
+        static std::string convert( T^ ref ) {
+            return ::Catch::Detail::clrReferenceToString(ref);
+        }
+    };
+#endif
+
+    namespace Detail {
+        template<typename InputIterator>
+        std::string rangeToString(InputIterator first, InputIterator last) {
+            ReusableStringStream rss;
+            rss << "{ ";
+            if (first != last) {
+                rss << ::Catch::Detail::stringify(*first);
+                for (++first; first != last; ++first)
+                    rss << ", " << ::Catch::Detail::stringify(*first);
+            }
+            rss << " }";
+            return rss.str();
+        }
+    }
+
+#ifdef __OBJC__
+    template<>
+    struct StringMaker<NSString*> {
+        static std::string convert(NSString * nsstring) {
+            if (!nsstring)
+                return "nil";
+            return std::string("@") + [nsstring UTF8String];
+        }
+    };
+    template<>
+    struct StringMaker<NSObject*> {
+        static std::string convert(NSObject* nsObject) {
+            return ::Catch::Detail::stringify([nsObject description]);
+        }
+
+    };
+    namespace Detail {
+        inline std::string stringify( NSString* nsstring ) {
+            return StringMaker<NSString*>::convert( nsstring );
+        }
+
+    } // namespace Detail
+#endif // __OBJC__
+
+} // namespace Catch
+
+//////////////////////////////////////////////////////
+// Separate std-lib types stringification, so it can be selectively enabled
+// This means that we do not bring in
+
+#if defined(CATCH_CONFIG_ENABLE_ALL_STRINGMAKERS)
+#  define CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
+#  define CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
+#  define CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
+#  define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
+#  define CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
+#endif
+
+// Separate std::pair specialization
+#if defined(CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER)
+#include <utility>
+namespace Catch {
+    template<typename T1, typename T2>
+    struct StringMaker<std::pair<T1, T2> > {
+        static std::string convert(const std::pair<T1, T2>& pair) {
+            ReusableStringStream rss;
+            rss << "{ "
+                << ::Catch::Detail::stringify(pair.first)
+                << ", "
+                << ::Catch::Detail::stringify(pair.second)
+                << " }";
+            return rss.str();
+        }
+    };
+}
+#endif // CATCH_CONFIG_ENABLE_PAIR_STRINGMAKER
+
+#if defined(CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_OPTIONAL)
+#include <optional>
+namespace Catch {
+    template<typename T>
+    struct StringMaker<std::optional<T> > {
+        static std::string convert(const std::optional<T>& optional) {
+            ReusableStringStream rss;
+            if (optional.has_value()) {
+                rss << ::Catch::Detail::stringify(*optional);
+            } else {
+                rss << "{ }";
+            }
+            return rss.str();
+        }
+    };
+}
+#endif // CATCH_CONFIG_ENABLE_OPTIONAL_STRINGMAKER
+
+// Separate std::tuple specialization
+#if defined(CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER)
+#include <tuple>
+namespace Catch {
+    namespace Detail {
+        template<
+            typename Tuple,
+            std::size_t N = 0,
+            bool = (N < std::tuple_size<Tuple>::value)
+            >
+            struct TupleElementPrinter {
+            static void print(const Tuple& tuple, std::ostream& os) {
+                os << (N ? ", " : " ")
+                    << ::Catch::Detail::stringify(std::get<N>(tuple));
+                TupleElementPrinter<Tuple, N + 1>::print(tuple, os);
+            }
+        };
+
+        template<
+            typename Tuple,
+            std::size_t N
+        >
+            struct TupleElementPrinter<Tuple, N, false> {
+            static void print(const Tuple&, std::ostream&) {}
+        };
+
+    }
+
+    template<typename ...Types>
+    struct StringMaker<std::tuple<Types...>> {
+        static std::string convert(const std::tuple<Types...>& tuple) {
+            ReusableStringStream rss;
+            rss << '{';
+            Detail::TupleElementPrinter<std::tuple<Types...>>::print(tuple, rss.get());
+            rss << " }";
+            return rss.str();
+        }
+    };
+}
+#endif // CATCH_CONFIG_ENABLE_TUPLE_STRINGMAKER
+
+#if defined(CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER) && defined(CATCH_CONFIG_CPP17_VARIANT)
+#include <variant>
+namespace Catch {
+    template<>
+    struct StringMaker<std::monostate> {
+        static std::string convert(const std::monostate&) {
+            return "{ }";
+        }
+    };
+
+    template<typename... Elements>
+    struct StringMaker<std::variant<Elements...>> {
+        static std::string convert(const std::variant<Elements...>& variant) {
+            if (variant.valueless_by_exception()) {
+                return "{valueless variant}";
+            } else {
+                return std::visit(
+                    [](const auto& value) {
+                        return ::Catch::Detail::stringify(value);
+                    },
+                    variant
+                );
+            }
+        }
+    };
+}
+#endif // CATCH_CONFIG_ENABLE_VARIANT_STRINGMAKER
+
+namespace Catch {
+    struct not_this_one {}; // Tag type for detecting which begin/ end are being selected
+
+    // Import begin/ end from std here so they are considered alongside the fallback (...) overloads in this namespace
+    using std::begin;
+    using std::end;
+
+    not_this_one begin( ... );
+    not_this_one end( ... );
+
+    template <typename T>
+    struct is_range {
+        static const bool value =
+            !std::is_same<decltype(begin(std::declval<T>())), not_this_one>::value &&
+            !std::is_same<decltype(end(std::declval<T>())), not_this_one>::value;
+    };
+
+#if defined(_MANAGED) // Managed types are never ranges
+    template <typename T>
+    struct is_range<T^> {
+        static const bool value = false;
+    };
+#endif
+
+    template<typename Range>
+    std::string rangeToString( Range const& range ) {
+        return ::Catch::Detail::rangeToString( begin( range ), end( range ) );
+    }
+
+    // Handle vector<bool> specially
+    template<typename Allocator>
+    std::string rangeToString( std::vector<bool, Allocator> const& v ) {
+        ReusableStringStream rss;
+        rss << "{ ";
+        bool first = true;
+        for( bool b : v ) {
+            if( first )
+                first = false;
+            else
+                rss << ", ";
+            rss << ::Catch::Detail::stringify( b );
+        }
+        rss << " }";
+        return rss.str();
+    }
+
+    template<typename R>
+    struct StringMaker<R, typename std::enable_if<is_range<R>::value && !::Catch::Detail::IsStreamInsertable<R>::value>::type> {
+        static std::string convert( R const& range ) {
+            return rangeToString( range );
+        }
+    };
+
+    template <typename T, int SZ>
+    struct StringMaker<T[SZ]> {
+        static std::string convert(T const(&arr)[SZ]) {
+            return rangeToString(arr);
+        }
+    };
+
+} // namespace Catch
+
+// Separate std::chrono::duration specialization
+#if defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
+#include <ctime>
+#include <ratio>
+#include <chrono>
+
+namespace Catch {
+
+template <class Ratio>
+struct ratio_string {
+    static std::string symbol();
+};
+
+template <class Ratio>
+std::string ratio_string<Ratio>::symbol() {
+    Catch::ReusableStringStream rss;
+    rss << '[' << Ratio::num << '/'
+        << Ratio::den << ']';
+    return rss.str();
+}
+template <>
+struct ratio_string<std::atto> {
+    static std::string symbol();
+};
+template <>
+struct ratio_string<std::femto> {
+    static std::string symbol();
+};
+template <>
+struct ratio_string<std::pico> {
+    static std::string symbol();
+};
+template <>
+struct ratio_string<std::nano> {
+    static std::string symbol();
+};
+template <>
+struct ratio_string<std::micro> {
+    static std::string symbol();
+};
+template <>
+struct ratio_string<std::milli> {
+    static std::string symbol();
+};
+
+    ////////////
+    // std::chrono::duration specializations
+    template<typename Value, typename Ratio>
+    struct StringMaker<std::chrono::duration<Value, Ratio>> {
+        static std::string convert(std::chrono::duration<Value, Ratio> const& duration) {
+            ReusableStringStream rss;
+            rss << duration.count() << ' ' << ratio_string<Ratio>::symbol() << 's';
+            return rss.str();
+        }
+    };
+    template<typename Value>
+    struct StringMaker<std::chrono::duration<Value, std::ratio<1>>> {
+        static std::string convert(std::chrono::duration<Value, std::ratio<1>> const& duration) {
+            ReusableStringStream rss;
+            rss << duration.count() << " s";
+            return rss.str();
+        }
+    };
+    template<typename Value>
+    struct StringMaker<std::chrono::duration<Value, std::ratio<60>>> {
+        static std::string convert(std::chrono::duration<Value, std::ratio<60>> const& duration) {
+            ReusableStringStream rss;
+            rss << duration.count() << " m";
+            return rss.str();
+        }
+    };
+    template<typename Value>
+    struct StringMaker<std::chrono::duration<Value, std::ratio<3600>>> {
+        static std::string convert(std::chrono::duration<Value, std::ratio<3600>> const& duration) {
+            ReusableStringStream rss;
+            rss << duration.count() << " h";
+            return rss.str();
+        }
+    };
+
+    ////////////
+    // std::chrono::time_point specialization
+    // Generic time_point cannot be specialized, only std::chrono::time_point<system_clock>
+    template<typename Clock, typename Duration>
+    struct StringMaker<std::chrono::time_point<Clock, Duration>> {
+        static std::string convert(std::chrono::time_point<Clock, Duration> const& time_point) {
+            return ::Catch::Detail::stringify(time_point.time_since_epoch()) + " since epoch";
+        }
+    };
+    // std::chrono::time_point<system_clock> specialization
+    template<typename Duration>
+    struct StringMaker<std::chrono::time_point<std::chrono::system_clock, Duration>> {
+        static std::string convert(std::chrono::time_point<std::chrono::system_clock, Duration> const& time_point) {
+            auto converted = std::chrono::system_clock::to_time_t(time_point);
+
+#ifdef _MSC_VER
+            std::tm timeInfo = {};
+            gmtime_s(&timeInfo, &converted);
+#else
+            std::tm* timeInfo = std::gmtime(&converted);
+#endif
+
+            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
+            char timeStamp[timeStampSize];
+            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
+
+#ifdef _MSC_VER
+            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
+#else
+            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
+#endif
+            return std::string(timeStamp);
+        }
+    };
+}
+#endif // CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
+
+#define INTERNAL_CATCH_REGISTER_ENUM( enumName, ... ) \
+namespace Catch { \
+    template<> struct StringMaker<enumName> { \
+        static std::string convert( enumName value ) { \
+            static const auto& enumInfo = ::Catch::getMutableRegistryHub().getMutableEnumValuesRegistry().registerEnum( #enumName, #__VA_ARGS__, { __VA_ARGS__ } ); \
+            return static_cast<std::string>(enumInfo.lookup( static_cast<int>( value ) )); \
+        } \
+    }; \
+}
+
+#define CATCH_REGISTER_ENUM( enumName, ... ) INTERNAL_CATCH_REGISTER_ENUM( enumName, __VA_ARGS__ )
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+// end catch_tostring.h
+#include <iosfwd>
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
+#pragma warning(disable:4018) // more "signed/unsigned mismatch"
+#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
+#pragma warning(disable:4180) // qualifier applied to function type has no meaning
+#pragma warning(disable:4800) // Forcing result to true or false
+#endif
+
+namespace Catch {
+
+    struct ITransientExpression {
+        auto isBinaryExpression() const -> bool { return m_isBinaryExpression; }
+        auto getResult() const -> bool { return m_result; }
+        virtual void streamReconstructedExpression( std::ostream &os ) const = 0;
+
+        ITransientExpression( bool isBinaryExpression, bool result )
+        :   m_isBinaryExpression( isBinaryExpression ),
+            m_result( result )
+        {}
+
+        // We don't actually need a virtual destructor, but many static analysers
+        // complain if it's not here :-(
+        virtual ~ITransientExpression();
+
+        bool m_isBinaryExpression;
+        bool m_result;
+
+    };
+
+    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs );
+
+    template<typename LhsT, typename RhsT>
+    class BinaryExpr  : public ITransientExpression {
+        LhsT m_lhs;
+        StringRef m_op;
+        RhsT m_rhs;
+
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            formatReconstructedExpression
+                    ( os, Catch::Detail::stringify( m_lhs ), m_op, Catch::Detail::stringify( m_rhs ) );
+        }
+
+    public:
+        BinaryExpr( bool comparisonResult, LhsT lhs, StringRef op, RhsT rhs )
+        :   ITransientExpression{ true, comparisonResult },
+            m_lhs( lhs ),
+            m_op( op ),
+            m_rhs( rhs )
+        {}
+
+        template<typename T>
+        auto operator && ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator || ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator == ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator != ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator > ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator < ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator >= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename T>
+        auto operator <= ( T ) const -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<T>::value,
+            "chained comparisons are not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+    };
+
+    template<typename LhsT>
+    class UnaryExpr : public ITransientExpression {
+        LhsT m_lhs;
+
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            os << Catch::Detail::stringify( m_lhs );
+        }
+
+    public:
+        explicit UnaryExpr( LhsT lhs )
+        :   ITransientExpression{ false, static_cast<bool>(lhs) },
+            m_lhs( lhs )
+        {}
+    };
+
+    // Specialised comparison functions to handle equality comparisons between ints and pointers (NULL deduces as an int)
+    template<typename LhsT, typename RhsT>
+    auto compareEqual( LhsT const& lhs, RhsT const& rhs ) -> bool { return static_cast<bool>(lhs == rhs); }
+    template<typename T>
+    auto compareEqual( T* const& lhs, int rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareEqual( T* const& lhs, long rhs ) -> bool { return lhs == reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
+    template<typename T>
+    auto compareEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) == rhs; }
+
+    template<typename LhsT, typename RhsT>
+    auto compareNotEqual( LhsT const& lhs, RhsT&& rhs ) -> bool { return static_cast<bool>(lhs != rhs); }
+    template<typename T>
+    auto compareNotEqual( T* const& lhs, int rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareNotEqual( T* const& lhs, long rhs ) -> bool { return lhs != reinterpret_cast<void const*>( rhs ); }
+    template<typename T>
+    auto compareNotEqual( int lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
+    template<typename T>
+    auto compareNotEqual( long lhs, T* const& rhs ) -> bool { return reinterpret_cast<void const*>( lhs ) != rhs; }
+
+    template<typename LhsT>
+    class ExprLhs {
+        LhsT m_lhs;
+    public:
+        explicit ExprLhs( LhsT lhs ) : m_lhs( lhs ) {}
+
+        template<typename RhsT>
+        auto operator == ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { compareEqual( m_lhs, rhs ), m_lhs, "==", rhs };
+        }
+        auto operator == ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
+            return { m_lhs == rhs, m_lhs, "==", rhs };
+        }
+
+        template<typename RhsT>
+        auto operator != ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { compareNotEqual( m_lhs, rhs ), m_lhs, "!=", rhs };
+        }
+        auto operator != ( bool rhs ) -> BinaryExpr<LhsT, bool> const {
+            return { m_lhs != rhs, m_lhs, "!=", rhs };
+        }
+
+        template<typename RhsT>
+        auto operator > ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs > rhs), m_lhs, ">", rhs };
+        }
+        template<typename RhsT>
+        auto operator < ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs < rhs), m_lhs, "<", rhs };
+        }
+        template<typename RhsT>
+        auto operator >= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs >= rhs), m_lhs, ">=", rhs };
+        }
+        template<typename RhsT>
+        auto operator <= ( RhsT const& rhs ) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs <= rhs), m_lhs, "<=", rhs };
+        }
+        template <typename RhsT>
+        auto operator | (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs | rhs), m_lhs, "|", rhs };
+        }
+        template <typename RhsT>
+        auto operator & (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs & rhs), m_lhs, "&", rhs };
+        }
+        template <typename RhsT>
+        auto operator ^ (RhsT const& rhs) -> BinaryExpr<LhsT, RhsT const&> const {
+            return { static_cast<bool>(m_lhs ^ rhs), m_lhs, "^", rhs };
+        }
+
+        template<typename RhsT>
+        auto operator && ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<RhsT>::value,
+            "operator&& is not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        template<typename RhsT>
+        auto operator || ( RhsT const& ) -> BinaryExpr<LhsT, RhsT const&> const {
+            static_assert(always_false<RhsT>::value,
+            "operator|| is not supported inside assertions, "
+            "wrap the expression inside parentheses, or decompose it");
+        }
+
+        auto makeUnaryExpr() const -> UnaryExpr<LhsT> {
+            return UnaryExpr<LhsT>{ m_lhs };
+        }
+    };
+
+    void handleExpression( ITransientExpression const& expr );
+
+    template<typename T>
+    void handleExpression( ExprLhs<T> const& expr ) {
+        handleExpression( expr.makeUnaryExpr() );
+    }
+
+    struct Decomposer {
+        template<typename T>
+        auto operator <= ( T const& lhs ) -> ExprLhs<T const&> {
+            return ExprLhs<T const&>{ lhs };
+        }
+
+        auto operator <=( bool value ) -> ExprLhs<bool> {
+            return ExprLhs<bool>{ value };
+        }
+    };
+
+} // end namespace Catch
+
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+// end catch_decomposer.h
+// start catch_interfaces_capture.h
+
+#include <string>
+#include <chrono>
+
+namespace Catch {
+
+    class AssertionResult;
+    struct AssertionInfo;
+    struct SectionInfo;
+    struct SectionEndInfo;
+    struct MessageInfo;
+    struct MessageBuilder;
+    struct Counts;
+    struct AssertionReaction;
+    struct SourceLineInfo;
+
+    struct ITransientExpression;
+    struct IGeneratorTracker;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+    struct BenchmarkInfo;
+    template <typename Duration = std::chrono::duration<double, std::nano>>
+    struct BenchmarkStats;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    struct IResultCapture {
+
+        virtual ~IResultCapture();
+
+        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
+                                        Counts& assertions ) = 0;
+        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
+        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
+
+        virtual auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& = 0;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        virtual void benchmarkPreparing( std::string const& name ) = 0;
+        virtual void benchmarkStarting( BenchmarkInfo const& info ) = 0;
+        virtual void benchmarkEnded( BenchmarkStats<> const& stats ) = 0;
+        virtual void benchmarkFailed( std::string const& error ) = 0;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
+        virtual void popScopedMessage( MessageInfo const& message ) = 0;
+
+        virtual void emplaceUnscopedMessage( MessageBuilder const& builder ) = 0;
+
+        virtual void handleFatalErrorCondition( StringRef message ) = 0;
+
+        virtual void handleExpr
+                (   AssertionInfo const& info,
+                    ITransientExpression const& expr,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleMessage
+                (   AssertionInfo const& info,
+                    ResultWas::OfType resultType,
+                    StringRef const& message,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleUnexpectedExceptionNotThrown
+                (   AssertionInfo const& info,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleUnexpectedInflightException
+                (   AssertionInfo const& info,
+                    std::string const& message,
+                    AssertionReaction& reaction ) = 0;
+        virtual void handleIncomplete
+                (   AssertionInfo const& info ) = 0;
+        virtual void handleNonExpr
+                (   AssertionInfo const &info,
+                    ResultWas::OfType resultType,
+                    AssertionReaction &reaction ) = 0;
+
+        virtual bool lastAssertionPassed() = 0;
+        virtual void assertionPassed() = 0;
+
+        // Deprecated, do not use:
+        virtual std::string getCurrentTestName() const = 0;
+        virtual const AssertionResult* getLastResult() const = 0;
+        virtual void exceptionEarlyReported() = 0;
+    };
+
+    IResultCapture& getResultCapture();
+}
+
+// end catch_interfaces_capture.h
+namespace Catch {
+
+    struct TestFailureException{};
+    struct AssertionResultData;
+    struct IResultCapture;
+    class RunContext;
+
+    class LazyExpression {
+        friend class AssertionHandler;
+        friend struct AssertionStats;
+        friend class RunContext;
+
+        ITransientExpression const* m_transientExpression = nullptr;
+        bool m_isNegated;
+    public:
+        LazyExpression( bool isNegated );
+        LazyExpression( LazyExpression const& other );
+        LazyExpression& operator = ( LazyExpression const& ) = delete;
+
+        explicit operator bool() const;
+
+        friend auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream&;
+    };
+
+    struct AssertionReaction {
+        bool shouldDebugBreak = false;
+        bool shouldThrow = false;
+    };
+
+    class AssertionHandler {
+        AssertionInfo m_assertionInfo;
+        AssertionReaction m_reaction;
+        bool m_completed = false;
+        IResultCapture& m_resultCapture;
+
+    public:
+        AssertionHandler
+            (   StringRef const& macroName,
+                SourceLineInfo const& lineInfo,
+                StringRef capturedExpression,
+                ResultDisposition::Flags resultDisposition );
+        ~AssertionHandler() {
+            if ( !m_completed ) {
+                m_resultCapture.handleIncomplete( m_assertionInfo );
+            }
+        }
+
+        template<typename T>
+        void handleExpr( ExprLhs<T> const& expr ) {
+            handleExpr( expr.makeUnaryExpr() );
+        }
+        void handleExpr( ITransientExpression const& expr );
+
+        void handleMessage(ResultWas::OfType resultType, StringRef const& message);
+
+        void handleExceptionThrownAsExpected();
+        void handleUnexpectedExceptionNotThrown();
+        void handleExceptionNotThrownAsExpected();
+        void handleThrowingCallSkipped();
+        void handleUnexpectedInflightException();
+
+        void complete();
+        void setCompleted();
+
+        // query
+        auto allowThrows() const -> bool;
+    };
+
+    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString );
+
+} // namespace Catch
+
+// end catch_assertionhandler.h
+// start catch_message.h
+
+#include <string>
+#include <vector>
+
+namespace Catch {
+
+    struct MessageInfo {
+        MessageInfo(    StringRef const& _macroName,
+                        SourceLineInfo const& _lineInfo,
+                        ResultWas::OfType _type );
+
+        StringRef macroName;
+        std::string message;
+        SourceLineInfo lineInfo;
+        ResultWas::OfType type;
+        unsigned int sequence;
+
+        bool operator == ( MessageInfo const& other ) const;
+        bool operator < ( MessageInfo const& other ) const;
+    private:
+        static unsigned int globalCount;
+    };
+
+    struct MessageStream {
+
+        template<typename T>
+        MessageStream& operator << ( T const& value ) {
+            m_stream << value;
+            return *this;
+        }
+
+        ReusableStringStream m_stream;
+    };
+
+    struct MessageBuilder : MessageStream {
+        MessageBuilder( StringRef const& macroName,
+                        SourceLineInfo const& lineInfo,
+                        ResultWas::OfType type );
+
+        template<typename T>
+        MessageBuilder& operator << ( T const& value ) {
+            m_stream << value;
+            return *this;
+        }
+
+        MessageInfo m_info;
+    };
+
+    class ScopedMessage {
+    public:
+        explicit ScopedMessage( MessageBuilder const& builder );
+        ScopedMessage( ScopedMessage& duplicate ) = delete;
+        ScopedMessage( ScopedMessage&& old );
+        ~ScopedMessage();
+
+        MessageInfo m_info;
+        bool m_moved;
+    };
+
+    class Capturer {
+        std::vector<MessageInfo> m_messages;
+        IResultCapture& m_resultCapture = getResultCapture();
+        size_t m_captured = 0;
+    public:
+        Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names );
+        ~Capturer();
+
+        void captureValue( size_t index, std::string const& value );
+
+        template<typename T>
+        void captureValues( size_t index, T const& value ) {
+            captureValue( index, Catch::Detail::stringify( value ) );
+        }
+
+        template<typename T, typename... Ts>
+        void captureValues( size_t index, T const& value, Ts const&... values ) {
+            captureValue( index, Catch::Detail::stringify(value) );
+            captureValues( index+1, values... );
+        }
+    };
+
+} // end namespace Catch
+
+// end catch_message.h
+#if !defined(CATCH_CONFIG_DISABLE)
+
+#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
+  #define CATCH_INTERNAL_STRINGIFY(...) #__VA_ARGS__
+#else
+  #define CATCH_INTERNAL_STRINGIFY(...) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
+#endif
+
+#if defined(CATCH_CONFIG_FAST_COMPILE) || defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+
+///////////////////////////////////////////////////////////////////////////////
+// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
+// macros.
+#define INTERNAL_CATCH_TRY
+#define INTERNAL_CATCH_CATCH( capturer )
+
+#else // CATCH_CONFIG_FAST_COMPILE
+
+#define INTERNAL_CATCH_TRY try
+#define INTERNAL_CATCH_CATCH( handler ) catch(...) { handler.handleUnexpectedInflightException(); }
+
+#endif
+
+#define INTERNAL_CATCH_REACT( handler ) handler.complete();
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_TEST( macroName, resultDisposition, ... ) \
+    do { \
+        CATCH_INTERNAL_IGNORE_BUT_WARN(__VA_ARGS__); \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
+        INTERNAL_CATCH_TRY { \
+            CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
+            catchAssertionHandler.handleExpr( Catch::Decomposer() <= __VA_ARGS__ ); \
+            CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( (void)0, (false) && static_cast<bool>( !!(__VA_ARGS__) ) )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_IF( macroName, resultDisposition, ... ) \
+    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
+    if( Catch::getResultCapture().lastAssertionPassed() )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, ... ) \
+    INTERNAL_CATCH_TEST( macroName, resultDisposition, __VA_ARGS__ ); \
+    if( !Catch::getResultCapture().lastAssertionPassed() )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, ... ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition ); \
+        try { \
+            static_cast<void>(__VA_ARGS__); \
+            catchAssertionHandler.handleExceptionNotThrownAsExpected(); \
+        } \
+        catch( ... ) { \
+            catchAssertionHandler.handleUnexpectedInflightException(); \
+        } \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, ... ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__), resultDisposition); \
+        if( catchAssertionHandler.allowThrows() ) \
+            try { \
+                static_cast<void>(__VA_ARGS__); \
+                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
+            } \
+            catch( ... ) { \
+                catchAssertionHandler.handleExceptionThrownAsExpected(); \
+            } \
+        else \
+            catchAssertionHandler.handleThrowingCallSkipped(); \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
+        if( catchAssertionHandler.allowThrows() ) \
+            try { \
+                static_cast<void>(expr); \
+                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
+            } \
+            catch( exceptionType const& ) { \
+                catchAssertionHandler.handleExceptionThrownAsExpected(); \
+            } \
+            catch( ... ) { \
+                catchAssertionHandler.handleUnexpectedInflightException(); \
+            } \
+        else \
+            catchAssertionHandler.handleThrowingCallSkipped(); \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::StringRef(), resultDisposition ); \
+        catchAssertionHandler.handleMessage( messageType, ( Catch::MessageStream() << __VA_ARGS__ + ::Catch::StreamEndStop() ).m_stream.str() ); \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_CAPTURE( varName, macroName, ... ) \
+    auto varName = Catch::Capturer( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info, #__VA_ARGS__ ); \
+    varName.captureValues( 0, __VA_ARGS__ )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_INFO( macroName, log ) \
+    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage )( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log );
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_UNSCOPED_INFO( macroName, log ) \
+    Catch::getResultCapture().emplaceUnscopedMessage( Catch::MessageBuilder( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log )
+
+///////////////////////////////////////////////////////////////////////////////
+// Although this is matcher-based, it can be used with just a string
+#define INTERNAL_CATCH_THROWS_STR_MATCHES( macroName, resultDisposition, matcher, ... ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
+        if( catchAssertionHandler.allowThrows() ) \
+            try { \
+                static_cast<void>(__VA_ARGS__); \
+                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
+            } \
+            catch( ... ) { \
+                Catch::handleExceptionMatchExpr( catchAssertionHandler, matcher, #matcher##_catch_sr ); \
+            } \
+        else \
+            catchAssertionHandler.handleThrowingCallSkipped(); \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+#endif // CATCH_CONFIG_DISABLE
+
+// end catch_capture.hpp
+// start catch_section.h
+
+// start catch_section_info.h
+
+// start catch_totals.h
+
+#include <cstddef>
+
+namespace Catch {
+
+    struct Counts {
+        Counts operator - ( Counts const& other ) const;
+        Counts& operator += ( Counts const& other );
+
+        std::size_t total() const;
+        bool allPassed() const;
+        bool allOk() const;
+
+        std::size_t passed = 0;
+        std::size_t failed = 0;
+        std::size_t failedButOk = 0;
+    };
+
+    struct Totals {
+
+        Totals operator - ( Totals const& other ) const;
+        Totals& operator += ( Totals const& other );
+
+        Totals delta( Totals const& prevTotals ) const;
+
+        int error = 0;
+        Counts assertions;
+        Counts testCases;
+    };
+}
+
+// end catch_totals.h
+#include <string>
+
+namespace Catch {
+
+    struct SectionInfo {
+        SectionInfo
+            (   SourceLineInfo const& _lineInfo,
+                std::string const& _name );
+
+        // Deprecated
+        SectionInfo
+            (   SourceLineInfo const& _lineInfo,
+                std::string const& _name,
+                std::string const& ) : SectionInfo( _lineInfo, _name ) {}
+
+        std::string name;
+        std::string description; // !Deprecated: this will always be empty
+        SourceLineInfo lineInfo;
+    };
+
+    struct SectionEndInfo {
+        SectionInfo sectionInfo;
+        Counts prevAssertions;
+        double durationInSeconds;
+    };
+
+} // end namespace Catch
+
+// end catch_section_info.h
+// start catch_timer.h
+
+#include <cstdint>
+
+namespace Catch {
+
+    auto getCurrentNanosecondsSinceEpoch() -> uint64_t;
+    auto getEstimatedClockResolution() -> uint64_t;
+
+    class Timer {
+        uint64_t m_nanoseconds = 0;
+    public:
+        void start();
+        auto getElapsedNanoseconds() const -> uint64_t;
+        auto getElapsedMicroseconds() const -> uint64_t;
+        auto getElapsedMilliseconds() const -> unsigned int;
+        auto getElapsedSeconds() const -> double;
+    };
+
+} // namespace Catch
+
+// end catch_timer.h
+#include <string>
+
+namespace Catch {
+
+    class Section : NonCopyable {
+    public:
+        Section( SectionInfo const& info );
+        ~Section();
+
+        // This indicates whether the section should be executed or not
+        explicit operator bool() const;
+
+    private:
+        SectionInfo m_info;
+
+        std::string m_name;
+        Counts m_assertions;
+        bool m_sectionIncluded;
+        Timer m_timer;
+    };
+
+} // end namespace Catch
+
+#define INTERNAL_CATCH_SECTION( ... ) \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
+    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) ) \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+#define INTERNAL_CATCH_DYNAMIC_SECTION( ... ) \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+    CATCH_INTERNAL_SUPPRESS_UNUSED_WARNINGS \
+    if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, (Catch::ReusableStringStream() << __VA_ARGS__).str() ) ) \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+// end catch_section.h
+// start catch_interfaces_exception.h
+
+// start catch_interfaces_registry_hub.h
+
+#include <string>
+#include <memory>
+
+namespace Catch {
+
+    class TestCase;
+    struct ITestCaseRegistry;
+    struct IExceptionTranslatorRegistry;
+    struct IExceptionTranslator;
+    struct IReporterRegistry;
+    struct IReporterFactory;
+    struct ITagAliasRegistry;
+    struct IMutableEnumValuesRegistry;
+
+    class StartupExceptionRegistry;
+
+    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
+
+    struct IRegistryHub {
+        virtual ~IRegistryHub();
+
+        virtual IReporterRegistry const& getReporterRegistry() const = 0;
+        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
+        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
+        virtual IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const = 0;
+
+        virtual StartupExceptionRegistry const& getStartupExceptionRegistry() const = 0;
+    };
+
+    struct IMutableRegistryHub {
+        virtual ~IMutableRegistryHub();
+        virtual void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) = 0;
+        virtual void registerListener( IReporterFactoryPtr const& factory ) = 0;
+        virtual void registerTest( TestCase const& testInfo ) = 0;
+        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
+        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
+        virtual void registerStartupException() noexcept = 0;
+        virtual IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() = 0;
+    };
+
+    IRegistryHub const& getRegistryHub();
+    IMutableRegistryHub& getMutableRegistryHub();
+    void cleanUp();
+    std::string translateActiveException();
+
+}
+
+// end catch_interfaces_registry_hub.h
+#if defined(CATCH_CONFIG_DISABLE)
+    #define INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( translatorName, signature) \
+        static std::string translatorName( signature )
+#endif
+
+#include <exception>
+#include <string>
+#include <vector>
+
+namespace Catch {
+    using exceptionTranslateFunction = std::string(*)();
+
+    struct IExceptionTranslator;
+    using ExceptionTranslators = std::vector<std::unique_ptr<IExceptionTranslator const>>;
+
+    struct IExceptionTranslator {
+        virtual ~IExceptionTranslator();
+        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
+    };
+
+    struct IExceptionTranslatorRegistry {
+        virtual ~IExceptionTranslatorRegistry();
+
+        virtual std::string translateActiveException() const = 0;
+    };
+
+    class ExceptionTranslatorRegistrar {
+        template<typename T>
+        class ExceptionTranslator : public IExceptionTranslator {
+        public:
+
+            ExceptionTranslator( std::string(*translateFunction)( T& ) )
+            : m_translateFunction( translateFunction )
+            {}
+
+            std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const override {
+#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+                return "";
+#else
+                try {
+                    if( it == itEnd )
+                        std::rethrow_exception(std::current_exception());
+                    else
+                        return (*it)->translate( it+1, itEnd );
+                }
+                catch( T& ex ) {
+                    return m_translateFunction( ex );
+                }
+#endif
+            }
+
+        protected:
+            std::string(*m_translateFunction)( T& );
+        };
+
+    public:
+        template<typename T>
+        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
+            getMutableRegistryHub().registerTranslator
+                ( new ExceptionTranslator<T>( translateFunction ) );
+        }
+    };
+}
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
+    static std::string translatorName( signature ); \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION \
+    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS \
+    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); } \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION \
+    static std::string translatorName( signature )
+
+#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
+
+// end catch_interfaces_exception.h
+// start catch_approx.h
+
+#include <type_traits>
+
+namespace Catch {
+namespace Detail {
+
+    class Approx {
+    private:
+        bool equalityComparisonImpl(double other) const;
+        // Validates the new margin (margin >= 0)
+        // out-of-line to avoid including stdexcept in the header
+        void setMargin(double margin);
+        // Validates the new epsilon (0 < epsilon < 1)
+        // out-of-line to avoid including stdexcept in the header
+        void setEpsilon(double epsilon);
+
+    public:
+        explicit Approx ( double value );
+
+        static Approx custom();
+
+        Approx operator-() const;
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx operator()( T const& value ) {
+            Approx approx( static_cast<double>(value) );
+            approx.m_epsilon = m_epsilon;
+            approx.m_margin = m_margin;
+            approx.m_scale = m_scale;
+            return approx;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        explicit Approx( T const& value ): Approx(static_cast<double>(value))
+        {}
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator == ( const T& lhs, Approx const& rhs ) {
+            auto lhs_v = static_cast<double>(lhs);
+            return rhs.equalityComparisonImpl(lhs_v);
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator == ( Approx const& lhs, const T& rhs ) {
+            return operator==( rhs, lhs );
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator != ( T const& lhs, Approx const& rhs ) {
+            return !operator==( lhs, rhs );
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator != ( Approx const& lhs, T const& rhs ) {
+            return !operator==( rhs, lhs );
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator <= ( T const& lhs, Approx const& rhs ) {
+            return static_cast<double>(lhs) < rhs.m_value || lhs == rhs;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator <= ( Approx const& lhs, T const& rhs ) {
+            return lhs.m_value < static_cast<double>(rhs) || lhs == rhs;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator >= ( T const& lhs, Approx const& rhs ) {
+            return static_cast<double>(lhs) > rhs.m_value || lhs == rhs;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        friend bool operator >= ( Approx const& lhs, T const& rhs ) {
+            return lhs.m_value > static_cast<double>(rhs) || lhs == rhs;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& epsilon( T const& newEpsilon ) {
+            double epsilonAsDouble = static_cast<double>(newEpsilon);
+            setEpsilon(epsilonAsDouble);
+            return *this;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& margin( T const& newMargin ) {
+            double marginAsDouble = static_cast<double>(newMargin);
+            setMargin(marginAsDouble);
+            return *this;
+        }
+
+        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+        Approx& scale( T const& newScale ) {
+            m_scale = static_cast<double>(newScale);
+            return *this;
+        }
+
+        std::string toString() const;
+
+    private:
+        double m_epsilon;
+        double m_margin;
+        double m_scale;
+        double m_value;
+    };
+} // end namespace Detail
+
+namespace literals {
+    Detail::Approx operator "" _a(long double val);
+    Detail::Approx operator "" _a(unsigned long long val);
+} // end namespace literals
+
+template<>
+struct StringMaker<Catch::Detail::Approx> {
+    static std::string convert(Catch::Detail::Approx const& value);
+};
+
+} // end namespace Catch
+
+// end catch_approx.h
+// start catch_string_manip.h
+
+#include <string>
+#include <iosfwd>
+#include <vector>
+
+namespace Catch {
+
+    bool startsWith( std::string const& s, std::string const& prefix );
+    bool startsWith( std::string const& s, char prefix );
+    bool endsWith( std::string const& s, std::string const& suffix );
+    bool endsWith( std::string const& s, char suffix );
+    bool contains( std::string const& s, std::string const& infix );
+    void toLowerInPlace( std::string& s );
+    std::string toLower( std::string const& s );
+    //! Returns a new string without whitespace at the start/end
+    std::string trim( std::string const& str );
+    //! Returns a substring of the original ref without whitespace. Beware lifetimes!
+    StringRef trim(StringRef ref);
+
+    // !!! Be aware, returns refs into original string - make sure original string outlives them
+    std::vector<StringRef> splitStringRef( StringRef str, char delimiter );
+    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
+
+    struct pluralise {
+        pluralise( std::size_t count, std::string const& label );
+
+        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
+
+        std::size_t m_count;
+        std::string m_label;
+    };
+}
+
+// end catch_string_manip.h
+#ifndef CATCH_CONFIG_DISABLE_MATCHERS
+// start catch_capture_matchers.h
+
+// start catch_matchers.h
+
+#include <string>
+#include <vector>
+
+namespace Catch {
+namespace Matchers {
+    namespace Impl {
+
+        template<typename ArgT> struct MatchAllOf;
+        template<typename ArgT> struct MatchAnyOf;
+        template<typename ArgT> struct MatchNotOf;
+
+        class MatcherUntypedBase {
+        public:
+            MatcherUntypedBase() = default;
+            MatcherUntypedBase ( MatcherUntypedBase const& ) = default;
+            MatcherUntypedBase& operator = ( MatcherUntypedBase const& ) = delete;
+            std::string toString() const;
+
+        protected:
+            virtual ~MatcherUntypedBase();
+            virtual std::string describe() const = 0;
+            mutable std::string m_cachedToString;
+        };
+
+#ifdef __clang__
+#    pragma clang diagnostic push
+#    pragma clang diagnostic ignored "-Wnon-virtual-dtor"
+#endif
+
+        template<typename ObjectT>
+        struct MatcherMethod {
+            virtual bool match( ObjectT const& arg ) const = 0;
+        };
+
+#if defined(__OBJC__)
+        // Hack to fix Catch GH issue #1661. Could use id for generic Object support.
+        // use of const for Object pointers is very uncommon and under ARC it causes some kind of signature mismatch that breaks compilation
+        template<>
+        struct MatcherMethod<NSString*> {
+            virtual bool match( NSString* arg ) const = 0;
+        };
+#endif
+
+#ifdef __clang__
+#    pragma clang diagnostic pop
+#endif
+
+        template<typename T>
+        struct MatcherBase : MatcherUntypedBase, MatcherMethod<T> {
+
+            MatchAllOf<T> operator && ( MatcherBase const& other ) const;
+            MatchAnyOf<T> operator || ( MatcherBase const& other ) const;
+            MatchNotOf<T> operator ! () const;
+        };
+
+        template<typename ArgT>
+        struct MatchAllOf : MatcherBase<ArgT> {
+            bool match( ArgT const& arg ) const override {
+                for( auto matcher : m_matchers ) {
+                    if (!matcher->match(arg))
+                        return false;
+                }
+                return true;
+            }
+            std::string describe() const override {
+                std::string description;
+                description.reserve( 4 + m_matchers.size()*32 );
+                description += "( ";
+                bool first = true;
+                for( auto matcher : m_matchers ) {
+                    if( first )
+                        first = false;
+                    else
+                        description += " and ";
+                    description += matcher->toString();
+                }
+                description += " )";
+                return description;
+            }
+
+            MatchAllOf<ArgT> operator && ( MatcherBase<ArgT> const& other ) {
+                auto copy(*this);
+                copy.m_matchers.push_back( &other );
+                return copy;
+            }
+
+            std::vector<MatcherBase<ArgT> const*> m_matchers;
+        };
+        template<typename ArgT>
+        struct MatchAnyOf : MatcherBase<ArgT> {
+
+            bool match( ArgT const& arg ) const override {
+                for( auto matcher : m_matchers ) {
+                    if (matcher->match(arg))
+                        return true;
+                }
+                return false;
+            }
+            std::string describe() const override {
+                std::string description;
+                description.reserve( 4 + m_matchers.size()*32 );
+                description += "( ";
+                bool first = true;
+                for( auto matcher : m_matchers ) {
+                    if( first )
+                        first = false;
+                    else
+                        description += " or ";
+                    description += matcher->toString();
+                }
+                description += " )";
+                return description;
+            }
+
+            MatchAnyOf<ArgT> operator || ( MatcherBase<ArgT> const& other ) {
+                auto copy(*this);
+                copy.m_matchers.push_back( &other );
+                return copy;
+            }
+
+            std::vector<MatcherBase<ArgT> const*> m_matchers;
+        };
+
+        template<typename ArgT>
+        struct MatchNotOf : MatcherBase<ArgT> {
+
+            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
+
+            bool match( ArgT const& arg ) const override {
+                return !m_underlyingMatcher.match( arg );
+            }
+
+            std::string describe() const override {
+                return "not " + m_underlyingMatcher.toString();
+            }
+            MatcherBase<ArgT> const& m_underlyingMatcher;
+        };
+
+        template<typename T>
+        MatchAllOf<T> MatcherBase<T>::operator && ( MatcherBase const& other ) const {
+            return MatchAllOf<T>() && *this && other;
+        }
+        template<typename T>
+        MatchAnyOf<T> MatcherBase<T>::operator || ( MatcherBase const& other ) const {
+            return MatchAnyOf<T>() || *this || other;
+        }
+        template<typename T>
+        MatchNotOf<T> MatcherBase<T>::operator ! () const {
+            return MatchNotOf<T>( *this );
+        }
+
+    } // namespace Impl
+
+} // namespace Matchers
+
+using namespace Matchers;
+using Matchers::Impl::MatcherBase;
+
+} // namespace Catch
+
+// end catch_matchers.h
+// start catch_matchers_exception.hpp
+
+namespace Catch {
+namespace Matchers {
+namespace Exception {
+
+class ExceptionMessageMatcher : public MatcherBase<std::exception> {
+    std::string m_message;
+public:
+
+    ExceptionMessageMatcher(std::string const& message):
+        m_message(message)
+    {}
+
+    bool match(std::exception const& ex) const override;
+
+    std::string describe() const override;
+};
+
+} // namespace Exception
+
+Exception::ExceptionMessageMatcher Message(std::string const& message);
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_exception.hpp
+// start catch_matchers_floating.h
+
+namespace Catch {
+namespace Matchers {
+
+    namespace Floating {
+
+        enum class FloatingPointKind : uint8_t;
+
+        struct WithinAbsMatcher : MatcherBase<double> {
+            WithinAbsMatcher(double target, double margin);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            double m_margin;
+        };
+
+        struct WithinUlpsMatcher : MatcherBase<double> {
+            WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            uint64_t m_ulps;
+            FloatingPointKind m_type;
+        };
+
+        // Given IEEE-754 format for floats and doubles, we can assume
+        // that float -> double promotion is lossless. Given this, we can
+        // assume that if we do the standard relative comparison of
+        // |lhs - rhs| <= epsilon * max(fabs(lhs), fabs(rhs)), then we get
+        // the same result if we do this for floats, as if we do this for
+        // doubles that were promoted from floats.
+        struct WithinRelMatcher : MatcherBase<double> {
+            WithinRelMatcher(double target, double epsilon);
+            bool match(double const& matchee) const override;
+            std::string describe() const override;
+        private:
+            double m_target;
+            double m_epsilon;
+        };
+
+    } // namespace Floating
+
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
+    Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff);
+    Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff);
+    Floating::WithinAbsMatcher WithinAbs(double target, double margin);
+    Floating::WithinRelMatcher WithinRel(double target, double eps);
+    // defaults epsilon to 100*numeric_limits<double>::epsilon()
+    Floating::WithinRelMatcher WithinRel(double target);
+    Floating::WithinRelMatcher WithinRel(float target, float eps);
+    // defaults epsilon to 100*numeric_limits<float>::epsilon()
+    Floating::WithinRelMatcher WithinRel(float target);
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_floating.h
+// start catch_matchers_generic.hpp
+
+#include <functional>
+#include <string>
+
+namespace Catch {
+namespace Matchers {
+namespace Generic {
+
+namespace Detail {
+    std::string finalizeDescription(const std::string& desc);
+}
+
+template <typename T>
+class PredicateMatcher : public MatcherBase<T> {
+    std::function<bool(T const&)> m_predicate;
+    std::string m_description;
+public:
+
+    PredicateMatcher(std::function<bool(T const&)> const& elem, std::string const& descr)
+        :m_predicate(std::move(elem)),
+        m_description(Detail::finalizeDescription(descr))
+    {}
+
+    bool match( T const& item ) const override {
+        return m_predicate(item);
+    }
+
+    std::string describe() const override {
+        return m_description;
+    }
+};
+
+} // namespace Generic
+
+    // The following functions create the actual matcher objects.
+    // The user has to explicitly specify type to the function, because
+    // inferring std::function<bool(T const&)> is hard (but possible) and
+    // requires a lot of TMP.
+    template<typename T>
+    Generic::PredicateMatcher<T> Predicate(std::function<bool(T const&)> const& predicate, std::string const& description = "") {
+        return Generic::PredicateMatcher<T>(predicate, description);
+    }
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_generic.hpp
+// start catch_matchers_string.h
+
+#include <string>
+
+namespace Catch {
+namespace Matchers {
+
+    namespace StdString {
+
+        struct CasedString
+        {
+            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
+            std::string adjustString( std::string const& str ) const;
+            std::string caseSensitivitySuffix() const;
+
+            CaseSensitive::Choice m_caseSensitivity;
+            std::string m_str;
+        };
+
+        struct StringMatcherBase : MatcherBase<std::string> {
+            StringMatcherBase( std::string const& operation, CasedString const& comparator );
+            std::string describe() const override;
+
+            CasedString m_comparator;
+            std::string m_operation;
+        };
+
+        struct EqualsMatcher : StringMatcherBase {
+            EqualsMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct ContainsMatcher : StringMatcherBase {
+            ContainsMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct StartsWithMatcher : StringMatcherBase {
+            StartsWithMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+        struct EndsWithMatcher : StringMatcherBase {
+            EndsWithMatcher( CasedString const& comparator );
+            bool match( std::string const& source ) const override;
+        };
+
+        struct RegexMatcher : MatcherBase<std::string> {
+            RegexMatcher( std::string regex, CaseSensitive::Choice caseSensitivity );
+            bool match( std::string const& matchee ) const override;
+            std::string describe() const override;
+
+        private:
+            std::string m_regex;
+            CaseSensitive::Choice m_caseSensitivity;
+        };
+
+    } // namespace StdString
+
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
+
+    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+    StdString::RegexMatcher Matches( std::string const& regex, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_string.h
+// start catch_matchers_vector.h
+
+#include <algorithm>
+
+namespace Catch {
+namespace Matchers {
+
+    namespace Vector {
+        template<typename T, typename Alloc>
+        struct ContainsElementMatcher : MatcherBase<std::vector<T, Alloc>> {
+
+            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
+
+            bool match(std::vector<T, Alloc> const &v) const override {
+                for (auto const& el : v) {
+                    if (el == m_comparator) {
+                        return true;
+                    }
+                }
+                return false;
+            }
+
+            std::string describe() const override {
+                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
+            }
+
+            T const& m_comparator;
+        };
+
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct ContainsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+
+            ContainsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
+
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                // !TBD: see note in EqualsMatcher
+                if (m_comparator.size() > v.size())
+                    return false;
+                for (auto const& comparator : m_comparator) {
+                    auto present = false;
+                    for (const auto& el : v) {
+                        if (el == comparator) {
+                            present = true;
+                            break;
+                        }
+                    }
+                    if (!present) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            std::string describe() const override {
+                return "Contains: " + ::Catch::Detail::stringify( m_comparator );
+            }
+
+            std::vector<T, AllocComp> const& m_comparator;
+        };
+
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct EqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+
+            EqualsMatcher(std::vector<T, AllocComp> const &comparator) : m_comparator( comparator ) {}
+
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                // !TBD: This currently works if all elements can be compared using !=
+                // - a more general approach would be via a compare template that defaults
+                // to using !=. but could be specialised for, e.g. std::vector<T, Alloc> etc
+                // - then just call that directly
+                if (m_comparator.size() != v.size())
+                    return false;
+                for (std::size_t i = 0; i < v.size(); ++i)
+                    if (m_comparator[i] != v[i])
+                        return false;
+                return true;
+            }
+            std::string describe() const override {
+                return "Equals: " + ::Catch::Detail::stringify( m_comparator );
+            }
+            std::vector<T, AllocComp> const& m_comparator;
+        };
+
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct ApproxMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+
+            ApproxMatcher(std::vector<T, AllocComp> const& comparator) : m_comparator( comparator ) {}
+
+            bool match(std::vector<T, AllocMatch> const &v) const override {
+                if (m_comparator.size() != v.size())
+                    return false;
+                for (std::size_t i = 0; i < v.size(); ++i)
+                    if (m_comparator[i] != approx(v[i]))
+                        return false;
+                return true;
+            }
+            std::string describe() const override {
+                return "is approx: " + ::Catch::Detail::stringify( m_comparator );
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& epsilon( T const& newEpsilon ) {
+                approx.epsilon(newEpsilon);
+                return *this;
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& margin( T const& newMargin ) {
+                approx.margin(newMargin);
+                return *this;
+            }
+            template <typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
+            ApproxMatcher& scale( T const& newScale ) {
+                approx.scale(newScale);
+                return *this;
+            }
+
+            std::vector<T, AllocComp> const& m_comparator;
+            mutable Catch::Detail::Approx approx = Catch::Detail::Approx::custom();
+        };
+
+        template<typename T, typename AllocComp, typename AllocMatch>
+        struct UnorderedEqualsMatcher : MatcherBase<std::vector<T, AllocMatch>> {
+            UnorderedEqualsMatcher(std::vector<T, AllocComp> const& target) : m_target(target) {}
+            bool match(std::vector<T, AllocMatch> const& vec) const override {
+                // Note: This is a reimplementation of std::is_permutation,
+                //       because I don't want to include <algorithm> inside the common path
+                if (m_target.size() != vec.size()) {
+                    return false;
+                }
+                return std::is_permutation(m_target.begin(), m_target.end(), vec.begin());
+            }
+
+            std::string describe() const override {
+                return "UnorderedEquals: " + ::Catch::Detail::stringify(m_target);
+            }
+        private:
+            std::vector<T, AllocComp> const& m_target;
+        };
+
+    } // namespace Vector
+
+    // The following functions create the actual matcher objects.
+    // This allows the types to be inferred
+
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::ContainsMatcher<T, AllocComp, AllocMatch> Contains( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::ContainsMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
+
+    template<typename T, typename Alloc = std::allocator<T>>
+    Vector::ContainsElementMatcher<T, Alloc> VectorContains( T const& comparator ) {
+        return Vector::ContainsElementMatcher<T, Alloc>( comparator );
+    }
+
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::EqualsMatcher<T, AllocComp, AllocMatch> Equals( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::EqualsMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
+
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::ApproxMatcher<T, AllocComp, AllocMatch> Approx( std::vector<T, AllocComp> const& comparator ) {
+        return Vector::ApproxMatcher<T, AllocComp, AllocMatch>( comparator );
+    }
+
+    template<typename T, typename AllocComp = std::allocator<T>, typename AllocMatch = AllocComp>
+    Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch> UnorderedEquals(std::vector<T, AllocComp> const& target) {
+        return Vector::UnorderedEqualsMatcher<T, AllocComp, AllocMatch>( target );
+    }
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_vector.h
+namespace Catch {
+
+    template<typename ArgT, typename MatcherT>
+    class MatchExpr : public ITransientExpression {
+        ArgT const& m_arg;
+        MatcherT m_matcher;
+        StringRef m_matcherString;
+    public:
+        MatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString )
+        :   ITransientExpression{ true, matcher.match( arg ) },
+            m_arg( arg ),
+            m_matcher( matcher ),
+            m_matcherString( matcherString )
+        {}
+
+        void streamReconstructedExpression( std::ostream &os ) const override {
+            auto matcherAsString = m_matcher.toString();
+            os << Catch::Detail::stringify( m_arg ) << ' ';
+            if( matcherAsString == Detail::unprintableString )
+                os << m_matcherString;
+            else
+                os << matcherAsString;
+        }
+    };
+
+    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
+
+    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  );
+
+    template<typename ArgT, typename MatcherT>
+    auto makeMatchExpr( ArgT const& arg, MatcherT const& matcher, StringRef const& matcherString  ) -> MatchExpr<ArgT, MatcherT> {
+        return MatchExpr<ArgT, MatcherT>( arg, matcher, matcherString );
+    }
+
+} // namespace Catch
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
+        INTERNAL_CATCH_TRY { \
+            catchAssertionHandler.handleExpr( Catch::makeMatchExpr( arg, matcher, #matcher##_catch_sr ) ); \
+        } INTERNAL_CATCH_CATCH( catchAssertionHandler ) \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+///////////////////////////////////////////////////////////////////////////////
+#define INTERNAL_CATCH_THROWS_MATCHES( macroName, exceptionType, resultDisposition, matcher, ... ) \
+    do { \
+        Catch::AssertionHandler catchAssertionHandler( macroName##_catch_sr, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(__VA_ARGS__) ", " CATCH_INTERNAL_STRINGIFY(exceptionType) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
+        if( catchAssertionHandler.allowThrows() ) \
+            try { \
+                static_cast<void>(__VA_ARGS__ ); \
+                catchAssertionHandler.handleUnexpectedExceptionNotThrown(); \
+            } \
+            catch( exceptionType const& ex ) { \
+                catchAssertionHandler.handleExpr( Catch::makeMatchExpr( ex, matcher, #matcher##_catch_sr ) ); \
+            } \
+            catch( ... ) { \
+                catchAssertionHandler.handleUnexpectedInflightException(); \
+            } \
+        else \
+            catchAssertionHandler.handleThrowingCallSkipped(); \
+        INTERNAL_CATCH_REACT( catchAssertionHandler ) \
+    } while( false )
+
+// end catch_capture_matchers.h
+#endif
+// start catch_generators.hpp
+
+// start catch_interfaces_generatortracker.h
+
+
+#include <memory>
+
+namespace Catch {
+
+    namespace Generators {
+        class GeneratorUntypedBase {
+        public:
+            GeneratorUntypedBase() = default;
+            virtual ~GeneratorUntypedBase();
+            // Attempts to move the generator to the next element
+             //
+             // Returns true iff the move succeeded (and a valid element
+             // can be retrieved).
+            virtual bool next() = 0;
+        };
+        using GeneratorBasePtr = std::unique_ptr<GeneratorUntypedBase>;
+
+    } // namespace Generators
+
+    struct IGeneratorTracker {
+        virtual ~IGeneratorTracker();
+        virtual auto hasGenerator() const -> bool = 0;
+        virtual auto getGenerator() const -> Generators::GeneratorBasePtr const& = 0;
+        virtual void setGenerator( Generators::GeneratorBasePtr&& generator ) = 0;
+    };
+
+} // namespace Catch
+
+// end catch_interfaces_generatortracker.h
+// start catch_enforce.h
+
+#include <exception>
+
+namespace Catch {
+#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+    template <typename Ex>
+    [[noreturn]]
+    void throw_exception(Ex const& e) {
+        throw e;
+    }
+#else // ^^ Exceptions are enabled //  Exceptions are disabled vv
+    [[noreturn]]
+    void throw_exception(std::exception const& e);
+#endif
+
+    [[noreturn]]
+    void throw_logic_error(std::string const& msg);
+    [[noreturn]]
+    void throw_domain_error(std::string const& msg);
+    [[noreturn]]
+    void throw_runtime_error(std::string const& msg);
+
+} // namespace Catch;
+
+#define CATCH_MAKE_MSG(...) \
+    (Catch::ReusableStringStream() << __VA_ARGS__).str()
+
+#define CATCH_INTERNAL_ERROR(...) \
+    Catch::throw_logic_error(CATCH_MAKE_MSG( CATCH_INTERNAL_LINEINFO << ": Internal Catch2 error: " << __VA_ARGS__))
+
+#define CATCH_ERROR(...) \
+    Catch::throw_domain_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
+
+#define CATCH_RUNTIME_ERROR(...) \
+    Catch::throw_runtime_error(CATCH_MAKE_MSG( __VA_ARGS__ ))
+
+#define CATCH_ENFORCE( condition, ... ) \
+    do{ if( !(condition) ) CATCH_ERROR( __VA_ARGS__ ); } while(false)
+
+// end catch_enforce.h
+#include <memory>
+#include <vector>
+#include <cassert>
+
+#include <utility>
+#include <exception>
+
+namespace Catch {
+
+class GeneratorException : public std::exception {
+    const char* const m_msg = "";
+
+public:
+    GeneratorException(const char* msg):
+        m_msg(msg)
+    {}
+
+    const char* what() const noexcept override final;
+};
+
+namespace Generators {
+
+    // !TBD move this into its own location?
+    namespace pf{
+        template<typename T, typename... Args>
+        std::unique_ptr<T> make_unique( Args&&... args ) {
+            return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
+        }
+    }
+
+    template<typename T>
+    struct IGenerator : GeneratorUntypedBase {
+        virtual ~IGenerator() = default;
+
+        // Returns the current element of the generator
+        //
+        // \Precondition The generator is either freshly constructed,
+        // or the last call to `next()` returned true
+        virtual T const& get() const = 0;
+        using type = T;
+    };
+
+    template<typename T>
+    class SingleValueGenerator final : public IGenerator<T> {
+        T m_value;
+    public:
+        SingleValueGenerator(T&& value) : m_value(std::move(value)) {}
+
+        T const& get() const override {
+            return m_value;
+        }
+        bool next() override {
+            return false;
+        }
+    };
+
+    template<typename T>
+    class FixedValuesGenerator final : public IGenerator<T> {
+        static_assert(!std::is_same<T, bool>::value,
+            "FixedValuesGenerator does not support bools because of std::vector<bool>"
+            "specialization, use SingleValue Generator instead.");
+        std::vector<T> m_values;
+        size_t m_idx = 0;
+    public:
+        FixedValuesGenerator( std::initializer_list<T> values ) : m_values( values ) {}
+
+        T const& get() const override {
+            return m_values[m_idx];
+        }
+        bool next() override {
+            ++m_idx;
+            return m_idx < m_values.size();
+        }
+    };
+
+    template <typename T>
+    class GeneratorWrapper final {
+        std::unique_ptr<IGenerator<T>> m_generator;
+    public:
+        GeneratorWrapper(std::unique_ptr<IGenerator<T>> generator):
+            m_generator(std::move(generator))
+        {}
+        T const& get() const {
+            return m_generator->get();
+        }
+        bool next() {
+            return m_generator->next();
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<T> value(T&& value) {
+        return GeneratorWrapper<T>(pf::make_unique<SingleValueGenerator<T>>(std::forward<T>(value)));
+    }
+    template <typename T>
+    GeneratorWrapper<T> values(std::initializer_list<T> values) {
+        return GeneratorWrapper<T>(pf::make_unique<FixedValuesGenerator<T>>(values));
+    }
+
+    template<typename T>
+    class Generators : public IGenerator<T> {
+        std::vector<GeneratorWrapper<T>> m_generators;
+        size_t m_current = 0;
+
+        void populate(GeneratorWrapper<T>&& generator) {
+            m_generators.emplace_back(std::move(generator));
+        }
+        void populate(T&& val) {
+            m_generators.emplace_back(value(std::forward<T>(val)));
+        }
+        template<typename U>
+        void populate(U&& val) {
+            populate(T(std::forward<U>(val)));
+        }
+        template<typename U, typename... Gs>
+        void populate(U&& valueOrGenerator, Gs &&... moreGenerators) {
+            populate(std::forward<U>(valueOrGenerator));
+            populate(std::forward<Gs>(moreGenerators)...);
+        }
+
+    public:
+        template <typename... Gs>
+        Generators(Gs &&... moreGenerators) {
+            m_generators.reserve(sizeof...(Gs));
+            populate(std::forward<Gs>(moreGenerators)...);
+        }
+
+        T const& get() const override {
+            return m_generators[m_current].get();
+        }
+
+        bool next() override {
+            if (m_current >= m_generators.size()) {
+                return false;
+            }
+            const bool current_status = m_generators[m_current].next();
+            if (!current_status) {
+                ++m_current;
+            }
+            return m_current < m_generators.size();
+        }
+    };
+
+    template<typename... Ts>
+    GeneratorWrapper<std::tuple<Ts...>> table( std::initializer_list<std::tuple<typename std::decay<Ts>::type...>> tuples ) {
+        return values<std::tuple<Ts...>>( tuples );
+    }
+
+    // Tag type to signal that a generator sequence should convert arguments to a specific type
+    template <typename T>
+    struct as {};
+
+    template<typename T, typename... Gs>
+    auto makeGenerators( GeneratorWrapper<T>&& generator, Gs &&... moreGenerators ) -> Generators<T> {
+        return Generators<T>(std::move(generator), std::forward<Gs>(moreGenerators)...);
+    }
+    template<typename T>
+    auto makeGenerators( GeneratorWrapper<T>&& generator ) -> Generators<T> {
+        return Generators<T>(std::move(generator));
+    }
+    template<typename T, typename... Gs>
+    auto makeGenerators( T&& val, Gs &&... moreGenerators ) -> Generators<T> {
+        return makeGenerators( value( std::forward<T>( val ) ), std::forward<Gs>( moreGenerators )... );
+    }
+    template<typename T, typename U, typename... Gs>
+    auto makeGenerators( as<T>, U&& val, Gs &&... moreGenerators ) -> Generators<T> {
+        return makeGenerators( value( T( std::forward<U>( val ) ) ), std::forward<Gs>( moreGenerators )... );
+    }
+
+    auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker&;
+
+    template<typename L>
+    // Note: The type after -> is weird, because VS2015 cannot parse
+    //       the expression used in the typedef inside, when it is in
+    //       return type. Yeah.
+    auto generate( SourceLineInfo const& lineInfo, L const& generatorExpression ) -> decltype(std::declval<decltype(generatorExpression())>().get()) {
+        using UnderlyingType = typename decltype(generatorExpression())::type;
+
+        IGeneratorTracker& tracker = acquireGeneratorTracker( lineInfo );
+        if (!tracker.hasGenerator()) {
+            tracker.setGenerator(pf::make_unique<Generators<UnderlyingType>>(generatorExpression()));
+        }
+
+        auto const& generator = static_cast<IGenerator<UnderlyingType> const&>( *tracker.getGenerator() );
+        return generator.get();
+    }
+
+} // namespace Generators
+} // namespace Catch
+
+#define GENERATE( ... ) \
+    Catch::Generators::generate( CATCH_INTERNAL_LINEINFO, [ ]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
+#define GENERATE_COPY( ... ) \
+    Catch::Generators::generate( CATCH_INTERNAL_LINEINFO, [=]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
+#define GENERATE_REF( ... ) \
+    Catch::Generators::generate( CATCH_INTERNAL_LINEINFO, [&]{ using namespace Catch::Generators; return makeGenerators( __VA_ARGS__ ); } ) //NOLINT(google-build-using-namespace)
+
+// end catch_generators.hpp
+// start catch_generators_generic.hpp
+
+namespace Catch {
+namespace Generators {
+
+    template <typename T>
+    class TakeGenerator : public IGenerator<T> {
+        GeneratorWrapper<T> m_generator;
+        size_t m_returned = 0;
+        size_t m_target;
+    public:
+        TakeGenerator(size_t target, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_target(target)
+        {
+            assert(target != 0 && "Empty generators are not allowed");
+        }
+        T const& get() const override {
+            return m_generator.get();
+        }
+        bool next() override {
+            ++m_returned;
+            if (m_returned >= m_target) {
+                return false;
+            }
+
+            const auto success = m_generator.next();
+            // If the underlying generator does not contain enough values
+            // then we cut short as well
+            if (!success) {
+                m_returned = m_target;
+            }
+            return success;
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<T> take(size_t target, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(pf::make_unique<TakeGenerator<T>>(target, std::move(generator)));
+    }
+
+    template <typename T, typename Predicate>
+    class FilterGenerator : public IGenerator<T> {
+        GeneratorWrapper<T> m_generator;
+        Predicate m_predicate;
+    public:
+        template <typename P = Predicate>
+        FilterGenerator(P&& pred, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_predicate(std::forward<P>(pred))
+        {
+            if (!m_predicate(m_generator.get())) {
+                // It might happen that there are no values that pass the
+                // filter. In that case we throw an exception.
+                auto has_initial_value = next();
+                if (!has_initial_value) {
+                    Catch::throw_exception(GeneratorException("No valid value found in filtered generator"));
+                }
+            }
+        }
+
+        T const& get() const override {
+            return m_generator.get();
+        }
+
+        bool next() override {
+            bool success = m_generator.next();
+            if (!success) {
+                return false;
+            }
+            while (!m_predicate(m_generator.get()) && (success = m_generator.next()) == true);
+            return success;
+        }
+    };
+
+    template <typename T, typename Predicate>
+    GeneratorWrapper<T> filter(Predicate&& pred, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(std::unique_ptr<IGenerator<T>>(pf::make_unique<FilterGenerator<T, Predicate>>(std::forward<Predicate>(pred), std::move(generator))));
+    }
+
+    template <typename T>
+    class RepeatGenerator : public IGenerator<T> {
+        static_assert(!std::is_same<T, bool>::value,
+            "RepeatGenerator currently does not support bools"
+            "because of std::vector<bool> specialization");
+        GeneratorWrapper<T> m_generator;
+        mutable std::vector<T> m_returned;
+        size_t m_target_repeats;
+        size_t m_current_repeat = 0;
+        size_t m_repeat_index = 0;
+    public:
+        RepeatGenerator(size_t repeats, GeneratorWrapper<T>&& generator):
+            m_generator(std::move(generator)),
+            m_target_repeats(repeats)
+        {
+            assert(m_target_repeats > 0 && "Repeat generator must repeat at least once");
+        }
+
+        T const& get() const override {
+            if (m_current_repeat == 0) {
+                m_returned.push_back(m_generator.get());
+                return m_returned.back();
+            }
+            return m_returned[m_repeat_index];
+        }
+
+        bool next() override {
+            // There are 2 basic cases:
+            // 1) We are still reading the generator
+            // 2) We are reading our own cache
+
+            // In the first case, we need to poke the underlying generator.
+            // If it happily moves, we are left in that state, otherwise it is time to start reading from our cache
+            if (m_current_repeat == 0) {
+                const auto success = m_generator.next();
+                if (!success) {
+                    ++m_current_repeat;
+                }
+                return m_current_repeat < m_target_repeats;
+            }
+
+            // In the second case, we need to move indices forward and check that we haven't run up against the end
+            ++m_repeat_index;
+            if (m_repeat_index == m_returned.size()) {
+                m_repeat_index = 0;
+                ++m_current_repeat;
+            }
+            return m_current_repeat < m_target_repeats;
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<T> repeat(size_t repeats, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<T>(pf::make_unique<RepeatGenerator<T>>(repeats, std::move(generator)));
+    }
+
+    template <typename T, typename U, typename Func>
+    class MapGenerator : public IGenerator<T> {
+        // TBD: provide static assert for mapping function, for friendly error message
+        GeneratorWrapper<U> m_generator;
+        Func m_function;
+        // To avoid returning dangling reference, we have to save the values
+        T m_cache;
+    public:
+        template <typename F2 = Func>
+        MapGenerator(F2&& function, GeneratorWrapper<U>&& generator) :
+            m_generator(std::move(generator)),
+            m_function(std::forward<F2>(function)),
+            m_cache(m_function(m_generator.get()))
+        {}
+
+        T const& get() const override {
+            return m_cache;
+        }
+        bool next() override {
+            const auto success = m_generator.next();
+            if (success) {
+                m_cache = m_function(m_generator.get());
+            }
+            return success;
+        }
+    };
+
+    template <typename Func, typename U, typename T = FunctionReturnType<Func, U>>
+    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
+        return GeneratorWrapper<T>(
+            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
+        );
+    }
+
+    template <typename T, typename U, typename Func>
+    GeneratorWrapper<T> map(Func&& function, GeneratorWrapper<U>&& generator) {
+        return GeneratorWrapper<T>(
+            pf::make_unique<MapGenerator<T, U, Func>>(std::forward<Func>(function), std::move(generator))
+        );
+    }
+
+    template <typename T>
+    class ChunkGenerator final : public IGenerator<std::vector<T>> {
+        std::vector<T> m_chunk;
+        size_t m_chunk_size;
+        GeneratorWrapper<T> m_generator;
+        bool m_used_up = false;
+    public:
+        ChunkGenerator(size_t size, GeneratorWrapper<T> generator) :
+            m_chunk_size(size), m_generator(std::move(generator))
+        {
+            m_chunk.reserve(m_chunk_size);
+            if (m_chunk_size != 0) {
+                m_chunk.push_back(m_generator.get());
+                for (size_t i = 1; i < m_chunk_size; ++i) {
+                    if (!m_generator.next()) {
+                        Catch::throw_exception(GeneratorException("Not enough values to initialize the first chunk"));
+                    }
+                    m_chunk.push_back(m_generator.get());
+                }
+            }
+        }
+        std::vector<T> const& get() const override {
+            return m_chunk;
+        }
+        bool next() override {
+            m_chunk.clear();
+            for (size_t idx = 0; idx < m_chunk_size; ++idx) {
+                if (!m_generator.next()) {
+                    return false;
+                }
+                m_chunk.push_back(m_generator.get());
+            }
+            return true;
+        }
+    };
+
+    template <typename T>
+    GeneratorWrapper<std::vector<T>> chunk(size_t size, GeneratorWrapper<T>&& generator) {
+        return GeneratorWrapper<std::vector<T>>(
+            pf::make_unique<ChunkGenerator<T>>(size, std::move(generator))
+        );
+    }
+
+} // namespace Generators
+} // namespace Catch
+
+// end catch_generators_generic.hpp
+// start catch_generators_specific.hpp
+
+// start catch_context.h
+
+#include <memory>
+
+namespace Catch {
+
+    struct IResultCapture;
+    struct IRunner;
+    struct IConfig;
+    struct IMutableContext;
+
+    using IConfigPtr = std::shared_ptr<IConfig const>;
+
+    struct IContext
+    {
+        virtual ~IContext();
+
+        virtual IResultCapture* getResultCapture() = 0;
+        virtual IRunner* getRunner() = 0;
+        virtual IConfigPtr const& getConfig() const = 0;
+    };
+
+    struct IMutableContext : IContext
+    {
+        virtual ~IMutableContext();
+        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
+        virtual void setRunner( IRunner* runner ) = 0;
+        virtual void setConfig( IConfigPtr const& config ) = 0;
+
+    private:
+        static IMutableContext *currentContext;
+        friend IMutableContext& getCurrentMutableContext();
+        friend void cleanUpContext();
+        static void createContext();
+    };
+
+    inline IMutableContext& getCurrentMutableContext()
+    {
+        if( !IMutableContext::currentContext )
+            IMutableContext::createContext();
+        // NOLINTNEXTLINE(clang-analyzer-core.uninitialized.UndefReturn)
+        return *IMutableContext::currentContext;
+    }
+
+    inline IContext& getCurrentContext()
+    {
+        return getCurrentMutableContext();
+    }
+
+    void cleanUpContext();
+
+    class SimplePcg32;
+    SimplePcg32& rng();
+}
+
+// end catch_context.h
+// start catch_interfaces_config.h
+
+// start catch_option.hpp
+
+namespace Catch {
+
+    // An optional type
+    template<typename T>
+    class Option {
+    public:
+        Option() : nullableValue( nullptr ) {}
+        Option( T const& _value )
+        : nullableValue( new( storage ) T( _value ) )
+        {}
+        Option( Option const& _other )
+        : nullableValue( _other ? new( storage ) T( *_other ) : nullptr )
+        {}
+
+        ~Option() {
+            reset();
+        }
+
+        Option& operator= ( Option const& _other ) {
+            if( &_other != this ) {
+                reset();
+                if( _other )
+                    nullableValue = new( storage ) T( *_other );
+            }
+            return *this;
+        }
+        Option& operator = ( T const& _value ) {
+            reset();
+            nullableValue = new( storage ) T( _value );
+            return *this;
+        }
+
+        void reset() {
+            if( nullableValue )
+                nullableValue->~T();
+            nullableValue = nullptr;
+        }
+
+        T& operator*() { return *nullableValue; }
+        T const& operator*() const { return *nullableValue; }
+        T* operator->() { return nullableValue; }
+        const T* operator->() const { return nullableValue; }
+
+        T valueOr( T const& defaultValue ) const {
+            return nullableValue ? *nullableValue : defaultValue;
+        }
+
+        bool some() const { return nullableValue != nullptr; }
+        bool none() const { return nullableValue == nullptr; }
+
+        bool operator !() const { return nullableValue == nullptr; }
+        explicit operator bool() const {
+            return some();
+        }
+
+    private:
+        T *nullableValue;
+        alignas(alignof(T)) char storage[sizeof(T)];
+    };
+
+} // end namespace Catch
+
+// end catch_option.hpp
+#include <chrono>
+#include <iosfwd>
+#include <string>
+#include <vector>
+#include <memory>
+
+namespace Catch {
+
+    enum class Verbosity {
+        Quiet = 0,
+        Normal,
+        High
+    };
+
+    struct WarnAbout { enum What {
+        Nothing = 0x00,
+        NoAssertions = 0x01,
+        NoTests = 0x02
+    }; };
+
+    struct ShowDurations { enum OrNot {
+        DefaultForReporter,
+        Always,
+        Never
+    }; };
+    struct RunTests { enum InWhatOrder {
+        InDeclarationOrder,
+        InLexicographicalOrder,
+        InRandomOrder
+    }; };
+    struct UseColour { enum YesOrNo {
+        Auto,
+        Yes,
+        No
+    }; };
+    struct WaitForKeypress { enum When {
+        Never,
+        BeforeStart = 1,
+        BeforeExit = 2,
+        BeforeStartAndExit = BeforeStart | BeforeExit
+    }; };
+
+    class TestSpec;
+
+    struct IConfig : NonCopyable {
+
+        virtual ~IConfig();
+
+        virtual bool allowThrows() const = 0;
+        virtual std::ostream& stream() const = 0;
+        virtual std::string name() const = 0;
+        virtual bool includeSuccessfulResults() const = 0;
+        virtual bool shouldDebugBreak() const = 0;
+        virtual bool warnAboutMissingAssertions() const = 0;
+        virtual bool warnAboutNoTests() const = 0;
+        virtual int abortAfter() const = 0;
+        virtual bool showInvisibles() const = 0;
+        virtual ShowDurations::OrNot showDurations() const = 0;
+        virtual TestSpec const& testSpec() const = 0;
+        virtual bool hasTestFilters() const = 0;
+        virtual std::vector<std::string> const& getTestsOrTags() const = 0;
+        virtual RunTests::InWhatOrder runOrder() const = 0;
+        virtual unsigned int rngSeed() const = 0;
+        virtual UseColour::YesOrNo useColour() const = 0;
+        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
+        virtual Verbosity verbosity() const = 0;
+
+        virtual bool benchmarkNoAnalysis() const = 0;
+        virtual int benchmarkSamples() const = 0;
+        virtual double benchmarkConfidenceInterval() const = 0;
+        virtual unsigned int benchmarkResamples() const = 0;
+        virtual std::chrono::milliseconds benchmarkWarmupTime() const = 0;
+    };
+
+    using IConfigPtr = std::shared_ptr<IConfig const>;
+}
+
+// end catch_interfaces_config.h
+// start catch_random_number_generator.h
+
+#include <cstdint>
+
+namespace Catch {
+
+    // This is a simple implementation of C++11 Uniform Random Number
+    // Generator. It does not provide all operators, because Catch2
+    // does not use it, but it should behave as expected inside stdlib's
+    // distributions.
+    // The implementation is based on the PCG family (http://pcg-random.org)
+    class SimplePcg32 {
+        using state_type = std::uint64_t;
+    public:
+        using result_type = std::uint32_t;
+        static constexpr result_type (min)() {
+            return 0;
+        }
+        static constexpr result_type (max)() {
+            return static_cast<result_type>(-1);
+        }
+
+        // Provide some default initial state for the default constructor
+        SimplePcg32():SimplePcg32(0xed743cc4U) {}
+
+        explicit SimplePcg32(result_type seed_);
+
+        void seed(result_type seed_);
+        void discard(uint64_t skip);
+
+        result_type operator()();
+
+    private:
+        friend bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
+        friend bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs);
+
+        // In theory we also need operator<< and operator>>
+        // In practice we do not use them, so we will skip them for now
+
+        std::uint64_t m_state;
+        // This part of the state determines which "stream" of the numbers
+        // is chosen -- we take it as a constant for Catch2, so we only
+        // need to deal with seeding the main state.
+        // Picked by reading 8 bytes from `/dev/random` :-)
+        static const std::uint64_t s_inc = (0x13ed0cc53f939476ULL << 1ULL) | 1ULL;
+    };
+
+} // end namespace Catch
+
+// end catch_random_number_generator.h
+#include <random>
+
+namespace Catch {
+namespace Generators {
+
+template <typename Float>
+class RandomFloatingGenerator final : public IGenerator<Float> {
+    Catch::SimplePcg32& m_rng;
+    std::uniform_real_distribution<Float> m_dist;
+    Float m_current_number;
+public:
+
+    RandomFloatingGenerator(Float a, Float b):
+        m_rng(rng()),
+        m_dist(a, b) {
+        static_cast<void>(next());
+    }
+
+    Float const& get() const override {
+        return m_current_number;
+    }
+    bool next() override {
+        m_current_number = m_dist(m_rng);
+        return true;
+    }
+};
+
+template <typename Integer>
+class RandomIntegerGenerator final : public IGenerator<Integer> {
+    Catch::SimplePcg32& m_rng;
+    std::uniform_int_distribution<Integer> m_dist;
+    Integer m_current_number;
+public:
+
+    RandomIntegerGenerator(Integer a, Integer b):
+        m_rng(rng()),
+        m_dist(a, b) {
+        static_cast<void>(next());
+    }
+
+    Integer const& get() const override {
+        return m_current_number;
+    }
+    bool next() override {
+        m_current_number = m_dist(m_rng);
+        return true;
+    }
+};
+
+// TODO: Ideally this would be also constrained against the various char types,
+//       but I don't expect users to run into that in practice.
+template <typename T>
+typename std::enable_if<std::is_integral<T>::value && !std::is_same<T, bool>::value,
+GeneratorWrapper<T>>::type
+random(T a, T b) {
+    return GeneratorWrapper<T>(
+        pf::make_unique<RandomIntegerGenerator<T>>(a, b)
+    );
+}
+
+template <typename T>
+typename std::enable_if<std::is_floating_point<T>::value,
+GeneratorWrapper<T>>::type
+random(T a, T b) {
+    return GeneratorWrapper<T>(
+        pf::make_unique<RandomFloatingGenerator<T>>(a, b)
+    );
+}
+
+template <typename T>
+class RangeGenerator final : public IGenerator<T> {
+    T m_current;
+    T m_end;
+    T m_step;
+    bool m_positive;
+
+public:
+    RangeGenerator(T const& start, T const& end, T const& step):
+        m_current(start),
+        m_end(end),
+        m_step(step),
+        m_positive(m_step > T(0))
+    {
+        assert(m_current != m_end && "Range start and end cannot be equal");
+        assert(m_step != T(0) && "Step size cannot be zero");
+        assert(((m_positive && m_current <= m_end) || (!m_positive && m_current >= m_end)) && "Step moves away from end");
+    }
+
+    RangeGenerator(T const& start, T const& end):
+        RangeGenerator(start, end, (start < end) ? T(1) : T(-1))
+    {}
+
+    T const& get() const override {
+        return m_current;
+    }
+
+    bool next() override {
+        m_current += m_step;
+        return (m_positive) ? (m_current < m_end) : (m_current > m_end);
+    }
+};
+
+template <typename T>
+GeneratorWrapper<T> range(T const& start, T const& end, T const& step) {
+    static_assert(std::is_arithmetic<T>::value && !std::is_same<T, bool>::value, "Type must be numeric");
+    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end, step));
+}
+
+template <typename T>
+GeneratorWrapper<T> range(T const& start, T const& end) {
+    static_assert(std::is_integral<T>::value && !std::is_same<T, bool>::value, "Type must be an integer");
+    return GeneratorWrapper<T>(pf::make_unique<RangeGenerator<T>>(start, end));
+}
+
+template <typename T>
+class IteratorGenerator final : public IGenerator<T> {
+    static_assert(!std::is_same<T, bool>::value,
+        "IteratorGenerator currently does not support bools"
+        "because of std::vector<bool> specialization");
+
+    std::vector<T> m_elems;
+    size_t m_current = 0;
+public:
+    template <typename InputIterator, typename InputSentinel>
+    IteratorGenerator(InputIterator first, InputSentinel last):m_elems(first, last) {
+        if (m_elems.empty()) {
+            Catch::throw_exception(GeneratorException("IteratorGenerator received no valid values"));
+        }
+    }
+
+    T const& get() const override {
+        return m_elems[m_current];
+    }
+
+    bool next() override {
+        ++m_current;
+        return m_current != m_elems.size();
+    }
+};
+
+template <typename InputIterator,
+          typename InputSentinel,
+          typename ResultType = typename std::iterator_traits<InputIterator>::value_type>
+GeneratorWrapper<ResultType> from_range(InputIterator from, InputSentinel to) {
+    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(from, to));
+}
+
+template <typename Container,
+          typename ResultType = typename Container::value_type>
+GeneratorWrapper<ResultType> from_range(Container const& cnt) {
+    return GeneratorWrapper<ResultType>(pf::make_unique<IteratorGenerator<ResultType>>(cnt.begin(), cnt.end()));
+}
+
+} // namespace Generators
+} // namespace Catch
+
+// end catch_generators_specific.hpp
+
+// These files are included here so the single_include script doesn't put them
+// in the conditionally compiled sections
+// start catch_test_case_info.h
+
+#include <string>
+#include <vector>
+#include <memory>
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wpadded"
+#endif
+
+namespace Catch {
+
+    struct ITestInvoker;
+
+    struct TestCaseInfo {
+        enum SpecialProperties{
+            None = 0,
+            IsHidden = 1 << 1,
+            ShouldFail = 1 << 2,
+            MayFail = 1 << 3,
+            Throws = 1 << 4,
+            NonPortable = 1 << 5,
+            Benchmark = 1 << 6
+        };
+
+        TestCaseInfo(   std::string const& _name,
+                        std::string const& _className,
+                        std::string const& _description,
+                        std::vector<std::string> const& _tags,
+                        SourceLineInfo const& _lineInfo );
+
+        friend void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags );
+
+        bool isHidden() const;
+        bool throws() const;
+        bool okToFail() const;
+        bool expectedToFail() const;
+
+        std::string tagsAsString() const;
+
+        std::string name;
+        std::string className;
+        std::string description;
+        std::vector<std::string> tags;
+        std::vector<std::string> lcaseTags;
+        SourceLineInfo lineInfo;
+        SpecialProperties properties;
+    };
+
+    class TestCase : public TestCaseInfo {
+    public:
+
+        TestCase( ITestInvoker* testCase, TestCaseInfo&& info );
+
+        TestCase withName( std::string const& _newName ) const;
+
+        void invoke() const;
+
+        TestCaseInfo const& getTestCaseInfo() const;
+
+        bool operator == ( TestCase const& other ) const;
+        bool operator < ( TestCase const& other ) const;
+
+    private:
+        std::shared_ptr<ITestInvoker> test;
+    };
+
+    TestCase makeTestCase(  ITestInvoker* testCase,
+                            std::string const& className,
+                            NameAndTags const& nameAndTags,
+                            SourceLineInfo const& lineInfo );
+}
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+// end catch_test_case_info.h
+// start catch_interfaces_runner.h
+
+namespace Catch {
+
+    struct IRunner {
+        virtual ~IRunner();
+        virtual bool aborting() const = 0;
+    };
+}
+
+// end catch_interfaces_runner.h
+
+#ifdef __OBJC__
+// start catch_objc.hpp
+
+#import <objc/runtime.h>
+
+#include <string>
+
+// NB. Any general catch headers included here must be included
+// in catch.hpp first to make sure they are included by the single
+// header for non obj-usage
+
+///////////////////////////////////////////////////////////////////////////////
+// This protocol is really only here for (self) documenting purposes, since
+// all its methods are optional.
+@protocol OcFixture
+
+@optional
+
+-(void) setUp;
+-(void) tearDown;
+
+@end
+
+namespace Catch {
+
+    class OcMethod : public ITestInvoker {
+
+    public:
+        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
+
+        virtual void invoke() const {
+            id obj = [[m_cls alloc] init];
+
+            performOptionalSelector( obj, @selector(setUp)  );
+            performOptionalSelector( obj, m_sel );
+            performOptionalSelector( obj, @selector(tearDown)  );
+
+            arcSafeRelease( obj );
+        }
+    private:
+        virtual ~OcMethod() {}
+
+        Class m_cls;
+        SEL m_sel;
+    };
+
+    namespace Detail{
+
+        inline std::string getAnnotation(   Class cls,
+                                            std::string const& annotationName,
+                                            std::string const& testCaseName ) {
+            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
+            SEL sel = NSSelectorFromString( selStr );
+            arcSafeRelease( selStr );
+            id value = performOptionalSelector( cls, sel );
+            if( value )
+                return [(NSString*)value UTF8String];
+            return "";
+        }
+    }
+
+    inline std::size_t registerTestMethods() {
+        std::size_t noTestMethods = 0;
+        int noClasses = objc_getClassList( nullptr, 0 );
+
+        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
+        objc_getClassList( classes, noClasses );
+
+        for( int c = 0; c < noClasses; c++ ) {
+            Class cls = classes[c];
+            {
+                u_int count;
+                Method* methods = class_copyMethodList( cls, &count );
+                for( u_int m = 0; m < count ; m++ ) {
+                    SEL selector = method_getName(methods[m]);
+                    std::string methodName = sel_getName(selector);
+                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
+                        std::string testCaseName = methodName.substr( 15 );
+                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
+                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
+                        const char* className = class_getName( cls );
+
+                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, NameAndTags( name.c_str(), desc.c_str() ), SourceLineInfo("",0) ) );
+                        noTestMethods++;
+                    }
+                }
+                free(methods);
+            }
+        }
+        return noTestMethods;
+    }
+
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+
+    namespace Matchers {
+        namespace Impl {
+        namespace NSStringMatchers {
+
+            struct StringHolder : MatcherBase<NSString*>{
+                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
+                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
+                StringHolder() {
+                    arcSafeRelease( m_substr );
+                }
+
+                bool match( NSString* str ) const override {
+                    return false;
+                }
+
+                NSString* CATCH_ARC_STRONG m_substr;
+            };
+
+            struct Equals : StringHolder {
+                Equals( NSString* substr ) : StringHolder( substr ){}
+
+                bool match( NSString* str ) const override {
+                    return  (str != nil || m_substr == nil ) &&
+                            [str isEqualToString:m_substr];
+                }
+
+                std::string describe() const override {
+                    return "equals string: " + Catch::Detail::stringify( m_substr );
+                }
+            };
+
+            struct Contains : StringHolder {
+                Contains( NSString* substr ) : StringHolder( substr ){}
+
+                bool match( NSString* str ) const override {
+                    return  (str != nil || m_substr == nil ) &&
+                            [str rangeOfString:m_substr].location != NSNotFound;
+                }
+
+                std::string describe() const override {
+                    return "contains string: " + Catch::Detail::stringify( m_substr );
+                }
+            };
+
+            struct StartsWith : StringHolder {
+                StartsWith( NSString* substr ) : StringHolder( substr ){}
+
+                bool match( NSString* str ) const override {
+                    return  (str != nil || m_substr == nil ) &&
+                            [str rangeOfString:m_substr].location == 0;
+                }
+
+                std::string describe() const override {
+                    return "starts with: " + Catch::Detail::stringify( m_substr );
+                }
+            };
+            struct EndsWith : StringHolder {
+                EndsWith( NSString* substr ) : StringHolder( substr ){}
+
+                bool match( NSString* str ) const override {
+                    return  (str != nil || m_substr == nil ) &&
+                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
+                }
+
+                std::string describe() const override {
+                    return "ends with: " + Catch::Detail::stringify( m_substr );
+                }
+            };
+
+        } // namespace NSStringMatchers
+        } // namespace Impl
+
+        inline Impl::NSStringMatchers::Equals
+            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
+
+        inline Impl::NSStringMatchers::Contains
+            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
+
+        inline Impl::NSStringMatchers::StartsWith
+            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
+
+        inline Impl::NSStringMatchers::EndsWith
+            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
+
+    } // namespace Matchers
+
+    using namespace Matchers;
+
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+
+} // namespace Catch
+
+///////////////////////////////////////////////////////////////////////////////
+#define OC_MAKE_UNIQUE_NAME( root, uniqueSuffix ) root##uniqueSuffix
+#define OC_TEST_CASE2( name, desc, uniqueSuffix ) \
++(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Name_test_, uniqueSuffix ) \
+{ \
+return @ name; \
+} \
++(NSString*) OC_MAKE_UNIQUE_NAME( Catch_Description_test_, uniqueSuffix ) \
+{ \
+return @ desc; \
+} \
+-(void) OC_MAKE_UNIQUE_NAME( Catch_TestCase_test_, uniqueSuffix )
+
+#define OC_TEST_CASE( name, desc ) OC_TEST_CASE2( name, desc, __LINE__ )
+
+// end catch_objc.hpp
+#endif
+
+// Benchmarking needs the externally-facing parts of reporters to work
+#if defined(CATCH_CONFIG_EXTERNAL_INTERFACES) || defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+// start catch_external_interfaces.h
+
+// start catch_reporter_bases.hpp
+
+// start catch_interfaces_reporter.h
+
+// start catch_config.hpp
+
+// start catch_test_spec_parser.h
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wpadded"
+#endif
+
+// start catch_test_spec.h
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wpadded"
+#endif
+
+// start catch_wildcard_pattern.h
+
+namespace Catch
+{
+    class WildcardPattern {
+        enum WildcardPosition {
+            NoWildcard = 0,
+            WildcardAtStart = 1,
+            WildcardAtEnd = 2,
+            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
+        };
+
+    public:
+
+        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity );
+        virtual ~WildcardPattern() = default;
+        virtual bool matches( std::string const& str ) const;
+
+    private:
+        std::string normaliseString( std::string const& str ) const;
+        CaseSensitive::Choice m_caseSensitivity;
+        WildcardPosition m_wildcard = NoWildcard;
+        std::string m_pattern;
+    };
+}
+
+// end catch_wildcard_pattern.h
+#include <string>
+#include <vector>
+#include <memory>
+
+namespace Catch {
+
+    struct IConfig;
+
+    class TestSpec {
+        class Pattern {
+        public:
+            explicit Pattern( std::string const& name );
+            virtual ~Pattern();
+            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
+            std::string const& name() const;
+        private:
+            std::string const m_name;
+        };
+        using PatternPtr = std::shared_ptr<Pattern>;
+
+        class NamePattern : public Pattern {
+        public:
+            explicit NamePattern( std::string const& name, std::string const& filterString );
+            bool matches( TestCaseInfo const& testCase ) const override;
+        private:
+            WildcardPattern m_wildcardPattern;
+        };
+
+        class TagPattern : public Pattern {
+        public:
+            explicit TagPattern( std::string const& tag, std::string const& filterString );
+            bool matches( TestCaseInfo const& testCase ) const override;
+        private:
+            std::string m_tag;
+        };
+
+        class ExcludedPattern : public Pattern {
+        public:
+            explicit ExcludedPattern( PatternPtr const& underlyingPattern );
+            bool matches( TestCaseInfo const& testCase ) const override;
+        private:
+            PatternPtr m_underlyingPattern;
+        };
+
+        struct Filter {
+            std::vector<PatternPtr> m_patterns;
+
+            bool matches( TestCaseInfo const& testCase ) const;
+            std::string name() const;
+        };
+
+    public:
+        struct FilterMatch {
+            std::string name;
+            std::vector<TestCase const*> tests;
+        };
+        using Matches = std::vector<FilterMatch>;
+        using vectorStrings = std::vector<std::string>;
+
+        bool hasFilters() const;
+        bool matches( TestCaseInfo const& testCase ) const;
+        Matches matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const;
+        const vectorStrings & getInvalidArgs() const;
+
+    private:
+        std::vector<Filter> m_filters;
+        std::vector<std::string> m_invalidArgs;
+        friend class TestSpecParser;
+    };
+}
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+// end catch_test_spec.h
+// start catch_interfaces_tag_alias_registry.h
+
+#include <string>
+
+namespace Catch {
+
+    struct TagAlias;
+
+    struct ITagAliasRegistry {
+        virtual ~ITagAliasRegistry();
+        // Nullptr if not present
+        virtual TagAlias const* find( std::string const& alias ) const = 0;
+        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
+
+        static ITagAliasRegistry const& get();
+    };
+
+} // end namespace Catch
+
+// end catch_interfaces_tag_alias_registry.h
+namespace Catch {
+
+    class TestSpecParser {
+        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
+        Mode m_mode = None;
+        Mode lastMode = None;
+        bool m_exclusion = false;
+        std::size_t m_pos = 0;
+        std::size_t m_realPatternPos = 0;
+        std::string m_arg;
+        std::string m_substring;
+        std::string m_patternName;
+        std::vector<std::size_t> m_escapeChars;
+        TestSpec::Filter m_currentFilter;
+        TestSpec m_testSpec;
+        ITagAliasRegistry const* m_tagAliases = nullptr;
+
+    public:
+        TestSpecParser( ITagAliasRegistry const& tagAliases );
+
+        TestSpecParser& parse( std::string const& arg );
+        TestSpec testSpec();
+
+    private:
+        bool visitChar( char c );
+        void startNewMode( Mode mode );
+        bool processNoneChar( char c );
+        void processNameChar( char c );
+        bool processOtherChar( char c );
+        void endMode();
+        void escape();
+        bool isControlChar( char c ) const;
+        void saveLastMode();
+        void revertBackToLastMode();
+        void addFilter();
+        bool separate();
+
+        // Handles common preprocessing of the pattern for name/tag patterns
+        std::string preprocessPattern();
+        // Adds the current pattern as a test name
+        void addNamePattern();
+        // Adds the current pattern as a tag
+        void addTagPattern();
+
+        inline void addCharToPattern(char c) {
+            m_substring += c;
+            m_patternName += c;
+            m_realPatternPos++;
+        }
+
+    };
+    TestSpec parseTestSpec( std::string const& arg );
+
+} // namespace Catch
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+// end catch_test_spec_parser.h
+// Libstdc++ doesn't like incomplete classes for unique_ptr
+
+#include <memory>
+#include <vector>
+#include <string>
+
+#ifndef CATCH_CONFIG_CONSOLE_WIDTH
+#define CATCH_CONFIG_CONSOLE_WIDTH 80
+#endif
+
+namespace Catch {
+
+    struct IStream;
+
+    struct ConfigData {
+        bool listTests = false;
+        bool listTags = false;
+        bool listReporters = false;
+        bool listTestNamesOnly = false;
+
+        bool showSuccessfulTests = false;
+        bool shouldDebugBreak = false;
+        bool noThrow = false;
+        bool showHelp = false;
+        bool showInvisibles = false;
+        bool filenamesAsTags = false;
+        bool libIdentify = false;
+
+        int abortAfter = -1;
+        unsigned int rngSeed = 0;
+
+        bool benchmarkNoAnalysis = false;
+        unsigned int benchmarkSamples = 100;
+        double benchmarkConfidenceInterval = 0.95;
+        unsigned int benchmarkResamples = 100000;
+        std::chrono::milliseconds::rep benchmarkWarmupTime = 100;
+
+        Verbosity verbosity = Verbosity::Normal;
+        WarnAbout::What warnings = WarnAbout::Nothing;
+        ShowDurations::OrNot showDurations = ShowDurations::DefaultForReporter;
+        RunTests::InWhatOrder runOrder = RunTests::InDeclarationOrder;
+        UseColour::YesOrNo useColour = UseColour::Auto;
+        WaitForKeypress::When waitForKeypress = WaitForKeypress::Never;
+
+        std::string outputFilename;
+        std::string name;
+        std::string processName;
+#ifndef CATCH_CONFIG_DEFAULT_REPORTER
+#define CATCH_CONFIG_DEFAULT_REPORTER "console"
+#endif
+        std::string reporterName = CATCH_CONFIG_DEFAULT_REPORTER;
+#undef CATCH_CONFIG_DEFAULT_REPORTER
+
+        std::vector<std::string> testsOrTags;
+        std::vector<std::string> sectionsToRun;
+    };
+
+    class Config : public IConfig {
+    public:
+
+        Config() = default;
+        Config( ConfigData const& data );
+        virtual ~Config() = default;
+
+        std::string const& getFilename() const;
+
+        bool listTests() const;
+        bool listTestNamesOnly() const;
+        bool listTags() const;
+        bool listReporters() const;
+
+        std::string getProcessName() const;
+        std::string const& getReporterName() const;
+
+        std::vector<std::string> const& getTestsOrTags() const override;
+        std::vector<std::string> const& getSectionsToRun() const override;
+
+        TestSpec const& testSpec() const override;
+        bool hasTestFilters() const override;
+
+        bool showHelp() const;
+
+        // IConfig interface
+        bool allowThrows() const override;
+        std::ostream& stream() const override;
+        std::string name() const override;
+        bool includeSuccessfulResults() const override;
+        bool warnAboutMissingAssertions() const override;
+        bool warnAboutNoTests() const override;
+        ShowDurations::OrNot showDurations() const override;
+        RunTests::InWhatOrder runOrder() const override;
+        unsigned int rngSeed() const override;
+        UseColour::YesOrNo useColour() const override;
+        bool shouldDebugBreak() const override;
+        int abortAfter() const override;
+        bool showInvisibles() const override;
+        Verbosity verbosity() const override;
+        bool benchmarkNoAnalysis() const override;
+        int benchmarkSamples() const override;
+        double benchmarkConfidenceInterval() const override;
+        unsigned int benchmarkResamples() const override;
+        std::chrono::milliseconds benchmarkWarmupTime() const override;
+
+    private:
+
+        IStream const* openStream();
+        ConfigData m_data;
+
+        std::unique_ptr<IStream const> m_stream;
+        TestSpec m_testSpec;
+        bool m_hasTestFilters = false;
+    };
+
+} // end namespace Catch
+
+// end catch_config.hpp
+// start catch_assertionresult.h
+
+#include <string>
+
+namespace Catch {
+
+    struct AssertionResultData
+    {
+        AssertionResultData() = delete;
+
+        AssertionResultData( ResultWas::OfType _resultType, LazyExpression const& _lazyExpression );
+
+        std::string message;
+        mutable std::string reconstructedExpression;
+        LazyExpression lazyExpression;
+        ResultWas::OfType resultType;
+
+        std::string reconstructExpression() const;
+    };
+
+    class AssertionResult {
+    public:
+        AssertionResult() = delete;
+        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
+
+        bool isOk() const;
+        bool succeeded() const;
+        ResultWas::OfType getResultType() const;
+        bool hasExpression() const;
+        bool hasMessage() const;
+        std::string getExpression() const;
+        std::string getExpressionInMacro() const;
+        bool hasExpandedExpression() const;
+        std::string getExpandedExpression() const;
+        std::string getMessage() const;
+        SourceLineInfo getSourceInfo() const;
+        StringRef getTestMacroName() const;
+
+    //protected:
+        AssertionInfo m_info;
+        AssertionResultData m_resultData;
+    };
+
+} // end namespace Catch
+
+// end catch_assertionresult.h
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+// start catch_estimate.hpp
+
+ // Statistics estimates
+
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Duration>
+        struct Estimate {
+            Duration point;
+            Duration lower_bound;
+            Duration upper_bound;
+            double confidence_interval;
+
+            template <typename Duration2>
+            operator Estimate<Duration2>() const {
+                return { point, lower_bound, upper_bound, confidence_interval };
+            }
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_estimate.hpp
+// start catch_outlier_classification.hpp
+
+// Outlier information
+
+namespace Catch {
+    namespace Benchmark {
+        struct OutlierClassification {
+            int samples_seen = 0;
+            int low_severe = 0;     // more than 3 times IQR below Q1
+            int low_mild = 0;       // 1.5 to 3 times IQR below Q1
+            int high_mild = 0;      // 1.5 to 3 times IQR above Q3
+            int high_severe = 0;    // more than 3 times IQR above Q3
+
+            int total() const {
+                return low_severe + low_mild + high_mild + high_severe;
+            }
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_outlier_classification.hpp
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+#include <string>
+#include <iosfwd>
+#include <map>
+#include <set>
+#include <memory>
+#include <algorithm>
+
+namespace Catch {
+
+    struct ReporterConfig {
+        explicit ReporterConfig( IConfigPtr const& _fullConfig );
+
+        ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream );
+
+        std::ostream& stream() const;
+        IConfigPtr fullConfig() const;
+
+    private:
+        std::ostream* m_stream;
+        IConfigPtr m_fullConfig;
+    };
+
+    struct ReporterPreferences {
+        bool shouldRedirectStdOut = false;
+        bool shouldReportAllAssertions = false;
+    };
+
+    template<typename T>
+    struct LazyStat : Option<T> {
+        LazyStat& operator=( T const& _value ) {
+            Option<T>::operator=( _value );
+            used = false;
+            return *this;
+        }
+        void reset() {
+            Option<T>::reset();
+            used = false;
+        }
+        bool used = false;
+    };
+
+    struct TestRunInfo {
+        TestRunInfo( std::string const& _name );
+        std::string name;
+    };
+    struct GroupInfo {
+        GroupInfo(  std::string const& _name,
+                    std::size_t _groupIndex,
+                    std::size_t _groupsCount );
+
+        std::string name;
+        std::size_t groupIndex;
+        std::size_t groupsCounts;
+    };
+
+    struct AssertionStats {
+        AssertionStats( AssertionResult const& _assertionResult,
+                        std::vector<MessageInfo> const& _infoMessages,
+                        Totals const& _totals );
+
+        AssertionStats( AssertionStats const& )              = default;
+        AssertionStats( AssertionStats && )                  = default;
+        AssertionStats& operator = ( AssertionStats const& ) = delete;
+        AssertionStats& operator = ( AssertionStats && )     = delete;
+        virtual ~AssertionStats();
+
+        AssertionResult assertionResult;
+        std::vector<MessageInfo> infoMessages;
+        Totals totals;
+    };
+
+    struct SectionStats {
+        SectionStats(   SectionInfo const& _sectionInfo,
+                        Counts const& _assertions,
+                        double _durationInSeconds,
+                        bool _missingAssertions );
+        SectionStats( SectionStats const& )              = default;
+        SectionStats( SectionStats && )                  = default;
+        SectionStats& operator = ( SectionStats const& ) = default;
+        SectionStats& operator = ( SectionStats && )     = default;
+        virtual ~SectionStats();
+
+        SectionInfo sectionInfo;
+        Counts assertions;
+        double durationInSeconds;
+        bool missingAssertions;
+    };
+
+    struct TestCaseStats {
+        TestCaseStats(  TestCaseInfo const& _testInfo,
+                        Totals const& _totals,
+                        std::string const& _stdOut,
+                        std::string const& _stdErr,
+                        bool _aborting );
+
+        TestCaseStats( TestCaseStats const& )              = default;
+        TestCaseStats( TestCaseStats && )                  = default;
+        TestCaseStats& operator = ( TestCaseStats const& ) = default;
+        TestCaseStats& operator = ( TestCaseStats && )     = default;
+        virtual ~TestCaseStats();
+
+        TestCaseInfo testInfo;
+        Totals totals;
+        std::string stdOut;
+        std::string stdErr;
+        bool aborting;
+    };
+
+    struct TestGroupStats {
+        TestGroupStats( GroupInfo const& _groupInfo,
+                        Totals const& _totals,
+                        bool _aborting );
+        TestGroupStats( GroupInfo const& _groupInfo );
+
+        TestGroupStats( TestGroupStats const& )              = default;
+        TestGroupStats( TestGroupStats && )                  = default;
+        TestGroupStats& operator = ( TestGroupStats const& ) = default;
+        TestGroupStats& operator = ( TestGroupStats && )     = default;
+        virtual ~TestGroupStats();
+
+        GroupInfo groupInfo;
+        Totals totals;
+        bool aborting;
+    };
+
+    struct TestRunStats {
+        TestRunStats(   TestRunInfo const& _runInfo,
+                        Totals const& _totals,
+                        bool _aborting );
+
+        TestRunStats( TestRunStats const& )              = default;
+        TestRunStats( TestRunStats && )                  = default;
+        TestRunStats& operator = ( TestRunStats const& ) = default;
+        TestRunStats& operator = ( TestRunStats && )     = default;
+        virtual ~TestRunStats();
+
+        TestRunInfo runInfo;
+        Totals totals;
+        bool aborting;
+    };
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+    struct BenchmarkInfo {
+        std::string name;
+        double estimatedDuration;
+        int iterations;
+        int samples;
+        unsigned int resamples;
+        double clockResolution;
+        double clockCost;
+    };
+
+    template <class Duration>
+    struct BenchmarkStats {
+        BenchmarkInfo info;
+
+        std::vector<Duration> samples;
+        Benchmark::Estimate<Duration> mean;
+        Benchmark::Estimate<Duration> standardDeviation;
+        Benchmark::OutlierClassification outliers;
+        double outlierVariance;
+
+        template <typename Duration2>
+        operator BenchmarkStats<Duration2>() const {
+            std::vector<Duration2> samples2;
+            samples2.reserve(samples.size());
+            std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
+            return {
+                info,
+                std::move(samples2),
+                mean,
+                standardDeviation,
+                outliers,
+                outlierVariance,
+            };
+        }
+    };
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    struct IStreamingReporter {
+        virtual ~IStreamingReporter() = default;
+
+        // Implementing class must also provide the following static methods:
+        // static std::string getDescription();
+        // static std::set<Verbosity> getSupportedVerbosities()
+
+        virtual ReporterPreferences getPreferences() const = 0;
+
+        virtual void noMatchingTestCases( std::string const& spec ) = 0;
+
+        virtual void reportInvalidArguments(std::string const&) {}
+
+        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
+        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
+
+        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
+        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        virtual void benchmarkPreparing( std::string const& ) {}
+        virtual void benchmarkStarting( BenchmarkInfo const& ) {}
+        virtual void benchmarkEnded( BenchmarkStats<> const& ) {}
+        virtual void benchmarkFailed( std::string const& ) {}
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
+
+        // The return value indicates if the messages buffer should be cleared:
+        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
+
+        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
+        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
+        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
+        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
+
+        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
+
+        // Default empty implementation provided
+        virtual void fatalErrorEncountered( StringRef name );
+
+        virtual bool isMulti() const;
+    };
+    using IStreamingReporterPtr = std::unique_ptr<IStreamingReporter>;
+
+    struct IReporterFactory {
+        virtual ~IReporterFactory();
+        virtual IStreamingReporterPtr create( ReporterConfig const& config ) const = 0;
+        virtual std::string getDescription() const = 0;
+    };
+    using IReporterFactoryPtr = std::shared_ptr<IReporterFactory>;
+
+    struct IReporterRegistry {
+        using FactoryMap = std::map<std::string, IReporterFactoryPtr>;
+        using Listeners = std::vector<IReporterFactoryPtr>;
+
+        virtual ~IReporterRegistry();
+        virtual IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const = 0;
+        virtual FactoryMap const& getFactories() const = 0;
+        virtual Listeners const& getListeners() const = 0;
+    };
+
+} // end namespace Catch
+
+// end catch_interfaces_reporter.h
+#include <algorithm>
+#include <cstring>
+#include <cfloat>
+#include <cstdio>
+#include <cassert>
+#include <memory>
+#include <ostream>
+
+namespace Catch {
+    void prepareExpandedExpression(AssertionResult& result);
+
+    // Returns double formatted as %.3f (format expected on output)
+    std::string getFormattedDuration( double duration );
+
+    std::string serializeFilters( std::vector<std::string> const& container );
+
+    template<typename DerivedT>
+    struct StreamingReporterBase : IStreamingReporter {
+
+        StreamingReporterBase( ReporterConfig const& _config )
+        :   m_config( _config.fullConfig() ),
+            stream( _config.stream() )
+        {
+            m_reporterPrefs.shouldRedirectStdOut = false;
+            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
+                CATCH_ERROR( "Verbosity level not supported by this reporter" );
+        }
+
+        ReporterPreferences getPreferences() const override {
+            return m_reporterPrefs;
+        }
+
+        static std::set<Verbosity> getSupportedVerbosities() {
+            return { Verbosity::Normal };
+        }
+
+        ~StreamingReporterBase() override = default;
+
+        void noMatchingTestCases(std::string const&) override {}
+
+        void reportInvalidArguments(std::string const&) override {}
+
+        void testRunStarting(TestRunInfo const& _testRunInfo) override {
+            currentTestRunInfo = _testRunInfo;
+        }
+
+        void testGroupStarting(GroupInfo const& _groupInfo) override {
+            currentGroupInfo = _groupInfo;
+        }
+
+        void testCaseStarting(TestCaseInfo const& _testInfo) override  {
+            currentTestCaseInfo = _testInfo;
+        }
+        void sectionStarting(SectionInfo const& _sectionInfo) override {
+            m_sectionStack.push_back(_sectionInfo);
+        }
+
+        void sectionEnded(SectionStats const& /* _sectionStats */) override {
+            m_sectionStack.pop_back();
+        }
+        void testCaseEnded(TestCaseStats const& /* _testCaseStats */) override {
+            currentTestCaseInfo.reset();
+        }
+        void testGroupEnded(TestGroupStats const& /* _testGroupStats */) override {
+            currentGroupInfo.reset();
+        }
+        void testRunEnded(TestRunStats const& /* _testRunStats */) override {
+            currentTestCaseInfo.reset();
+            currentGroupInfo.reset();
+            currentTestRunInfo.reset();
+        }
+
+        void skipTest(TestCaseInfo const&) override {
+            // Don't do anything with this by default.
+            // It can optionally be overridden in the derived class.
+        }
+
+        IConfigPtr m_config;
+        std::ostream& stream;
+
+        LazyStat<TestRunInfo> currentTestRunInfo;
+        LazyStat<GroupInfo> currentGroupInfo;
+        LazyStat<TestCaseInfo> currentTestCaseInfo;
+
+        std::vector<SectionInfo> m_sectionStack;
+        ReporterPreferences m_reporterPrefs;
+    };
+
+    template<typename DerivedT>
+    struct CumulativeReporterBase : IStreamingReporter {
+        template<typename T, typename ChildNodeT>
+        struct Node {
+            explicit Node( T const& _value ) : value( _value ) {}
+            virtual ~Node() {}
+
+            using ChildNodes = std::vector<std::shared_ptr<ChildNodeT>>;
+            T value;
+            ChildNodes children;
+        };
+        struct SectionNode {
+            explicit SectionNode(SectionStats const& _stats) : stats(_stats) {}
+            virtual ~SectionNode() = default;
+
+            bool operator == (SectionNode const& other) const {
+                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
+            }
+            bool operator == (std::shared_ptr<SectionNode> const& other) const {
+                return operator==(*other);
+            }
+
+            SectionStats stats;
+            using ChildSections = std::vector<std::shared_ptr<SectionNode>>;
+            using Assertions = std::vector<AssertionStats>;
+            ChildSections childSections;
+            Assertions assertions;
+            std::string stdOut;
+            std::string stdErr;
+        };
+
+        struct BySectionInfo {
+            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
+            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
+            bool operator() (std::shared_ptr<SectionNode> const& node) const {
+                return ((node->stats.sectionInfo.name == m_other.name) &&
+                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));
+            }
+            void operator=(BySectionInfo const&) = delete;
+
+        private:
+            SectionInfo const& m_other;
+        };
+
+        using TestCaseNode = Node<TestCaseStats, SectionNode>;
+        using TestGroupNode = Node<TestGroupStats, TestCaseNode>;
+        using TestRunNode = Node<TestRunStats, TestGroupNode>;
+
+        CumulativeReporterBase( ReporterConfig const& _config )
+        :   m_config( _config.fullConfig() ),
+            stream( _config.stream() )
+        {
+            m_reporterPrefs.shouldRedirectStdOut = false;
+            if( !DerivedT::getSupportedVerbosities().count( m_config->verbosity() ) )
+                CATCH_ERROR( "Verbosity level not supported by this reporter" );
+        }
+        ~CumulativeReporterBase() override = default;
+
+        ReporterPreferences getPreferences() const override {
+            return m_reporterPrefs;
+        }
+
+        static std::set<Verbosity> getSupportedVerbosities() {
+            return { Verbosity::Normal };
+        }
+
+        void testRunStarting( TestRunInfo const& ) override {}
+        void testGroupStarting( GroupInfo const& ) override {}
+
+        void testCaseStarting( TestCaseInfo const& ) override {}
+
+        void sectionStarting( SectionInfo const& sectionInfo ) override {
+            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
+            std::shared_ptr<SectionNode> node;
+            if( m_sectionStack.empty() ) {
+                if( !m_rootSection )
+                    m_rootSection = std::make_shared<SectionNode>( incompleteStats );
+                node = m_rootSection;
+            }
+            else {
+                SectionNode& parentNode = *m_sectionStack.back();
+                auto it =
+                    std::find_if(   parentNode.childSections.begin(),
+                                    parentNode.childSections.end(),
+                                    BySectionInfo( sectionInfo ) );
+                if( it == parentNode.childSections.end() ) {
+                    node = std::make_shared<SectionNode>( incompleteStats );
+                    parentNode.childSections.push_back( node );
+                }
+                else
+                    node = *it;
+            }
+            m_sectionStack.push_back( node );
+            m_deepestSection = std::move(node);
+        }
+
+        void assertionStarting(AssertionInfo const&) override {}
+
+        bool assertionEnded(AssertionStats const& assertionStats) override {
+            assert(!m_sectionStack.empty());
+            // AssertionResult holds a pointer to a temporary DecomposedExpression,
+            // which getExpandedExpression() calls to build the expression string.
+            // Our section stack copy of the assertionResult will likely outlive the
+            // temporary, so it must be expanded or discarded now to avoid calling
+            // a destroyed object later.
+            prepareExpandedExpression(const_cast<AssertionResult&>( assertionStats.assertionResult ) );
+            SectionNode& sectionNode = *m_sectionStack.back();
+            sectionNode.assertions.push_back(assertionStats);
+            return true;
+        }
+        void sectionEnded(SectionStats const& sectionStats) override {
+            assert(!m_sectionStack.empty());
+            SectionNode& node = *m_sectionStack.back();
+            node.stats = sectionStats;
+            m_sectionStack.pop_back();
+        }
+        void testCaseEnded(TestCaseStats const& testCaseStats) override {
+            auto node = std::make_shared<TestCaseNode>(testCaseStats);
+            assert(m_sectionStack.size() == 0);
+            node->children.push_back(m_rootSection);
+            m_testCases.push_back(node);
+            m_rootSection.reset();
+
+            assert(m_deepestSection);
+            m_deepestSection->stdOut = testCaseStats.stdOut;
+            m_deepestSection->stdErr = testCaseStats.stdErr;
+        }
+        void testGroupEnded(TestGroupStats const& testGroupStats) override {
+            auto node = std::make_shared<TestGroupNode>(testGroupStats);
+            node->children.swap(m_testCases);
+            m_testGroups.push_back(node);
+        }
+        void testRunEnded(TestRunStats const& testRunStats) override {
+            auto node = std::make_shared<TestRunNode>(testRunStats);
+            node->children.swap(m_testGroups);
+            m_testRuns.push_back(node);
+            testRunEndedCumulative();
+        }
+        virtual void testRunEndedCumulative() = 0;
+
+        void skipTest(TestCaseInfo const&) override {}
+
+        IConfigPtr m_config;
+        std::ostream& stream;
+        std::vector<AssertionStats> m_assertions;
+        std::vector<std::vector<std::shared_ptr<SectionNode>>> m_sections;
+        std::vector<std::shared_ptr<TestCaseNode>> m_testCases;
+        std::vector<std::shared_ptr<TestGroupNode>> m_testGroups;
+
+        std::vector<std::shared_ptr<TestRunNode>> m_testRuns;
+
+        std::shared_ptr<SectionNode> m_rootSection;
+        std::shared_ptr<SectionNode> m_deepestSection;
+        std::vector<std::shared_ptr<SectionNode>> m_sectionStack;
+        ReporterPreferences m_reporterPrefs;
+    };
+
+    template<char C>
+    char const* getLineOfChars() {
+        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
+        if( !*line ) {
+            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
+            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
+        }
+        return line;
+    }
+
+    struct TestEventListenerBase : StreamingReporterBase<TestEventListenerBase> {
+        TestEventListenerBase( ReporterConfig const& _config );
+
+        static std::set<Verbosity> getSupportedVerbosities();
+
+        void assertionStarting(AssertionInfo const&) override;
+        bool assertionEnded(AssertionStats const&) override;
+    };
+
+} // end namespace Catch
+
+// end catch_reporter_bases.hpp
+// start catch_console_colour.h
+
+namespace Catch {
+
+    struct Colour {
+        enum Code {
+            None = 0,
+
+            White,
+            Red,
+            Green,
+            Blue,
+            Cyan,
+            Yellow,
+            Grey,
+
+            Bright = 0x10,
+
+            BrightRed = Bright | Red,
+            BrightGreen = Bright | Green,
+            LightGrey = Bright | Grey,
+            BrightWhite = Bright | White,
+            BrightYellow = Bright | Yellow,
+
+            // By intention
+            FileName = LightGrey,
+            Warning = BrightYellow,
+            ResultError = BrightRed,
+            ResultSuccess = BrightGreen,
+            ResultExpectedFailure = Warning,
+
+            Error = BrightRed,
+            Success = Green,
+
+            OriginalExpression = Cyan,
+            ReconstructedExpression = BrightYellow,
+
+            SecondaryText = LightGrey,
+            Headers = White
+        };
+
+        // Use constructed object for RAII guard
+        Colour( Code _colourCode );
+        Colour( Colour&& other ) noexcept;
+        Colour& operator=( Colour&& other ) noexcept;
+        ~Colour();
+
+        // Use static method for one-shot changes
+        static void use( Code _colourCode );
+
+    private:
+        bool m_moved = false;
+    };
+
+    std::ostream& operator << ( std::ostream& os, Colour const& );
+
+} // end namespace Catch
+
+// end catch_console_colour.h
+// start catch_reporter_registrars.hpp
+
+
+namespace Catch {
+
+    template<typename T>
+    class ReporterRegistrar {
+
+        class ReporterFactory : public IReporterFactory {
+
+            IStreamingReporterPtr create( ReporterConfig const& config ) const override {
+                return std::unique_ptr<T>( new T( config ) );
+            }
+
+            std::string getDescription() const override {
+                return T::getDescription();
+            }
+        };
+
+    public:
+
+        explicit ReporterRegistrar( std::string const& name ) {
+            getMutableRegistryHub().registerReporter( name, std::make_shared<ReporterFactory>() );
+        }
+    };
+
+    template<typename T>
+    class ListenerRegistrar {
+
+        class ListenerFactory : public IReporterFactory {
+
+            IStreamingReporterPtr create( ReporterConfig const& config ) const override {
+                return std::unique_ptr<T>( new T( config ) );
+            }
+            std::string getDescription() const override {
+                return std::string();
+            }
+        };
+
+    public:
+
+        ListenerRegistrar() {
+            getMutableRegistryHub().registerListener( std::make_shared<ListenerFactory>() );
+        }
+    };
+}
+
+#if !defined(CATCH_CONFIG_DISABLE)
+
+#define CATCH_REGISTER_REPORTER( name, reporterType ) \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION         \
+    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS          \
+    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); } \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+#define CATCH_REGISTER_LISTENER( listenerType ) \
+    CATCH_INTERNAL_START_WARNINGS_SUPPRESSION   \
+    CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS    \
+    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; } \
+    CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+#else // CATCH_CONFIG_DISABLE
+
+#define CATCH_REGISTER_REPORTER(name, reporterType)
+#define CATCH_REGISTER_LISTENER(listenerType)
+
+#endif // CATCH_CONFIG_DISABLE
+
+// end catch_reporter_registrars.hpp
+// Allow users to base their work off existing reporters
+// start catch_reporter_compact.h
+
+namespace Catch {
+
+    struct CompactReporter : StreamingReporterBase<CompactReporter> {
+
+        using StreamingReporterBase::StreamingReporterBase;
+
+        ~CompactReporter() override;
+
+        static std::string getDescription();
+
+        ReporterPreferences getPreferences() const override;
+
+        void noMatchingTestCases(std::string const& spec) override;
+
+        void assertionStarting(AssertionInfo const&) override;
+
+        bool assertionEnded(AssertionStats const& _assertionStats) override;
+
+        void sectionEnded(SectionStats const& _sectionStats) override;
+
+        void testRunEnded(TestRunStats const& _testRunStats) override;
+
+    };
+
+} // end namespace Catch
+
+// end catch_reporter_compact.h
+// start catch_reporter_console.h
+
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
+                              // Note that 4062 (not all labels are handled
+                              // and default is missing) is enabled
+#endif
+
+namespace Catch {
+    // Fwd decls
+    struct SummaryColumn;
+    class TablePrinter;
+
+    struct ConsoleReporter : StreamingReporterBase<ConsoleReporter> {
+        std::unique_ptr<TablePrinter> m_tablePrinter;
+
+        ConsoleReporter(ReporterConfig const& config);
+        ~ConsoleReporter() override;
+        static std::string getDescription();
+
+        void noMatchingTestCases(std::string const& spec) override;
+
+        void reportInvalidArguments(std::string const&arg) override;
+
+        void assertionStarting(AssertionInfo const&) override;
+
+        bool assertionEnded(AssertionStats const& _assertionStats) override;
+
+        void sectionStarting(SectionInfo const& _sectionInfo) override;
+        void sectionEnded(SectionStats const& _sectionStats) override;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        void benchmarkPreparing(std::string const& name) override;
+        void benchmarkStarting(BenchmarkInfo const& info) override;
+        void benchmarkEnded(BenchmarkStats<> const& stats) override;
+        void benchmarkFailed(std::string const& error) override;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+        void testCaseEnded(TestCaseStats const& _testCaseStats) override;
+        void testGroupEnded(TestGroupStats const& _testGroupStats) override;
+        void testRunEnded(TestRunStats const& _testRunStats) override;
+        void testRunStarting(TestRunInfo const& _testRunInfo) override;
+    private:
+
+        void lazyPrint();
+
+        void lazyPrintWithoutClosingBenchmarkTable();
+        void lazyPrintRunInfo();
+        void lazyPrintGroupInfo();
+        void printTestCaseAndSectionHeader();
+
+        void printClosedHeader(std::string const& _name);
+        void printOpenHeader(std::string const& _name);
+
+        // if string has a : in first line will set indent to follow it on
+        // subsequent lines
+        void printHeaderString(std::string const& _string, std::size_t indent = 0);
+
+        void printTotals(Totals const& totals);
+        void printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row);
+
+        void printTotalsDivider(Totals const& totals);
+        void printSummaryDivider();
+        void printTestFilters();
+
+    private:
+        bool m_headerPrinted = false;
+    };
+
+} // end namespace Catch
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+// end catch_reporter_console.h
+// start catch_reporter_junit.h
+
+// start catch_xmlwriter.h
+
+#include <vector>
+
+namespace Catch {
+    enum class XmlFormatting {
+        None = 0x00,
+        Indent = 0x01,
+        Newline = 0x02,
+    };
+
+    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs);
+    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs);
+
+    class XmlEncode {
+    public:
+        enum ForWhat { ForTextNodes, ForAttributes };
+
+        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );
+
+        void encodeTo( std::ostream& os ) const;
+
+        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );
+
+    private:
+        std::string m_str;
+        ForWhat m_forWhat;
+    };
+
+    class XmlWriter {
+    public:
+
+        class ScopedElement {
+        public:
+            ScopedElement( XmlWriter* writer, XmlFormatting fmt );
+
+            ScopedElement( ScopedElement&& other ) noexcept;
+            ScopedElement& operator=( ScopedElement&& other ) noexcept;
+
+            ~ScopedElement();
+
+            ScopedElement& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent );
+
+            template<typename T>
+            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
+                m_writer->writeAttribute( name, attribute );
+                return *this;
+            }
+
+        private:
+            mutable XmlWriter* m_writer = nullptr;
+            XmlFormatting m_fmt;
+        };
+
+        XmlWriter( std::ostream& os = Catch::cout() );
+        ~XmlWriter();
+
+        XmlWriter( XmlWriter const& ) = delete;
+        XmlWriter& operator=( XmlWriter const& ) = delete;
+
+        XmlWriter& startElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
+
+        ScopedElement scopedElement( std::string const& name, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
+
+        XmlWriter& endElement(XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
+
+        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );
+
+        XmlWriter& writeAttribute( std::string const& name, bool attribute );
+
+        template<typename T>
+        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
+            ReusableStringStream rss;
+            rss << attribute;
+            return writeAttribute( name, rss.str() );
+        }
+
+        XmlWriter& writeText( std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
+
+        XmlWriter& writeComment(std::string const& text, XmlFormatting fmt = XmlFormatting::Newline | XmlFormatting::Indent);
+
+        void writeStylesheetRef( std::string const& url );
+
+        XmlWriter& writeBlankLine();
+
+        void ensureTagClosed();
+
+    private:
+
+        void applyFormatting(XmlFormatting fmt);
+
+        void writeDeclaration();
+
+        void newlineIfNecessary();
+
+        bool m_tagIsOpen = false;
+        bool m_needsNewline = false;
+        std::vector<std::string> m_tags;
+        std::string m_indent;
+        std::ostream& m_os;
+    };
+
+}
+
+// end catch_xmlwriter.h
+namespace Catch {
+
+    class JunitReporter : public CumulativeReporterBase<JunitReporter> {
+    public:
+        JunitReporter(ReporterConfig const& _config);
+
+        ~JunitReporter() override;
+
+        static std::string getDescription();
+
+        void noMatchingTestCases(std::string const& /*spec*/) override;
+
+        void testRunStarting(TestRunInfo const& runInfo) override;
+
+        void testGroupStarting(GroupInfo const& groupInfo) override;
+
+        void testCaseStarting(TestCaseInfo const& testCaseInfo) override;
+        bool assertionEnded(AssertionStats const& assertionStats) override;
+
+        void testCaseEnded(TestCaseStats const& testCaseStats) override;
+
+        void testGroupEnded(TestGroupStats const& testGroupStats) override;
+
+        void testRunEndedCumulative() override;
+
+        void writeGroup(TestGroupNode const& groupNode, double suiteTime);
+
+        void writeTestCase(TestCaseNode const& testCaseNode);
+
+        void writeSection(std::string const& className,
+                          std::string const& rootName,
+                          SectionNode const& sectionNode);
+
+        void writeAssertions(SectionNode const& sectionNode);
+        void writeAssertion(AssertionStats const& stats);
+
+        XmlWriter xml;
+        Timer suiteTimer;
+        std::string stdOutForSuite;
+        std::string stdErrForSuite;
+        unsigned int unexpectedExceptions = 0;
+        bool m_okToFail = false;
+    };
+
+} // end namespace Catch
+
+// end catch_reporter_junit.h
+// start catch_reporter_xml.h
+
+namespace Catch {
+    class XmlReporter : public StreamingReporterBase<XmlReporter> {
+    public:
+        XmlReporter(ReporterConfig const& _config);
+
+        ~XmlReporter() override;
+
+        static std::string getDescription();
+
+        virtual std::string getStylesheetRef() const;
+
+        void writeSourceInfo(SourceLineInfo const& sourceInfo);
+
+    public: // StreamingReporterBase
+
+        void noMatchingTestCases(std::string const& s) override;
+
+        void testRunStarting(TestRunInfo const& testInfo) override;
+
+        void testGroupStarting(GroupInfo const& groupInfo) override;
+
+        void testCaseStarting(TestCaseInfo const& testInfo) override;
+
+        void sectionStarting(SectionInfo const& sectionInfo) override;
+
+        void assertionStarting(AssertionInfo const&) override;
+
+        bool assertionEnded(AssertionStats const& assertionStats) override;
+
+        void sectionEnded(SectionStats const& sectionStats) override;
+
+        void testCaseEnded(TestCaseStats const& testCaseStats) override;
+
+        void testGroupEnded(TestGroupStats const& testGroupStats) override;
+
+        void testRunEnded(TestRunStats const& testRunStats) override;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        void benchmarkPreparing(std::string const& name) override;
+        void benchmarkStarting(BenchmarkInfo const&) override;
+        void benchmarkEnded(BenchmarkStats<> const&) override;
+        void benchmarkFailed(std::string const&) override;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    private:
+        Timer m_testCaseTimer;
+        XmlWriter m_xml;
+        int m_sectionDepth = 0;
+    };
+
+} // end namespace Catch
+
+// end catch_reporter_xml.h
+
+// end catch_external_interfaces.h
+#endif
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+// start catch_benchmarking_all.hpp
+
+// A proxy header that includes all of the benchmarking headers to allow
+// concise include of the benchmarking features. You should prefer the
+// individual includes in standard use.
+
+// start catch_benchmark.hpp
+
+ // Benchmark
+
+// start catch_chronometer.hpp
+
+// User-facing chronometer
+
+
+// start catch_clock.hpp
+
+// Clocks
+
+
+#include <chrono>
+#include <ratio>
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Clock>
+        using ClockDuration = typename Clock::duration;
+        template <typename Clock>
+        using FloatDuration = std::chrono::duration<double, typename Clock::period>;
+
+        template <typename Clock>
+        using TimePoint = typename Clock::time_point;
+
+        using default_clock = std::chrono::steady_clock;
+
+        template <typename Clock>
+        struct now {
+            TimePoint<Clock> operator()() const {
+                return Clock::now();
+            }
+        };
+
+        using fp_seconds = std::chrono::duration<double, std::ratio<1>>;
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_clock.hpp
+// start catch_optimizer.hpp
+
+ // Hinting the optimizer
+
+
+#if defined(_MSC_VER)
+#   include <atomic> // atomic_thread_fence
+#endif
+
+namespace Catch {
+    namespace Benchmark {
+#if defined(__GNUC__) || defined(__clang__)
+        template <typename T>
+        inline void keep_memory(T* p) {
+            asm volatile("" : : "g"(p) : "memory");
+        }
+        inline void keep_memory() {
+            asm volatile("" : : : "memory");
+        }
+
+        namespace Detail {
+            inline void optimizer_barrier() { keep_memory(); }
+        } // namespace Detail
+#elif defined(_MSC_VER)
+
+#pragma optimize("", off)
+        template <typename T>
+        inline void keep_memory(T* p) {
+            // thanks @milleniumbug
+            *reinterpret_cast<char volatile*>(p) = *reinterpret_cast<char const volatile*>(p);
+        }
+        // TODO equivalent keep_memory()
+#pragma optimize("", on)
+
+        namespace Detail {
+            inline void optimizer_barrier() {
+                std::atomic_thread_fence(std::memory_order_seq_cst);
+            }
+        } // namespace Detail
+
+#endif
+
+        template <typename T>
+        inline void deoptimize_value(T&& x) {
+            keep_memory(&x);
+        }
+
+        template <typename Fn, typename... Args>
+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<!std::is_same<void, decltype(fn(args...))>::value>::type {
+            deoptimize_value(std::forward<Fn>(fn) (std::forward<Args...>(args...)));
+        }
+
+        template <typename Fn, typename... Args>
+        inline auto invoke_deoptimized(Fn&& fn, Args&&... args) -> typename std::enable_if<std::is_same<void, decltype(fn(args...))>::value>::type {
+            std::forward<Fn>(fn) (std::forward<Args...>(args...));
+        }
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_optimizer.hpp
+// start catch_complete_invoke.hpp
+
+// Invoke with a special case for void
+
+
+#include <type_traits>
+#include <utility>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename T>
+            struct CompleteType { using type = T; };
+            template <>
+            struct CompleteType<void> { struct type {}; };
+
+            template <typename T>
+            using CompleteType_t = typename CompleteType<T>::type;
+
+            template <typename Result>
+            struct CompleteInvoker {
+                template <typename Fun, typename... Args>
+                static Result invoke(Fun&& fun, Args&&... args) {
+                    return std::forward<Fun>(fun)(std::forward<Args>(args)...);
+                }
+            };
+            template <>
+            struct CompleteInvoker<void> {
+                template <typename Fun, typename... Args>
+                static CompleteType_t<void> invoke(Fun&& fun, Args&&... args) {
+                    std::forward<Fun>(fun)(std::forward<Args>(args)...);
+                    return {};
+                }
+            };
+            template <typename Sig>
+            using ResultOf_t = typename std::result_of<Sig>::type;
+
+            // invoke and not return void :(
+            template <typename Fun, typename... Args>
+            CompleteType_t<ResultOf_t<Fun(Args...)>> complete_invoke(Fun&& fun, Args&&... args) {
+                return CompleteInvoker<ResultOf_t<Fun(Args...)>>::invoke(std::forward<Fun>(fun), std::forward<Args>(args)...);
+            }
+
+            const std::string benchmarkErrorMsg = "a benchmark failed to run successfully";
+        } // namespace Detail
+
+        template <typename Fun>
+        Detail::CompleteType_t<Detail::ResultOf_t<Fun()>> user_code(Fun&& fun) {
+            CATCH_TRY{
+                return Detail::complete_invoke(std::forward<Fun>(fun));
+            } CATCH_CATCH_ALL{
+                getResultCapture().benchmarkFailed(translateActiveException());
+                CATCH_RUNTIME_ERROR(Detail::benchmarkErrorMsg);
+            }
+        }
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_complete_invoke.hpp
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            struct ChronometerConcept {
+                virtual void start() = 0;
+                virtual void finish() = 0;
+                virtual ~ChronometerConcept() = default;
+            };
+            template <typename Clock>
+            struct ChronometerModel final : public ChronometerConcept {
+                void start() override { started = Clock::now(); }
+                void finish() override { finished = Clock::now(); }
+
+                ClockDuration<Clock> elapsed() const { return finished - started; }
+
+                TimePoint<Clock> started;
+                TimePoint<Clock> finished;
+            };
+        } // namespace Detail
+
+        struct Chronometer {
+        public:
+            template <typename Fun>
+            void measure(Fun&& fun) { measure(std::forward<Fun>(fun), is_callable<Fun(int)>()); }
+
+            int runs() const { return k; }
+
+            Chronometer(Detail::ChronometerConcept& meter, int k)
+                : impl(&meter)
+                , k(k) {}
+
+        private:
+            template <typename Fun>
+            void measure(Fun&& fun, std::false_type) {
+                measure([&fun](int) { return fun(); }, std::true_type());
+            }
+
+            template <typename Fun>
+            void measure(Fun&& fun, std::true_type) {
+                Detail::optimizer_barrier();
+                impl->start();
+                for (int i = 0; i < k; ++i) invoke_deoptimized(fun, i);
+                impl->finish();
+                Detail::optimizer_barrier();
+            }
+
+            Detail::ChronometerConcept* impl;
+            int k;
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_chronometer.hpp
+// start catch_environment.hpp
+
+// Environment information
+
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Duration>
+        struct EnvironmentEstimate {
+            Duration mean;
+            OutlierClassification outliers;
+
+            template <typename Duration2>
+            operator EnvironmentEstimate<Duration2>() const {
+                return { mean, outliers };
+            }
+        };
+        template <typename Clock>
+        struct Environment {
+            using clock_type = Clock;
+            EnvironmentEstimate<FloatDuration<Clock>> clock_resolution;
+            EnvironmentEstimate<FloatDuration<Clock>> clock_cost;
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_environment.hpp
+// start catch_execution_plan.hpp
+
+ // Execution plan
+
+
+// start catch_benchmark_function.hpp
+
+ // Dumb std::function implementation for consistent call overhead
+
+
+#include <cassert>
+#include <type_traits>
+#include <utility>
+#include <memory>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename T>
+            using Decay = typename std::decay<T>::type;
+            template <typename T, typename U>
+            struct is_related
+                : std::is_same<Decay<T>, Decay<U>> {};
+
+            /// We need to reinvent std::function because every piece of code that might add overhead
+            /// in a measurement context needs to have consistent performance characteristics so that we
+            /// can account for it in the measurement.
+            /// Implementations of std::function with optimizations that aren't always applicable, like
+            /// small buffer optimizations, are not uncommon.
+            /// This is effectively an implementation of std::function without any such optimizations;
+            /// it may be slow, but it is consistently slow.
+            struct BenchmarkFunction {
+            private:
+                struct callable {
+                    virtual void call(Chronometer meter) const = 0;
+                    virtual callable* clone() const = 0;
+                    virtual ~callable() = default;
+                };
+                template <typename Fun>
+                struct model : public callable {
+                    model(Fun&& fun) : fun(std::move(fun)) {}
+                    model(Fun const& fun) : fun(fun) {}
+
+                    model<Fun>* clone() const override { return new model<Fun>(*this); }
+
+                    void call(Chronometer meter) const override {
+                        call(meter, is_callable<Fun(Chronometer)>());
+                    }
+                    void call(Chronometer meter, std::true_type) const {
+                        fun(meter);
+                    }
+                    void call(Chronometer meter, std::false_type) const {
+                        meter.measure(fun);
+                    }
+
+                    Fun fun;
+                };
+
+                struct do_nothing { void operator()() const {} };
+
+                template <typename T>
+                BenchmarkFunction(model<T>* c) : f(c) {}
+
+            public:
+                BenchmarkFunction()
+                    : f(new model<do_nothing>{ {} }) {}
+
+                template <typename Fun,
+                    typename std::enable_if<!is_related<Fun, BenchmarkFunction>::value, int>::type = 0>
+                    BenchmarkFunction(Fun&& fun)
+                    : f(new model<typename std::decay<Fun>::type>(std::forward<Fun>(fun))) {}
+
+                BenchmarkFunction(BenchmarkFunction&& that)
+                    : f(std::move(that.f)) {}
+
+                BenchmarkFunction(BenchmarkFunction const& that)
+                    : f(that.f->clone()) {}
+
+                BenchmarkFunction& operator=(BenchmarkFunction&& that) {
+                    f = std::move(that.f);
+                    return *this;
+                }
+
+                BenchmarkFunction& operator=(BenchmarkFunction const& that) {
+                    f.reset(that.f->clone());
+                    return *this;
+                }
+
+                void operator()(Chronometer meter) const { f->call(meter); }
+
+            private:
+                std::unique_ptr<callable> f;
+            };
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_benchmark_function.hpp
+// start catch_repeat.hpp
+
+// repeat algorithm
+
+
+#include <type_traits>
+#include <utility>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename Fun>
+            struct repeater {
+                void operator()(int k) const {
+                    for (int i = 0; i < k; ++i) {
+                        fun();
+                    }
+                }
+                Fun fun;
+            };
+            template <typename Fun>
+            repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {
+                return { std::forward<Fun>(fun) };
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_repeat.hpp
+// start catch_run_for_at_least.hpp
+
+// Run a function for a minimum amount of time
+
+
+// start catch_measure.hpp
+
+// Measure
+
+
+// start catch_timing.hpp
+
+// Timing
+
+
+#include <tuple>
+#include <type_traits>
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Duration, typename Result>
+        struct Timing {
+            Duration elapsed;
+            Result result;
+            int iterations;
+        };
+        template <typename Clock, typename Sig>
+        using TimingOf = Timing<ClockDuration<Clock>, Detail::CompleteType_t<Detail::ResultOf_t<Sig>>>;
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_timing.hpp
+#include <utility>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename Clock, typename Fun, typename... Args>
+            TimingOf<Clock, Fun(Args...)> measure(Fun&& fun, Args&&... args) {
+                auto start = Clock::now();
+                auto&& r = Detail::complete_invoke(fun, std::forward<Args>(args)...);
+                auto end = Clock::now();
+                auto delta = end - start;
+                return { delta, std::forward<decltype(r)>(r), 1 };
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_measure.hpp
+#include <utility>
+#include <type_traits>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename Clock, typename Fun>
+            TimingOf<Clock, Fun(int)> measure_one(Fun&& fun, int iters, std::false_type) {
+                return Detail::measure<Clock>(fun, iters);
+            }
+            template <typename Clock, typename Fun>
+            TimingOf<Clock, Fun(Chronometer)> measure_one(Fun&& fun, int iters, std::true_type) {
+                Detail::ChronometerModel<Clock> meter;
+                auto&& result = Detail::complete_invoke(fun, Chronometer(meter, iters));
+
+                return { meter.elapsed(), std::move(result), iters };
+            }
+
+            template <typename Clock, typename Fun>
+            using run_for_at_least_argument_t = typename std::conditional<is_callable<Fun(Chronometer)>::value, Chronometer, int>::type;
+
+            struct optimized_away_error : std::exception {
+                const char* what() const noexcept override {
+                    return "could not measure benchmark, maybe it was optimized away";
+                }
+            };
+
+            template <typename Clock, typename Fun>
+            TimingOf<Clock, Fun(run_for_at_least_argument_t<Clock, Fun>)> run_for_at_least(ClockDuration<Clock> how_long, int seed, Fun&& fun) {
+                auto iters = seed;
+                while (iters < (1 << 30)) {
+                    auto&& Timing = measure_one<Clock>(fun, iters, is_callable<Fun(Chronometer)>());
+
+                    if (Timing.elapsed >= how_long) {
+                        return { Timing.elapsed, std::move(Timing.result), iters };
+                    }
+                    iters *= 2;
+                }
+                throw optimized_away_error{};
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_run_for_at_least.hpp
+#include <algorithm>
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Duration>
+        struct ExecutionPlan {
+            int iterations_per_sample;
+            Duration estimated_duration;
+            Detail::BenchmarkFunction benchmark;
+            Duration warmup_time;
+            int warmup_iterations;
+
+            template <typename Duration2>
+            operator ExecutionPlan<Duration2>() const {
+                return { iterations_per_sample, estimated_duration, benchmark, warmup_time, warmup_iterations };
+            }
+
+            template <typename Clock>
+            std::vector<FloatDuration<Clock>> run(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
+                // warmup a bit
+                Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_iterations, Detail::repeat(now<Clock>{}));
+
+                std::vector<FloatDuration<Clock>> times;
+                times.reserve(cfg.benchmarkSamples());
+                std::generate_n(std::back_inserter(times), cfg.benchmarkSamples(), [this, env] {
+                    Detail::ChronometerModel<Clock> model;
+                    this->benchmark(Chronometer(model, iterations_per_sample));
+                    auto sample_time = model.elapsed() - env.clock_cost.mean;
+                    if (sample_time < FloatDuration<Clock>::zero()) sample_time = FloatDuration<Clock>::zero();
+                    return sample_time / iterations_per_sample;
+                });
+                return times;
+            }
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_execution_plan.hpp
+// start catch_estimate_clock.hpp
+
+ // Environment measurement
+
+
+// start catch_stats.hpp
+
+// Statistical analysis tools
+
+
+#include <algorithm>
+#include <functional>
+#include <vector>
+#include <iterator>
+#include <numeric>
+#include <tuple>
+#include <cmath>
+#include <utility>
+#include <cstddef>
+#include <random>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            using sample = std::vector<double>;
+
+            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last);
+
+            template <typename Iterator>
+            OutlierClassification classify_outliers(Iterator first, Iterator last) {
+                std::vector<double> copy(first, last);
+
+                auto q1 = weighted_average_quantile(1, 4, copy.begin(), copy.end());
+                auto q3 = weighted_average_quantile(3, 4, copy.begin(), copy.end());
+                auto iqr = q3 - q1;
+                auto los = q1 - (iqr * 3.);
+                auto lom = q1 - (iqr * 1.5);
+                auto him = q3 + (iqr * 1.5);
+                auto his = q3 + (iqr * 3.);
+
+                OutlierClassification o;
+                for (; first != last; ++first) {
+                    auto&& t = *first;
+                    if (t < los) ++o.low_severe;
+                    else if (t < lom) ++o.low_mild;
+                    else if (t > his) ++o.high_severe;
+                    else if (t > him) ++o.high_mild;
+                    ++o.samples_seen;
+                }
+                return o;
+            }
+
+            template <typename Iterator>
+            double mean(Iterator first, Iterator last) {
+                auto count = last - first;
+                double sum = std::accumulate(first, last, 0.);
+                return sum / count;
+            }
+
+            template <typename URng, typename Iterator, typename Estimator>
+            sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {
+                auto n = last - first;
+                std::uniform_int_distribution<decltype(n)> dist(0, n - 1);
+
+                sample out;
+                out.reserve(resamples);
+                std::generate_n(std::back_inserter(out), resamples, [n, first, &estimator, &dist, &rng] {
+                    std::vector<double> resampled;
+                    resampled.reserve(n);
+                    std::generate_n(std::back_inserter(resampled), n, [first, &dist, &rng] { return first[dist(rng)]; });
+                    return estimator(resampled.begin(), resampled.end());
+                });
+                std::sort(out.begin(), out.end());
+                return out;
+            }
+
+            template <typename Estimator, typename Iterator>
+            sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {
+                auto n = last - first;
+                auto second = std::next(first);
+                sample results;
+                results.reserve(n);
+
+                for (auto it = first; it != last; ++it) {
+                    std::iter_swap(it, first);
+                    results.push_back(estimator(second, last));
+                }
+
+                return results;
+            }
+
+            inline double normal_cdf(double x) {
+                return std::erfc(-x / std::sqrt(2.0)) / 2.0;
+            }
+
+            double erfc_inv(double x);
+
+            double normal_quantile(double p);
+
+            template <typename Iterator, typename Estimator>
+            Estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {
+                auto n_samples = last - first;
+
+                double point = estimator(first, last);
+                // Degenerate case with a single sample
+                if (n_samples == 1) return { point, point, point, confidence_level };
+
+                sample jack = jackknife(estimator, first, last);
+                double jack_mean = mean(jack.begin(), jack.end());
+                double sum_squares, sum_cubes;
+                std::tie(sum_squares, sum_cubes) = std::accumulate(jack.begin(), jack.end(), std::make_pair(0., 0.), [jack_mean](std::pair<double, double> sqcb, double x) -> std::pair<double, double> {
+                    auto d = jack_mean - x;
+                    auto d2 = d * d;
+                    auto d3 = d2 * d;
+                    return { sqcb.first + d2, sqcb.second + d3 };
+                });
+
+                double accel = sum_cubes / (6 * std::pow(sum_squares, 1.5));
+                int n = static_cast<int>(resample.size());
+                double prob_n = std::count_if(resample.begin(), resample.end(), [point](double x) { return x < point; }) / (double)n;
+                // degenerate case with uniform samples
+                if (prob_n == 0) return { point, point, point, confidence_level };
+
+                double bias = normal_quantile(prob_n);
+                double z1 = normal_quantile((1. - confidence_level) / 2.);
+
+                auto cumn = [n](double x) -> int {
+                    return std::lround(normal_cdf(x) * n); };
+                auto a = [bias, accel](double b) { return bias + b / (1. - accel * b); };
+                double b1 = bias + z1;
+                double b2 = bias - z1;
+                double a1 = a(b1);
+                double a2 = a(b2);
+                auto lo = std::max(cumn(a1), 0);
+                auto hi = std::min(cumn(a2), n - 1);
+
+                return { point, resample[lo], resample[hi], confidence_level };
+            }
+
+            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n);
+
+            struct bootstrap_analysis {
+                Estimate<double> mean;
+                Estimate<double> standard_deviation;
+                double outlier_variance;
+            };
+
+            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last);
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_stats.hpp
+#include <algorithm>
+#include <iterator>
+#include <tuple>
+#include <vector>
+#include <cmath>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename Clock>
+            std::vector<double> resolution(int k) {
+                std::vector<TimePoint<Clock>> times;
+                times.reserve(k + 1);
+                std::generate_n(std::back_inserter(times), k + 1, now<Clock>{});
+
+                std::vector<double> deltas;
+                deltas.reserve(k);
+                std::transform(std::next(times.begin()), times.end(), times.begin(),
+                    std::back_inserter(deltas),
+                    [](TimePoint<Clock> a, TimePoint<Clock> b) { return static_cast<double>((a - b).count()); });
+
+                return deltas;
+            }
+
+            const auto warmup_iterations = 10000;
+            const auto warmup_time = std::chrono::milliseconds(100);
+            const auto minimum_ticks = 1000;
+            const auto warmup_seed = 10000;
+            const auto clock_resolution_estimation_time = std::chrono::milliseconds(500);
+            const auto clock_cost_estimation_time_limit = std::chrono::seconds(1);
+            const auto clock_cost_estimation_tick_limit = 100000;
+            const auto clock_cost_estimation_time = std::chrono::milliseconds(10);
+            const auto clock_cost_estimation_iterations = 10000;
+
+            template <typename Clock>
+            int warmup() {
+                return run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(warmup_time), warmup_seed, &resolution<Clock>)
+                    .iterations;
+            }
+            template <typename Clock>
+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {
+                auto r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_resolution_estimation_time), iterations, &resolution<Clock>)
+                    .result;
+                return {
+                    FloatDuration<Clock>(mean(r.begin(), r.end())),
+                    classify_outliers(r.begin(), r.end()),
+                };
+            }
+            template <typename Clock>
+            EnvironmentEstimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {
+                auto time_limit = std::min(resolution * clock_cost_estimation_tick_limit, FloatDuration<Clock>(clock_cost_estimation_time_limit));
+                auto time_clock = [](int k) {
+                    return Detail::measure<Clock>([k] {
+                        for (int i = 0; i < k; ++i) {
+                            volatile auto ignored = Clock::now();
+                            (void)ignored;
+                        }
+                    }).elapsed;
+                };
+                time_clock(1);
+                int iters = clock_cost_estimation_iterations;
+                auto&& r = run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(clock_cost_estimation_time), iters, time_clock);
+                std::vector<double> times;
+                int nsamples = static_cast<int>(std::ceil(time_limit / r.elapsed));
+                times.reserve(nsamples);
+                std::generate_n(std::back_inserter(times), nsamples, [time_clock, &r] {
+                    return static_cast<double>((time_clock(r.iterations) / r.iterations).count());
+                });
+                return {
+                    FloatDuration<Clock>(mean(times.begin(), times.end())),
+                    classify_outliers(times.begin(), times.end()),
+                };
+            }
+
+            template <typename Clock>
+            Environment<FloatDuration<Clock>> measure_environment() {
+                static Environment<FloatDuration<Clock>>* env = nullptr;
+                if (env) {
+                    return *env;
+                }
+
+                auto iters = Detail::warmup<Clock>();
+                auto resolution = Detail::estimate_clock_resolution<Clock>(iters);
+                auto cost = Detail::estimate_clock_cost<Clock>(resolution.mean);
+
+                env = new Environment<FloatDuration<Clock>>{ resolution, cost };
+                return *env;
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_estimate_clock.hpp
+// start catch_analyse.hpp
+
+ // Run and analyse one benchmark
+
+
+// start catch_sample_analysis.hpp
+
+// Benchmark results
+
+
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <iterator>
+
+namespace Catch {
+    namespace Benchmark {
+        template <typename Duration>
+        struct SampleAnalysis {
+            std::vector<Duration> samples;
+            Estimate<Duration> mean;
+            Estimate<Duration> standard_deviation;
+            OutlierClassification outliers;
+            double outlier_variance;
+
+            template <typename Duration2>
+            operator SampleAnalysis<Duration2>() const {
+                std::vector<Duration2> samples2;
+                samples2.reserve(samples.size());
+                std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](Duration d) { return Duration2(d); });
+                return {
+                    std::move(samples2),
+                    mean,
+                    standard_deviation,
+                    outliers,
+                    outlier_variance,
+                };
+            }
+        };
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_sample_analysis.hpp
+#include <algorithm>
+#include <iterator>
+#include <vector>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename Duration, typename Iterator>
+            SampleAnalysis<Duration> analyse(const IConfig &cfg, Environment<Duration>, Iterator first, Iterator last) {
+                if (!cfg.benchmarkNoAnalysis()) {
+                    std::vector<double> samples;
+                    samples.reserve(last - first);
+                    std::transform(first, last, std::back_inserter(samples), [](Duration d) { return d.count(); });
+
+                    auto analysis = Catch::Benchmark::Detail::analyse_samples(cfg.benchmarkConfidenceInterval(), cfg.benchmarkResamples(), samples.begin(), samples.end());
+                    auto outliers = Catch::Benchmark::Detail::classify_outliers(samples.begin(), samples.end());
+
+                    auto wrap_estimate = [](Estimate<double> e) {
+                        return Estimate<Duration> {
+                            Duration(e.point),
+                                Duration(e.lower_bound),
+                                Duration(e.upper_bound),
+                                e.confidence_interval,
+                        };
+                    };
+                    std::vector<Duration> samples2;
+                    samples2.reserve(samples.size());
+                    std::transform(samples.begin(), samples.end(), std::back_inserter(samples2), [](double d) { return Duration(d); });
+                    return {
+                        std::move(samples2),
+                        wrap_estimate(analysis.mean),
+                        wrap_estimate(analysis.standard_deviation),
+                        outliers,
+                        analysis.outlier_variance,
+                    };
+                } else {
+                    std::vector<Duration> samples;
+                    samples.reserve(last - first);
+
+                    Duration mean = Duration(0);
+                    int i = 0;
+                    for (auto it = first; it < last; ++it, ++i) {
+                        samples.push_back(Duration(*it));
+                        mean += Duration(*it);
+                    }
+                    mean /= i;
+
+                    return {
+                        std::move(samples),
+                        Estimate<Duration>{mean, mean, mean, 0.0},
+                        Estimate<Duration>{Duration(0), Duration(0), Duration(0), 0.0},
+                        OutlierClassification{},
+                        0.0
+                    };
+                }
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+// end catch_analyse.hpp
+#include <algorithm>
+#include <functional>
+#include <string>
+#include <vector>
+#include <cmath>
+
+namespace Catch {
+    namespace Benchmark {
+        struct Benchmark {
+            Benchmark(std::string &&name)
+                : name(std::move(name)) {}
+
+            template <class FUN>
+            Benchmark(std::string &&name, FUN &&func)
+                : fun(std::move(func)), name(std::move(name)) {}
+
+            template <typename Clock>
+            ExecutionPlan<FloatDuration<Clock>> prepare(const IConfig &cfg, Environment<FloatDuration<Clock>> env) const {
+                auto min_time = env.clock_resolution.mean * Detail::minimum_ticks;
+                auto run_time = std::max(min_time, std::chrono::duration_cast<decltype(min_time)>(cfg.benchmarkWarmupTime()));
+                auto&& test = Detail::run_for_at_least<Clock>(std::chrono::duration_cast<ClockDuration<Clock>>(run_time), 1, fun);
+                int new_iters = static_cast<int>(std::ceil(min_time * test.iterations / test.elapsed));
+                return { new_iters, test.elapsed / test.iterations * new_iters * cfg.benchmarkSamples(), fun, std::chrono::duration_cast<FloatDuration<Clock>>(cfg.benchmarkWarmupTime()), Detail::warmup_iterations };
+            }
+
+            template <typename Clock = default_clock>
+            void run() {
+                IConfigPtr cfg = getCurrentContext().getConfig();
+
+                auto env = Detail::measure_environment<Clock>();
+
+                getResultCapture().benchmarkPreparing(name);
+                CATCH_TRY{
+                    auto plan = user_code([&] {
+                        return prepare<Clock>(*cfg, env);
+                    });
+
+                    BenchmarkInfo info {
+                        name,
+                        plan.estimated_duration.count(),
+                        plan.iterations_per_sample,
+                        cfg->benchmarkSamples(),
+                        cfg->benchmarkResamples(),
+                        env.clock_resolution.mean.count(),
+                        env.clock_cost.mean.count()
+                    };
+
+                    getResultCapture().benchmarkStarting(info);
+
+                    auto samples = user_code([&] {
+                        return plan.template run<Clock>(*cfg, env);
+                    });
+
+                    auto analysis = Detail::analyse(*cfg, env, samples.begin(), samples.end());
+                    BenchmarkStats<FloatDuration<Clock>> stats{ info, analysis.samples, analysis.mean, analysis.standard_deviation, analysis.outliers, analysis.outlier_variance };
+                    getResultCapture().benchmarkEnded(stats);
+
+                } CATCH_CATCH_ALL{
+                    if (translateActiveException() != Detail::benchmarkErrorMsg) // benchmark errors have been reported, otherwise rethrow.
+                        std::rethrow_exception(std::current_exception());
+                }
+            }
+
+            // sets lambda to be used in fun *and* executes benchmark!
+            template <typename Fun,
+                typename std::enable_if<!Detail::is_related<Fun, Benchmark>::value, int>::type = 0>
+                Benchmark & operator=(Fun func) {
+                fun = Detail::BenchmarkFunction(func);
+                run();
+                return *this;
+            }
+
+            explicit operator bool() {
+                return true;
+            }
+
+        private:
+            Detail::BenchmarkFunction fun;
+            std::string name;
+        };
+    }
+} // namespace Catch
+
+#define INTERNAL_CATCH_GET_1_ARG(arg1, arg2, ...) arg1
+#define INTERNAL_CATCH_GET_2_ARG(arg1, arg2, ...) arg2
+
+#define INTERNAL_CATCH_BENCHMARK(BenchmarkName, name, benchmarkIndex)\
+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
+        BenchmarkName = [&](int benchmarkIndex)
+
+#define INTERNAL_CATCH_BENCHMARK_ADVANCED(BenchmarkName, name)\
+    if( Catch::Benchmark::Benchmark BenchmarkName{name} ) \
+        BenchmarkName = [&]
+
+// end catch_benchmark.hpp
+// start catch_constructor.hpp
+
+// Constructor and destructor helpers
+
+
+#include <type_traits>
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+            template <typename T, bool Destruct>
+            struct ObjectStorage
+            {
+                using TStorage = typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type;
+
+                ObjectStorage() : data() {}
+
+                ObjectStorage(const ObjectStorage& other)
+                {
+                    new(&data) T(other.stored_object());
+                }
+
+                ObjectStorage(ObjectStorage&& other)
+                {
+                    new(&data) T(std::move(other.stored_object()));
+                }
+
+                ~ObjectStorage() { destruct_on_exit<T>(); }
+
+                template <typename... Args>
+                void construct(Args&&... args)
+                {
+                    new (&data) T(std::forward<Args>(args)...);
+                }
+
+                template <bool AllowManualDestruction = !Destruct>
+                typename std::enable_if<AllowManualDestruction>::type destruct()
+                {
+                    stored_object().~T();
+                }
+
+            private:
+                // If this is a constructor benchmark, destruct the underlying object
+                template <typename U>
+                void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }
+                // Otherwise, don't
+                template <typename U>
+                void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }
+
+                T& stored_object() {
+                    return *static_cast<T*>(static_cast<void*>(&data));
+                }
+
+                T const& stored_object() const {
+                    return *static_cast<T*>(static_cast<void*>(&data));
+                }
+
+                TStorage data;
+            };
+        }
+
+        template <typename T>
+        using storage_for = Detail::ObjectStorage<T, true>;
+
+        template <typename T>
+        using destructable_object = Detail::ObjectStorage<T, false>;
+    }
+}
+
+// end catch_constructor.hpp
+// end catch_benchmarking_all.hpp
+#endif
+
+#endif // ! CATCH_CONFIG_IMPL_ONLY
+
+#ifdef CATCH_IMPL
+// start catch_impl.hpp
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wweak-vtables"
+#endif
+
+// Keep these here for external reporters
+// start catch_test_case_tracker.h
+
+#include <string>
+#include <vector>
+#include <memory>
+
+namespace Catch {
+namespace TestCaseTracking {
+
+    struct NameAndLocation {
+        std::string name;
+        SourceLineInfo location;
+
+        NameAndLocation( std::string const& _name, SourceLineInfo const& _location );
+    };
+
+    struct ITracker;
+
+    using ITrackerPtr = std::shared_ptr<ITracker>;
+
+    struct ITracker {
+        virtual ~ITracker();
+
+        // static queries
+        virtual NameAndLocation const& nameAndLocation() const = 0;
+
+        // dynamic queries
+        virtual bool isComplete() const = 0; // Successfully completed or failed
+        virtual bool isSuccessfullyCompleted() const = 0;
+        virtual bool isOpen() const = 0; // Started but not complete
+        virtual bool hasChildren() const = 0;
+
+        virtual ITracker& parent() = 0;
+
+        // actions
+        virtual void close() = 0; // Successfully complete
+        virtual void fail() = 0;
+        virtual void markAsNeedingAnotherRun() = 0;
+
+        virtual void addChild( ITrackerPtr const& child ) = 0;
+        virtual ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) = 0;
+        virtual void openChild() = 0;
+
+        // Debug/ checking
+        virtual bool isSectionTracker() const = 0;
+        virtual bool isGeneratorTracker() const = 0;
+    };
+
+    class TrackerContext {
+
+        enum RunState {
+            NotStarted,
+            Executing,
+            CompletedCycle
+        };
+
+        ITrackerPtr m_rootTracker;
+        ITracker* m_currentTracker = nullptr;
+        RunState m_runState = NotStarted;
+
+    public:
+
+        ITracker& startRun();
+        void endRun();
+
+        void startCycle();
+        void completeCycle();
+
+        bool completedCycle() const;
+        ITracker& currentTracker();
+        void setCurrentTracker( ITracker* tracker );
+    };
+
+    class TrackerBase : public ITracker {
+    protected:
+        enum CycleState {
+            NotStarted,
+            Executing,
+            ExecutingChildren,
+            NeedsAnotherRun,
+            CompletedSuccessfully,
+            Failed
+        };
+
+        using Children = std::vector<ITrackerPtr>;
+        NameAndLocation m_nameAndLocation;
+        TrackerContext& m_ctx;
+        ITracker* m_parent;
+        Children m_children;
+        CycleState m_runState = NotStarted;
+
+    public:
+        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
+
+        NameAndLocation const& nameAndLocation() const override;
+        bool isComplete() const override;
+        bool isSuccessfullyCompleted() const override;
+        bool isOpen() const override;
+        bool hasChildren() const override;
+
+        void addChild( ITrackerPtr const& child ) override;
+
+        ITrackerPtr findChild( NameAndLocation const& nameAndLocation ) override;
+        ITracker& parent() override;
+
+        void openChild() override;
+
+        bool isSectionTracker() const override;
+        bool isGeneratorTracker() const override;
+
+        void open();
+
+        void close() override;
+        void fail() override;
+        void markAsNeedingAnotherRun() override;
+
+    private:
+        void moveToParent();
+        void moveToThis();
+    };
+
+    class SectionTracker : public TrackerBase {
+        std::vector<std::string> m_filters;
+        std::string m_trimmed_name;
+    public:
+        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent );
+
+        bool isSectionTracker() const override;
+
+        bool isComplete() const override;
+
+        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation );
+
+        void tryOpen();
+
+        void addInitialFilters( std::vector<std::string> const& filters );
+        void addNextFilters( std::vector<std::string> const& filters );
+    };
+
+} // namespace TestCaseTracking
+
+using TestCaseTracking::ITracker;
+using TestCaseTracking::TrackerContext;
+using TestCaseTracking::SectionTracker;
+
+} // namespace Catch
+
+// end catch_test_case_tracker.h
+
+// start catch_leak_detector.h
+
+namespace Catch {
+
+    struct LeakDetector {
+        LeakDetector();
+        ~LeakDetector();
+    };
+
+}
+// end catch_leak_detector.h
+// Cpp files will be included in the single-header file here
+// start catch_stats.cpp
+
+// Statistical analysis tools
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+
+#include <cassert>
+#include <random>
+
+#if defined(CATCH_CONFIG_USE_ASYNC)
+#include <future>
+#endif
+
+namespace {
+    double erf_inv(double x) {
+        // Code accompanying the article "Approximating the erfinv function" in GPU Computing Gems, Volume 2
+        double w, p;
+
+        w = -log((1.0 - x) * (1.0 + x));
+
+        if (w < 6.250000) {
+            w = w - 3.125000;
+            p = -3.6444120640178196996e-21;
+            p = -1.685059138182016589e-19 + p * w;
+            p = 1.2858480715256400167e-18 + p * w;
+            p = 1.115787767802518096e-17 + p * w;
+            p = -1.333171662854620906e-16 + p * w;
+            p = 2.0972767875968561637e-17 + p * w;
+            p = 6.6376381343583238325e-15 + p * w;
+            p = -4.0545662729752068639e-14 + p * w;
+            p = -8.1519341976054721522e-14 + p * w;
+            p = 2.6335093153082322977e-12 + p * w;
+            p = -1.2975133253453532498e-11 + p * w;
+            p = -5.4154120542946279317e-11 + p * w;
+            p = 1.051212273321532285e-09 + p * w;
+            p = -4.1126339803469836976e-09 + p * w;
+            p = -2.9070369957882005086e-08 + p * w;
+            p = 4.2347877827932403518e-07 + p * w;
+            p = -1.3654692000834678645e-06 + p * w;
+            p = -1.3882523362786468719e-05 + p * w;
+            p = 0.0001867342080340571352 + p * w;
+            p = -0.00074070253416626697512 + p * w;
+            p = -0.0060336708714301490533 + p * w;
+            p = 0.24015818242558961693 + p * w;
+            p = 1.6536545626831027356 + p * w;
+        } else if (w < 16.000000) {
+            w = sqrt(w) - 3.250000;
+            p = 2.2137376921775787049e-09;
+            p = 9.0756561938885390979e-08 + p * w;
+            p = -2.7517406297064545428e-07 + p * w;
+            p = 1.8239629214389227755e-08 + p * w;
+            p = 1.5027403968909827627e-06 + p * w;
+            p = -4.013867526981545969e-06 + p * w;
+            p = 2.9234449089955446044e-06 + p * w;
+            p = 1.2475304481671778723e-05 + p * w;
+            p = -4.7318229009055733981e-05 + p * w;
+            p = 6.8284851459573175448e-05 + p * w;
+            p = 2.4031110387097893999e-05 + p * w;
+            p = -0.0003550375203628474796 + p * w;
+            p = 0.00095328937973738049703 + p * w;
+            p = -0.0016882755560235047313 + p * w;
+            p = 0.0024914420961078508066 + p * w;
+            p = -0.0037512085075692412107 + p * w;
+            p = 0.005370914553590063617 + p * w;
+            p = 1.0052589676941592334 + p * w;
+            p = 3.0838856104922207635 + p * w;
+        } else {
+            w = sqrt(w) - 5.000000;
+            p = -2.7109920616438573243e-11;
+            p = -2.5556418169965252055e-10 + p * w;
+            p = 1.5076572693500548083e-09 + p * w;
+            p = -3.7894654401267369937e-09 + p * w;
+            p = 7.6157012080783393804e-09 + p * w;
+            p = -1.4960026627149240478e-08 + p * w;
+            p = 2.9147953450901080826e-08 + p * w;
+            p = -6.7711997758452339498e-08 + p * w;
+            p = 2.2900482228026654717e-07 + p * w;
+            p = -9.9298272942317002539e-07 + p * w;
+            p = 4.5260625972231537039e-06 + p * w;
+            p = -1.9681778105531670567e-05 + p * w;
+            p = 7.5995277030017761139e-05 + p * w;
+            p = -0.00021503011930044477347 + p * w;
+            p = -0.00013871931833623122026 + p * w;
+            p = 1.0103004648645343977 + p * w;
+            p = 4.8499064014085844221 + p * w;
+        }
+        return p * x;
+    }
+
+    double standard_deviation(std::vector<double>::iterator first, std::vector<double>::iterator last) {
+        auto m = Catch::Benchmark::Detail::mean(first, last);
+        double variance = std::accumulate(first, last, 0., [m](double a, double b) {
+            double diff = b - m;
+            return a + diff * diff;
+            }) / (last - first);
+            return std::sqrt(variance);
+    }
+
+}
+
+namespace Catch {
+    namespace Benchmark {
+        namespace Detail {
+
+            double weighted_average_quantile(int k, int q, std::vector<double>::iterator first, std::vector<double>::iterator last) {
+                auto count = last - first;
+                double idx = (count - 1) * k / static_cast<double>(q);
+                int j = static_cast<int>(idx);
+                double g = idx - j;
+                std::nth_element(first, first + j, last);
+                auto xj = first[j];
+                if (g == 0) return xj;
+
+                auto xj1 = *std::min_element(first + (j + 1), last);
+                return xj + g * (xj1 - xj);
+            }
+
+            double erfc_inv(double x) {
+                return erf_inv(1.0 - x);
+            }
+
+            double normal_quantile(double p) {
+                static const double ROOT_TWO = std::sqrt(2.0);
+
+                double result = 0.0;
+                assert(p >= 0 && p <= 1);
+                if (p < 0 || p > 1) {
+                    return result;
+                }
+
+                result = -erfc_inv(2.0 * p);
+                // result *= normal distribution standard deviation (1.0) * sqrt(2)
+                result *= /*sd * */ ROOT_TWO;
+                // result += normal disttribution mean (0)
+                return result;
+            }
+
+            double outlier_variance(Estimate<double> mean, Estimate<double> stddev, int n) {
+                double sb = stddev.point;
+                double mn = mean.point / n;
+                double mg_min = mn / 2.;
+                double sg = std::min(mg_min / 4., sb / std::sqrt(n));
+                double sg2 = sg * sg;
+                double sb2 = sb * sb;
+
+                auto c_max = [n, mn, sb2, sg2](double x) -> double {
+                    double k = mn - x;
+                    double d = k * k;
+                    double nd = n * d;
+                    double k0 = -n * nd;
+                    double k1 = sb2 - n * sg2 + nd;
+                    double det = k1 * k1 - 4 * sg2 * k0;
+                    return (int)(-2. * k0 / (k1 + std::sqrt(det)));
+                };
+
+                auto var_out = [n, sb2, sg2](double c) {
+                    double nc = n - c;
+                    return (nc / n) * (sb2 - nc * sg2);
+                };
+
+                return std::min(var_out(1), var_out(std::min(c_max(0.), c_max(mg_min)))) / sb2;
+            }
+
+            bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, std::vector<double>::iterator first, std::vector<double>::iterator last) {
+                CATCH_INTERNAL_START_WARNINGS_SUPPRESSION
+                CATCH_INTERNAL_SUPPRESS_GLOBALS_WARNINGS
+                static std::random_device entropy;
+                CATCH_INTERNAL_STOP_WARNINGS_SUPPRESSION
+
+                auto n = static_cast<int>(last - first); // seriously, one can't use integral types without hell in C++
+
+                auto mean = &Detail::mean<std::vector<double>::iterator>;
+                auto stddev = &standard_deviation;
+
+#if defined(CATCH_CONFIG_USE_ASYNC)
+                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
+                    auto seed = entropy();
+                    return std::async(std::launch::async, [=] {
+                        std::mt19937 rng(seed);
+                        auto resampled = resample(rng, n_resamples, first, last, f);
+                        return bootstrap(confidence_level, first, last, resampled, f);
+                    });
+                };
+
+                auto mean_future = Estimate(mean);
+                auto stddev_future = Estimate(stddev);
+
+                auto mean_estimate = mean_future.get();
+                auto stddev_estimate = stddev_future.get();
+#else
+                auto Estimate = [=](double(*f)(std::vector<double>::iterator, std::vector<double>::iterator)) {
+                    auto seed = entropy();
+                    std::mt19937 rng(seed);
+                    auto resampled = resample(rng, n_resamples, first, last, f);
+                    return bootstrap(confidence_level, first, last, resampled, f);
+                };
+
+                auto mean_estimate = Estimate(mean);
+                auto stddev_estimate = Estimate(stddev);
+#endif // CATCH_USE_ASYNC
+
+                double outlier_variance = Detail::outlier_variance(mean_estimate, stddev_estimate, n);
+
+                return { mean_estimate, stddev_estimate, outlier_variance };
+            }
+        } // namespace Detail
+    } // namespace Benchmark
+} // namespace Catch
+
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+// end catch_stats.cpp
+// start catch_approx.cpp
+
+#include <cmath>
+#include <limits>
+
+namespace {
+
+// Performs equivalent check of std::fabs(lhs - rhs) <= margin
+// But without the subtraction to allow for INFINITY in comparison
+bool marginComparison(double lhs, double rhs, double margin) {
+    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
+}
+
+}
+
+namespace Catch {
+namespace Detail {
+
+    Approx::Approx ( double value )
+    :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
+        m_margin( 0.0 ),
+        m_scale( 0.0 ),
+        m_value( value )
+    {}
+
+    Approx Approx::custom() {
+        return Approx( 0 );
+    }
+
+    Approx Approx::operator-() const {
+        auto temp(*this);
+        temp.m_value = -temp.m_value;
+        return temp;
+    }
+
+    std::string Approx::toString() const {
+        ReusableStringStream rss;
+        rss << "Approx( " << ::Catch::Detail::stringify( m_value ) << " )";
+        return rss.str();
+    }
+
+    bool Approx::equalityComparisonImpl(const double other) const {
+        // First try with fixed margin, then compute margin based on epsilon, scale and Approx's value
+        // Thanks to Richard Harris for his help refining the scaled margin value
+        return marginComparison(m_value, other, m_margin)
+            || marginComparison(m_value, other, m_epsilon * (m_scale + std::fabs(std::isinf(m_value)? 0 : m_value)));
+    }
+
+    void Approx::setMargin(double newMargin) {
+        CATCH_ENFORCE(newMargin >= 0,
+            "Invalid Approx::margin: " << newMargin << '.'
+            << " Approx::Margin has to be non-negative.");
+        m_margin = newMargin;
+    }
+
+    void Approx::setEpsilon(double newEpsilon) {
+        CATCH_ENFORCE(newEpsilon >= 0 && newEpsilon <= 1.0,
+            "Invalid Approx::epsilon: " << newEpsilon << '.'
+            << " Approx::epsilon has to be in [0, 1]");
+        m_epsilon = newEpsilon;
+    }
+
+} // end namespace Detail
+
+namespace literals {
+    Detail::Approx operator "" _a(long double val) {
+        return Detail::Approx(val);
+    }
+    Detail::Approx operator "" _a(unsigned long long val) {
+        return Detail::Approx(val);
+    }
+} // end namespace literals
+
+std::string StringMaker<Catch::Detail::Approx>::convert(Catch::Detail::Approx const& value) {
+    return value.toString();
+}
+
+} // end namespace Catch
+// end catch_approx.cpp
+// start catch_assertionhandler.cpp
+
+// start catch_debugger.h
+
+namespace Catch {
+    bool isDebuggerActive();
+}
+
+#ifdef CATCH_PLATFORM_MAC
+
+    #define CATCH_TRAP() __asm__("int $3\n" : : ) /* NOLINT */
+
+#elif defined(CATCH_PLATFORM_IPHONE)
+
+    // use inline assembler
+    #if defined(__i386__) || defined(__x86_64__)
+        #define CATCH_TRAP()  __asm__("int $3")
+    #elif defined(__aarch64__)
+        #define CATCH_TRAP()  __asm__(".inst 0xd4200000")
+    #elif defined(__arm__) && !defined(__thumb__)
+        #define CATCH_TRAP()  __asm__(".inst 0xe7f001f0")
+    #elif defined(__arm__) &&  defined(__thumb__)
+        #define CATCH_TRAP()  __asm__(".inst 0xde01")
+    #endif
+
+#elif defined(CATCH_PLATFORM_LINUX)
+    // If we can use inline assembler, do it because this allows us to break
+    // directly at the location of the failing check instead of breaking inside
+    // raise() called from it, i.e. one stack frame below.
+    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
+        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
+    #else // Fall back to the generic way.
+        #include <signal.h>
+
+        #define CATCH_TRAP() raise(SIGTRAP)
+    #endif
+#elif defined(_MSC_VER)
+    #define CATCH_TRAP() __debugbreak()
+#elif defined(__MINGW32__)
+    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
+    #define CATCH_TRAP() DebugBreak()
+#endif
+
+#ifndef CATCH_BREAK_INTO_DEBUGGER
+    #ifdef CATCH_TRAP
+        #define CATCH_BREAK_INTO_DEBUGGER() []{ if( Catch::isDebuggerActive() ) { CATCH_TRAP(); } }()
+    #else
+        #define CATCH_BREAK_INTO_DEBUGGER() []{}()
+    #endif
+#endif
+
+// end catch_debugger.h
+// start catch_run_context.h
+
+// start catch_fatal_condition.h
+
+// start catch_windows_h_proxy.h
+
+
+#if defined(CATCH_PLATFORM_WINDOWS)
+
+#if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
+#  define CATCH_DEFINED_NOMINMAX
+#  define NOMINMAX
+#endif
+#if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
+#  define CATCH_DEFINED_WIN32_LEAN_AND_MEAN
+#  define WIN32_LEAN_AND_MEAN
+#endif
+
+#ifdef __AFXDLL
+#include <AfxWin.h>
+#else
+#include <windows.h>
+#endif
+
+#ifdef CATCH_DEFINED_NOMINMAX
+#  undef NOMINMAX
+#endif
+#ifdef CATCH_DEFINED_WIN32_LEAN_AND_MEAN
+#  undef WIN32_LEAN_AND_MEAN
+#endif
+
+#endif // defined(CATCH_PLATFORM_WINDOWS)
+
+// end catch_windows_h_proxy.h
+#if defined( CATCH_CONFIG_WINDOWS_SEH )
+
+namespace Catch {
+
+    struct FatalConditionHandler {
+
+        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo);
+        FatalConditionHandler();
+        static void reset();
+        ~FatalConditionHandler();
+
+    private:
+        static bool isSet;
+        static ULONG guaranteeSize;
+        static PVOID exceptionHandlerHandle;
+    };
+
+} // namespace Catch
+
+#elif defined ( CATCH_CONFIG_POSIX_SIGNALS )
+
+#include <signal.h>
+
+namespace Catch {
+
+    struct FatalConditionHandler {
+
+        static bool isSet;
+        static struct sigaction oldSigActions[];
+        static stack_t oldSigStack;
+        static char altStackMem[];
+
+        static void handleSignal( int sig );
+
+        FatalConditionHandler();
+        ~FatalConditionHandler();
+        static void reset();
+    };
+
+} // namespace Catch
+
+#else
+
+namespace Catch {
+    struct FatalConditionHandler {
+        void reset();
+    };
+}
+
+#endif
+
+// end catch_fatal_condition.h
+#include <string>
+
+namespace Catch {
+
+    struct IMutableContext;
+
+    ///////////////////////////////////////////////////////////////////////////
+
+    class RunContext : public IResultCapture, public IRunner {
+
+    public:
+        RunContext( RunContext const& ) = delete;
+        RunContext& operator =( RunContext const& ) = delete;
+
+        explicit RunContext( IConfigPtr const& _config, IStreamingReporterPtr&& reporter );
+
+        ~RunContext() override;
+
+        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount );
+        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount );
+
+        Totals runTest(TestCase const& testCase);
+
+        IConfigPtr config() const;
+        IStreamingReporter& reporter() const;
+
+    public: // IResultCapture
+
+        // Assertion handlers
+        void handleExpr
+                (   AssertionInfo const& info,
+                    ITransientExpression const& expr,
+                    AssertionReaction& reaction ) override;
+        void handleMessage
+                (   AssertionInfo const& info,
+                    ResultWas::OfType resultType,
+                    StringRef const& message,
+                    AssertionReaction& reaction ) override;
+        void handleUnexpectedExceptionNotThrown
+                (   AssertionInfo const& info,
+                    AssertionReaction& reaction ) override;
+        void handleUnexpectedInflightException
+                (   AssertionInfo const& info,
+                    std::string const& message,
+                    AssertionReaction& reaction ) override;
+        void handleIncomplete
+                (   AssertionInfo const& info ) override;
+        void handleNonExpr
+                (   AssertionInfo const &info,
+                    ResultWas::OfType resultType,
+                    AssertionReaction &reaction ) override;
+
+        bool sectionStarted( SectionInfo const& sectionInfo, Counts& assertions ) override;
+
+        void sectionEnded( SectionEndInfo const& endInfo ) override;
+        void sectionEndedEarly( SectionEndInfo const& endInfo ) override;
+
+        auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& override;
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        void benchmarkPreparing( std::string const& name ) override;
+        void benchmarkStarting( BenchmarkInfo const& info ) override;
+        void benchmarkEnded( BenchmarkStats<> const& stats ) override;
+        void benchmarkFailed( std::string const& error ) override;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+        void pushScopedMessage( MessageInfo const& message ) override;
+        void popScopedMessage( MessageInfo const& message ) override;
+
+        void emplaceUnscopedMessage( MessageBuilder const& builder ) override;
+
+        std::string getCurrentTestName() const override;
+
+        const AssertionResult* getLastResult() const override;
+
+        void exceptionEarlyReported() override;
+
+        void handleFatalErrorCondition( StringRef message ) override;
+
+        bool lastAssertionPassed() override;
+
+        void assertionPassed() override;
+
+    public:
+        // !TBD We need to do this another way!
+        bool aborting() const final;
+
+    private:
+
+        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr );
+        void invokeActiveTestCase();
+
+        void resetAssertionInfo();
+        bool testForMissingAssertions( Counts& assertions );
+
+        void assertionEnded( AssertionResult const& result );
+        void reportExpr
+                (   AssertionInfo const &info,
+                    ResultWas::OfType resultType,
+                    ITransientExpression const *expr,
+                    bool negated );
+
+        void populateReaction( AssertionReaction& reaction );
+
+    private:
+
+        void handleUnfinishedSections();
+
+        TestRunInfo m_runInfo;
+        IMutableContext& m_context;
+        TestCase const* m_activeTestCase = nullptr;
+        ITracker* m_testCaseTracker = nullptr;
+        Option<AssertionResult> m_lastResult;
+
+        IConfigPtr m_config;
+        Totals m_totals;
+        IStreamingReporterPtr m_reporter;
+        std::vector<MessageInfo> m_messages;
+        std::vector<ScopedMessage> m_messageScopes; /* Keeps owners of so-called unscoped messages. */
+        AssertionInfo m_lastAssertionInfo;
+        std::vector<SectionEndInfo> m_unfinishedSections;
+        std::vector<ITracker*> m_activeSections;
+        TrackerContext m_trackerContext;
+        bool m_lastAssertionPassed = false;
+        bool m_shouldReportUnexpected = true;
+        bool m_includeSuccessfulResults;
+    };
+
+    void seedRng(IConfig const& config);
+    unsigned int rngSeed();
+} // end namespace Catch
+
+// end catch_run_context.h
+namespace Catch {
+
+    namespace {
+        auto operator <<( std::ostream& os, ITransientExpression const& expr ) -> std::ostream& {
+            expr.streamReconstructedExpression( os );
+            return os;
+        }
+    }
+
+    LazyExpression::LazyExpression( bool isNegated )
+    :   m_isNegated( isNegated )
+    {}
+
+    LazyExpression::LazyExpression( LazyExpression const& other ) : m_isNegated( other.m_isNegated ) {}
+
+    LazyExpression::operator bool() const {
+        return m_transientExpression != nullptr;
+    }
+
+    auto operator << ( std::ostream& os, LazyExpression const& lazyExpr ) -> std::ostream& {
+        if( lazyExpr.m_isNegated )
+            os << "!";
+
+        if( lazyExpr ) {
+            if( lazyExpr.m_isNegated && lazyExpr.m_transientExpression->isBinaryExpression() )
+                os << "(" << *lazyExpr.m_transientExpression << ")";
+            else
+                os << *lazyExpr.m_transientExpression;
+        }
+        else {
+            os << "{** error - unchecked empty expression requested **}";
+        }
+        return os;
+    }
+
+    AssertionHandler::AssertionHandler
+        (   StringRef const& macroName,
+            SourceLineInfo const& lineInfo,
+            StringRef capturedExpression,
+            ResultDisposition::Flags resultDisposition )
+    :   m_assertionInfo{ macroName, lineInfo, capturedExpression, resultDisposition },
+        m_resultCapture( getResultCapture() )
+    {}
+
+    void AssertionHandler::handleExpr( ITransientExpression const& expr ) {
+        m_resultCapture.handleExpr( m_assertionInfo, expr, m_reaction );
+    }
+    void AssertionHandler::handleMessage(ResultWas::OfType resultType, StringRef const& message) {
+        m_resultCapture.handleMessage( m_assertionInfo, resultType, message, m_reaction );
+    }
+
+    auto AssertionHandler::allowThrows() const -> bool {
+        return getCurrentContext().getConfig()->allowThrows();
+    }
+
+    void AssertionHandler::complete() {
+        setCompleted();
+        if( m_reaction.shouldDebugBreak ) {
+
+            // If you find your debugger stopping you here then go one level up on the
+            // call-stack for the code that caused it (typically a failed assertion)
+
+            // (To go back to the test and change execution, jump over the throw, next)
+            CATCH_BREAK_INTO_DEBUGGER();
+        }
+        if (m_reaction.shouldThrow) {
+#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+            throw Catch::TestFailureException();
+#else
+            CATCH_ERROR( "Test failure requires aborting test!" );
+#endif
+        }
+    }
+    void AssertionHandler::setCompleted() {
+        m_completed = true;
+    }
+
+    void AssertionHandler::handleUnexpectedInflightException() {
+        m_resultCapture.handleUnexpectedInflightException( m_assertionInfo, Catch::translateActiveException(), m_reaction );
+    }
+
+    void AssertionHandler::handleExceptionThrownAsExpected() {
+        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
+    }
+    void AssertionHandler::handleExceptionNotThrownAsExpected() {
+        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
+    }
+
+    void AssertionHandler::handleUnexpectedExceptionNotThrown() {
+        m_resultCapture.handleUnexpectedExceptionNotThrown( m_assertionInfo, m_reaction );
+    }
+
+    void AssertionHandler::handleThrowingCallSkipped() {
+        m_resultCapture.handleNonExpr(m_assertionInfo, ResultWas::Ok, m_reaction);
+    }
+
+    // This is the overload that takes a string and infers the Equals matcher from it
+    // The more general overload, that takes any string matcher, is in catch_capture_matchers.cpp
+    void handleExceptionMatchExpr( AssertionHandler& handler, std::string const& str, StringRef const& matcherString  ) {
+        handleExceptionMatchExpr( handler, Matchers::Equals( str ), matcherString );
+    }
+
+} // namespace Catch
+// end catch_assertionhandler.cpp
+// start catch_assertionresult.cpp
+
+namespace Catch {
+    AssertionResultData::AssertionResultData(ResultWas::OfType _resultType, LazyExpression const & _lazyExpression):
+        lazyExpression(_lazyExpression),
+        resultType(_resultType) {}
+
+    std::string AssertionResultData::reconstructExpression() const {
+
+        if( reconstructedExpression.empty() ) {
+            if( lazyExpression ) {
+                ReusableStringStream rss;
+                rss << lazyExpression;
+                reconstructedExpression = rss.str();
+            }
+        }
+        return reconstructedExpression;
+    }
+
+    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
+    :   m_info( info ),
+        m_resultData( data )
+    {}
+
+    // Result was a success
+    bool AssertionResult::succeeded() const {
+        return Catch::isOk( m_resultData.resultType );
+    }
+
+    // Result was a success, or failure is suppressed
+    bool AssertionResult::isOk() const {
+        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
+    }
+
+    ResultWas::OfType AssertionResult::getResultType() const {
+        return m_resultData.resultType;
+    }
+
+    bool AssertionResult::hasExpression() const {
+        return !m_info.capturedExpression.empty();
+    }
+
+    bool AssertionResult::hasMessage() const {
+        return !m_resultData.message.empty();
+    }
+
+    std::string AssertionResult::getExpression() const {
+        // Possibly overallocating by 3 characters should be basically free
+        std::string expr; expr.reserve(m_info.capturedExpression.size() + 3);
+        if (isFalseTest(m_info.resultDisposition)) {
+            expr += "!(";
+        }
+        expr += m_info.capturedExpression;
+        if (isFalseTest(m_info.resultDisposition)) {
+            expr += ')';
+        }
+        return expr;
+    }
+
+    std::string AssertionResult::getExpressionInMacro() const {
+        std::string expr;
+        if( m_info.macroName.empty() )
+            expr = static_cast<std::string>(m_info.capturedExpression);
+        else {
+            expr.reserve( m_info.macroName.size() + m_info.capturedExpression.size() + 4 );
+            expr += m_info.macroName;
+            expr += "( ";
+            expr += m_info.capturedExpression;
+            expr += " )";
+        }
+        return expr;
+    }
+
+    bool AssertionResult::hasExpandedExpression() const {
+        return hasExpression() && getExpandedExpression() != getExpression();
+    }
+
+    std::string AssertionResult::getExpandedExpression() const {
+        std::string expr = m_resultData.reconstructExpression();
+        return expr.empty()
+                ? getExpression()
+                : expr;
+    }
+
+    std::string AssertionResult::getMessage() const {
+        return m_resultData.message;
+    }
+    SourceLineInfo AssertionResult::getSourceInfo() const {
+        return m_info.lineInfo;
+    }
+
+    StringRef AssertionResult::getTestMacroName() const {
+        return m_info.macroName;
+    }
+
+} // end namespace Catch
+// end catch_assertionresult.cpp
+// start catch_capture_matchers.cpp
+
+namespace Catch {
+
+    using StringMatcher = Matchers::Impl::MatcherBase<std::string>;
+
+    // This is the general overload that takes a any string matcher
+    // There is another overload, in catch_assertionhandler.h/.cpp, that only takes a string and infers
+    // the Equals matcher (so the header does not mention matchers)
+    void handleExceptionMatchExpr( AssertionHandler& handler, StringMatcher const& matcher, StringRef const& matcherString  ) {
+        std::string exceptionMessage = Catch::translateActiveException();
+        MatchExpr<std::string, StringMatcher const&> expr( exceptionMessage, matcher, matcherString );
+        handler.handleExpr( expr );
+    }
+
+} // namespace Catch
+// end catch_capture_matchers.cpp
+// start catch_commandline.cpp
+
+// start catch_commandline.h
+
+// start catch_clara.h
+
+// Use Catch's value for console width (store Clara's off to the side, if present)
+#ifdef CLARA_CONFIG_CONSOLE_WIDTH
+#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
+#undef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
+#endif
+#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH-1
+
+#ifdef __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wweak-vtables"
+#pragma clang diagnostic ignored "-Wexit-time-destructors"
+#pragma clang diagnostic ignored "-Wshadow"
+#endif
+
+// start clara.hpp
+// Copyright 2017 Two Blue Cubes Ltd. All rights reserved.
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// See https://github.com/philsquared/Clara for more details
+
+// Clara v1.1.5
+
+
+#ifndef CATCH_CLARA_CONFIG_CONSOLE_WIDTH
+#define CATCH_CLARA_CONFIG_CONSOLE_WIDTH 80
+#endif
+
+#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
+#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_CLARA_CONFIG_CONSOLE_WIDTH
+#endif
+
+#ifndef CLARA_CONFIG_OPTIONAL_TYPE
+#ifdef __has_include
+#if __has_include(<optional>) && __cplusplus >= 201703L
+#include <optional>
+#define CLARA_CONFIG_OPTIONAL_TYPE std::optional
+#endif
+#endif
+#endif
+
+// ----------- #included from clara_textflow.hpp -----------
+
+// TextFlowCpp
+//
+// A single-header library for wrapping and laying out basic text, by Phil Nash
+//
+// Distributed under the Boost Software License, Version 1.0. (See accompanying
+// file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
+//
+// This project is hosted at https://github.com/philsquared/textflowcpp
+
+
+#include <cassert>
+#include <ostream>
+#include <sstream>
+#include <vector>
+
+#ifndef CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH
+#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH 80
+#endif
+
+namespace Catch {
+namespace clara {
+namespace TextFlow {
+
+inline auto isWhitespace(char c) -> bool {
+	static std::string chars = " \t\n\r";
+	return chars.find(c) != std::string::npos;
+}
+inline auto isBreakableBefore(char c) -> bool {
+	static std::string chars = "[({<|";
+	return chars.find(c) != std::string::npos;
+}
+inline auto isBreakableAfter(char c) -> bool {
+	static std::string chars = "])}>.,:;*+-=&/\\";
+	return chars.find(c) != std::string::npos;
+}
+
+class Columns;
+
+class Column {
+	std::vector<std::string> m_strings;
+	size_t m_width = CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH;
+	size_t m_indent = 0;
+	size_t m_initialIndent = std::string::npos;
+
+public:
+	class iterator {
+		friend Column;
+
+		Column const& m_column;
+		size_t m_stringIndex = 0;
+		size_t m_pos = 0;
+
+		size_t m_len = 0;
+		size_t m_end = 0;
+		bool m_suffix = false;
+
+		iterator(Column const& column, size_t stringIndex)
+			: m_column(column),
+			m_stringIndex(stringIndex) {}
+
+		auto line() const -> std::string const& { return m_column.m_strings[m_stringIndex]; }
+
+		auto isBoundary(size_t at) const -> bool {
+			assert(at > 0);
+			assert(at <= line().size());
+
+			return at == line().size() ||
+				(isWhitespace(line()[at]) && !isWhitespace(line()[at - 1])) ||
+				isBreakableBefore(line()[at]) ||
+				isBreakableAfter(line()[at - 1]);
+		}
+
+		void calcLength() {
+			assert(m_stringIndex < m_column.m_strings.size());
+
+			m_suffix = false;
+			auto width = m_column.m_width - indent();
+			m_end = m_pos;
+			if (line()[m_pos] == '\n') {
+				++m_end;
+			}
+			while (m_end < line().size() && line()[m_end] != '\n')
+				++m_end;
+
+			if (m_end < m_pos + width) {
+				m_len = m_end - m_pos;
+			} else {
+				size_t len = width;
+				while (len > 0 && !isBoundary(m_pos + len))
+					--len;
+				while (len > 0 && isWhitespace(line()[m_pos + len - 1]))
+					--len;
+
+				if (len > 0) {
+					m_len = len;
+				} else {
+					m_suffix = true;
+					m_len = width - 1;
+				}
+			}
+		}
+
+		auto indent() const -> size_t {
+			auto initial = m_pos == 0 && m_stringIndex == 0 ? m_column.m_initialIndent : std::string::npos;
+			return initial == std::string::npos ? m_column.m_indent : initial;
+		}
+
+		auto addIndentAndSuffix(std::string const &plain) const -> std::string {
+			return std::string(indent(), ' ') + (m_suffix ? plain + "-" : plain);
+		}
+
+	public:
+		using difference_type = std::ptrdiff_t;
+		using value_type = std::string;
+		using pointer = value_type * ;
+		using reference = value_type & ;
+		using iterator_category = std::forward_iterator_tag;
+
+		explicit iterator(Column const& column) : m_column(column) {
+			assert(m_column.m_width > m_column.m_indent);
+			assert(m_column.m_initialIndent == std::string::npos || m_column.m_width > m_column.m_initialIndent);
+			calcLength();
+			if (m_len == 0)
+				m_stringIndex++; // Empty string
+		}
+
+		auto operator *() const -> std::string {
+			assert(m_stringIndex < m_column.m_strings.size());
+			assert(m_pos <= m_end);
+			return addIndentAndSuffix(line().substr(m_pos, m_len));
+		}
+
+		auto operator ++() -> iterator& {
+			m_pos += m_len;
+			if (m_pos < line().size() && line()[m_pos] == '\n')
+				m_pos += 1;
+			else
+				while (m_pos < line().size() && isWhitespace(line()[m_pos]))
+					++m_pos;
+
+			if (m_pos == line().size()) {
+				m_pos = 0;
+				++m_stringIndex;
+			}
+			if (m_stringIndex < m_column.m_strings.size())
+				calcLength();
+			return *this;
+		}
+		auto operator ++(int) -> iterator {
+			iterator prev(*this);
+			operator++();
+			return prev;
+		}
+
+		auto operator ==(iterator const& other) const -> bool {
+			return
+				m_pos == other.m_pos &&
+				m_stringIndex == other.m_stringIndex &&
+				&m_column == &other.m_column;
+		}
+		auto operator !=(iterator const& other) const -> bool {
+			return !operator==(other);
+		}
+	};
+	using const_iterator = iterator;
+
+	explicit Column(std::string const& text) { m_strings.push_back(text); }
+
+	auto width(size_t newWidth) -> Column& {
+		assert(newWidth > 0);
+		m_width = newWidth;
+		return *this;
+	}
+	auto indent(size_t newIndent) -> Column& {
+		m_indent = newIndent;
+		return *this;
+	}
+	auto initialIndent(size_t newIndent) -> Column& {
+		m_initialIndent = newIndent;
+		return *this;
+	}
+
+	auto width() const -> size_t { return m_width; }
+	auto begin() const -> iterator { return iterator(*this); }
+	auto end() const -> iterator { return { *this, m_strings.size() }; }
+
+	inline friend std::ostream& operator << (std::ostream& os, Column const& col) {
+		bool first = true;
+		for (auto line : col) {
+			if (first)
+				first = false;
+			else
+				os << "\n";
+			os << line;
+		}
+		return os;
+	}
+
+	auto operator + (Column const& other)->Columns;
+
+	auto toString() const -> std::string {
+		std::ostringstream oss;
+		oss << *this;
+		return oss.str();
+	}
+};
+
+class Spacer : public Column {
+
+public:
+	explicit Spacer(size_t spaceWidth) : Column("") {
+		width(spaceWidth);
+	}
+};
+
+class Columns {
+	std::vector<Column> m_columns;
+
+public:
+
+	class iterator {
+		friend Columns;
+		struct EndTag {};
+
+		std::vector<Column> const& m_columns;
+		std::vector<Column::iterator> m_iterators;
+		size_t m_activeIterators;
+
+		iterator(Columns const& columns, EndTag)
+			: m_columns(columns.m_columns),
+			m_activeIterators(0) {
+			m_iterators.reserve(m_columns.size());
+
+			for (auto const& col : m_columns)
+				m_iterators.push_back(col.end());
+		}
+
+	public:
+		using difference_type = std::ptrdiff_t;
+		using value_type = std::string;
+		using pointer = value_type * ;
+		using reference = value_type & ;
+		using iterator_category = std::forward_iterator_tag;
+
+		explicit iterator(Columns const& columns)
+			: m_columns(columns.m_columns),
+			m_activeIterators(m_columns.size()) {
+			m_iterators.reserve(m_columns.size());
+
+			for (auto const& col : m_columns)
+				m_iterators.push_back(col.begin());
+		}
+
+		auto operator ==(iterator const& other) const -> bool {
+			return m_iterators == other.m_iterators;
+		}
+		auto operator !=(iterator const& other) const -> bool {
+			return m_iterators != other.m_iterators;
+		}
+		auto operator *() const -> std::string {
+			std::string row, padding;
+
+			for (size_t i = 0; i < m_columns.size(); ++i) {
+				auto width = m_columns[i].width();
+				if (m_iterators[i] != m_columns[i].end()) {
+					std::string col = *m_iterators[i];
+					row += padding + col;
+					if (col.size() < width)
+						padding = std::string(width - col.size(), ' ');
+					else
+						padding = "";
+				} else {
+					padding += std::string(width, ' ');
+				}
+			}
+			return row;
+		}
+		auto operator ++() -> iterator& {
+			for (size_t i = 0; i < m_columns.size(); ++i) {
+				if (m_iterators[i] != m_columns[i].end())
+					++m_iterators[i];
+			}
+			return *this;
+		}
+		auto operator ++(int) -> iterator {
+			iterator prev(*this);
+			operator++();
+			return prev;
+		}
+	};
+	using const_iterator = iterator;
+
+	auto begin() const -> iterator { return iterator(*this); }
+	auto end() const -> iterator { return { *this, iterator::EndTag() }; }
+
+	auto operator += (Column const& col) -> Columns& {
+		m_columns.push_back(col);
+		return *this;
+	}
+	auto operator + (Column const& col) -> Columns {
+		Columns combined = *this;
+		combined += col;
+		return combined;
+	}
+
+	inline friend std::ostream& operator << (std::ostream& os, Columns const& cols) {
+
+		bool first = true;
+		for (auto line : cols) {
+			if (first)
+				first = false;
+			else
+				os << "\n";
+			os << line;
+		}
+		return os;
+	}
+
+	auto toString() const -> std::string {
+		std::ostringstream oss;
+		oss << *this;
+		return oss.str();
+	}
+};
+
+inline auto Column::operator + (Column const& other) -> Columns {
+	Columns cols;
+	cols += *this;
+	cols += other;
+	return cols;
+}
+}
+
+}
+}
+
+// ----------- end of #include from clara_textflow.hpp -----------
+// ........... back in clara.hpp
+
+#include <cctype>
+#include <string>
+#include <memory>
+#include <set>
+#include <algorithm>
+
+#if !defined(CATCH_PLATFORM_WINDOWS) && ( defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER) )
+#define CATCH_PLATFORM_WINDOWS
+#endif
+
+namespace Catch { namespace clara {
+namespace detail {
+
+    // Traits for extracting arg and return type of lambdas (for single argument lambdas)
+    template<typename L>
+    struct UnaryLambdaTraits : UnaryLambdaTraits<decltype( &L::operator() )> {};
+
+    template<typename ClassT, typename ReturnT, typename... Args>
+    struct UnaryLambdaTraits<ReturnT( ClassT::* )( Args... ) const> {
+        static const bool isValid = false;
+    };
+
+    template<typename ClassT, typename ReturnT, typename ArgT>
+    struct UnaryLambdaTraits<ReturnT( ClassT::* )( ArgT ) const> {
+        static const bool isValid = true;
+        using ArgType = typename std::remove_const<typename std::remove_reference<ArgT>::type>::type;
+        using ReturnType = ReturnT;
+    };
+
+    class TokenStream;
+
+    // Transport for raw args (copied from main args, or supplied via init list for testing)
+    class Args {
+        friend TokenStream;
+        std::string m_exeName;
+        std::vector<std::string> m_args;
+
+    public:
+        Args( int argc, char const* const* argv )
+            : m_exeName(argv[0]),
+              m_args(argv + 1, argv + argc) {}
+
+        Args( std::initializer_list<std::string> args )
+        :   m_exeName( *args.begin() ),
+            m_args( args.begin()+1, args.end() )
+        {}
+
+        auto exeName() const -> std::string {
+            return m_exeName;
+        }
+    };
+
+    // Wraps a token coming from a token stream. These may not directly correspond to strings as a single string
+    // may encode an option + its argument if the : or = form is used
+    enum class TokenType {
+        Option, Argument
+    };
+    struct Token {
+        TokenType type;
+        std::string token;
+    };
+
+    inline auto isOptPrefix( char c ) -> bool {
+        return c == '-'
+#ifdef CATCH_PLATFORM_WINDOWS
+            || c == '/'
+#endif
+        ;
+    }
+
+    // Abstracts iterators into args as a stream of tokens, with option arguments uniformly handled
+    class TokenStream {
+        using Iterator = std::vector<std::string>::const_iterator;
+        Iterator it;
+        Iterator itEnd;
+        std::vector<Token> m_tokenBuffer;
+
+        void loadBuffer() {
+            m_tokenBuffer.resize( 0 );
+
+            // Skip any empty strings
+            while( it != itEnd && it->empty() )
+                ++it;
+
+            if( it != itEnd ) {
+                auto const &next = *it;
+                if( isOptPrefix( next[0] ) ) {
+                    auto delimiterPos = next.find_first_of( " :=" );
+                    if( delimiterPos != std::string::npos ) {
+                        m_tokenBuffer.push_back( { TokenType::Option, next.substr( 0, delimiterPos ) } );
+                        m_tokenBuffer.push_back( { TokenType::Argument, next.substr( delimiterPos + 1 ) } );
+                    } else {
+                        if( next[1] != '-' && next.size() > 2 ) {
+                            std::string opt = "- ";
+                            for( size_t i = 1; i < next.size(); ++i ) {
+                                opt[1] = next[i];
+                                m_tokenBuffer.push_back( { TokenType::Option, opt } );
+                            }
+                        } else {
+                            m_tokenBuffer.push_back( { TokenType::Option, next } );
+                        }
+                    }
+                } else {
+                    m_tokenBuffer.push_back( { TokenType::Argument, next } );
+                }
+            }
+        }
+
+    public:
+        explicit TokenStream( Args const &args ) : TokenStream( args.m_args.begin(), args.m_args.end() ) {}
+
+        TokenStream( Iterator it, Iterator itEnd ) : it( it ), itEnd( itEnd ) {
+            loadBuffer();
+        }
+
+        explicit operator bool() const {
+            return !m_tokenBuffer.empty() || it != itEnd;
+        }
+
+        auto count() const -> size_t { return m_tokenBuffer.size() + (itEnd - it); }
+
+        auto operator*() const -> Token {
+            assert( !m_tokenBuffer.empty() );
+            return m_tokenBuffer.front();
+        }
+
+        auto operator->() const -> Token const * {
+            assert( !m_tokenBuffer.empty() );
+            return &m_tokenBuffer.front();
+        }
+
+        auto operator++() -> TokenStream & {
+            if( m_tokenBuffer.size() >= 2 ) {
+                m_tokenBuffer.erase( m_tokenBuffer.begin() );
+            } else {
+                if( it != itEnd )
+                    ++it;
+                loadBuffer();
+            }
+            return *this;
+        }
+    };
+
+    class ResultBase {
+    public:
+        enum Type {
+            Ok, LogicError, RuntimeError
+        };
+
+    protected:
+        ResultBase( Type type ) : m_type( type ) {}
+        virtual ~ResultBase() = default;
+
+        virtual void enforceOk() const = 0;
+
+        Type m_type;
+    };
+
+    template<typename T>
+    class ResultValueBase : public ResultBase {
+    public:
+        auto value() const -> T const & {
+            enforceOk();
+            return m_value;
+        }
+
+    protected:
+        ResultValueBase( Type type ) : ResultBase( type ) {}
+
+        ResultValueBase( ResultValueBase const &other ) : ResultBase( other ) {
+            if( m_type == ResultBase::Ok )
+                new( &m_value ) T( other.m_value );
+        }
+
+        ResultValueBase( Type, T const &value ) : ResultBase( Ok ) {
+            new( &m_value ) T( value );
+        }
+
+        auto operator=( ResultValueBase const &other ) -> ResultValueBase & {
+            if( m_type == ResultBase::Ok )
+                m_value.~T();
+            ResultBase::operator=(other);
+            if( m_type == ResultBase::Ok )
+                new( &m_value ) T( other.m_value );
+            return *this;
+        }
+
+        ~ResultValueBase() override {
+            if( m_type == Ok )
+                m_value.~T();
+        }
+
+        union {
+            T m_value;
+        };
+    };
+
+    template<>
+    class ResultValueBase<void> : public ResultBase {
+    protected:
+        using ResultBase::ResultBase;
+    };
+
+    template<typename T = void>
+    class BasicResult : public ResultValueBase<T> {
+    public:
+        template<typename U>
+        explicit BasicResult( BasicResult<U> const &other )
+        :   ResultValueBase<T>( other.type() ),
+            m_errorMessage( other.errorMessage() )
+        {
+            assert( type() != ResultBase::Ok );
+        }
+
+        template<typename U>
+        static auto ok( U const &value ) -> BasicResult { return { ResultBase::Ok, value }; }
+        static auto ok() -> BasicResult { return { ResultBase::Ok }; }
+        static auto logicError( std::string const &message ) -> BasicResult { return { ResultBase::LogicError, message }; }
+        static auto runtimeError( std::string const &message ) -> BasicResult { return { ResultBase::RuntimeError, message }; }
+
+        explicit operator bool() const { return m_type == ResultBase::Ok; }
+        auto type() const -> ResultBase::Type { return m_type; }
+        auto errorMessage() const -> std::string { return m_errorMessage; }
+
+    protected:
+        void enforceOk() const override {
+
+            // Errors shouldn't reach this point, but if they do
+            // the actual error message will be in m_errorMessage
+            assert( m_type != ResultBase::LogicError );
+            assert( m_type != ResultBase::RuntimeError );
+            if( m_type != ResultBase::Ok )
+                std::abort();
+        }
+
+        std::string m_errorMessage; // Only populated if resultType is an error
+
+        BasicResult( ResultBase::Type type, std::string const &message )
+        :   ResultValueBase<T>(type),
+            m_errorMessage(message)
+        {
+            assert( m_type != ResultBase::Ok );
+        }
+
+        using ResultValueBase<T>::ResultValueBase;
+        using ResultBase::m_type;
+    };
+
+    enum class ParseResultType {
+        Matched, NoMatch, ShortCircuitAll, ShortCircuitSame
+    };
+
+    class ParseState {
+    public:
+
+        ParseState( ParseResultType type, TokenStream const &remainingTokens )
+        : m_type(type),
+          m_remainingTokens( remainingTokens )
+        {}
+
+        auto type() const -> ParseResultType { return m_type; }
+        auto remainingTokens() const -> TokenStream { return m_remainingTokens; }
+
+    private:
+        ParseResultType m_type;
+        TokenStream m_remainingTokens;
+    };
+
+    using Result = BasicResult<void>;
+    using ParserResult = BasicResult<ParseResultType>;
+    using InternalParseResult = BasicResult<ParseState>;
+
+    struct HelpColumns {
+        std::string left;
+        std::string right;
+    };
+
+    template<typename T>
+    inline auto convertInto( std::string const &source, T& target ) -> ParserResult {
+        std::stringstream ss;
+        ss << source;
+        ss >> target;
+        if( ss.fail() )
+            return ParserResult::runtimeError( "Unable to convert '" + source + "' to destination type" );
+        else
+            return ParserResult::ok( ParseResultType::Matched );
+    }
+    inline auto convertInto( std::string const &source, std::string& target ) -> ParserResult {
+        target = source;
+        return ParserResult::ok( ParseResultType::Matched );
+    }
+    inline auto convertInto( std::string const &source, bool &target ) -> ParserResult {
+        std::string srcLC = source;
+        std::transform( srcLC.begin(), srcLC.end(), srcLC.begin(), []( char c ) { return static_cast<char>( std::tolower(c) ); } );
+        if (srcLC == "y" || srcLC == "1" || srcLC == "true" || srcLC == "yes" || srcLC == "on")
+            target = true;
+        else if (srcLC == "n" || srcLC == "0" || srcLC == "false" || srcLC == "no" || srcLC == "off")
+            target = false;
+        else
+            return ParserResult::runtimeError( "Expected a boolean value but did not recognise: '" + source + "'" );
+        return ParserResult::ok( ParseResultType::Matched );
+    }
+#ifdef CLARA_CONFIG_OPTIONAL_TYPE
+    template<typename T>
+    inline auto convertInto( std::string const &source, CLARA_CONFIG_OPTIONAL_TYPE<T>& target ) -> ParserResult {
+        T temp;
+        auto result = convertInto( source, temp );
+        if( result )
+            target = std::move(temp);
+        return result;
+    }
+#endif // CLARA_CONFIG_OPTIONAL_TYPE
+
+    struct NonCopyable {
+        NonCopyable() = default;
+        NonCopyable( NonCopyable const & ) = delete;
+        NonCopyable( NonCopyable && ) = delete;
+        NonCopyable &operator=( NonCopyable const & ) = delete;
+        NonCopyable &operator=( NonCopyable && ) = delete;
+    };
+
+    struct BoundRef : NonCopyable {
+        virtual ~BoundRef() = default;
+        virtual auto isContainer() const -> bool { return false; }
+        virtual auto isFlag() const -> bool { return false; }
+    };
+    struct BoundValueRefBase : BoundRef {
+        virtual auto setValue( std::string const &arg ) -> ParserResult = 0;
+    };
+    struct BoundFlagRefBase : BoundRef {
+        virtual auto setFlag( bool flag ) -> ParserResult = 0;
+        virtual auto isFlag() const -> bool { return true; }
+    };
+
+    template<typename T>
+    struct BoundValueRef : BoundValueRefBase {
+        T &m_ref;
+
+        explicit BoundValueRef( T &ref ) : m_ref( ref ) {}
+
+        auto setValue( std::string const &arg ) -> ParserResult override {
+            return convertInto( arg, m_ref );
+        }
+    };
+
+    template<typename T>
+    struct BoundValueRef<std::vector<T>> : BoundValueRefBase {
+        std::vector<T> &m_ref;
+
+        explicit BoundValueRef( std::vector<T> &ref ) : m_ref( ref ) {}
+
+        auto isContainer() const -> bool override { return true; }
+
+        auto setValue( std::string const &arg ) -> ParserResult override {
+            T temp;
+            auto result = convertInto( arg, temp );
+            if( result )
+                m_ref.push_back( temp );
+            return result;
+        }
+    };
+
+    struct BoundFlagRef : BoundFlagRefBase {
+        bool &m_ref;
+
+        explicit BoundFlagRef( bool &ref ) : m_ref( ref ) {}
+
+        auto setFlag( bool flag ) -> ParserResult override {
+            m_ref = flag;
+            return ParserResult::ok( ParseResultType::Matched );
+        }
+    };
+
+    template<typename ReturnType>
+    struct LambdaInvoker {
+        static_assert( std::is_same<ReturnType, ParserResult>::value, "Lambda must return void or clara::ParserResult" );
+
+        template<typename L, typename ArgType>
+        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
+            return lambda( arg );
+        }
+    };
+
+    template<>
+    struct LambdaInvoker<void> {
+        template<typename L, typename ArgType>
+        static auto invoke( L const &lambda, ArgType const &arg ) -> ParserResult {
+            lambda( arg );
+            return ParserResult::ok( ParseResultType::Matched );
+        }
+    };
+
+    template<typename ArgType, typename L>
+    inline auto invokeLambda( L const &lambda, std::string const &arg ) -> ParserResult {
+        ArgType temp{};
+        auto result = convertInto( arg, temp );
+        return !result
+           ? result
+           : LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( lambda, temp );
+    }
+
+    template<typename L>
+    struct BoundLambda : BoundValueRefBase {
+        L m_lambda;
+
+        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
+        explicit BoundLambda( L const &lambda ) : m_lambda( lambda ) {}
+
+        auto setValue( std::string const &arg ) -> ParserResult override {
+            return invokeLambda<typename UnaryLambdaTraits<L>::ArgType>( m_lambda, arg );
+        }
+    };
+
+    template<typename L>
+    struct BoundFlagLambda : BoundFlagRefBase {
+        L m_lambda;
+
+        static_assert( UnaryLambdaTraits<L>::isValid, "Supplied lambda must take exactly one argument" );
+        static_assert( std::is_same<typename UnaryLambdaTraits<L>::ArgType, bool>::value, "flags must be boolean" );
+
+        explicit BoundFlagLambda( L const &lambda ) : m_lambda( lambda ) {}
+
+        auto setFlag( bool flag ) -> ParserResult override {
+            return LambdaInvoker<typename UnaryLambdaTraits<L>::ReturnType>::invoke( m_lambda, flag );
+        }
+    };
+
+    enum class Optionality { Optional, Required };
+
+    struct Parser;
+
+    class ParserBase {
+    public:
+        virtual ~ParserBase() = default;
+        virtual auto validate() const -> Result { return Result::ok(); }
+        virtual auto parse( std::string const& exeName, TokenStream const &tokens) const -> InternalParseResult  = 0;
+        virtual auto cardinality() const -> size_t { return 1; }
+
+        auto parse( Args const &args ) const -> InternalParseResult {
+            return parse( args.exeName(), TokenStream( args ) );
+        }
+    };
+
+    template<typename DerivedT>
+    class ComposableParserImpl : public ParserBase {
+    public:
+        template<typename T>
+        auto operator|( T const &other ) const -> Parser;
+
+		template<typename T>
+        auto operator+( T const &other ) const -> Parser;
+    };
+
+    // Common code and state for Args and Opts
+    template<typename DerivedT>
+    class ParserRefImpl : public ComposableParserImpl<DerivedT> {
+    protected:
+        Optionality m_optionality = Optionality::Optional;
+        std::shared_ptr<BoundRef> m_ref;
+        std::string m_hint;
+        std::string m_description;
+
+        explicit ParserRefImpl( std::shared_ptr<BoundRef> const &ref ) : m_ref( ref ) {}
+
+    public:
+        template<typename T>
+        ParserRefImpl( T &ref, std::string const &hint )
+        :   m_ref( std::make_shared<BoundValueRef<T>>( ref ) ),
+            m_hint( hint )
+        {}
+
+        template<typename LambdaT>
+        ParserRefImpl( LambdaT const &ref, std::string const &hint )
+        :   m_ref( std::make_shared<BoundLambda<LambdaT>>( ref ) ),
+            m_hint(hint)
+        {}
+
+        auto operator()( std::string const &description ) -> DerivedT & {
+            m_description = description;
+            return static_cast<DerivedT &>( *this );
+        }
+
+        auto optional() -> DerivedT & {
+            m_optionality = Optionality::Optional;
+            return static_cast<DerivedT &>( *this );
+        };
+
+        auto required() -> DerivedT & {
+            m_optionality = Optionality::Required;
+            return static_cast<DerivedT &>( *this );
+        };
+
+        auto isOptional() const -> bool {
+            return m_optionality == Optionality::Optional;
+        }
+
+        auto cardinality() const -> size_t override {
+            if( m_ref->isContainer() )
+                return 0;
+            else
+                return 1;
+        }
+
+        auto hint() const -> std::string { return m_hint; }
+    };
+
+    class ExeName : public ComposableParserImpl<ExeName> {
+        std::shared_ptr<std::string> m_name;
+        std::shared_ptr<BoundValueRefBase> m_ref;
+
+        template<typename LambdaT>
+        static auto makeRef(LambdaT const &lambda) -> std::shared_ptr<BoundValueRefBase> {
+            return std::make_shared<BoundLambda<LambdaT>>( lambda) ;
+        }
+
+    public:
+        ExeName() : m_name( std::make_shared<std::string>( "<executable>" ) ) {}
+
+        explicit ExeName( std::string &ref ) : ExeName() {
+            m_ref = std::make_shared<BoundValueRef<std::string>>( ref );
+        }
+
+        template<typename LambdaT>
+        explicit ExeName( LambdaT const& lambda ) : ExeName() {
+            m_ref = std::make_shared<BoundLambda<LambdaT>>( lambda );
+        }
+
+        // The exe name is not parsed out of the normal tokens, but is handled specially
+        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
+            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
+        }
+
+        auto name() const -> std::string { return *m_name; }
+        auto set( std::string const& newName ) -> ParserResult {
+
+            auto lastSlash = newName.find_last_of( "\\/" );
+            auto filename = ( lastSlash == std::string::npos )
+                    ? newName
+                    : newName.substr( lastSlash+1 );
+
+            *m_name = filename;
+            if( m_ref )
+                return m_ref->setValue( filename );
+            else
+                return ParserResult::ok( ParseResultType::Matched );
+        }
+    };
+
+    class Arg : public ParserRefImpl<Arg> {
+    public:
+        using ParserRefImpl::ParserRefImpl;
+
+        auto parse( std::string const &, TokenStream const &tokens ) const -> InternalParseResult override {
+            auto validationResult = validate();
+            if( !validationResult )
+                return InternalParseResult( validationResult );
+
+            auto remainingTokens = tokens;
+            auto const &token = *remainingTokens;
+            if( token.type != TokenType::Argument )
+                return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
+
+            assert( !m_ref->isFlag() );
+            auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
+
+            auto result = valueRef->setValue( remainingTokens->token );
+            if( !result )
+                return InternalParseResult( result );
+            else
+                return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
+        }
+    };
+
+    inline auto normaliseOpt( std::string const &optName ) -> std::string {
+#ifdef CATCH_PLATFORM_WINDOWS
+        if( optName[0] == '/' )
+            return "-" + optName.substr( 1 );
+        else
+#endif
+            return optName;
+    }
+
+    class Opt : public ParserRefImpl<Opt> {
+    protected:
+        std::vector<std::string> m_optNames;
+
+    public:
+        template<typename LambdaT>
+        explicit Opt( LambdaT const &ref ) : ParserRefImpl( std::make_shared<BoundFlagLambda<LambdaT>>( ref ) ) {}
+
+        explicit Opt( bool &ref ) : ParserRefImpl( std::make_shared<BoundFlagRef>( ref ) ) {}
+
+        template<typename LambdaT>
+        Opt( LambdaT const &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
+
+        template<typename T>
+        Opt( T &ref, std::string const &hint ) : ParserRefImpl( ref, hint ) {}
+
+        auto operator[]( std::string const &optName ) -> Opt & {
+            m_optNames.push_back( optName );
+            return *this;
+        }
+
+        auto getHelpColumns() const -> std::vector<HelpColumns> {
+            std::ostringstream oss;
+            bool first = true;
+            for( auto const &opt : m_optNames ) {
+                if (first)
+                    first = false;
+                else
+                    oss << ", ";
+                oss << opt;
+            }
+            if( !m_hint.empty() )
+                oss << " <" << m_hint << ">";
+            return { { oss.str(), m_description } };
+        }
+
+        auto isMatch( std::string const &optToken ) const -> bool {
+            auto normalisedToken = normaliseOpt( optToken );
+            for( auto const &name : m_optNames ) {
+                if( normaliseOpt( name ) == normalisedToken )
+                    return true;
+            }
+            return false;
+        }
+
+        using ParserBase::parse;
+
+        auto parse( std::string const&, TokenStream const &tokens ) const -> InternalParseResult override {
+            auto validationResult = validate();
+            if( !validationResult )
+                return InternalParseResult( validationResult );
+
+            auto remainingTokens = tokens;
+            if( remainingTokens && remainingTokens->type == TokenType::Option ) {
+                auto const &token = *remainingTokens;
+                if( isMatch(token.token ) ) {
+                    if( m_ref->isFlag() ) {
+                        auto flagRef = static_cast<detail::BoundFlagRefBase*>( m_ref.get() );
+                        auto result = flagRef->setFlag( true );
+                        if( !result )
+                            return InternalParseResult( result );
+                        if( result.value() == ParseResultType::ShortCircuitAll )
+                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
+                    } else {
+                        auto valueRef = static_cast<detail::BoundValueRefBase*>( m_ref.get() );
+                        ++remainingTokens;
+                        if( !remainingTokens )
+                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
+                        auto const &argToken = *remainingTokens;
+                        if( argToken.type != TokenType::Argument )
+                            return InternalParseResult::runtimeError( "Expected argument following " + token.token );
+                        auto result = valueRef->setValue( argToken.token );
+                        if( !result )
+                            return InternalParseResult( result );
+                        if( result.value() == ParseResultType::ShortCircuitAll )
+                            return InternalParseResult::ok( ParseState( result.value(), remainingTokens ) );
+                    }
+                    return InternalParseResult::ok( ParseState( ParseResultType::Matched, ++remainingTokens ) );
+                }
+            }
+            return InternalParseResult::ok( ParseState( ParseResultType::NoMatch, remainingTokens ) );
+        }
+
+        auto validate() const -> Result override {
+            if( m_optNames.empty() )
+                return Result::logicError( "No options supplied to Opt" );
+            for( auto const &name : m_optNames ) {
+                if( name.empty() )
+                    return Result::logicError( "Option name cannot be empty" );
+#ifdef CATCH_PLATFORM_WINDOWS
+                if( name[0] != '-' && name[0] != '/' )
+                    return Result::logicError( "Option name must begin with '-' or '/'" );
+#else
+                if( name[0] != '-' )
+                    return Result::logicError( "Option name must begin with '-'" );
+#endif
+            }
+            return ParserRefImpl::validate();
+        }
+    };
+
+    struct Help : Opt {
+        Help( bool &showHelpFlag )
+        :   Opt([&]( bool flag ) {
+                showHelpFlag = flag;
+                return ParserResult::ok( ParseResultType::ShortCircuitAll );
+            })
+        {
+            static_cast<Opt &>( *this )
+                    ("display usage information")
+                    ["-?"]["-h"]["--help"]
+                    .optional();
+        }
+    };
+
+    struct Parser : ParserBase {
+
+        mutable ExeName m_exeName;
+        std::vector<Opt> m_options;
+        std::vector<Arg> m_args;
+
+        auto operator|=( ExeName const &exeName ) -> Parser & {
+            m_exeName = exeName;
+            return *this;
+        }
+
+        auto operator|=( Arg const &arg ) -> Parser & {
+            m_args.push_back(arg);
+            return *this;
+        }
+
+        auto operator|=( Opt const &opt ) -> Parser & {
+            m_options.push_back(opt);
+            return *this;
+        }
+
+        auto operator|=( Parser const &other ) -> Parser & {
+            m_options.insert(m_options.end(), other.m_options.begin(), other.m_options.end());
+            m_args.insert(m_args.end(), other.m_args.begin(), other.m_args.end());
+            return *this;
+        }
+
+        template<typename T>
+        auto operator|( T const &other ) const -> Parser {
+            return Parser( *this ) |= other;
+        }
+
+        // Forward deprecated interface with '+' instead of '|'
+        template<typename T>
+        auto operator+=( T const &other ) -> Parser & { return operator|=( other ); }
+        template<typename T>
+        auto operator+( T const &other ) const -> Parser { return operator|( other ); }
+
+        auto getHelpColumns() const -> std::vector<HelpColumns> {
+            std::vector<HelpColumns> cols;
+            for (auto const &o : m_options) {
+                auto childCols = o.getHelpColumns();
+                cols.insert( cols.end(), childCols.begin(), childCols.end() );
+            }
+            return cols;
+        }
+
+        void writeToStream( std::ostream &os ) const {
+            if (!m_exeName.name().empty()) {
+                os << "usage:\n" << "  " << m_exeName.name() << " ";
+                bool required = true, first = true;
+                for( auto const &arg : m_args ) {
+                    if (first)
+                        first = false;
+                    else
+                        os << " ";
+                    if( arg.isOptional() && required ) {
+                        os << "[";
+                        required = false;
+                    }
+                    os << "<" << arg.hint() << ">";
+                    if( arg.cardinality() == 0 )
+                        os << " ... ";
+                }
+                if( !required )
+                    os << "]";
+                if( !m_options.empty() )
+                    os << " options";
+                os << "\n\nwhere options are:" << std::endl;
+            }
+
+            auto rows = getHelpColumns();
+            size_t consoleWidth = CATCH_CLARA_CONFIG_CONSOLE_WIDTH;
+            size_t optWidth = 0;
+            for( auto const &cols : rows )
+                optWidth = (std::max)(optWidth, cols.left.size() + 2);
+
+            optWidth = (std::min)(optWidth, consoleWidth/2);
+
+            for( auto const &cols : rows ) {
+                auto row =
+                        TextFlow::Column( cols.left ).width( optWidth ).indent( 2 ) +
+                        TextFlow::Spacer(4) +
+                        TextFlow::Column( cols.right ).width( consoleWidth - 7 - optWidth );
+                os << row << std::endl;
+            }
+        }
+
+        friend auto operator<<( std::ostream &os, Parser const &parser ) -> std::ostream& {
+            parser.writeToStream( os );
+            return os;
+        }
+
+        auto validate() const -> Result override {
+            for( auto const &opt : m_options ) {
+                auto result = opt.validate();
+                if( !result )
+                    return result;
+            }
+            for( auto const &arg : m_args ) {
+                auto result = arg.validate();
+                if( !result )
+                    return result;
+            }
+            return Result::ok();
+        }
+
+        using ParserBase::parse;
+
+        auto parse( std::string const& exeName, TokenStream const &tokens ) const -> InternalParseResult override {
+
+            struct ParserInfo {
+                ParserBase const* parser = nullptr;
+                size_t count = 0;
+            };
+            const size_t totalParsers = m_options.size() + m_args.size();
+            assert( totalParsers < 512 );
+            // ParserInfo parseInfos[totalParsers]; // <-- this is what we really want to do
+            ParserInfo parseInfos[512];
+
+            {
+                size_t i = 0;
+                for (auto const &opt : m_options) parseInfos[i++].parser = &opt;
+                for (auto const &arg : m_args) parseInfos[i++].parser = &arg;
+            }
+
+            m_exeName.set( exeName );
+
+            auto result = InternalParseResult::ok( ParseState( ParseResultType::NoMatch, tokens ) );
+            while( result.value().remainingTokens() ) {
+                bool tokenParsed = false;
+
+                for( size_t i = 0; i < totalParsers; ++i ) {
+                    auto&  parseInfo = parseInfos[i];
+                    if( parseInfo.parser->cardinality() == 0 || parseInfo.count < parseInfo.parser->cardinality() ) {
+                        result = parseInfo.parser->parse(exeName, result.value().remainingTokens());
+                        if (!result)
+                            return result;
+                        if (result.value().type() != ParseResultType::NoMatch) {
+                            tokenParsed = true;
+                            ++parseInfo.count;
+                            break;
+                        }
+                    }
+                }
+
+                if( result.value().type() == ParseResultType::ShortCircuitAll )
+                    return result;
+                if( !tokenParsed )
+                    return InternalParseResult::runtimeError( "Unrecognised token: " + result.value().remainingTokens()->token );
+            }
+            // !TBD Check missing required options
+            return result;
+        }
+    };
+
+    template<typename DerivedT>
+    template<typename T>
+    auto ComposableParserImpl<DerivedT>::operator|( T const &other ) const -> Parser {
+        return Parser() | static_cast<DerivedT const &>( *this ) | other;
+    }
+} // namespace detail
+
+// A Combined parser
+using detail::Parser;
+
+// A parser for options
+using detail::Opt;
+
+// A parser for arguments
+using detail::Arg;
+
+// Wrapper for argc, argv from main()
+using detail::Args;
+
+// Specifies the name of the executable
+using detail::ExeName;
+
+// Convenience wrapper for option parser that specifies the help option
+using detail::Help;
+
+// enum of result types from a parse
+using detail::ParseResultType;
+
+// Result type for parser operation
+using detail::ParserResult;
+
+}} // namespace Catch::clara
+
+// end clara.hpp
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+// Restore Clara's value for console width, if present
+#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
+#define CATCH_CLARA_TEXTFLOW_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
+#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
+#endif
+
+// end catch_clara.h
+namespace Catch {
+
+    clara::Parser makeCommandLineParser( ConfigData& config );
+
+} // end namespace Catch
+
+// end catch_commandline.h
+#include <fstream>
+#include <ctime>
+
+namespace Catch {
+
+    clara::Parser makeCommandLineParser( ConfigData& config ) {
+
+        using namespace clara;
+
+        auto const setWarning = [&]( std::string const& warning ) {
+                auto warningSet = [&]() {
+                    if( warning == "NoAssertions" )
+                        return WarnAbout::NoAssertions;
+
+                    if ( warning == "NoTests" )
+                        return WarnAbout::NoTests;
+
+                    return WarnAbout::Nothing;
+                }();
+
+                if (warningSet == WarnAbout::Nothing)
+                    return ParserResult::runtimeError( "Unrecognised warning: '" + warning + "'" );
+                config.warnings = static_cast<WarnAbout::What>( config.warnings | warningSet );
+                return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const loadTestNamesFromFile = [&]( std::string const& filename ) {
+                std::ifstream f( filename.c_str() );
+                if( !f.is_open() )
+                    return ParserResult::runtimeError( "Unable to load input file: '" + filename + "'" );
+
+                std::string line;
+                while( std::getline( f, line ) ) {
+                    line = trim(line);
+                    if( !line.empty() && !startsWith( line, '#' ) ) {
+                        if( !startsWith( line, '"' ) )
+                            line = '"' + line + '"';
+                        config.testsOrTags.push_back( line );
+                        config.testsOrTags.emplace_back( "," );
+                    }
+                }
+                //Remove comma in the end
+                if(!config.testsOrTags.empty())
+                    config.testsOrTags.erase( config.testsOrTags.end()-1 );
+
+                return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const setTestOrder = [&]( std::string const& order ) {
+                if( startsWith( "declared", order ) )
+                    config.runOrder = RunTests::InDeclarationOrder;
+                else if( startsWith( "lexical", order ) )
+                    config.runOrder = RunTests::InLexicographicalOrder;
+                else if( startsWith( "random", order ) )
+                    config.runOrder = RunTests::InRandomOrder;
+                else
+                    return clara::ParserResult::runtimeError( "Unrecognised ordering: '" + order + "'" );
+                return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const setRngSeed = [&]( std::string const& seed ) {
+                if( seed != "time" )
+                    return clara::detail::convertInto( seed, config.rngSeed );
+                config.rngSeed = static_cast<unsigned int>( std::time(nullptr) );
+                return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const setColourUsage = [&]( std::string const& useColour ) {
+                    auto mode = toLower( useColour );
+
+                    if( mode == "yes" )
+                        config.useColour = UseColour::Yes;
+                    else if( mode == "no" )
+                        config.useColour = UseColour::No;
+                    else if( mode == "auto" )
+                        config.useColour = UseColour::Auto;
+                    else
+                        return ParserResult::runtimeError( "colour mode must be one of: auto, yes or no. '" + useColour + "' not recognised" );
+                return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const setWaitForKeypress = [&]( std::string const& keypress ) {
+                auto keypressLc = toLower( keypress );
+                if (keypressLc == "never")
+                    config.waitForKeypress = WaitForKeypress::Never;
+                else if( keypressLc == "start" )
+                    config.waitForKeypress = WaitForKeypress::BeforeStart;
+                else if( keypressLc == "exit" )
+                    config.waitForKeypress = WaitForKeypress::BeforeExit;
+                else if( keypressLc == "both" )
+                    config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
+                else
+                    return ParserResult::runtimeError( "keypress argument must be one of: never, start, exit or both. '" + keypress + "' not recognised" );
+            return ParserResult::ok( ParseResultType::Matched );
+            };
+        auto const setVerbosity = [&]( std::string const& verbosity ) {
+            auto lcVerbosity = toLower( verbosity );
+            if( lcVerbosity == "quiet" )
+                config.verbosity = Verbosity::Quiet;
+            else if( lcVerbosity == "normal" )
+                config.verbosity = Verbosity::Normal;
+            else if( lcVerbosity == "high" )
+                config.verbosity = Verbosity::High;
+            else
+                return ParserResult::runtimeError( "Unrecognised verbosity, '" + verbosity + "'" );
+            return ParserResult::ok( ParseResultType::Matched );
+        };
+        auto const setReporter = [&]( std::string const& reporter ) {
+            IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
+
+            auto lcReporter = toLower( reporter );
+            auto result = factories.find( lcReporter );
+
+            if( factories.end() != result )
+                config.reporterName = lcReporter;
+            else
+                return ParserResult::runtimeError( "Unrecognized reporter, '" + reporter + "'. Check available with --list-reporters" );
+            return ParserResult::ok( ParseResultType::Matched );
+        };
+
+        auto cli
+            = ExeName( config.processName )
+            | Help( config.showHelp )
+            | Opt( config.listTests )
+                ["-l"]["--list-tests"]
+                ( "list all/matching test cases" )
+            | Opt( config.listTags )
+                ["-t"]["--list-tags"]
+                ( "list all/matching tags" )
+            | Opt( config.showSuccessfulTests )
+                ["-s"]["--success"]
+                ( "include successful tests in output" )
+            | Opt( config.shouldDebugBreak )
+                ["-b"]["--break"]
+                ( "break into debugger on failure" )
+            | Opt( config.noThrow )
+                ["-e"]["--nothrow"]
+                ( "skip exception tests" )
+            | Opt( config.showInvisibles )
+                ["-i"]["--invisibles"]
+                ( "show invisibles (tabs, newlines)" )
+            | Opt( config.outputFilename, "filename" )
+                ["-o"]["--out"]
+                ( "output filename" )
+            | Opt( setReporter, "name" )
+                ["-r"]["--reporter"]
+                ( "reporter to use (defaults to console)" )
+            | Opt( config.name, "name" )
+                ["-n"]["--name"]
+                ( "suite name" )
+            | Opt( [&]( bool ){ config.abortAfter = 1; } )
+                ["-a"]["--abort"]
+                ( "abort at first failure" )
+            | Opt( [&]( int x ){ config.abortAfter = x; }, "no. failures" )
+                ["-x"]["--abortx"]
+                ( "abort after x failures" )
+            | Opt( setWarning, "warning name" )
+                ["-w"]["--warn"]
+                ( "enable warnings" )
+            | Opt( [&]( bool flag ) { config.showDurations = flag ? ShowDurations::Always : ShowDurations::Never; }, "yes|no" )
+                ["-d"]["--durations"]
+                ( "show test durations" )
+            | Opt( loadTestNamesFromFile, "filename" )
+                ["-f"]["--input-file"]
+                ( "load test names to run from a file" )
+            | Opt( config.filenamesAsTags )
+                ["-#"]["--filenames-as-tags"]
+                ( "adds a tag for the filename" )
+            | Opt( config.sectionsToRun, "section name" )
+                ["-c"]["--section"]
+                ( "specify section to run" )
+            | Opt( setVerbosity, "quiet|normal|high" )
+                ["-v"]["--verbosity"]
+                ( "set output verbosity" )
+            | Opt( config.listTestNamesOnly )
+                ["--list-test-names-only"]
+                ( "list all/matching test cases names only" )
+            | Opt( config.listReporters )
+                ["--list-reporters"]
+                ( "list all reporters" )
+            | Opt( setTestOrder, "decl|lex|rand" )
+                ["--order"]
+                ( "test case order (defaults to decl)" )
+            | Opt( setRngSeed, "'time'|number" )
+                ["--rng-seed"]
+                ( "set a specific seed for random numbers" )
+            | Opt( setColourUsage, "yes|no" )
+                ["--use-colour"]
+                ( "should output be colourised" )
+            | Opt( config.libIdentify )
+                ["--libidentify"]
+                ( "report name and version according to libidentify standard" )
+            | Opt( setWaitForKeypress, "never|start|exit|both" )
+                ["--wait-for-keypress"]
+                ( "waits for a keypress before exiting" )
+            | Opt( config.benchmarkSamples, "samples" )
+                ["--benchmark-samples"]
+                ( "number of samples to collect (default: 100)" )
+            | Opt( config.benchmarkResamples, "resamples" )
+                ["--benchmark-resamples"]
+                ( "number of resamples for the bootstrap (default: 100000)" )
+            | Opt( config.benchmarkConfidenceInterval, "confidence interval" )
+                ["--benchmark-confidence-interval"]
+                ( "confidence interval for the bootstrap (between 0 and 1, default: 0.95)" )
+            | Opt( config.benchmarkNoAnalysis )
+                ["--benchmark-no-analysis"]
+                ( "perform only measurements; do not perform any analysis" )
+            | Opt( config.benchmarkWarmupTime, "benchmarkWarmupTime" )
+                ["--benchmark-warmup-time"]
+                ( "amount of time in milliseconds spent on warming up each test (default: 100)" )
+            | Arg( config.testsOrTags, "test name|pattern|tags" )
+                ( "which test or tests to use" );
+
+        return cli;
+    }
+
+} // end namespace Catch
+// end catch_commandline.cpp
+// start catch_common.cpp
+
+#include <cstring>
+#include <ostream>
+
+namespace Catch {
+
+    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const noexcept {
+        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
+    }
+    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const noexcept {
+        // We can assume that the same file will usually have the same pointer.
+        // Thus, if the pointers are the same, there is no point in calling the strcmp
+        return line < other.line || ( line == other.line && file != other.file && (std::strcmp(file, other.file) < 0));
+    }
+
+    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
+#ifndef __GNUG__
+        os << info.file << '(' << info.line << ')';
+#else
+        os << info.file << ':' << info.line;
+#endif
+        return os;
+    }
+
+    std::string StreamEndStop::operator+() const {
+        return std::string();
+    }
+
+    NonCopyable::NonCopyable() = default;
+    NonCopyable::~NonCopyable() = default;
+
+}
+// end catch_common.cpp
+// start catch_config.cpp
+
+namespace Catch {
+
+    Config::Config( ConfigData const& data )
+    :   m_data( data ),
+        m_stream( openStream() )
+    {
+        // We need to trim filter specs to avoid trouble with superfluous
+        // whitespace (esp. important for bdd macros, as those are manually
+        // aligned with whitespace).
+
+        for (auto& elem : m_data.testsOrTags) {
+            elem = trim(elem);
+        }
+        for (auto& elem : m_data.sectionsToRun) {
+            elem = trim(elem);
+        }
+
+        TestSpecParser parser(ITagAliasRegistry::get());
+        if (!m_data.testsOrTags.empty()) {
+            m_hasTestFilters = true;
+            for (auto const& testOrTags : m_data.testsOrTags) {
+                parser.parse(testOrTags);
+            }
+        }
+        m_testSpec = parser.testSpec();
+    }
+
+    std::string const& Config::getFilename() const {
+        return m_data.outputFilename ;
+    }
+
+    bool Config::listTests() const          { return m_data.listTests; }
+    bool Config::listTestNamesOnly() const  { return m_data.listTestNamesOnly; }
+    bool Config::listTags() const           { return m_data.listTags; }
+    bool Config::listReporters() const      { return m_data.listReporters; }
+
+    std::string Config::getProcessName() const { return m_data.processName; }
+    std::string const& Config::getReporterName() const { return m_data.reporterName; }
+
+    std::vector<std::string> const& Config::getTestsOrTags() const { return m_data.testsOrTags; }
+    std::vector<std::string> const& Config::getSectionsToRun() const { return m_data.sectionsToRun; }
+
+    TestSpec const& Config::testSpec() const { return m_testSpec; }
+    bool Config::hasTestFilters() const { return m_hasTestFilters; }
+
+    bool Config::showHelp() const { return m_data.showHelp; }
+
+    // IConfig interface
+    bool Config::allowThrows() const                   { return !m_data.noThrow; }
+    std::ostream& Config::stream() const               { return m_stream->stream(); }
+    std::string Config::name() const                   { return m_data.name.empty() ? m_data.processName : m_data.name; }
+    bool Config::includeSuccessfulResults() const      { return m_data.showSuccessfulTests; }
+    bool Config::warnAboutMissingAssertions() const    { return !!(m_data.warnings & WarnAbout::NoAssertions); }
+    bool Config::warnAboutNoTests() const              { return !!(m_data.warnings & WarnAbout::NoTests); }
+    ShowDurations::OrNot Config::showDurations() const { return m_data.showDurations; }
+    RunTests::InWhatOrder Config::runOrder() const     { return m_data.runOrder; }
+    unsigned int Config::rngSeed() const               { return m_data.rngSeed; }
+    UseColour::YesOrNo Config::useColour() const       { return m_data.useColour; }
+    bool Config::shouldDebugBreak() const              { return m_data.shouldDebugBreak; }
+    int Config::abortAfter() const                     { return m_data.abortAfter; }
+    bool Config::showInvisibles() const                { return m_data.showInvisibles; }
+    Verbosity Config::verbosity() const                { return m_data.verbosity; }
+
+    bool Config::benchmarkNoAnalysis() const                      { return m_data.benchmarkNoAnalysis; }
+    int Config::benchmarkSamples() const                          { return m_data.benchmarkSamples; }
+    double Config::benchmarkConfidenceInterval() const            { return m_data.benchmarkConfidenceInterval; }
+    unsigned int Config::benchmarkResamples() const               { return m_data.benchmarkResamples; }
+    std::chrono::milliseconds Config::benchmarkWarmupTime() const { return std::chrono::milliseconds(m_data.benchmarkWarmupTime); }
+
+    IStream const* Config::openStream() {
+        return Catch::makeStream(m_data.outputFilename);
+    }
+
+} // end namespace Catch
+// end catch_config.cpp
+// start catch_console_colour.cpp
+
+#if defined(__clang__)
+#    pragma clang diagnostic push
+#    pragma clang diagnostic ignored "-Wexit-time-destructors"
+#endif
+
+// start catch_errno_guard.h
+
+namespace Catch {
+
+    class ErrnoGuard {
+    public:
+        ErrnoGuard();
+        ~ErrnoGuard();
+    private:
+        int m_oldErrno;
+    };
+
+}
+
+// end catch_errno_guard.h
+#include <sstream>
+
+namespace Catch {
+    namespace {
+
+        struct IColourImpl {
+            virtual ~IColourImpl() = default;
+            virtual void use( Colour::Code _colourCode ) = 0;
+        };
+
+        struct NoColourImpl : IColourImpl {
+            void use( Colour::Code ) override {}
+
+            static IColourImpl* instance() {
+                static NoColourImpl s_instance;
+                return &s_instance;
+            }
+        };
+
+    } // anon namespace
+} // namespace Catch
+
+#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
+#   ifdef CATCH_PLATFORM_WINDOWS
+#       define CATCH_CONFIG_COLOUR_WINDOWS
+#   else
+#       define CATCH_CONFIG_COLOUR_ANSI
+#   endif
+#endif
+
+#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
+
+namespace Catch {
+namespace {
+
+    class Win32ColourImpl : public IColourImpl {
+    public:
+        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
+        {
+            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
+            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
+            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
+            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
+        }
+
+        void use( Colour::Code _colourCode ) override {
+            switch( _colourCode ) {
+                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
+                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
+                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
+                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
+                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
+                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
+                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
+                case Colour::Grey:      return setTextAttribute( 0 );
+
+                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
+                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
+                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
+                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
+                case Colour::BrightYellow:  return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN );
+
+                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
+
+                default:
+                    CATCH_ERROR( "Unknown colour requested" );
+            }
+        }
+
+    private:
+        void setTextAttribute( WORD _textAttribute ) {
+            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
+        }
+        HANDLE stdoutHandle;
+        WORD originalForegroundAttributes;
+        WORD originalBackgroundAttributes;
+    };
+
+    IColourImpl* platformColourInstance() {
+        static Win32ColourImpl s_instance;
+
+        IConfigPtr config = getCurrentContext().getConfig();
+        UseColour::YesOrNo colourMode = config
+            ? config->useColour()
+            : UseColour::Auto;
+        if( colourMode == UseColour::Auto )
+            colourMode = UseColour::Yes;
+        return colourMode == UseColour::Yes
+            ? &s_instance
+            : NoColourImpl::instance();
+    }
+
+} // end anon namespace
+} // end namespace Catch
+
+#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
+
+#include <unistd.h>
+
+namespace Catch {
+namespace {
+
+    // use POSIX/ ANSI console terminal codes
+    // Thanks to Adam Strzelecki for original contribution
+    // (http://github.com/nanoant)
+    // https://github.com/philsquared/Catch/pull/131
+    class PosixColourImpl : public IColourImpl {
+    public:
+        void use( Colour::Code _colourCode ) override {
+            switch( _colourCode ) {
+                case Colour::None:
+                case Colour::White:     return setColour( "[0m" );
+                case Colour::Red:       return setColour( "[0;31m" );
+                case Colour::Green:     return setColour( "[0;32m" );
+                case Colour::Blue:      return setColour( "[0;34m" );
+                case Colour::Cyan:      return setColour( "[0;36m" );
+                case Colour::Yellow:    return setColour( "[0;33m" );
+                case Colour::Grey:      return setColour( "[1;30m" );
+
+                case Colour::LightGrey:     return setColour( "[0;37m" );
+                case Colour::BrightRed:     return setColour( "[1;31m" );
+                case Colour::BrightGreen:   return setColour( "[1;32m" );
+                case Colour::BrightWhite:   return setColour( "[1;37m" );
+                case Colour::BrightYellow:  return setColour( "[1;33m" );
+
+                case Colour::Bright: CATCH_INTERNAL_ERROR( "not a colour" );
+                default: CATCH_INTERNAL_ERROR( "Unknown colour requested" );
+            }
+        }
+        static IColourImpl* instance() {
+            static PosixColourImpl s_instance;
+            return &s_instance;
+        }
+
+    private:
+        void setColour( const char* _escapeCode ) {
+            getCurrentContext().getConfig()->stream()
+                << '\033' << _escapeCode;
+        }
+    };
+
+    bool useColourOnPlatform() {
+        return
+#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
+            !isDebuggerActive() &&
+#endif
+#if !(defined(__DJGPP__) && defined(__STRICT_ANSI__))
+            isatty(STDOUT_FILENO)
+#else
+            false
+#endif
+            ;
+    }
+    IColourImpl* platformColourInstance() {
+        ErrnoGuard guard;
+        IConfigPtr config = getCurrentContext().getConfig();
+        UseColour::YesOrNo colourMode = config
+            ? config->useColour()
+            : UseColour::Auto;
+        if( colourMode == UseColour::Auto )
+            colourMode = useColourOnPlatform()
+                ? UseColour::Yes
+                : UseColour::No;
+        return colourMode == UseColour::Yes
+            ? PosixColourImpl::instance()
+            : NoColourImpl::instance();
+    }
+
+} // end anon namespace
+} // end namespace Catch
+
+#else  // not Windows or ANSI ///////////////////////////////////////////////
+
+namespace Catch {
+
+    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
+
+} // end namespace Catch
+
+#endif // Windows/ ANSI/ None
+
+namespace Catch {
+
+    Colour::Colour( Code _colourCode ) { use( _colourCode ); }
+    Colour::Colour( Colour&& other ) noexcept {
+        m_moved = other.m_moved;
+        other.m_moved = true;
+    }
+    Colour& Colour::operator=( Colour&& other ) noexcept {
+        m_moved = other.m_moved;
+        other.m_moved  = true;
+        return *this;
+    }
+
+    Colour::~Colour(){ if( !m_moved ) use( None ); }
+
+    void Colour::use( Code _colourCode ) {
+        static IColourImpl* impl = platformColourInstance();
+        // Strictly speaking, this cannot possibly happen.
+        // However, under some conditions it does happen (see #1626),
+        // and this change is small enough that we can let practicality
+        // triumph over purity in this case.
+        if (impl != nullptr) {
+            impl->use( _colourCode );
+        }
+    }
+
+    std::ostream& operator << ( std::ostream& os, Colour const& ) {
+        return os;
+    }
+
+} // end namespace Catch
+
+#if defined(__clang__)
+#    pragma clang diagnostic pop
+#endif
+
+// end catch_console_colour.cpp
+// start catch_context.cpp
+
+namespace Catch {
+
+    class Context : public IMutableContext, NonCopyable {
+
+    public: // IContext
+        IResultCapture* getResultCapture() override {
+            return m_resultCapture;
+        }
+        IRunner* getRunner() override {
+            return m_runner;
+        }
+
+        IConfigPtr const& getConfig() const override {
+            return m_config;
+        }
+
+        ~Context() override;
+
+    public: // IMutableContext
+        void setResultCapture( IResultCapture* resultCapture ) override {
+            m_resultCapture = resultCapture;
+        }
+        void setRunner( IRunner* runner ) override {
+            m_runner = runner;
+        }
+        void setConfig( IConfigPtr const& config ) override {
+            m_config = config;
+        }
+
+        friend IMutableContext& getCurrentMutableContext();
+
+    private:
+        IConfigPtr m_config;
+        IRunner* m_runner = nullptr;
+        IResultCapture* m_resultCapture = nullptr;
+    };
+
+    IMutableContext *IMutableContext::currentContext = nullptr;
+
+    void IMutableContext::createContext()
+    {
+        currentContext = new Context();
+    }
+
+    void cleanUpContext() {
+        delete IMutableContext::currentContext;
+        IMutableContext::currentContext = nullptr;
+    }
+    IContext::~IContext() = default;
+    IMutableContext::~IMutableContext() = default;
+    Context::~Context() = default;
+
+    SimplePcg32& rng() {
+        static SimplePcg32 s_rng;
+        return s_rng;
+    }
+
+}
+// end catch_context.cpp
+// start catch_debug_console.cpp
+
+// start catch_debug_console.h
+
+#include <string>
+
+namespace Catch {
+    void writeToDebugConsole( std::string const& text );
+}
+
+// end catch_debug_console.h
+#if defined(CATCH_CONFIG_ANDROID_LOGWRITE)
+#include <android/log.h>
+
+    namespace Catch {
+        void writeToDebugConsole( std::string const& text ) {
+            __android_log_write( ANDROID_LOG_DEBUG, "Catch", text.c_str() );
+        }
+    }
+
+#elif defined(CATCH_PLATFORM_WINDOWS)
+
+    namespace Catch {
+        void writeToDebugConsole( std::string const& text ) {
+            ::OutputDebugStringA( text.c_str() );
+        }
+    }
+
+#else
+
+    namespace Catch {
+        void writeToDebugConsole( std::string const& text ) {
+            // !TBD: Need a version for Mac/ XCode and other IDEs
+            Catch::cout() << text;
+        }
+    }
+
+#endif // Platform
+// end catch_debug_console.cpp
+// start catch_debugger.cpp
+
+#if defined(CATCH_PLATFORM_MAC) || defined(CATCH_PLATFORM_IPHONE)
+
+#  include <cassert>
+#  include <sys/types.h>
+#  include <unistd.h>
+#  include <cstddef>
+#  include <ostream>
+
+#ifdef __apple_build_version__
+    // These headers will only compile with AppleClang (XCode)
+    // For other compilers (Clang, GCC, ... ) we need to exclude them
+#  include <sys/sysctl.h>
+#endif
+
+    namespace Catch {
+        #ifdef __apple_build_version__
+        // The following function is taken directly from the following technical note:
+        // https://developer.apple.com/library/archive/qa/qa1361/_index.html
+
+        // Returns true if the current process is being debugged (either
+        // running under the debugger or has a debugger attached post facto).
+        bool isDebuggerActive(){
+            int                 mib[4];
+            struct kinfo_proc   info;
+            std::size_t         size;
+
+            // Initialize the flags so that, if sysctl fails for some bizarre
+            // reason, we get a predictable result.
+
+            info.kp_proc.p_flag = 0;
+
+            // Initialize mib, which tells sysctl the info we want, in this case
+            // we're looking for information about a specific process ID.
+
+            mib[0] = CTL_KERN;
+            mib[1] = KERN_PROC;
+            mib[2] = KERN_PROC_PID;
+            mib[3] = getpid();
+
+            // Call sysctl.
+
+            size = sizeof(info);
+            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, nullptr, 0) != 0 ) {
+                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
+                return false;
+            }
+
+            // We're being debugged if the P_TRACED flag is set.
+
+            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
+        }
+        #else
+        bool isDebuggerActive() {
+            // We need to find another way to determine this for non-appleclang compilers on macOS
+            return false;
+        }
+        #endif
+    } // namespace Catch
+
+#elif defined(CATCH_PLATFORM_LINUX)
+    #include <fstream>
+    #include <string>
+
+    namespace Catch{
+        // The standard POSIX way of detecting a debugger is to attempt to
+        // ptrace() the process, but this needs to be done from a child and not
+        // this process itself to still allow attaching to this process later
+        // if wanted, so is rather heavy. Under Linux we have the PID of the
+        // "debugger" (which doesn't need to be gdb, of course, it could also
+        // be strace, for example) in /proc/$PID/status, so just get it from
+        // there instead.
+        bool isDebuggerActive(){
+            // Libstdc++ has a bug, where std::ifstream sets errno to 0
+            // This way our users can properly assert over errno values
+            ErrnoGuard guard;
+            std::ifstream in("/proc/self/status");
+            for( std::string line; std::getline(in, line); ) {
+                static const int PREFIX_LEN = 11;
+                if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
+                    // We're traced if the PID is not 0 and no other PID starts
+                    // with 0 digit, so it's enough to check for just a single
+                    // character.
+                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
+                }
+            }
+
+            return false;
+        }
+    } // namespace Catch
+#elif defined(_MSC_VER)
+    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
+    namespace Catch {
+        bool isDebuggerActive() {
+            return IsDebuggerPresent() != 0;
+        }
+    }
+#elif defined(__MINGW32__)
+    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
+    namespace Catch {
+        bool isDebuggerActive() {
+            return IsDebuggerPresent() != 0;
+        }
+    }
+#else
+    namespace Catch {
+       bool isDebuggerActive() { return false; }
+    }
+#endif // Platform
+// end catch_debugger.cpp
+// start catch_decomposer.cpp
+
+namespace Catch {
+
+    ITransientExpression::~ITransientExpression() = default;
+
+    void formatReconstructedExpression( std::ostream &os, std::string const& lhs, StringRef op, std::string const& rhs ) {
+        if( lhs.size() + rhs.size() < 40 &&
+                lhs.find('\n') == std::string::npos &&
+                rhs.find('\n') == std::string::npos )
+            os << lhs << " " << op << " " << rhs;
+        else
+            os << lhs << "\n" << op << "\n" << rhs;
+    }
+}
+// end catch_decomposer.cpp
+// start catch_enforce.cpp
+
+#include <stdexcept>
+
+namespace Catch {
+#if defined(CATCH_CONFIG_DISABLE_EXCEPTIONS) && !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS_CUSTOM_HANDLER)
+    [[noreturn]]
+    void throw_exception(std::exception const& e) {
+        Catch::cerr() << "Catch will terminate because it needed to throw an exception.\n"
+                      << "The message was: " << e.what() << '\n';
+        std::terminate();
+    }
+#endif
+
+    [[noreturn]]
+    void throw_logic_error(std::string const& msg) {
+        throw_exception(std::logic_error(msg));
+    }
+
+    [[noreturn]]
+    void throw_domain_error(std::string const& msg) {
+        throw_exception(std::domain_error(msg));
+    }
+
+    [[noreturn]]
+    void throw_runtime_error(std::string const& msg) {
+        throw_exception(std::runtime_error(msg));
+    }
+
+} // namespace Catch;
+// end catch_enforce.cpp
+// start catch_enum_values_registry.cpp
+// start catch_enum_values_registry.h
+
+#include <vector>
+#include <memory>
+
+namespace Catch {
+
+    namespace Detail {
+
+        std::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values );
+
+        class EnumValuesRegistry : public IMutableEnumValuesRegistry {
+
+            std::vector<std::unique_ptr<EnumInfo>> m_enumInfos;
+
+            EnumInfo const& registerEnum( StringRef enumName, StringRef allEnums, std::vector<int> const& values) override;
+        };
+
+        std::vector<StringRef> parseEnums( StringRef enums );
+
+    } // Detail
+
+} // Catch
+
+// end catch_enum_values_registry.h
+
+#include <map>
+#include <cassert>
+
+namespace Catch {
+
+    IMutableEnumValuesRegistry::~IMutableEnumValuesRegistry() {}
+
+    namespace Detail {
+
+        namespace {
+            // Extracts the actual name part of an enum instance
+            // In other words, it returns the Blue part of Bikeshed::Colour::Blue
+            StringRef extractInstanceName(StringRef enumInstance) {
+                // Find last occurence of ":"
+                size_t name_start = enumInstance.size();
+                while (name_start > 0 && enumInstance[name_start - 1] != ':') {
+                    --name_start;
+                }
+                return enumInstance.substr(name_start, enumInstance.size() - name_start);
+            }
+        }
+
+        std::vector<StringRef> parseEnums( StringRef enums ) {
+            auto enumValues = splitStringRef( enums, ',' );
+            std::vector<StringRef> parsed;
+            parsed.reserve( enumValues.size() );
+            for( auto const& enumValue : enumValues ) {
+                parsed.push_back(trim(extractInstanceName(enumValue)));
+            }
+            return parsed;
+        }
+
+        EnumInfo::~EnumInfo() {}
+
+        StringRef EnumInfo::lookup( int value ) const {
+            for( auto const& valueToName : m_values ) {
+                if( valueToName.first == value )
+                    return valueToName.second;
+            }
+            return "{** unexpected enum value **}"_sr;
+        }
+
+        std::unique_ptr<EnumInfo> makeEnumInfo( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
+            std::unique_ptr<EnumInfo> enumInfo( new EnumInfo );
+            enumInfo->m_name = enumName;
+            enumInfo->m_values.reserve( values.size() );
+
+            const auto valueNames = Catch::Detail::parseEnums( allValueNames );
+            assert( valueNames.size() == values.size() );
+            std::size_t i = 0;
+            for( auto value : values )
+                enumInfo->m_values.emplace_back(value, valueNames[i++]);
+
+            return enumInfo;
+        }
+
+        EnumInfo const& EnumValuesRegistry::registerEnum( StringRef enumName, StringRef allValueNames, std::vector<int> const& values ) {
+            m_enumInfos.push_back(makeEnumInfo(enumName, allValueNames, values));
+            return *m_enumInfos.back();
+        }
+
+    } // Detail
+} // Catch
+
+// end catch_enum_values_registry.cpp
+// start catch_errno_guard.cpp
+
+#include <cerrno>
+
+namespace Catch {
+        ErrnoGuard::ErrnoGuard():m_oldErrno(errno){}
+        ErrnoGuard::~ErrnoGuard() { errno = m_oldErrno; }
+}
+// end catch_errno_guard.cpp
+// start catch_exception_translator_registry.cpp
+
+// start catch_exception_translator_registry.h
+
+#include <vector>
+#include <string>
+#include <memory>
+
+namespace Catch {
+
+    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
+    public:
+        ~ExceptionTranslatorRegistry();
+        virtual void registerTranslator( const IExceptionTranslator* translator );
+        std::string translateActiveException() const override;
+        std::string tryTranslators() const;
+
+    private:
+        std::vector<std::unique_ptr<IExceptionTranslator const>> m_translators;
+    };
+}
+
+// end catch_exception_translator_registry.h
+#ifdef __OBJC__
+#import "Foundation/Foundation.h"
+#endif
+
+namespace Catch {
+
+    ExceptionTranslatorRegistry::~ExceptionTranslatorRegistry() {
+    }
+
+    void ExceptionTranslatorRegistry::registerTranslator( const IExceptionTranslator* translator ) {
+        m_translators.push_back( std::unique_ptr<const IExceptionTranslator>( translator ) );
+    }
+
+#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+    std::string ExceptionTranslatorRegistry::translateActiveException() const {
+        try {
+#ifdef __OBJC__
+            // In Objective-C try objective-c exceptions first
+            @try {
+                return tryTranslators();
+            }
+            @catch (NSException *exception) {
+                return Catch::Detail::stringify( [exception description] );
+            }
+#else
+            // Compiling a mixed mode project with MSVC means that CLR
+            // exceptions will be caught in (...) as well. However, these
+            // do not fill-in std::current_exception and thus lead to crash
+            // when attempting rethrow.
+            // /EHa switch also causes structured exceptions to be caught
+            // here, but they fill-in current_exception properly, so
+            // at worst the output should be a little weird, instead of
+            // causing a crash.
+            if (std::current_exception() == nullptr) {
+                return "Non C++ exception. Possibly a CLR exception.";
+            }
+            return tryTranslators();
+#endif
+        }
+        catch( TestFailureException& ) {
+            std::rethrow_exception(std::current_exception());
+        }
+        catch( std::exception& ex ) {
+            return ex.what();
+        }
+        catch( std::string& msg ) {
+            return msg;
+        }
+        catch( const char* msg ) {
+            return msg;
+        }
+        catch(...) {
+            return "Unknown exception";
+        }
+    }
+
+    std::string ExceptionTranslatorRegistry::tryTranslators() const {
+        if (m_translators.empty()) {
+            std::rethrow_exception(std::current_exception());
+        } else {
+            return m_translators[0]->translate(m_translators.begin() + 1, m_translators.end());
+        }
+    }
+
+#else // ^^ Exceptions are enabled // Exceptions are disabled vv
+    std::string ExceptionTranslatorRegistry::translateActiveException() const {
+        CATCH_INTERNAL_ERROR("Attempted to translate active exception under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
+    }
+
+    std::string ExceptionTranslatorRegistry::tryTranslators() const {
+        CATCH_INTERNAL_ERROR("Attempted to use exception translators under CATCH_CONFIG_DISABLE_EXCEPTIONS!");
+    }
+#endif
+
+}
+// end catch_exception_translator_registry.cpp
+// start catch_fatal_condition.cpp
+
+#if defined(__GNUC__)
+#    pragma GCC diagnostic push
+#    pragma GCC diagnostic ignored "-Wmissing-field-initializers"
+#endif
+
+#if defined( CATCH_CONFIG_WINDOWS_SEH ) || defined( CATCH_CONFIG_POSIX_SIGNALS )
+
+namespace {
+    // Report the error condition
+    void reportFatal( char const * const message ) {
+        Catch::getCurrentContext().getResultCapture()->handleFatalErrorCondition( message );
+    }
+}
+
+#endif // signals/SEH handling
+
+#if defined( CATCH_CONFIG_WINDOWS_SEH )
+
+namespace Catch {
+    struct SignalDefs { DWORD id; const char* name; };
+
+    // There is no 1-1 mapping between signals and windows exceptions.
+    // Windows can easily distinguish between SO and SigSegV,
+    // but SigInt, SigTerm, etc are handled differently.
+    static SignalDefs signalDefs[] = {
+        { static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),  "SIGILL - Illegal instruction signal" },
+        { static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), "SIGSEGV - Stack overflow" },
+        { static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION), "SIGSEGV - Segmentation violation signal" },
+        { static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), "Divide by zero error" },
+    };
+
+    LONG CALLBACK FatalConditionHandler::handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
+        for (auto const& def : signalDefs) {
+            if (ExceptionInfo->ExceptionRecord->ExceptionCode == def.id) {
+                reportFatal(def.name);
+            }
+        }
+        // If its not an exception we care about, pass it along.
+        // This stops us from eating debugger breaks etc.
+        return EXCEPTION_CONTINUE_SEARCH;
+    }
+
+    FatalConditionHandler::FatalConditionHandler() {
+        isSet = true;
+        // 32k seems enough for Catch to handle stack overflow,
+        // but the value was found experimentally, so there is no strong guarantee
+        guaranteeSize = 32 * 1024;
+        exceptionHandlerHandle = nullptr;
+        // Register as first handler in current chain
+        exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
+        // Pass in guarantee size to be filled
+        SetThreadStackGuarantee(&guaranteeSize);
+    }
+
+    void FatalConditionHandler::reset() {
+        if (isSet) {
+            RemoveVectoredExceptionHandler(exceptionHandlerHandle);
+            SetThreadStackGuarantee(&guaranteeSize);
+            exceptionHandlerHandle = nullptr;
+            isSet = false;
+        }
+    }
+
+    FatalConditionHandler::~FatalConditionHandler() {
+        reset();
+    }
+
+bool FatalConditionHandler::isSet = false;
+ULONG FatalConditionHandler::guaranteeSize = 0;
+PVOID FatalConditionHandler::exceptionHandlerHandle = nullptr;
+
+} // namespace Catch
+
+#elif defined( CATCH_CONFIG_POSIX_SIGNALS )
+
+namespace Catch {
+
+    struct SignalDefs {
+        int id;
+        const char* name;
+    };
+
+    // 32kb for the alternate stack seems to be sufficient. However, this value
+    // is experimentally determined, so that's not guaranteed.
+    static constexpr std::size_t sigStackSize = 32768 >= MINSIGSTKSZ ? 32768 : MINSIGSTKSZ;
+
+    static SignalDefs signalDefs[] = {
+        { SIGINT,  "SIGINT - Terminal interrupt signal" },
+        { SIGILL,  "SIGILL - Illegal instruction signal" },
+        { SIGFPE,  "SIGFPE - Floating point error signal" },
+        { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
+        { SIGTERM, "SIGTERM - Termination request signal" },
+        { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
+    };
+
+    void FatalConditionHandler::handleSignal( int sig ) {
+        char const * name = "<unknown signal>";
+        for (auto const& def : signalDefs) {
+            if (sig == def.id) {
+                name = def.name;
+                break;
+            }
+        }
+        reset();
+        reportFatal(name);
+        raise( sig );
+    }
+
+    FatalConditionHandler::FatalConditionHandler() {
+        isSet = true;
+        stack_t sigStack;
+        sigStack.ss_sp = altStackMem;
+        sigStack.ss_size = sigStackSize;
+        sigStack.ss_flags = 0;
+        sigaltstack(&sigStack, &oldSigStack);
+        struct sigaction sa = { };
+
+        sa.sa_handler = handleSignal;
+        sa.sa_flags = SA_ONSTACK;
+        for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
+            sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
+        }
+    }
+
+    FatalConditionHandler::~FatalConditionHandler() {
+        reset();
+    }
+
+    void FatalConditionHandler::reset() {
+        if( isSet ) {
+            // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
+            for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
+                sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);
+            }
+            // Return the old stack
+            sigaltstack(&oldSigStack, nullptr);
+            isSet = false;
+        }
+    }
+
+    bool FatalConditionHandler::isSet = false;
+    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
+    stack_t FatalConditionHandler::oldSigStack = {};
+    char FatalConditionHandler::altStackMem[sigStackSize] = {};
+
+} // namespace Catch
+
+#else
+
+namespace Catch {
+    void FatalConditionHandler::reset() {}
+}
+
+#endif // signals/SEH handling
+
+#if defined(__GNUC__)
+#    pragma GCC diagnostic pop
+#endif
+// end catch_fatal_condition.cpp
+// start catch_generators.cpp
+
+#include <limits>
+#include <set>
+
+namespace Catch {
+
+IGeneratorTracker::~IGeneratorTracker() {}
+
+const char* GeneratorException::what() const noexcept {
+    return m_msg;
+}
+
+namespace Generators {
+
+    GeneratorUntypedBase::~GeneratorUntypedBase() {}
+
+    auto acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
+        return getResultCapture().acquireGeneratorTracker( lineInfo );
+    }
+
+} // namespace Generators
+} // namespace Catch
+// end catch_generators.cpp
+// start catch_interfaces_capture.cpp
+
+namespace Catch {
+    IResultCapture::~IResultCapture() = default;
+}
+// end catch_interfaces_capture.cpp
+// start catch_interfaces_config.cpp
+
+namespace Catch {
+    IConfig::~IConfig() = default;
+}
+// end catch_interfaces_config.cpp
+// start catch_interfaces_exception.cpp
+
+namespace Catch {
+    IExceptionTranslator::~IExceptionTranslator() = default;
+    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() = default;
+}
+// end catch_interfaces_exception.cpp
+// start catch_interfaces_registry_hub.cpp
+
+namespace Catch {
+    IRegistryHub::~IRegistryHub() = default;
+    IMutableRegistryHub::~IMutableRegistryHub() = default;
+}
+// end catch_interfaces_registry_hub.cpp
+// start catch_interfaces_reporter.cpp
+
+// start catch_reporter_listening.h
+
+namespace Catch {
+
+    class ListeningReporter : public IStreamingReporter {
+        using Reporters = std::vector<IStreamingReporterPtr>;
+        Reporters m_listeners;
+        IStreamingReporterPtr m_reporter = nullptr;
+        ReporterPreferences m_preferences;
+
+    public:
+        ListeningReporter();
+
+        void addListener( IStreamingReporterPtr&& listener );
+        void addReporter( IStreamingReporterPtr&& reporter );
+
+    public: // IStreamingReporter
+
+        ReporterPreferences getPreferences() const override;
+
+        void noMatchingTestCases( std::string const& spec ) override;
+
+        void reportInvalidArguments(std::string const&arg) override;
+
+        static std::set<Verbosity> getSupportedVerbosities();
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+        void benchmarkPreparing(std::string const& name) override;
+        void benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) override;
+        void benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) override;
+        void benchmarkFailed(std::string const&) override;
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+        void testRunStarting( TestRunInfo const& testRunInfo ) override;
+        void testGroupStarting( GroupInfo const& groupInfo ) override;
+        void testCaseStarting( TestCaseInfo const& testInfo ) override;
+        void sectionStarting( SectionInfo const& sectionInfo ) override;
+        void assertionStarting( AssertionInfo const& assertionInfo ) override;
+
+        // The return value indicates if the messages buffer should be cleared:
+        bool assertionEnded( AssertionStats const& assertionStats ) override;
+        void sectionEnded( SectionStats const& sectionStats ) override;
+        void testCaseEnded( TestCaseStats const& testCaseStats ) override;
+        void testGroupEnded( TestGroupStats const& testGroupStats ) override;
+        void testRunEnded( TestRunStats const& testRunStats ) override;
+
+        void skipTest( TestCaseInfo const& testInfo ) override;
+        bool isMulti() const override;
+
+    };
+
+} // end namespace Catch
+
+// end catch_reporter_listening.h
+namespace Catch {
+
+    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig )
+    :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
+
+    ReporterConfig::ReporterConfig( IConfigPtr const& _fullConfig, std::ostream& _stream )
+    :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
+
+    std::ostream& ReporterConfig::stream() const { return *m_stream; }
+    IConfigPtr ReporterConfig::fullConfig() const { return m_fullConfig; }
+
+    TestRunInfo::TestRunInfo( std::string const& _name ) : name( _name ) {}
+
+    GroupInfo::GroupInfo(  std::string const& _name,
+                           std::size_t _groupIndex,
+                           std::size_t _groupsCount )
+    :   name( _name ),
+        groupIndex( _groupIndex ),
+        groupsCounts( _groupsCount )
+    {}
+
+     AssertionStats::AssertionStats( AssertionResult const& _assertionResult,
+                                     std::vector<MessageInfo> const& _infoMessages,
+                                     Totals const& _totals )
+    :   assertionResult( _assertionResult ),
+        infoMessages( _infoMessages ),
+        totals( _totals )
+    {
+        assertionResult.m_resultData.lazyExpression.m_transientExpression = _assertionResult.m_resultData.lazyExpression.m_transientExpression;
+
+        if( assertionResult.hasMessage() ) {
+            // Copy message into messages list.
+            // !TBD This should have been done earlier, somewhere
+            MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
+            builder << assertionResult.getMessage();
+            builder.m_info.message = builder.m_stream.str();
+
+            infoMessages.push_back( builder.m_info );
+        }
+    }
+
+     AssertionStats::~AssertionStats() = default;
+
+    SectionStats::SectionStats(  SectionInfo const& _sectionInfo,
+                                 Counts const& _assertions,
+                                 double _durationInSeconds,
+                                 bool _missingAssertions )
+    :   sectionInfo( _sectionInfo ),
+        assertions( _assertions ),
+        durationInSeconds( _durationInSeconds ),
+        missingAssertions( _missingAssertions )
+    {}
+
+    SectionStats::~SectionStats() = default;
+
+    TestCaseStats::TestCaseStats(  TestCaseInfo const& _testInfo,
+                                   Totals const& _totals,
+                                   std::string const& _stdOut,
+                                   std::string const& _stdErr,
+                                   bool _aborting )
+    : testInfo( _testInfo ),
+        totals( _totals ),
+        stdOut( _stdOut ),
+        stdErr( _stdErr ),
+        aborting( _aborting )
+    {}
+
+    TestCaseStats::~TestCaseStats() = default;
+
+    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo,
+                                    Totals const& _totals,
+                                    bool _aborting )
+    :   groupInfo( _groupInfo ),
+        totals( _totals ),
+        aborting( _aborting )
+    {}
+
+    TestGroupStats::TestGroupStats( GroupInfo const& _groupInfo )
+    :   groupInfo( _groupInfo ),
+        aborting( false )
+    {}
+
+    TestGroupStats::~TestGroupStats() = default;
+
+    TestRunStats::TestRunStats(   TestRunInfo const& _runInfo,
+                    Totals const& _totals,
+                    bool _aborting )
+    :   runInfo( _runInfo ),
+        totals( _totals ),
+        aborting( _aborting )
+    {}
+
+    TestRunStats::~TestRunStats() = default;
+
+    void IStreamingReporter::fatalErrorEncountered( StringRef ) {}
+    bool IStreamingReporter::isMulti() const { return false; }
+
+    IReporterFactory::~IReporterFactory() = default;
+    IReporterRegistry::~IReporterRegistry() = default;
+
+} // end namespace Catch
+// end catch_interfaces_reporter.cpp
+// start catch_interfaces_runner.cpp
+
+namespace Catch {
+    IRunner::~IRunner() = default;
+}
+// end catch_interfaces_runner.cpp
+// start catch_interfaces_testcase.cpp
+
+namespace Catch {
+    ITestInvoker::~ITestInvoker() = default;
+    ITestCaseRegistry::~ITestCaseRegistry() = default;
+}
+// end catch_interfaces_testcase.cpp
+// start catch_leak_detector.cpp
+
+#ifdef CATCH_CONFIG_WINDOWS_CRTDBG
+#include <crtdbg.h>
+
+namespace Catch {
+
+    LeakDetector::LeakDetector() {
+        int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
+        flag |= _CRTDBG_LEAK_CHECK_DF;
+        flag |= _CRTDBG_ALLOC_MEM_DF;
+        _CrtSetDbgFlag(flag);
+        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
+        _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
+        // Change this to leaking allocation's number to break there
+        _CrtSetBreakAlloc(-1);
+    }
+}
+
+#else
+
+    Catch::LeakDetector::LeakDetector() {}
+
+#endif
+
+Catch::LeakDetector::~LeakDetector() {
+    Catch::cleanUp();
+}
+// end catch_leak_detector.cpp
+// start catch_list.cpp
+
+// start catch_list.h
+
+#include <set>
+
+namespace Catch {
+
+    std::size_t listTests( Config const& config );
+
+    std::size_t listTestsNamesOnly( Config const& config );
+
+    struct TagInfo {
+        void add( std::string const& spelling );
+        std::string all() const;
+
+        std::set<std::string> spellings;
+        std::size_t count = 0;
+    };
+
+    std::size_t listTags( Config const& config );
+
+    std::size_t listReporters();
+
+    Option<std::size_t> list( std::shared_ptr<Config> const& config );
+
+} // end namespace Catch
+
+// end catch_list.h
+// start catch_text.h
+
+namespace Catch {
+    using namespace clara::TextFlow;
+}
+
+// end catch_text.h
+#include <limits>
+#include <algorithm>
+#include <iomanip>
+
+namespace Catch {
+
+    std::size_t listTests( Config const& config ) {
+        TestSpec const& testSpec = config.testSpec();
+        if( config.hasTestFilters() )
+            Catch::cout() << "Matching test cases:\n";
+        else {
+            Catch::cout() << "All available test cases:\n";
+        }
+
+        auto matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
+        for( auto const& testCaseInfo : matchedTestCases ) {
+            Colour::Code colour = testCaseInfo.isHidden()
+                ? Colour::SecondaryText
+                : Colour::None;
+            Colour colourGuard( colour );
+
+            Catch::cout() << Column( testCaseInfo.name ).initialIndent( 2 ).indent( 4 ) << "\n";
+            if( config.verbosity() >= Verbosity::High ) {
+                Catch::cout() << Column( Catch::Detail::stringify( testCaseInfo.lineInfo ) ).indent(4) << std::endl;
+                std::string description = testCaseInfo.description;
+                if( description.empty() )
+                    description = "(NO DESCRIPTION)";
+                Catch::cout() << Column( description ).indent(4) << std::endl;
+            }
+            if( !testCaseInfo.tags.empty() )
+                Catch::cout() << Column( testCaseInfo.tagsAsString() ).indent( 6 ) << "\n";
+        }
+
+        if( !config.hasTestFilters() )
+            Catch::cout() << pluralise( matchedTestCases.size(), "test case" ) << '\n' << std::endl;
+        else
+            Catch::cout() << pluralise( matchedTestCases.size(), "matching test case" ) << '\n' << std::endl;
+        return matchedTestCases.size();
+    }
+
+    std::size_t listTestsNamesOnly( Config const& config ) {
+        TestSpec const& testSpec = config.testSpec();
+        std::size_t matchedTests = 0;
+        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
+        for( auto const& testCaseInfo : matchedTestCases ) {
+            matchedTests++;
+            if( startsWith( testCaseInfo.name, '#' ) )
+               Catch::cout() << '"' << testCaseInfo.name << '"';
+            else
+               Catch::cout() << testCaseInfo.name;
+            if ( config.verbosity() >= Verbosity::High )
+                Catch::cout() << "\t@" << testCaseInfo.lineInfo;
+            Catch::cout() << std::endl;
+        }
+        return matchedTests;
+    }
+
+    void TagInfo::add( std::string const& spelling ) {
+        ++count;
+        spellings.insert( spelling );
+    }
+
+    std::string TagInfo::all() const {
+        size_t size = 0;
+        for (auto const& spelling : spellings) {
+            // Add 2 for the brackes
+            size += spelling.size() + 2;
+        }
+
+        std::string out; out.reserve(size);
+        for (auto const& spelling : spellings) {
+            out += '[';
+            out += spelling;
+            out += ']';
+        }
+        return out;
+    }
+
+    std::size_t listTags( Config const& config ) {
+        TestSpec const& testSpec = config.testSpec();
+        if( config.hasTestFilters() )
+            Catch::cout() << "Tags for matching test cases:\n";
+        else {
+            Catch::cout() << "All available tags:\n";
+        }
+
+        std::map<std::string, TagInfo> tagCounts;
+
+        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
+        for( auto const& testCase : matchedTestCases ) {
+            for( auto const& tagName : testCase.getTestCaseInfo().tags ) {
+                std::string lcaseTagName = toLower( tagName );
+                auto countIt = tagCounts.find( lcaseTagName );
+                if( countIt == tagCounts.end() )
+                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
+                countIt->second.add( tagName );
+            }
+        }
+
+        for( auto const& tagCount : tagCounts ) {
+            ReusableStringStream rss;
+            rss << "  " << std::setw(2) << tagCount.second.count << "  ";
+            auto str = rss.str();
+            auto wrapper = Column( tagCount.second.all() )
+                                                    .initialIndent( 0 )
+                                                    .indent( str.size() )
+                                                    .width( CATCH_CONFIG_CONSOLE_WIDTH-10 );
+            Catch::cout() << str << wrapper << '\n';
+        }
+        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << '\n' << std::endl;
+        return tagCounts.size();
+    }
+
+    std::size_t listReporters() {
+        Catch::cout() << "Available reporters:\n";
+        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
+        std::size_t maxNameLen = 0;
+        for( auto const& factoryKvp : factories )
+            maxNameLen = (std::max)( maxNameLen, factoryKvp.first.size() );
+
+        for( auto const& factoryKvp : factories ) {
+            Catch::cout()
+                    << Column( factoryKvp.first + ":" )
+                            .indent(2)
+                            .width( 5+maxNameLen )
+                    +  Column( factoryKvp.second->getDescription() )
+                            .initialIndent(0)
+                            .indent(2)
+                            .width( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 )
+                    << "\n";
+        }
+        Catch::cout() << std::endl;
+        return factories.size();
+    }
+
+    Option<std::size_t> list( std::shared_ptr<Config> const& config ) {
+        Option<std::size_t> listedCount;
+        getCurrentMutableContext().setConfig( config );
+        if( config->listTests() )
+            listedCount = listedCount.valueOr(0) + listTests( *config );
+        if( config->listTestNamesOnly() )
+            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( *config );
+        if( config->listTags() )
+            listedCount = listedCount.valueOr(0) + listTags( *config );
+        if( config->listReporters() )
+            listedCount = listedCount.valueOr(0) + listReporters();
+        return listedCount;
+    }
+
+} // end namespace Catch
+// end catch_list.cpp
+// start catch_matchers.cpp
+
+namespace Catch {
+namespace Matchers {
+    namespace Impl {
+
+        std::string MatcherUntypedBase::toString() const {
+            if( m_cachedToString.empty() )
+                m_cachedToString = describe();
+            return m_cachedToString;
+        }
+
+        MatcherUntypedBase::~MatcherUntypedBase() = default;
+
+    } // namespace Impl
+} // namespace Matchers
+
+using namespace Matchers;
+using Matchers::Impl::MatcherBase;
+
+} // namespace Catch
+// end catch_matchers.cpp
+// start catch_matchers_exception.cpp
+
+namespace Catch {
+namespace Matchers {
+namespace Exception {
+
+bool ExceptionMessageMatcher::match(std::exception const& ex) const {
+    return ex.what() == m_message;
+}
+
+std::string ExceptionMessageMatcher::describe() const {
+    return "exception message matches \"" + m_message + "\"";
+}
+
+}
+Exception::ExceptionMessageMatcher Message(std::string const& message) {
+    return Exception::ExceptionMessageMatcher(message);
+}
+
+// namespace Exception
+} // namespace Matchers
+} // namespace Catch
+// end catch_matchers_exception.cpp
+// start catch_matchers_floating.cpp
+
+// start catch_polyfills.hpp
+
+namespace Catch {
+    bool isnan(float f);
+    bool isnan(double d);
+}
+
+// end catch_polyfills.hpp
+// start catch_to_string.hpp
+
+#include <string>
+
+namespace Catch {
+    template <typename T>
+    std::string to_string(T const& t) {
+#if defined(CATCH_CONFIG_CPP11_TO_STRING)
+        return std::to_string(t);
+#else
+        ReusableStringStream rss;
+        rss << t;
+        return rss.str();
+#endif
+    }
+} // end namespace Catch
+
+// end catch_to_string.hpp
+#include <algorithm>
+#include <cmath>
+#include <cstdlib>
+#include <cstdint>
+#include <cstring>
+#include <sstream>
+#include <type_traits>
+#include <iomanip>
+#include <limits>
+
+namespace Catch {
+namespace {
+
+    int32_t convert(float f) {
+        static_assert(sizeof(float) == sizeof(int32_t), "Important ULP matcher assumption violated");
+        int32_t i;
+        std::memcpy(&i, &f, sizeof(f));
+        return i;
+    }
+
+    int64_t convert(double d) {
+        static_assert(sizeof(double) == sizeof(int64_t), "Important ULP matcher assumption violated");
+        int64_t i;
+        std::memcpy(&i, &d, sizeof(d));
+        return i;
+    }
+
+    template <typename FP>
+    bool almostEqualUlps(FP lhs, FP rhs, uint64_t maxUlpDiff) {
+        // Comparison with NaN should always be false.
+        // This way we can rule it out before getting into the ugly details
+        if (Catch::isnan(lhs) || Catch::isnan(rhs)) {
+            return false;
+        }
+
+        auto lc = convert(lhs);
+        auto rc = convert(rhs);
+
+        if ((lc < 0) != (rc < 0)) {
+            // Potentially we can have +0 and -0
+            return lhs == rhs;
+        }
+
+        auto ulpDiff = std::abs(lc - rc);
+        return static_cast<uint64_t>(ulpDiff) <= maxUlpDiff;
+    }
+
+#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
+
+    float nextafter(float x, float y) {
+        return ::nextafterf(x, y);
+    }
+
+    double nextafter(double x, double y) {
+        return ::nextafter(x, y);
+    }
+
+#endif // ^^^ CATCH_CONFIG_GLOBAL_NEXTAFTER ^^^
+
+template <typename FP>
+FP step(FP start, FP direction, uint64_t steps) {
+    for (uint64_t i = 0; i < steps; ++i) {
+#if defined(CATCH_CONFIG_GLOBAL_NEXTAFTER)
+        start = Catch::nextafter(start, direction);
+#else
+        start = std::nextafter(start, direction);
+#endif
+    }
+    return start;
+}
+
+// Performs equivalent check of std::fabs(lhs - rhs) <= margin
+// But without the subtraction to allow for INFINITY in comparison
+bool marginComparison(double lhs, double rhs, double margin) {
+    return (lhs + margin >= rhs) && (rhs + margin >= lhs);
+}
+
+template <typename FloatingPoint>
+void write(std::ostream& out, FloatingPoint num) {
+    out << std::scientific
+        << std::setprecision(std::numeric_limits<FloatingPoint>::max_digits10 - 1)
+        << num;
+}
+
+} // end anonymous namespace
+
+namespace Matchers {
+namespace Floating {
+
+    enum class FloatingPointKind : uint8_t {
+        Float,
+        Double
+    };
+
+    WithinAbsMatcher::WithinAbsMatcher(double target, double margin)
+        :m_target{ target }, m_margin{ margin } {
+        CATCH_ENFORCE(margin >= 0, "Invalid margin: " << margin << '.'
+            << " Margin has to be non-negative.");
+    }
+
+    // Performs equivalent check of std::fabs(lhs - rhs) <= margin
+    // But without the subtraction to allow for INFINITY in comparison
+    bool WithinAbsMatcher::match(double const& matchee) const {
+        return (matchee + m_margin >= m_target) && (m_target + m_margin >= matchee);
+    }
+
+    std::string WithinAbsMatcher::describe() const {
+        return "is within " + ::Catch::Detail::stringify(m_margin) + " of " + ::Catch::Detail::stringify(m_target);
+    }
+
+    WithinUlpsMatcher::WithinUlpsMatcher(double target, uint64_t ulps, FloatingPointKind baseType)
+        :m_target{ target }, m_ulps{ ulps }, m_type{ baseType } {
+        CATCH_ENFORCE(m_type == FloatingPointKind::Double
+                   || m_ulps < (std::numeric_limits<uint32_t>::max)(),
+            "Provided ULP is impossibly large for a float comparison.");
+    }
+
+#if defined(__clang__)
+#pragma clang diagnostic push
+// Clang <3.5 reports on the default branch in the switch below
+#pragma clang diagnostic ignored "-Wunreachable-code"
+#endif
+
+    bool WithinUlpsMatcher::match(double const& matchee) const {
+        switch (m_type) {
+        case FloatingPointKind::Float:
+            return almostEqualUlps<float>(static_cast<float>(matchee), static_cast<float>(m_target), m_ulps);
+        case FloatingPointKind::Double:
+            return almostEqualUlps<double>(matchee, m_target, m_ulps);
+        default:
+            CATCH_INTERNAL_ERROR( "Unknown FloatingPointKind value" );
+        }
+    }
+
+#if defined(__clang__)
+#pragma clang diagnostic pop
+#endif
+
+    std::string WithinUlpsMatcher::describe() const {
+        std::stringstream ret;
+
+        ret << "is within " << m_ulps << " ULPs of ";
+
+        if (m_type == FloatingPointKind::Float) {
+            write(ret, static_cast<float>(m_target));
+            ret << 'f';
+        } else {
+            write(ret, m_target);
+        }
+
+        ret << " ([";
+        if (m_type == FloatingPointKind::Double) {
+            write(ret, step(m_target, static_cast<double>(-INFINITY), m_ulps));
+            ret << ", ";
+            write(ret, step(m_target, static_cast<double>( INFINITY), m_ulps));
+        } else {
+            // We have to cast INFINITY to float because of MinGW, see #1782
+            write(ret, step(static_cast<float>(m_target), static_cast<float>(-INFINITY), m_ulps));
+            ret << ", ";
+            write(ret, step(static_cast<float>(m_target), static_cast<float>( INFINITY), m_ulps));
+        }
+        ret << "])";
+
+        return ret.str();
+    }
+
+    WithinRelMatcher::WithinRelMatcher(double target, double epsilon):
+        m_target(target),
+        m_epsilon(epsilon){
+        CATCH_ENFORCE(m_epsilon >= 0., "Relative comparison with epsilon <  0 does not make sense.");
+        CATCH_ENFORCE(m_epsilon  < 1., "Relative comparison with epsilon >= 1 does not make sense.");
+    }
+
+    bool WithinRelMatcher::match(double const& matchee) const {
+        const auto relMargin = m_epsilon * (std::max)(std::fabs(matchee), std::fabs(m_target));
+        return marginComparison(matchee, m_target,
+                                std::isinf(relMargin)? 0 : relMargin);
+    }
+
+    std::string WithinRelMatcher::describe() const {
+        Catch::ReusableStringStream sstr;
+        sstr << "and " << m_target << " are within " << m_epsilon * 100. << "% of each other";
+        return sstr.str();
+    }
+
+}// namespace Floating
+
+Floating::WithinUlpsMatcher WithinULP(double target, uint64_t maxUlpDiff) {
+    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Double);
+}
+
+Floating::WithinUlpsMatcher WithinULP(float target, uint64_t maxUlpDiff) {
+    return Floating::WithinUlpsMatcher(target, maxUlpDiff, Floating::FloatingPointKind::Float);
+}
+
+Floating::WithinAbsMatcher WithinAbs(double target, double margin) {
+    return Floating::WithinAbsMatcher(target, margin);
+}
+
+Floating::WithinRelMatcher WithinRel(double target, double eps) {
+    return Floating::WithinRelMatcher(target, eps);
+}
+
+Floating::WithinRelMatcher WithinRel(double target) {
+    return Floating::WithinRelMatcher(target, std::numeric_limits<double>::epsilon() * 100);
+}
+
+Floating::WithinRelMatcher WithinRel(float target, float eps) {
+    return Floating::WithinRelMatcher(target, eps);
+}
+
+Floating::WithinRelMatcher WithinRel(float target) {
+    return Floating::WithinRelMatcher(target, std::numeric_limits<float>::epsilon() * 100);
+}
+
+} // namespace Matchers
+} // namespace Catch
+
+// end catch_matchers_floating.cpp
+// start catch_matchers_generic.cpp
+
+std::string Catch::Matchers::Generic::Detail::finalizeDescription(const std::string& desc) {
+    if (desc.empty()) {
+        return "matches undescribed predicate";
+    } else {
+        return "matches predicate: \"" + desc + '"';
+    }
+}
+// end catch_matchers_generic.cpp
+// start catch_matchers_string.cpp
+
+#include <regex>
+
+namespace Catch {
+namespace Matchers {
+
+    namespace StdString {
+
+        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
+        :   m_caseSensitivity( caseSensitivity ),
+            m_str( adjustString( str ) )
+        {}
+        std::string CasedString::adjustString( std::string const& str ) const {
+            return m_caseSensitivity == CaseSensitive::No
+                   ? toLower( str )
+                   : str;
+        }
+        std::string CasedString::caseSensitivitySuffix() const {
+            return m_caseSensitivity == CaseSensitive::No
+                   ? " (case insensitive)"
+                   : std::string();
+        }
+
+        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
+        : m_comparator( comparator ),
+          m_operation( operation ) {
+        }
+
+        std::string StringMatcherBase::describe() const {
+            std::string description;
+            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
+                                        m_comparator.caseSensitivitySuffix().size());
+            description += m_operation;
+            description += ": \"";
+            description += m_comparator.m_str;
+            description += "\"";
+            description += m_comparator.caseSensitivitySuffix();
+            return description;
+        }
+
+        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}
+
+        bool EqualsMatcher::match( std::string const& source ) const {
+            return m_comparator.adjustString( source ) == m_comparator.m_str;
+        }
+
+        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}
+
+        bool ContainsMatcher::match( std::string const& source ) const {
+            return contains( m_comparator.adjustString( source ), m_comparator.m_str );
+        }
+
+        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}
+
+        bool StartsWithMatcher::match( std::string const& source ) const {
+            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
+        }
+
+        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}
+
+        bool EndsWithMatcher::match( std::string const& source ) const {
+            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
+        }
+
+        RegexMatcher::RegexMatcher(std::string regex, CaseSensitive::Choice caseSensitivity): m_regex(std::move(regex)), m_caseSensitivity(caseSensitivity) {}
+
+        bool RegexMatcher::match(std::string const& matchee) const {
+            auto flags = std::regex::ECMAScript; // ECMAScript is the default syntax option anyway
+            if (m_caseSensitivity == CaseSensitive::Choice::No) {
+                flags |= std::regex::icase;
+            }
+            auto reg = std::regex(m_regex, flags);
+            return std::regex_match(matchee, reg);
+        }
+
+        std::string RegexMatcher::describe() const {
+            return "matches " + ::Catch::Detail::stringify(m_regex) + ((m_caseSensitivity == CaseSensitive::Choice::Yes)? " case sensitively" : " case insensitively");
+        }
+
+    } // namespace StdString
+
+    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
+        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
+    }
+    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
+        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
+    }
+    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
+        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
+    }
+    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
+        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
+    }
+
+    StdString::RegexMatcher Matches(std::string const& regex, CaseSensitive::Choice caseSensitivity) {
+        return StdString::RegexMatcher(regex, caseSensitivity);
+    }
+
+} // namespace Matchers
+} // namespace Catch
+// end catch_matchers_string.cpp
+// start catch_message.cpp
+
+// start catch_uncaught_exceptions.h
+
+namespace Catch {
+    bool uncaught_exceptions();
+} // end namespace Catch
+
+// end catch_uncaught_exceptions.h
+#include <cassert>
+#include <stack>
+
+namespace Catch {
+
+    MessageInfo::MessageInfo(   StringRef const& _macroName,
+                                SourceLineInfo const& _lineInfo,
+                                ResultWas::OfType _type )
+    :   macroName( _macroName ),
+        lineInfo( _lineInfo ),
+        type( _type ),
+        sequence( ++globalCount )
+    {}
+
+    bool MessageInfo::operator==( MessageInfo const& other ) const {
+        return sequence == other.sequence;
+    }
+
+    bool MessageInfo::operator<( MessageInfo const& other ) const {
+        return sequence < other.sequence;
+    }
+
+    // This may need protecting if threading support is added
+    unsigned int MessageInfo::globalCount = 0;
+
+    ////////////////////////////////////////////////////////////////////////////
+
+    Catch::MessageBuilder::MessageBuilder( StringRef const& macroName,
+                                           SourceLineInfo const& lineInfo,
+                                           ResultWas::OfType type )
+        :m_info(macroName, lineInfo, type) {}
+
+    ////////////////////////////////////////////////////////////////////////////
+
+    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
+    : m_info( builder.m_info ), m_moved()
+    {
+        m_info.message = builder.m_stream.str();
+        getResultCapture().pushScopedMessage( m_info );
+    }
+
+    ScopedMessage::ScopedMessage( ScopedMessage&& old )
+    : m_info( old.m_info ), m_moved()
+    {
+        old.m_moved = true;
+    }
+
+    ScopedMessage::~ScopedMessage() {
+        if ( !uncaught_exceptions() && !m_moved ){
+            getResultCapture().popScopedMessage(m_info);
+        }
+    }
+
+    Capturer::Capturer( StringRef macroName, SourceLineInfo const& lineInfo, ResultWas::OfType resultType, StringRef names ) {
+        auto trimmed = [&] (size_t start, size_t end) {
+            while (names[start] == ',' || isspace(names[start])) {
+                ++start;
+            }
+            while (names[end] == ',' || isspace(names[end])) {
+                --end;
+            }
+            return names.substr(start, end - start + 1);
+        };
+        auto skipq = [&] (size_t start, char quote) {
+            for (auto i = start + 1; i < names.size() ; ++i) {
+                if (names[i] == quote)
+                    return i;
+                if (names[i] == '\\')
+                    ++i;
+            }
+            CATCH_INTERNAL_ERROR("CAPTURE parsing encountered unmatched quote");
+        };
+
+        size_t start = 0;
+        std::stack<char> openings;
+        for (size_t pos = 0; pos < names.size(); ++pos) {
+            char c = names[pos];
+            switch (c) {
+            case '[':
+            case '{':
+            case '(':
+            // It is basically impossible to disambiguate between
+            // comparison and start of template args in this context
+//            case '<':
+                openings.push(c);
+                break;
+            case ']':
+            case '}':
+            case ')':
+//           case '>':
+                openings.pop();
+                break;
+            case '"':
+            case '\'':
+                pos = skipq(pos, c);
+                break;
+            case ',':
+                if (start != pos && openings.empty()) {
+                    m_messages.emplace_back(macroName, lineInfo, resultType);
+                    m_messages.back().message = static_cast<std::string>(trimmed(start, pos));
+                    m_messages.back().message += " := ";
+                    start = pos;
+                }
+            }
+        }
+        assert(openings.empty() && "Mismatched openings");
+        m_messages.emplace_back(macroName, lineInfo, resultType);
+        m_messages.back().message = static_cast<std::string>(trimmed(start, names.size() - 1));
+        m_messages.back().message += " := ";
+    }
+    Capturer::~Capturer() {
+        if ( !uncaught_exceptions() ){
+            assert( m_captured == m_messages.size() );
+            for( size_t i = 0; i < m_captured; ++i  )
+                m_resultCapture.popScopedMessage( m_messages[i] );
+        }
+    }
+
+    void Capturer::captureValue( size_t index, std::string const& value ) {
+        assert( index < m_messages.size() );
+        m_messages[index].message += value;
+        m_resultCapture.pushScopedMessage( m_messages[index] );
+        m_captured++;
+    }
+
+} // end namespace Catch
+// end catch_message.cpp
+// start catch_output_redirect.cpp
+
+// start catch_output_redirect.h
+#ifndef TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
+#define TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
+
+#include <cstdio>
+#include <iosfwd>
+#include <string>
+
+namespace Catch {
+
+    class RedirectedStream {
+        std::ostream& m_originalStream;
+        std::ostream& m_redirectionStream;
+        std::streambuf* m_prevBuf;
+
+    public:
+        RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream );
+        ~RedirectedStream();
+    };
+
+    class RedirectedStdOut {
+        ReusableStringStream m_rss;
+        RedirectedStream m_cout;
+    public:
+        RedirectedStdOut();
+        auto str() const -> std::string;
+    };
+
+    // StdErr has two constituent streams in C++, std::cerr and std::clog
+    // This means that we need to redirect 2 streams into 1 to keep proper
+    // order of writes
+    class RedirectedStdErr {
+        ReusableStringStream m_rss;
+        RedirectedStream m_cerr;
+        RedirectedStream m_clog;
+    public:
+        RedirectedStdErr();
+        auto str() const -> std::string;
+    };
+
+    class RedirectedStreams {
+    public:
+        RedirectedStreams(RedirectedStreams const&) = delete;
+        RedirectedStreams& operator=(RedirectedStreams const&) = delete;
+        RedirectedStreams(RedirectedStreams&&) = delete;
+        RedirectedStreams& operator=(RedirectedStreams&&) = delete;
+
+        RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr);
+        ~RedirectedStreams();
+    private:
+        std::string& m_redirectedCout;
+        std::string& m_redirectedCerr;
+        RedirectedStdOut m_redirectedStdOut;
+        RedirectedStdErr m_redirectedStdErr;
+    };
+
+#if defined(CATCH_CONFIG_NEW_CAPTURE)
+
+    // Windows's implementation of std::tmpfile is terrible (it tries
+    // to create a file inside system folder, thus requiring elevated
+    // privileges for the binary), so we have to use tmpnam(_s) and
+    // create the file ourselves there.
+    class TempFile {
+    public:
+        TempFile(TempFile const&) = delete;
+        TempFile& operator=(TempFile const&) = delete;
+        TempFile(TempFile&&) = delete;
+        TempFile& operator=(TempFile&&) = delete;
+
+        TempFile();
+        ~TempFile();
+
+        std::FILE* getFile();
+        std::string getContents();
+
+    private:
+        std::FILE* m_file = nullptr;
+    #if defined(_MSC_VER)
+        char m_buffer[L_tmpnam] = { 0 };
+    #endif
+    };
+
+    class OutputRedirect {
+    public:
+        OutputRedirect(OutputRedirect const&) = delete;
+        OutputRedirect& operator=(OutputRedirect const&) = delete;
+        OutputRedirect(OutputRedirect&&) = delete;
+        OutputRedirect& operator=(OutputRedirect&&) = delete;
+
+        OutputRedirect(std::string& stdout_dest, std::string& stderr_dest);
+        ~OutputRedirect();
+
+    private:
+        int m_originalStdout = -1;
+        int m_originalStderr = -1;
+        TempFile m_stdoutFile;
+        TempFile m_stderrFile;
+        std::string& m_stdoutDest;
+        std::string& m_stderrDest;
+    };
+
+#endif
+
+} // end namespace Catch
+
+#endif // TWOBLUECUBES_CATCH_OUTPUT_REDIRECT_H
+// end catch_output_redirect.h
+#include <cstdio>
+#include <cstring>
+#include <fstream>
+#include <sstream>
+#include <stdexcept>
+
+#if defined(CATCH_CONFIG_NEW_CAPTURE)
+    #if defined(_MSC_VER)
+    #include <io.h>      //_dup and _dup2
+    #define dup _dup
+    #define dup2 _dup2
+    #define fileno _fileno
+    #else
+    #include <unistd.h>  // dup and dup2
+    #endif
+#endif
+
+namespace Catch {
+
+    RedirectedStream::RedirectedStream( std::ostream& originalStream, std::ostream& redirectionStream )
+    :   m_originalStream( originalStream ),
+        m_redirectionStream( redirectionStream ),
+        m_prevBuf( m_originalStream.rdbuf() )
+    {
+        m_originalStream.rdbuf( m_redirectionStream.rdbuf() );
+    }
+
+    RedirectedStream::~RedirectedStream() {
+        m_originalStream.rdbuf( m_prevBuf );
+    }
+
+    RedirectedStdOut::RedirectedStdOut() : m_cout( Catch::cout(), m_rss.get() ) {}
+    auto RedirectedStdOut::str() const -> std::string { return m_rss.str(); }
+
+    RedirectedStdErr::RedirectedStdErr()
+    :   m_cerr( Catch::cerr(), m_rss.get() ),
+        m_clog( Catch::clog(), m_rss.get() )
+    {}
+    auto RedirectedStdErr::str() const -> std::string { return m_rss.str(); }
+
+    RedirectedStreams::RedirectedStreams(std::string& redirectedCout, std::string& redirectedCerr)
+    :   m_redirectedCout(redirectedCout),
+        m_redirectedCerr(redirectedCerr)
+    {}
+
+    RedirectedStreams::~RedirectedStreams() {
+        m_redirectedCout += m_redirectedStdOut.str();
+        m_redirectedCerr += m_redirectedStdErr.str();
+    }
+
+#if defined(CATCH_CONFIG_NEW_CAPTURE)
+
+#if defined(_MSC_VER)
+    TempFile::TempFile() {
+        if (tmpnam_s(m_buffer)) {
+            CATCH_RUNTIME_ERROR("Could not get a temp filename");
+        }
+        if (fopen_s(&m_file, m_buffer, "w")) {
+            char buffer[100];
+            if (strerror_s(buffer, errno)) {
+                CATCH_RUNTIME_ERROR("Could not translate errno to a string");
+            }
+            CATCH_RUNTIME_ERROR("Could not open the temp file: '" << m_buffer << "' because: " << buffer);
+        }
+    }
+#else
+    TempFile::TempFile() {
+        m_file = std::tmpfile();
+        if (!m_file) {
+            CATCH_RUNTIME_ERROR("Could not create a temp file.");
+        }
+    }
+
+#endif
+
+    TempFile::~TempFile() {
+         // TBD: What to do about errors here?
+         std::fclose(m_file);
+         // We manually create the file on Windows only, on Linux
+         // it will be autodeleted
+#if defined(_MSC_VER)
+         std::remove(m_buffer);
+#endif
+    }
+
+    FILE* TempFile::getFile() {
+        return m_file;
+    }
+
+    std::string TempFile::getContents() {
+        std::stringstream sstr;
+        char buffer[100] = {};
+        std::rewind(m_file);
+        while (std::fgets(buffer, sizeof(buffer), m_file)) {
+            sstr << buffer;
+        }
+        return sstr.str();
+    }
+
+    OutputRedirect::OutputRedirect(std::string& stdout_dest, std::string& stderr_dest) :
+        m_originalStdout(dup(1)),
+        m_originalStderr(dup(2)),
+        m_stdoutDest(stdout_dest),
+        m_stderrDest(stderr_dest) {
+        dup2(fileno(m_stdoutFile.getFile()), 1);
+        dup2(fileno(m_stderrFile.getFile()), 2);
+    }
+
+    OutputRedirect::~OutputRedirect() {
+        Catch::cout() << std::flush;
+        fflush(stdout);
+        // Since we support overriding these streams, we flush cerr
+        // even though std::cerr is unbuffered
+        Catch::cerr() << std::flush;
+        Catch::clog() << std::flush;
+        fflush(stderr);
+
+        dup2(m_originalStdout, 1);
+        dup2(m_originalStderr, 2);
+
+        m_stdoutDest += m_stdoutFile.getContents();
+        m_stderrDest += m_stderrFile.getContents();
+    }
+
+#endif // CATCH_CONFIG_NEW_CAPTURE
+
+} // namespace Catch
+
+#if defined(CATCH_CONFIG_NEW_CAPTURE)
+    #if defined(_MSC_VER)
+    #undef dup
+    #undef dup2
+    #undef fileno
+    #endif
+#endif
+// end catch_output_redirect.cpp
+// start catch_polyfills.cpp
+
+#include <cmath>
+
+namespace Catch {
+
+#if !defined(CATCH_CONFIG_POLYFILL_ISNAN)
+    bool isnan(float f) {
+        return std::isnan(f);
+    }
+    bool isnan(double d) {
+        return std::isnan(d);
+    }
+#else
+    // For now we only use this for embarcadero
+    bool isnan(float f) {
+        return std::_isnan(f);
+    }
+    bool isnan(double d) {
+        return std::_isnan(d);
+    }
+#endif
+
+} // end namespace Catch
+// end catch_polyfills.cpp
+// start catch_random_number_generator.cpp
+
+namespace Catch {
+
+namespace {
+
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable:4146) // we negate uint32 during the rotate
+#endif
+        // Safe rotr implementation thanks to John Regehr
+        uint32_t rotate_right(uint32_t val, uint32_t count) {
+            const uint32_t mask = 31;
+            count &= mask;
+            return (val >> count) | (val << (-count & mask));
+        }
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+}
+
+    SimplePcg32::SimplePcg32(result_type seed_) {
+        seed(seed_);
+    }
+
+    void SimplePcg32::seed(result_type seed_) {
+        m_state = 0;
+        (*this)();
+        m_state += seed_;
+        (*this)();
+    }
+
+    void SimplePcg32::discard(uint64_t skip) {
+        // We could implement this to run in O(log n) steps, but this
+        // should suffice for our use case.
+        for (uint64_t s = 0; s < skip; ++s) {
+            static_cast<void>((*this)());
+        }
+    }
+
+    SimplePcg32::result_type SimplePcg32::operator()() {
+        // prepare the output value
+        const uint32_t xorshifted = static_cast<uint32_t>(((m_state >> 18u) ^ m_state) >> 27u);
+        const auto output = rotate_right(xorshifted, m_state >> 59u);
+
+        // advance state
+        m_state = m_state * 6364136223846793005ULL + s_inc;
+
+        return output;
+    }
+
+    bool operator==(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
+        return lhs.m_state == rhs.m_state;
+    }
+
+    bool operator!=(SimplePcg32 const& lhs, SimplePcg32 const& rhs) {
+        return lhs.m_state != rhs.m_state;
+    }
+}
+// end catch_random_number_generator.cpp
+// start catch_registry_hub.cpp
+
+// start catch_test_case_registry_impl.h
+
+#include <vector>
+#include <set>
+#include <algorithm>
+#include <ios>
+
+namespace Catch {
+
+    class TestCase;
+    struct IConfig;
+
+    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases );
+
+    bool isThrowSafe( TestCase const& testCase, IConfig const& config );
+    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
+
+    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions );
+
+    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
+    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
+
+    class TestRegistry : public ITestCaseRegistry {
+    public:
+        virtual ~TestRegistry() = default;
+
+        virtual void registerTest( TestCase const& testCase );
+
+        std::vector<TestCase> const& getAllTests() const override;
+        std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const override;
+
+    private:
+        std::vector<TestCase> m_functions;
+        mutable RunTests::InWhatOrder m_currentSortOrder = RunTests::InDeclarationOrder;
+        mutable std::vector<TestCase> m_sortedFunctions;
+        std::size_t m_unnamedCount = 0;
+        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
+    };
+
+    ///////////////////////////////////////////////////////////////////////////
+
+    class TestInvokerAsFunction : public ITestInvoker {
+        void(*m_testAsFunction)();
+    public:
+        TestInvokerAsFunction( void(*testAsFunction)() ) noexcept;
+
+        void invoke() const override;
+    };
+
+    std::string extractClassName( StringRef const& classOrQualifiedMethodName );
+
+    ///////////////////////////////////////////////////////////////////////////
+
+} // end namespace Catch
+
+// end catch_test_case_registry_impl.h
+// start catch_reporter_registry.h
+
+#include <map>
+
+namespace Catch {
+
+    class ReporterRegistry : public IReporterRegistry {
+
+    public:
+
+        ~ReporterRegistry() override;
+
+        IStreamingReporterPtr create( std::string const& name, IConfigPtr const& config ) const override;
+
+        void registerReporter( std::string const& name, IReporterFactoryPtr const& factory );
+        void registerListener( IReporterFactoryPtr const& factory );
+
+        FactoryMap const& getFactories() const override;
+        Listeners const& getListeners() const override;
+
+    private:
+        FactoryMap m_factories;
+        Listeners m_listeners;
+    };
+}
+
+// end catch_reporter_registry.h
+// start catch_tag_alias_registry.h
+
+// start catch_tag_alias.h
+
+#include <string>
+
+namespace Catch {
+
+    struct TagAlias {
+        TagAlias(std::string const& _tag, SourceLineInfo _lineInfo);
+
+        std::string tag;
+        SourceLineInfo lineInfo;
+    };
+
+} // end namespace Catch
+
+// end catch_tag_alias.h
+#include <map>
+
+namespace Catch {
+
+    class TagAliasRegistry : public ITagAliasRegistry {
+    public:
+        ~TagAliasRegistry() override;
+        TagAlias const* find( std::string const& alias ) const override;
+        std::string expandAliases( std::string const& unexpandedTestSpec ) const override;
+        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
+
+    private:
+        std::map<std::string, TagAlias> m_registry;
+    };
+
+} // end namespace Catch
+
+// end catch_tag_alias_registry.h
+// start catch_startup_exception_registry.h
+
+#include <vector>
+#include <exception>
+
+namespace Catch {
+
+    class StartupExceptionRegistry {
+    public:
+        void add(std::exception_ptr const& exception) noexcept;
+        std::vector<std::exception_ptr> const& getExceptions() const noexcept;
+    private:
+        std::vector<std::exception_ptr> m_exceptions;
+    };
+
+} // end namespace Catch
+
+// end catch_startup_exception_registry.h
+// start catch_singletons.hpp
+
+namespace Catch {
+
+    struct ISingleton {
+        virtual ~ISingleton();
+    };
+
+    void addSingleton( ISingleton* singleton );
+    void cleanupSingletons();
+
+    template<typename SingletonImplT, typename InterfaceT = SingletonImplT, typename MutableInterfaceT = InterfaceT>
+    class Singleton : SingletonImplT, public ISingleton {
+
+        static auto getInternal() -> Singleton* {
+            static Singleton* s_instance = nullptr;
+            if( !s_instance ) {
+                s_instance = new Singleton;
+                addSingleton( s_instance );
+            }
+            return s_instance;
+        }
+
+    public:
+        static auto get() -> InterfaceT const& {
+            return *getInternal();
+        }
+        static auto getMutable() -> MutableInterfaceT& {
+            return *getInternal();
+        }
+    };
+
+} // namespace Catch
+
+// end catch_singletons.hpp
+namespace Catch {
+
+    namespace {
+
+        class RegistryHub : public IRegistryHub, public IMutableRegistryHub,
+                            private NonCopyable {
+
+        public: // IRegistryHub
+            RegistryHub() = default;
+            IReporterRegistry const& getReporterRegistry() const override {
+                return m_reporterRegistry;
+            }
+            ITestCaseRegistry const& getTestCaseRegistry() const override {
+                return m_testCaseRegistry;
+            }
+            IExceptionTranslatorRegistry const& getExceptionTranslatorRegistry() const override {
+                return m_exceptionTranslatorRegistry;
+            }
+            ITagAliasRegistry const& getTagAliasRegistry() const override {
+                return m_tagAliasRegistry;
+            }
+            StartupExceptionRegistry const& getStartupExceptionRegistry() const override {
+                return m_exceptionRegistry;
+            }
+
+        public: // IMutableRegistryHub
+            void registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) override {
+                m_reporterRegistry.registerReporter( name, factory );
+            }
+            void registerListener( IReporterFactoryPtr const& factory ) override {
+                m_reporterRegistry.registerListener( factory );
+            }
+            void registerTest( TestCase const& testInfo ) override {
+                m_testCaseRegistry.registerTest( testInfo );
+            }
+            void registerTranslator( const IExceptionTranslator* translator ) override {
+                m_exceptionTranslatorRegistry.registerTranslator( translator );
+            }
+            void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) override {
+                m_tagAliasRegistry.add( alias, tag, lineInfo );
+            }
+            void registerStartupException() noexcept override {
+                m_exceptionRegistry.add(std::current_exception());
+            }
+            IMutableEnumValuesRegistry& getMutableEnumValuesRegistry() override {
+                return m_enumValuesRegistry;
+            }
+
+        private:
+            TestRegistry m_testCaseRegistry;
+            ReporterRegistry m_reporterRegistry;
+            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
+            TagAliasRegistry m_tagAliasRegistry;
+            StartupExceptionRegistry m_exceptionRegistry;
+            Detail::EnumValuesRegistry m_enumValuesRegistry;
+        };
+    }
+
+    using RegistryHubSingleton = Singleton<RegistryHub, IRegistryHub, IMutableRegistryHub>;
+
+    IRegistryHub const& getRegistryHub() {
+        return RegistryHubSingleton::get();
+    }
+    IMutableRegistryHub& getMutableRegistryHub() {
+        return RegistryHubSingleton::getMutable();
+    }
+    void cleanUp() {
+        cleanupSingletons();
+        cleanUpContext();
+    }
+    std::string translateActiveException() {
+        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
+    }
+
+} // end namespace Catch
+// end catch_registry_hub.cpp
+// start catch_reporter_registry.cpp
+
+namespace Catch {
+
+    ReporterRegistry::~ReporterRegistry() = default;
+
+    IStreamingReporterPtr ReporterRegistry::create( std::string const& name, IConfigPtr const& config ) const {
+        auto it =  m_factories.find( name );
+        if( it == m_factories.end() )
+            return nullptr;
+        return it->second->create( ReporterConfig( config ) );
+    }
+
+    void ReporterRegistry::registerReporter( std::string const& name, IReporterFactoryPtr const& factory ) {
+        m_factories.emplace(name, factory);
+    }
+    void ReporterRegistry::registerListener( IReporterFactoryPtr const& factory ) {
+        m_listeners.push_back( factory );
+    }
+
+    IReporterRegistry::FactoryMap const& ReporterRegistry::getFactories() const {
+        return m_factories;
+    }
+    IReporterRegistry::Listeners const& ReporterRegistry::getListeners() const {
+        return m_listeners;
+    }
+
+}
+// end catch_reporter_registry.cpp
+// start catch_result_type.cpp
+
+namespace Catch {
+
+    bool isOk( ResultWas::OfType resultType ) {
+        return ( resultType & ResultWas::FailureBit ) == 0;
+    }
+    bool isJustInfo( int flags ) {
+        return flags == ResultWas::Info;
+    }
+
+    ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
+        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
+    }
+
+    bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
+    bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
+
+} // end namespace Catch
+// end catch_result_type.cpp
+// start catch_run_context.cpp
+
+#include <cassert>
+#include <algorithm>
+#include <sstream>
+
+namespace Catch {
+
+    namespace Generators {
+        struct GeneratorTracker : TestCaseTracking::TrackerBase, IGeneratorTracker {
+            GeneratorBasePtr m_generator;
+
+            GeneratorTracker( TestCaseTracking::NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
+            :   TrackerBase( nameAndLocation, ctx, parent )
+            {}
+            ~GeneratorTracker();
+
+            static GeneratorTracker& acquire( TrackerContext& ctx, TestCaseTracking::NameAndLocation const& nameAndLocation ) {
+                std::shared_ptr<GeneratorTracker> tracker;
+
+                ITracker& currentTracker = ctx.currentTracker();
+                if( TestCaseTracking::ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
+                    assert( childTracker );
+                    assert( childTracker->isGeneratorTracker() );
+                    tracker = std::static_pointer_cast<GeneratorTracker>( childTracker );
+                }
+                else {
+                    tracker = std::make_shared<GeneratorTracker>( nameAndLocation, ctx, &currentTracker );
+                    currentTracker.addChild( tracker );
+                }
+
+                if( !ctx.completedCycle() && !tracker->isComplete() ) {
+                    tracker->open();
+                }
+
+                return *tracker;
+            }
+
+            // TrackerBase interface
+            bool isGeneratorTracker() const override { return true; }
+            auto hasGenerator() const -> bool override {
+                return !!m_generator;
+            }
+            void close() override {
+                TrackerBase::close();
+                // Generator interface only finds out if it has another item on atual move
+                if (m_runState == CompletedSuccessfully && m_generator->next()) {
+                    m_children.clear();
+                    m_runState = Executing;
+                }
+            }
+
+            // IGeneratorTracker interface
+            auto getGenerator() const -> GeneratorBasePtr const& override {
+                return m_generator;
+            }
+            void setGenerator( GeneratorBasePtr&& generator ) override {
+                m_generator = std::move( generator );
+            }
+        };
+        GeneratorTracker::~GeneratorTracker() {}
+    }
+
+    RunContext::RunContext(IConfigPtr const& _config, IStreamingReporterPtr&& reporter)
+    :   m_runInfo(_config->name()),
+        m_context(getCurrentMutableContext()),
+        m_config(_config),
+        m_reporter(std::move(reporter)),
+        m_lastAssertionInfo{ StringRef(), SourceLineInfo("",0), StringRef(), ResultDisposition::Normal },
+        m_includeSuccessfulResults( m_config->includeSuccessfulResults() || m_reporter->getPreferences().shouldReportAllAssertions )
+    {
+        m_context.setRunner(this);
+        m_context.setConfig(m_config);
+        m_context.setResultCapture(this);
+        m_reporter->testRunStarting(m_runInfo);
+    }
+
+    RunContext::~RunContext() {
+        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, aborting()));
+    }
+
+    void RunContext::testGroupStarting(std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount) {
+        m_reporter->testGroupStarting(GroupInfo(testSpec, groupIndex, groupsCount));
+    }
+
+    void RunContext::testGroupEnded(std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount) {
+        m_reporter->testGroupEnded(TestGroupStats(GroupInfo(testSpec, groupIndex, groupsCount), totals, aborting()));
+    }
+
+    Totals RunContext::runTest(TestCase const& testCase) {
+        Totals prevTotals = m_totals;
+
+        std::string redirectedCout;
+        std::string redirectedCerr;
+
+        auto const& testInfo = testCase.getTestCaseInfo();
+
+        m_reporter->testCaseStarting(testInfo);
+
+        m_activeTestCase = &testCase;
+
+        ITracker& rootTracker = m_trackerContext.startRun();
+        assert(rootTracker.isSectionTracker());
+        static_cast<SectionTracker&>(rootTracker).addInitialFilters(m_config->getSectionsToRun());
+        do {
+            m_trackerContext.startCycle();
+            m_testCaseTracker = &SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(testInfo.name, testInfo.lineInfo));
+            runCurrentTest(redirectedCout, redirectedCerr);
+        } while (!m_testCaseTracker->isSuccessfullyCompleted() && !aborting());
+
+        Totals deltaTotals = m_totals.delta(prevTotals);
+        if (testInfo.expectedToFail() && deltaTotals.testCases.passed > 0) {
+            deltaTotals.assertions.failed++;
+            deltaTotals.testCases.passed--;
+            deltaTotals.testCases.failed++;
+        }
+        m_totals.testCases += deltaTotals.testCases;
+        m_reporter->testCaseEnded(TestCaseStats(testInfo,
+                                  deltaTotals,
+                                  redirectedCout,
+                                  redirectedCerr,
+                                  aborting()));
+
+        m_activeTestCase = nullptr;
+        m_testCaseTracker = nullptr;
+
+        return deltaTotals;
+    }
+
+    IConfigPtr RunContext::config() const {
+        return m_config;
+    }
+
+    IStreamingReporter& RunContext::reporter() const {
+        return *m_reporter;
+    }
+
+    void RunContext::assertionEnded(AssertionResult const & result) {
+        if (result.getResultType() == ResultWas::Ok) {
+            m_totals.assertions.passed++;
+            m_lastAssertionPassed = true;
+        } else if (!result.isOk()) {
+            m_lastAssertionPassed = false;
+            if( m_activeTestCase->getTestCaseInfo().okToFail() )
+                m_totals.assertions.failedButOk++;
+            else
+                m_totals.assertions.failed++;
+        }
+        else {
+            m_lastAssertionPassed = true;
+        }
+
+        // We have no use for the return value (whether messages should be cleared), because messages were made scoped
+        // and should be let to clear themselves out.
+        static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));
+
+        if (result.getResultType() != ResultWas::Warning)
+            m_messageScopes.clear();
+
+        // Reset working state
+        resetAssertionInfo();
+        m_lastResult = result;
+    }
+    void RunContext::resetAssertionInfo() {
+        m_lastAssertionInfo.macroName = StringRef();
+        m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}"_sr;
+    }
+
+    bool RunContext::sectionStarted(SectionInfo const & sectionInfo, Counts & assertions) {
+        ITracker& sectionTracker = SectionTracker::acquire(m_trackerContext, TestCaseTracking::NameAndLocation(sectionInfo.name, sectionInfo.lineInfo));
+        if (!sectionTracker.isOpen())
+            return false;
+        m_activeSections.push_back(&sectionTracker);
+
+        m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
+
+        m_reporter->sectionStarting(sectionInfo);
+
+        assertions = m_totals.assertions;
+
+        return true;
+    }
+    auto RunContext::acquireGeneratorTracker( SourceLineInfo const& lineInfo ) -> IGeneratorTracker& {
+        using namespace Generators;
+        GeneratorTracker& tracker = GeneratorTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( "generator", lineInfo ) );
+        assert( tracker.isOpen() );
+        m_lastAssertionInfo.lineInfo = lineInfo;
+        return tracker;
+    }
+
+    bool RunContext::testForMissingAssertions(Counts& assertions) {
+        if (assertions.total() != 0)
+            return false;
+        if (!m_config->warnAboutMissingAssertions())
+            return false;
+        if (m_trackerContext.currentTracker().hasChildren())
+            return false;
+        m_totals.assertions.failed++;
+        assertions.failed++;
+        return true;
+    }
+
+    void RunContext::sectionEnded(SectionEndInfo const & endInfo) {
+        Counts assertions = m_totals.assertions - endInfo.prevAssertions;
+        bool missingAssertions = testForMissingAssertions(assertions);
+
+        if (!m_activeSections.empty()) {
+            m_activeSections.back()->close();
+            m_activeSections.pop_back();
+        }
+
+        m_reporter->sectionEnded(SectionStats(endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions));
+        m_messages.clear();
+        m_messageScopes.clear();
+    }
+
+    void RunContext::sectionEndedEarly(SectionEndInfo const & endInfo) {
+        if (m_unfinishedSections.empty())
+            m_activeSections.back()->fail();
+        else
+            m_activeSections.back()->close();
+        m_activeSections.pop_back();
+
+        m_unfinishedSections.push_back(endInfo);
+    }
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+    void RunContext::benchmarkPreparing(std::string const& name) {
+		m_reporter->benchmarkPreparing(name);
+	}
+    void RunContext::benchmarkStarting( BenchmarkInfo const& info ) {
+        m_reporter->benchmarkStarting( info );
+    }
+    void RunContext::benchmarkEnded( BenchmarkStats<> const& stats ) {
+        m_reporter->benchmarkEnded( stats );
+    }
+	void RunContext::benchmarkFailed(std::string const & error) {
+		m_reporter->benchmarkFailed(error);
+	}
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    void RunContext::pushScopedMessage(MessageInfo const & message) {
+        m_messages.push_back(message);
+    }
+
+    void RunContext::popScopedMessage(MessageInfo const & message) {
+        m_messages.erase(std::remove(m_messages.begin(), m_messages.end(), message), m_messages.end());
+    }
+
+    void RunContext::emplaceUnscopedMessage( MessageBuilder const& builder ) {
+        m_messageScopes.emplace_back( builder );
+    }
+
+    std::string RunContext::getCurrentTestName() const {
+        return m_activeTestCase
+            ? m_activeTestCase->getTestCaseInfo().name
+            : std::string();
+    }
+
+    const AssertionResult * RunContext::getLastResult() const {
+        return &(*m_lastResult);
+    }
+
+    void RunContext::exceptionEarlyReported() {
+        m_shouldReportUnexpected = false;
+    }
+
+    void RunContext::handleFatalErrorCondition( StringRef message ) {
+        // First notify reporter that bad things happened
+        m_reporter->fatalErrorEncountered(message);
+
+        // Don't rebuild the result -- the stringification itself can cause more fatal errors
+        // Instead, fake a result data.
+        AssertionResultData tempResult( ResultWas::FatalErrorCondition, { false } );
+        tempResult.message = static_cast<std::string>(message);
+        AssertionResult result(m_lastAssertionInfo, tempResult);
+
+        assertionEnded(result);
+
+        handleUnfinishedSections();
+
+        // Recreate section for test case (as we will lose the one that was in scope)
+        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
+        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
+
+        Counts assertions;
+        assertions.failed = 1;
+        SectionStats testCaseSectionStats(testCaseSection, assertions, 0, false);
+        m_reporter->sectionEnded(testCaseSectionStats);
+
+        auto const& testInfo = m_activeTestCase->getTestCaseInfo();
+
+        Totals deltaTotals;
+        deltaTotals.testCases.failed = 1;
+        deltaTotals.assertions.failed = 1;
+        m_reporter->testCaseEnded(TestCaseStats(testInfo,
+                                  deltaTotals,
+                                  std::string(),
+                                  std::string(),
+                                  false));
+        m_totals.testCases.failed++;
+        testGroupEnded(std::string(), m_totals, 1, 1);
+        m_reporter->testRunEnded(TestRunStats(m_runInfo, m_totals, false));
+    }
+
+    bool RunContext::lastAssertionPassed() {
+         return m_lastAssertionPassed;
+    }
+
+    void RunContext::assertionPassed() {
+        m_lastAssertionPassed = true;
+        ++m_totals.assertions.passed;
+        resetAssertionInfo();
+        m_messageScopes.clear();
+    }
+
+    bool RunContext::aborting() const {
+        return m_totals.assertions.failed >= static_cast<std::size_t>(m_config->abortAfter());
+    }
+
+    void RunContext::runCurrentTest(std::string & redirectedCout, std::string & redirectedCerr) {
+        auto const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
+        SectionInfo testCaseSection(testCaseInfo.lineInfo, testCaseInfo.name);
+        m_reporter->sectionStarting(testCaseSection);
+        Counts prevAssertions = m_totals.assertions;
+        double duration = 0;
+        m_shouldReportUnexpected = true;
+        m_lastAssertionInfo = { "TEST_CASE"_sr, testCaseInfo.lineInfo, StringRef(), ResultDisposition::Normal };
+
+        seedRng(*m_config);
+
+        Timer timer;
+        CATCH_TRY {
+            if (m_reporter->getPreferences().shouldRedirectStdOut) {
+#if !defined(CATCH_CONFIG_EXPERIMENTAL_REDIRECT)
+                RedirectedStreams redirectedStreams(redirectedCout, redirectedCerr);
+
+                timer.start();
+                invokeActiveTestCase();
+#else
+                OutputRedirect r(redirectedCout, redirectedCerr);
+                timer.start();
+                invokeActiveTestCase();
+#endif
+            } else {
+                timer.start();
+                invokeActiveTestCase();
+            }
+            duration = timer.getElapsedSeconds();
+        } CATCH_CATCH_ANON (TestFailureException&) {
+            // This just means the test was aborted due to failure
+        } CATCH_CATCH_ALL {
+            // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
+            // are reported without translation at the point of origin.
+            if( m_shouldReportUnexpected ) {
+                AssertionReaction dummyReaction;
+                handleUnexpectedInflightException( m_lastAssertionInfo, translateActiveException(), dummyReaction );
+            }
+        }
+        Counts assertions = m_totals.assertions - prevAssertions;
+        bool missingAssertions = testForMissingAssertions(assertions);
+
+        m_testCaseTracker->close();
+        handleUnfinishedSections();
+        m_messages.clear();
+        m_messageScopes.clear();
+
+        SectionStats testCaseSectionStats(testCaseSection, assertions, duration, missingAssertions);
+        m_reporter->sectionEnded(testCaseSectionStats);
+    }
+
+    void RunContext::invokeActiveTestCase() {
+        FatalConditionHandler fatalConditionHandler; // Handle signals
+        m_activeTestCase->invoke();
+        fatalConditionHandler.reset();
+    }
+
+    void RunContext::handleUnfinishedSections() {
+        // If sections ended prematurely due to an exception we stored their
+        // infos here so we can tear them down outside the unwind process.
+        for (auto it = m_unfinishedSections.rbegin(),
+             itEnd = m_unfinishedSections.rend();
+             it != itEnd;
+             ++it)
+            sectionEnded(*it);
+        m_unfinishedSections.clear();
+    }
+
+    void RunContext::handleExpr(
+        AssertionInfo const& info,
+        ITransientExpression const& expr,
+        AssertionReaction& reaction
+    ) {
+        m_reporter->assertionStarting( info );
+
+        bool negated = isFalseTest( info.resultDisposition );
+        bool result = expr.getResult() != negated;
+
+        if( result ) {
+            if (!m_includeSuccessfulResults) {
+                assertionPassed();
+            }
+            else {
+                reportExpr(info, ResultWas::Ok, &expr, negated);
+            }
+        }
+        else {
+            reportExpr(info, ResultWas::ExpressionFailed, &expr, negated );
+            populateReaction( reaction );
+        }
+    }
+    void RunContext::reportExpr(
+            AssertionInfo const &info,
+            ResultWas::OfType resultType,
+            ITransientExpression const *expr,
+            bool negated ) {
+
+        m_lastAssertionInfo = info;
+        AssertionResultData data( resultType, LazyExpression( negated ) );
+
+        AssertionResult assertionResult{ info, data };
+        assertionResult.m_resultData.lazyExpression.m_transientExpression = expr;
+
+        assertionEnded( assertionResult );
+    }
+
+    void RunContext::handleMessage(
+            AssertionInfo const& info,
+            ResultWas::OfType resultType,
+            StringRef const& message,
+            AssertionReaction& reaction
+    ) {
+        m_reporter->assertionStarting( info );
+
+        m_lastAssertionInfo = info;
+
+        AssertionResultData data( resultType, LazyExpression( false ) );
+        data.message = static_cast<std::string>(message);
+        AssertionResult assertionResult{ m_lastAssertionInfo, data };
+        assertionEnded( assertionResult );
+        if( !assertionResult.isOk() )
+            populateReaction( reaction );
+    }
+    void RunContext::handleUnexpectedExceptionNotThrown(
+            AssertionInfo const& info,
+            AssertionReaction& reaction
+    ) {
+        handleNonExpr(info, Catch::ResultWas::DidntThrowException, reaction);
+    }
+
+    void RunContext::handleUnexpectedInflightException(
+            AssertionInfo const& info,
+            std::string const& message,
+            AssertionReaction& reaction
+    ) {
+        m_lastAssertionInfo = info;
+
+        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
+        data.message = message;
+        AssertionResult assertionResult{ info, data };
+        assertionEnded( assertionResult );
+        populateReaction( reaction );
+    }
+
+    void RunContext::populateReaction( AssertionReaction& reaction ) {
+        reaction.shouldDebugBreak = m_config->shouldDebugBreak();
+        reaction.shouldThrow = aborting() || (m_lastAssertionInfo.resultDisposition & ResultDisposition::Normal);
+    }
+
+    void RunContext::handleIncomplete(
+            AssertionInfo const& info
+    ) {
+        m_lastAssertionInfo = info;
+
+        AssertionResultData data( ResultWas::ThrewException, LazyExpression( false ) );
+        data.message = "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
+        AssertionResult assertionResult{ info, data };
+        assertionEnded( assertionResult );
+    }
+    void RunContext::handleNonExpr(
+            AssertionInfo const &info,
+            ResultWas::OfType resultType,
+            AssertionReaction &reaction
+    ) {
+        m_lastAssertionInfo = info;
+
+        AssertionResultData data( resultType, LazyExpression( false ) );
+        AssertionResult assertionResult{ info, data };
+        assertionEnded( assertionResult );
+
+        if( !assertionResult.isOk() )
+            populateReaction( reaction );
+    }
+
+    IResultCapture& getResultCapture() {
+        if (auto* capture = getCurrentContext().getResultCapture())
+            return *capture;
+        else
+            CATCH_INTERNAL_ERROR("No result capture instance");
+    }
+
+    void seedRng(IConfig const& config) {
+        if (config.rngSeed() != 0) {
+            std::srand(config.rngSeed());
+            rng().seed(config.rngSeed());
+        }
+    }
+
+    unsigned int rngSeed() {
+        return getCurrentContext().getConfig()->rngSeed();
+    }
+
+}
+// end catch_run_context.cpp
+// start catch_section.cpp
+
+namespace Catch {
+
+    Section::Section( SectionInfo const& info )
+    :   m_info( info ),
+        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
+    {
+        m_timer.start();
+    }
+
+    Section::~Section() {
+        if( m_sectionIncluded ) {
+            SectionEndInfo endInfo{ m_info, m_assertions, m_timer.getElapsedSeconds() };
+            if( uncaught_exceptions() )
+                getResultCapture().sectionEndedEarly( endInfo );
+            else
+                getResultCapture().sectionEnded( endInfo );
+        }
+    }
+
+    // This indicates whether the section should be executed or not
+    Section::operator bool() const {
+        return m_sectionIncluded;
+    }
+
+} // end namespace Catch
+// end catch_section.cpp
+// start catch_section_info.cpp
+
+namespace Catch {
+
+    SectionInfo::SectionInfo
+        (   SourceLineInfo const& _lineInfo,
+            std::string const& _name )
+    :   name( _name ),
+        lineInfo( _lineInfo )
+    {}
+
+} // end namespace Catch
+// end catch_section_info.cpp
+// start catch_session.cpp
+
+// start catch_session.h
+
+#include <memory>
+
+namespace Catch {
+
+    class Session : NonCopyable {
+    public:
+
+        Session();
+        ~Session() override;
+
+        void showHelp() const;
+        void libIdentify();
+
+        int applyCommandLine( int argc, char const * const * argv );
+    #if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
+        int applyCommandLine( int argc, wchar_t const * const * argv );
+    #endif
+
+        void useConfigData( ConfigData const& configData );
+
+        template<typename CharT>
+        int run(int argc, CharT const * const argv[]) {
+            if (m_startupExceptions)
+                return 1;
+            int returnCode = applyCommandLine(argc, argv);
+            if (returnCode == 0)
+                returnCode = run();
+            return returnCode;
+        }
+
+        int run();
+
+        clara::Parser const& cli() const;
+        void cli( clara::Parser const& newParser );
+        ConfigData& configData();
+        Config& config();
+    private:
+        int runInternal();
+
+        clara::Parser m_cli;
+        ConfigData m_configData;
+        std::shared_ptr<Config> m_config;
+        bool m_startupExceptions = false;
+    };
+
+} // end namespace Catch
+
+// end catch_session.h
+// start catch_version.h
+
+#include <iosfwd>
+
+namespace Catch {
+
+    // Versioning information
+    struct Version {
+        Version( Version const& ) = delete;
+        Version& operator=( Version const& ) = delete;
+        Version(    unsigned int _majorVersion,
+                    unsigned int _minorVersion,
+                    unsigned int _patchNumber,
+                    char const * const _branchName,
+                    unsigned int _buildNumber );
+
+        unsigned int const majorVersion;
+        unsigned int const minorVersion;
+        unsigned int const patchNumber;
+
+        // buildNumber is only used if branchName is not null
+        char const * const branchName;
+        unsigned int const buildNumber;
+
+        friend std::ostream& operator << ( std::ostream& os, Version const& version );
+    };
+
+    Version const& libraryVersion();
+}
+
+// end catch_version.h
+#include <cstdlib>
+#include <iomanip>
+#include <set>
+#include <iterator>
+
+namespace Catch {
+
+    namespace {
+        const int MaxExitCode = 255;
+
+        IStreamingReporterPtr createReporter(std::string const& reporterName, IConfigPtr const& config) {
+            auto reporter = Catch::getRegistryHub().getReporterRegistry().create(reporterName, config);
+            CATCH_ENFORCE(reporter, "No reporter registered with name: '" << reporterName << "'");
+
+            return reporter;
+        }
+
+        IStreamingReporterPtr makeReporter(std::shared_ptr<Config> const& config) {
+            if (Catch::getRegistryHub().getReporterRegistry().getListeners().empty()) {
+                return createReporter(config->getReporterName(), config);
+            }
+
+            // On older platforms, returning std::unique_ptr<ListeningReporter>
+            // when the return type is std::unique_ptr<IStreamingReporter>
+            // doesn't compile without a std::move call. However, this causes
+            // a warning on newer platforms. Thus, we have to work around
+            // it a bit and downcast the pointer manually.
+            auto ret = std::unique_ptr<IStreamingReporter>(new ListeningReporter);
+            auto& multi = static_cast<ListeningReporter&>(*ret);
+            auto const& listeners = Catch::getRegistryHub().getReporterRegistry().getListeners();
+            for (auto const& listener : listeners) {
+                multi.addListener(listener->create(Catch::ReporterConfig(config)));
+            }
+            multi.addReporter(createReporter(config->getReporterName(), config));
+            return ret;
+        }
+
+        class TestGroup {
+        public:
+            explicit TestGroup(std::shared_ptr<Config> const& config)
+            : m_config{config}
+            , m_context{config, makeReporter(config)}
+            {
+                auto const& allTestCases = getAllTestCasesSorted(*m_config);
+                m_matches = m_config->testSpec().matchesByFilter(allTestCases, *m_config);
+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();
+
+                if (m_matches.empty() && invalidArgs.empty()) {
+                    for (auto const& test : allTestCases)
+                        if (!test.isHidden())
+                            m_tests.emplace(&test);
+                } else {
+                    for (auto const& match : m_matches)
+                        m_tests.insert(match.tests.begin(), match.tests.end());
+                }
+            }
+
+            Totals execute() {
+                auto const& invalidArgs = m_config->testSpec().getInvalidArgs();
+                Totals totals;
+                m_context.testGroupStarting(m_config->name(), 1, 1);
+                for (auto const& testCase : m_tests) {
+                    if (!m_context.aborting())
+                        totals += m_context.runTest(*testCase);
+                    else
+                        m_context.reporter().skipTest(*testCase);
+                }
+
+                for (auto const& match : m_matches) {
+                    if (match.tests.empty()) {
+                        m_context.reporter().noMatchingTestCases(match.name);
+                        totals.error = -1;
+                    }
+                }
+
+                if (!invalidArgs.empty()) {
+                    for (auto const& invalidArg: invalidArgs)
+                         m_context.reporter().reportInvalidArguments(invalidArg);
+                }
+
+                m_context.testGroupEnded(m_config->name(), totals, 1, 1);
+                return totals;
+            }
+
+        private:
+            using Tests = std::set<TestCase const*>;
+
+            std::shared_ptr<Config> m_config;
+            RunContext m_context;
+            Tests m_tests;
+            TestSpec::Matches m_matches;
+        };
+
+        void applyFilenamesAsTags(Catch::IConfig const& config) {
+            auto& tests = const_cast<std::vector<TestCase>&>(getAllTestCasesSorted(config));
+            for (auto& testCase : tests) {
+                auto tags = testCase.tags;
+
+                std::string filename = testCase.lineInfo.file;
+                auto lastSlash = filename.find_last_of("\\/");
+                if (lastSlash != std::string::npos) {
+                    filename.erase(0, lastSlash);
+                    filename[0] = '#';
+                }
+
+                auto lastDot = filename.find_last_of('.');
+                if (lastDot != std::string::npos) {
+                    filename.erase(lastDot);
+                }
+
+                tags.push_back(std::move(filename));
+                setTags(testCase, tags);
+            }
+        }
+
+    } // anon namespace
+
+    Session::Session() {
+        static bool alreadyInstantiated = false;
+        if( alreadyInstantiated ) {
+            CATCH_TRY { CATCH_INTERNAL_ERROR( "Only one instance of Catch::Session can ever be used" ); }
+            CATCH_CATCH_ALL { getMutableRegistryHub().registerStartupException(); }
+        }
+
+        // There cannot be exceptions at startup in no-exception mode.
+#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+        const auto& exceptions = getRegistryHub().getStartupExceptionRegistry().getExceptions();
+        if ( !exceptions.empty() ) {
+            config();
+            getCurrentMutableContext().setConfig(m_config);
+
+            m_startupExceptions = true;
+            Colour colourGuard( Colour::Red );
+            Catch::cerr() << "Errors occurred during startup!" << '\n';
+            // iterate over all exceptions and notify user
+            for ( const auto& ex_ptr : exceptions ) {
+                try {
+                    std::rethrow_exception(ex_ptr);
+                } catch ( std::exception const& ex ) {
+                    Catch::cerr() << Column( ex.what() ).indent(2) << '\n';
+                }
+            }
+        }
+#endif
+
+        alreadyInstantiated = true;
+        m_cli = makeCommandLineParser( m_configData );
+    }
+    Session::~Session() {
+        Catch::cleanUp();
+    }
+
+    void Session::showHelp() const {
+        Catch::cout()
+                << "\nCatch v" << libraryVersion() << "\n"
+                << m_cli << std::endl
+                << "For more detailed usage please see the project docs\n" << std::endl;
+    }
+    void Session::libIdentify() {
+        Catch::cout()
+                << std::left << std::setw(16) << "description: " << "A Catch2 test executable\n"
+                << std::left << std::setw(16) << "category: " << "testframework\n"
+                << std::left << std::setw(16) << "framework: " << "Catch Test\n"
+                << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
+    }
+
+    int Session::applyCommandLine( int argc, char const * const * argv ) {
+        if( m_startupExceptions )
+            return 1;
+
+        auto result = m_cli.parse( clara::Args( argc, argv ) );
+        if( !result ) {
+            config();
+            getCurrentMutableContext().setConfig(m_config);
+            Catch::cerr()
+                << Colour( Colour::Red )
+                << "\nError(s) in input:\n"
+                << Column( result.errorMessage() ).indent( 2 )
+                << "\n\n";
+            Catch::cerr() << "Run with -? for usage\n" << std::endl;
+            return MaxExitCode;
+        }
+
+        if( m_configData.showHelp )
+            showHelp();
+        if( m_configData.libIdentify )
+            libIdentify();
+        m_config.reset();
+        return 0;
+    }
+
+#if defined(CATCH_CONFIG_WCHAR) && defined(_WIN32) && defined(UNICODE)
+    int Session::applyCommandLine( int argc, wchar_t const * const * argv ) {
+
+        char **utf8Argv = new char *[ argc ];
+
+        for ( int i = 0; i < argc; ++i ) {
+            int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, nullptr, 0, nullptr, nullptr );
+
+            utf8Argv[ i ] = new char[ bufSize ];
+
+            WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, nullptr, nullptr );
+        }
+
+        int returnCode = applyCommandLine( argc, utf8Argv );
+
+        for ( int i = 0; i < argc; ++i )
+            delete [] utf8Argv[ i ];
+
+        delete [] utf8Argv;
+
+        return returnCode;
+    }
+#endif
+
+    void Session::useConfigData( ConfigData const& configData ) {
+        m_configData = configData;
+        m_config.reset();
+    }
+
+    int Session::run() {
+        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
+            Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
+            static_cast<void>(std::getchar());
+        }
+        int exitCode = runInternal();
+        if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
+            Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
+            static_cast<void>(std::getchar());
+        }
+        return exitCode;
+    }
+
+    clara::Parser const& Session::cli() const {
+        return m_cli;
+    }
+    void Session::cli( clara::Parser const& newParser ) {
+        m_cli = newParser;
+    }
+    ConfigData& Session::configData() {
+        return m_configData;
+    }
+    Config& Session::config() {
+        if( !m_config )
+            m_config = std::make_shared<Config>( m_configData );
+        return *m_config;
+    }
+
+    int Session::runInternal() {
+        if( m_startupExceptions )
+            return 1;
+
+        if (m_configData.showHelp || m_configData.libIdentify) {
+            return 0;
+        }
+
+        CATCH_TRY {
+            config(); // Force config to be constructed
+
+            seedRng( *m_config );
+
+            if( m_configData.filenamesAsTags )
+                applyFilenamesAsTags( *m_config );
+
+            // Handle list request
+            if( Option<std::size_t> listed = list( m_config ) )
+                return static_cast<int>( *listed );
+
+            TestGroup tests { m_config };
+            auto const totals = tests.execute();
+
+            if( m_config->warnAboutNoTests() && totals.error == -1 )
+                return 2;
+
+            // Note that on unices only the lower 8 bits are usually used, clamping
+            // the return value to 255 prevents false negative when some multiple
+            // of 256 tests has failed
+            return (std::min) (MaxExitCode, (std::max) (totals.error, static_cast<int>(totals.assertions.failed)));
+        }
+#if !defined(CATCH_CONFIG_DISABLE_EXCEPTIONS)
+        catch( std::exception& ex ) {
+            Catch::cerr() << ex.what() << std::endl;
+            return MaxExitCode;
+        }
+#endif
+    }
+
+} // end namespace Catch
+// end catch_session.cpp
+// start catch_singletons.cpp
+
+#include <vector>
+
+namespace Catch {
+
+    namespace {
+        static auto getSingletons() -> std::vector<ISingleton*>*& {
+            static std::vector<ISingleton*>* g_singletons = nullptr;
+            if( !g_singletons )
+                g_singletons = new std::vector<ISingleton*>();
+            return g_singletons;
+        }
+    }
+
+    ISingleton::~ISingleton() {}
+
+    void addSingleton(ISingleton* singleton ) {
+        getSingletons()->push_back( singleton );
+    }
+    void cleanupSingletons() {
+        auto& singletons = getSingletons();
+        for( auto singleton : *singletons )
+            delete singleton;
+        delete singletons;
+        singletons = nullptr;
+    }
+
+} // namespace Catch
+// end catch_singletons.cpp
+// start catch_startup_exception_registry.cpp
+
+namespace Catch {
+void StartupExceptionRegistry::add( std::exception_ptr const& exception ) noexcept {
+        CATCH_TRY {
+            m_exceptions.push_back(exception);
+        } CATCH_CATCH_ALL {
+            // If we run out of memory during start-up there's really not a lot more we can do about it
+            std::terminate();
+        }
+    }
+
+    std::vector<std::exception_ptr> const& StartupExceptionRegistry::getExceptions() const noexcept {
+        return m_exceptions;
+    }
+
+} // end namespace Catch
+// end catch_startup_exception_registry.cpp
+// start catch_stream.cpp
+
+#include <cstdio>
+#include <iostream>
+#include <fstream>
+#include <sstream>
+#include <vector>
+#include <memory>
+
+namespace Catch {
+
+    Catch::IStream::~IStream() = default;
+
+    namespace Detail { namespace {
+        template<typename WriterF, std::size_t bufferSize=256>
+        class StreamBufImpl : public std::streambuf {
+            char data[bufferSize];
+            WriterF m_writer;
+
+        public:
+            StreamBufImpl() {
+                setp( data, data + sizeof(data) );
+            }
+
+            ~StreamBufImpl() noexcept {
+                StreamBufImpl::sync();
+            }
+
+        private:
+            int overflow( int c ) override {
+                sync();
+
+                if( c != EOF ) {
+                    if( pbase() == epptr() )
+                        m_writer( std::string( 1, static_cast<char>( c ) ) );
+                    else
+                        sputc( static_cast<char>( c ) );
+                }
+                return 0;
+            }
+
+            int sync() override {
+                if( pbase() != pptr() ) {
+                    m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
+                    setp( pbase(), epptr() );
+                }
+                return 0;
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////////
+
+        struct OutputDebugWriter {
+
+            void operator()( std::string const&str ) {
+                writeToDebugConsole( str );
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////////
+
+        class FileStream : public IStream {
+            mutable std::ofstream m_ofs;
+        public:
+            FileStream( StringRef filename ) {
+                m_ofs.open( filename.c_str() );
+                CATCH_ENFORCE( !m_ofs.fail(), "Unable to open file: '" << filename << "'" );
+            }
+            ~FileStream() override = default;
+        public: // IStream
+            std::ostream& stream() const override {
+                return m_ofs;
+            }
+        };
+
+        ///////////////////////////////////////////////////////////////////////////
+
+        class CoutStream : public IStream {
+            mutable std::ostream m_os;
+        public:
+            // Store the streambuf from cout up-front because
+            // cout may get redirected when running tests
+            CoutStream() : m_os( Catch::cout().rdbuf() ) {}
+            ~CoutStream() override = default;
+
+        public: // IStream
+            std::ostream& stream() const override { return m_os; }
+        };
+
+        ///////////////////////////////////////////////////////////////////////////
+
+        class DebugOutStream : public IStream {
+            std::unique_ptr<StreamBufImpl<OutputDebugWriter>> m_streamBuf;
+            mutable std::ostream m_os;
+        public:
+            DebugOutStream()
+            :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
+                m_os( m_streamBuf.get() )
+            {}
+
+            ~DebugOutStream() override = default;
+
+        public: // IStream
+            std::ostream& stream() const override { return m_os; }
+        };
+
+    }} // namespace anon::detail
+
+    ///////////////////////////////////////////////////////////////////////////
+
+    auto makeStream( StringRef const &filename ) -> IStream const* {
+        if( filename.empty() )
+            return new Detail::CoutStream();
+        else if( filename[0] == '%' ) {
+            if( filename == "%debug" )
+                return new Detail::DebugOutStream();
+            else
+                CATCH_ERROR( "Unrecognised stream: '" << filename << "'" );
+        }
+        else
+            return new Detail::FileStream( filename );
+    }
+
+    // This class encapsulates the idea of a pool of ostringstreams that can be reused.
+    struct StringStreams {
+        std::vector<std::unique_ptr<std::ostringstream>> m_streams;
+        std::vector<std::size_t> m_unused;
+        std::ostringstream m_referenceStream; // Used for copy state/ flags from
+
+        auto add() -> std::size_t {
+            if( m_unused.empty() ) {
+                m_streams.push_back( std::unique_ptr<std::ostringstream>( new std::ostringstream ) );
+                return m_streams.size()-1;
+            }
+            else {
+                auto index = m_unused.back();
+                m_unused.pop_back();
+                return index;
+            }
+        }
+
+        void release( std::size_t index ) {
+            m_streams[index]->copyfmt( m_referenceStream ); // Restore initial flags and other state
+            m_unused.push_back(index);
+        }
+    };
+
+    ReusableStringStream::ReusableStringStream()
+    :   m_index( Singleton<StringStreams>::getMutable().add() ),
+        m_oss( Singleton<StringStreams>::getMutable().m_streams[m_index].get() )
+    {}
+
+    ReusableStringStream::~ReusableStringStream() {
+        static_cast<std::ostringstream*>( m_oss )->str("");
+        m_oss->clear();
+        Singleton<StringStreams>::getMutable().release( m_index );
+    }
+
+    auto ReusableStringStream::str() const -> std::string {
+        return static_cast<std::ostringstream*>( m_oss )->str();
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+
+#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
+    std::ostream& cout() { return std::cout; }
+    std::ostream& cerr() { return std::cerr; }
+    std::ostream& clog() { return std::clog; }
+#endif
+}
+// end catch_stream.cpp
+// start catch_string_manip.cpp
+
+#include <algorithm>
+#include <ostream>
+#include <cstring>
+#include <cctype>
+#include <vector>
+
+namespace Catch {
+
+    namespace {
+        char toLowerCh(char c) {
+            return static_cast<char>( std::tolower( c ) );
+        }
+    }
+
+    bool startsWith( std::string const& s, std::string const& prefix ) {
+        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
+    }
+    bool startsWith( std::string const& s, char prefix ) {
+        return !s.empty() && s[0] == prefix;
+    }
+    bool endsWith( std::string const& s, std::string const& suffix ) {
+        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
+    }
+    bool endsWith( std::string const& s, char suffix ) {
+        return !s.empty() && s[s.size()-1] == suffix;
+    }
+    bool contains( std::string const& s, std::string const& infix ) {
+        return s.find( infix ) != std::string::npos;
+    }
+    void toLowerInPlace( std::string& s ) {
+        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
+    }
+    std::string toLower( std::string const& s ) {
+        std::string lc = s;
+        toLowerInPlace( lc );
+        return lc;
+    }
+    std::string trim( std::string const& str ) {
+        static char const* whitespaceChars = "\n\r\t ";
+        std::string::size_type start = str.find_first_not_of( whitespaceChars );
+        std::string::size_type end = str.find_last_not_of( whitespaceChars );
+
+        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
+    }
+
+    StringRef trim(StringRef ref) {
+        const auto is_ws = [](char c) {
+            return c == ' ' || c == '\t' || c == '\n' || c == '\r';
+        };
+        size_t real_begin = 0;
+        while (real_begin < ref.size() && is_ws(ref[real_begin])) { ++real_begin; }
+        size_t real_end = ref.size();
+        while (real_end > real_begin && is_ws(ref[real_end - 1])) { --real_end; }
+
+        return ref.substr(real_begin, real_end - real_begin);
+    }
+
+    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
+        bool replaced = false;
+        std::size_t i = str.find( replaceThis );
+        while( i != std::string::npos ) {
+            replaced = true;
+            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
+            if( i < str.size()-withThis.size() )
+                i = str.find( replaceThis, i+withThis.size() );
+            else
+                i = std::string::npos;
+        }
+        return replaced;
+    }
+
+    std::vector<StringRef> splitStringRef( StringRef str, char delimiter ) {
+        std::vector<StringRef> subStrings;
+        std::size_t start = 0;
+        for(std::size_t pos = 0; pos < str.size(); ++pos ) {
+            if( str[pos] == delimiter ) {
+                if( pos - start > 1 )
+                    subStrings.push_back( str.substr( start, pos-start ) );
+                start = pos+1;
+            }
+        }
+        if( start < str.size() )
+            subStrings.push_back( str.substr( start, str.size()-start ) );
+        return subStrings;
+    }
+
+    pluralise::pluralise( std::size_t count, std::string const& label )
+    :   m_count( count ),
+        m_label( label )
+    {}
+
+    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
+        os << pluraliser.m_count << ' ' << pluraliser.m_label;
+        if( pluraliser.m_count != 1 )
+            os << 's';
+        return os;
+    }
+
+}
+// end catch_string_manip.cpp
+// start catch_stringref.cpp
+
+#include <algorithm>
+#include <ostream>
+#include <cstring>
+#include <cstdint>
+
+namespace Catch {
+    StringRef::StringRef( char const* rawChars ) noexcept
+    : StringRef( rawChars, static_cast<StringRef::size_type>(std::strlen(rawChars) ) )
+    {}
+
+    auto StringRef::c_str() const -> char const* {
+        CATCH_ENFORCE(isNullTerminated(), "Called StringRef::c_str() on a non-null-terminated instance");
+        return m_start;
+    }
+    auto StringRef::data() const noexcept -> char const* {
+        return m_start;
+    }
+
+    auto StringRef::substr( size_type start, size_type size ) const noexcept -> StringRef {
+        if (start < m_size) {
+            return StringRef(m_start + start, (std::min)(m_size - start, size));
+        } else {
+            return StringRef();
+        }
+    }
+    auto StringRef::operator == ( StringRef const& other ) const noexcept -> bool {
+        return m_size == other.m_size
+            && (std::memcmp( m_start, other.m_start, m_size ) == 0);
+    }
+
+    auto operator << ( std::ostream& os, StringRef const& str ) -> std::ostream& {
+        return os.write(str.data(), str.size());
+    }
+
+    auto operator+=( std::string& lhs, StringRef const& rhs ) -> std::string& {
+        lhs.append(rhs.data(), rhs.size());
+        return lhs;
+    }
+
+} // namespace Catch
+// end catch_stringref.cpp
+// start catch_tag_alias.cpp
+
+namespace Catch {
+    TagAlias::TagAlias(std::string const & _tag, SourceLineInfo _lineInfo): tag(_tag), lineInfo(_lineInfo) {}
+}
+// end catch_tag_alias.cpp
+// start catch_tag_alias_autoregistrar.cpp
+
+namespace Catch {
+
+    RegistrarForTagAliases::RegistrarForTagAliases(char const* alias, char const* tag, SourceLineInfo const& lineInfo) {
+        CATCH_TRY {
+            getMutableRegistryHub().registerTagAlias(alias, tag, lineInfo);
+        } CATCH_CATCH_ALL {
+            // Do not throw when constructing global objects, instead register the exception to be processed later
+            getMutableRegistryHub().registerStartupException();
+        }
+    }
+
+}
+// end catch_tag_alias_autoregistrar.cpp
+// start catch_tag_alias_registry.cpp
+
+#include <sstream>
+
+namespace Catch {
+
+    TagAliasRegistry::~TagAliasRegistry() {}
+
+    TagAlias const* TagAliasRegistry::find( std::string const& alias ) const {
+        auto it = m_registry.find( alias );
+        if( it != m_registry.end() )
+            return &(it->second);
+        else
+            return nullptr;
+    }
+
+    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
+        std::string expandedTestSpec = unexpandedTestSpec;
+        for( auto const& registryKvp : m_registry ) {
+            std::size_t pos = expandedTestSpec.find( registryKvp.first );
+            if( pos != std::string::npos ) {
+                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
+                                    registryKvp.second.tag +
+                                    expandedTestSpec.substr( pos + registryKvp.first.size() );
+            }
+        }
+        return expandedTestSpec;
+    }
+
+    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
+        CATCH_ENFORCE( startsWith(alias, "[@") && endsWith(alias, ']'),
+                      "error: tag alias, '" << alias << "' is not of the form [@alias name].\n" << lineInfo );
+
+        CATCH_ENFORCE( m_registry.insert(std::make_pair(alias, TagAlias(tag, lineInfo))).second,
+                      "error: tag alias, '" << alias << "' already registered.\n"
+                      << "\tFirst seen at: " << find(alias)->lineInfo << "\n"
+                      << "\tRedefined at: " << lineInfo );
+    }
+
+    ITagAliasRegistry::~ITagAliasRegistry() {}
+
+    ITagAliasRegistry const& ITagAliasRegistry::get() {
+        return getRegistryHub().getTagAliasRegistry();
+    }
+
+} // end namespace Catch
+// end catch_tag_alias_registry.cpp
+// start catch_test_case_info.cpp
+
+#include <cctype>
+#include <exception>
+#include <algorithm>
+#include <sstream>
+
+namespace Catch {
+
+    namespace {
+        TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
+            if( startsWith( tag, '.' ) ||
+                tag == "!hide" )
+                return TestCaseInfo::IsHidden;
+            else if( tag == "!throws" )
+                return TestCaseInfo::Throws;
+            else if( tag == "!shouldfail" )
+                return TestCaseInfo::ShouldFail;
+            else if( tag == "!mayfail" )
+                return TestCaseInfo::MayFail;
+            else if( tag == "!nonportable" )
+                return TestCaseInfo::NonPortable;
+            else if( tag == "!benchmark" )
+                return static_cast<TestCaseInfo::SpecialProperties>( TestCaseInfo::Benchmark | TestCaseInfo::IsHidden );
+            else
+                return TestCaseInfo::None;
+        }
+        bool isReservedTag( std::string const& tag ) {
+            return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( static_cast<unsigned char>(tag[0]) );
+        }
+        void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
+            CATCH_ENFORCE( !isReservedTag(tag),
+                          "Tag name: [" << tag << "] is not allowed.\n"
+                          << "Tag names starting with non alphanumeric characters are reserved\n"
+                          << _lineInfo );
+        }
+    }
+
+    TestCase makeTestCase(  ITestInvoker* _testCase,
+                            std::string const& _className,
+                            NameAndTags const& nameAndTags,
+                            SourceLineInfo const& _lineInfo )
+    {
+        bool isHidden = false;
+
+        // Parse out tags
+        std::vector<std::string> tags;
+        std::string desc, tag;
+        bool inTag = false;
+        for (char c : nameAndTags.tags) {
+            if( !inTag ) {
+                if( c == '[' )
+                    inTag = true;
+                else
+                    desc += c;
+            }
+            else {
+                if( c == ']' ) {
+                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
+                    if( ( prop & TestCaseInfo::IsHidden ) != 0 )
+                        isHidden = true;
+                    else if( prop == TestCaseInfo::None )
+                        enforceNotReservedTag( tag, _lineInfo );
+
+                    // Merged hide tags like `[.approvals]` should be added as
+                    // `[.][approvals]`. The `[.]` is added at later point, so
+                    // we only strip the prefix
+                    if (startsWith(tag, '.') && tag.size() > 1) {
+                        tag.erase(0, 1);
+                    }
+                    tags.push_back( tag );
+                    tag.clear();
+                    inTag = false;
+                }
+                else
+                    tag += c;
+            }
+        }
+        if( isHidden ) {
+            // Add all "hidden" tags to make them behave identically
+            tags.insert( tags.end(), { ".", "!hide" } );
+        }
+
+        TestCaseInfo info( static_cast<std::string>(nameAndTags.name), _className, desc, tags, _lineInfo );
+        return TestCase( _testCase, std::move(info) );
+    }
+
+    void setTags( TestCaseInfo& testCaseInfo, std::vector<std::string> tags ) {
+        std::sort(begin(tags), end(tags));
+        tags.erase(std::unique(begin(tags), end(tags)), end(tags));
+        testCaseInfo.lcaseTags.clear();
+
+        for( auto const& tag : tags ) {
+            std::string lcaseTag = toLower( tag );
+            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
+            testCaseInfo.lcaseTags.push_back( lcaseTag );
+        }
+        testCaseInfo.tags = std::move(tags);
+    }
+
+    TestCaseInfo::TestCaseInfo( std::string const& _name,
+                                std::string const& _className,
+                                std::string const& _description,
+                                std::vector<std::string> const& _tags,
+                                SourceLineInfo const& _lineInfo )
+    :   name( _name ),
+        className( _className ),
+        description( _description ),
+        lineInfo( _lineInfo ),
+        properties( None )
+    {
+        setTags( *this, _tags );
+    }
+
+    bool TestCaseInfo::isHidden() const {
+        return ( properties & IsHidden ) != 0;
+    }
+    bool TestCaseInfo::throws() const {
+        return ( properties & Throws ) != 0;
+    }
+    bool TestCaseInfo::okToFail() const {
+        return ( properties & (ShouldFail | MayFail ) ) != 0;
+    }
+    bool TestCaseInfo::expectedToFail() const {
+        return ( properties & (ShouldFail ) ) != 0;
+    }
+
+    std::string TestCaseInfo::tagsAsString() const {
+        std::string ret;
+        // '[' and ']' per tag
+        std::size_t full_size = 2 * tags.size();
+        for (const auto& tag : tags) {
+            full_size += tag.size();
+        }
+        ret.reserve(full_size);
+        for (const auto& tag : tags) {
+            ret.push_back('[');
+            ret.append(tag);
+            ret.push_back(']');
+        }
+
+        return ret;
+    }
+
+    TestCase::TestCase( ITestInvoker* testCase, TestCaseInfo&& info ) : TestCaseInfo( std::move(info) ), test( testCase ) {}
+
+    TestCase TestCase::withName( std::string const& _newName ) const {
+        TestCase other( *this );
+        other.name = _newName;
+        return other;
+    }
+
+    void TestCase::invoke() const {
+        test->invoke();
+    }
+
+    bool TestCase::operator == ( TestCase const& other ) const {
+        return  test.get() == other.test.get() &&
+                name == other.name &&
+                className == other.className;
+    }
+
+    bool TestCase::operator < ( TestCase const& other ) const {
+        return name < other.name;
+    }
+
+    TestCaseInfo const& TestCase::getTestCaseInfo() const
+    {
+        return *this;
+    }
+
+} // end namespace Catch
+// end catch_test_case_info.cpp
+// start catch_test_case_registry_impl.cpp
+
+#include <algorithm>
+#include <sstream>
+
+namespace Catch {
+
+    namespace {
+        struct TestHasher {
+            explicit TestHasher(Catch::SimplePcg32& rng) {
+                basis = rng();
+                basis <<= 32;
+                basis |= rng();
+            }
+
+            uint64_t basis;
+
+            uint64_t operator()(TestCase const& t) const {
+                // Modified FNV-1a hash
+                static constexpr uint64_t prime = 1099511628211;
+                uint64_t hash = basis;
+                for (const char c : t.name) {
+                    hash ^= c;
+                    hash *= prime;
+                }
+                return hash;
+            }
+        };
+    } // end unnamed namespace
+
+    std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
+        switch( config.runOrder() ) {
+            case RunTests::InDeclarationOrder:
+                // already in declaration order
+                break;
+
+            case RunTests::InLexicographicalOrder: {
+                std::vector<TestCase> sorted = unsortedTestCases;
+                std::sort( sorted.begin(), sorted.end() );
+                return sorted;
+            }
+
+            case RunTests::InRandomOrder: {
+                seedRng( config );
+                TestHasher h( rng() );
+
+                using hashedTest = std::pair<uint64_t, TestCase const*>;
+                std::vector<hashedTest> indexed_tests;
+                indexed_tests.reserve( unsortedTestCases.size() );
+
+                for (auto const& testCase : unsortedTestCases) {
+                    indexed_tests.emplace_back(h(testCase), &testCase);
+                }
+
+                std::sort(indexed_tests.begin(), indexed_tests.end(),
+                          [](hashedTest const& lhs, hashedTest const& rhs) {
+                          if (lhs.first == rhs.first) {
+                              return lhs.second->name < rhs.second->name;
+                          }
+                          return lhs.first < rhs.first;
+                });
+
+                std::vector<TestCase> sorted;
+                sorted.reserve( indexed_tests.size() );
+
+                for (auto const& hashed : indexed_tests) {
+                    sorted.emplace_back(*hashed.second);
+                }
+
+                return sorted;
+            }
+        }
+        return unsortedTestCases;
+    }
+
+    bool isThrowSafe( TestCase const& testCase, IConfig const& config ) {
+        return !testCase.throws() || config.allowThrows();
+    }
+
+    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
+        return testSpec.matches( testCase ) && isThrowSafe( testCase, config );
+    }
+
+    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
+        std::set<TestCase> seenFunctions;
+        for( auto const& function : functions ) {
+            auto prev = seenFunctions.insert( function );
+            CATCH_ENFORCE( prev.second,
+                    "error: TEST_CASE( \"" << function.name << "\" ) already defined.\n"
+                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << "\n"
+                    << "\tRedefined at " << function.getTestCaseInfo().lineInfo );
+        }
+    }
+
+    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
+        std::vector<TestCase> filtered;
+        filtered.reserve( testCases.size() );
+        for (auto const& testCase : testCases) {
+            if ((!testSpec.hasFilters() && !testCase.isHidden()) ||
+                (testSpec.hasFilters() && matchTest(testCase, testSpec, config))) {
+                filtered.push_back(testCase);
+            }
+        }
+        return filtered;
+    }
+    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
+        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
+    }
+
+    void TestRegistry::registerTest( TestCase const& testCase ) {
+        std::string name = testCase.getTestCaseInfo().name;
+        if( name.empty() ) {
+            ReusableStringStream rss;
+            rss << "Anonymous test case " << ++m_unnamedCount;
+            return registerTest( testCase.withName( rss.str() ) );
+        }
+        m_functions.push_back( testCase );
+    }
+
+    std::vector<TestCase> const& TestRegistry::getAllTests() const {
+        return m_functions;
+    }
+    std::vector<TestCase> const& TestRegistry::getAllTestsSorted( IConfig const& config ) const {
+        if( m_sortedFunctions.empty() )
+            enforceNoDuplicateTestCases( m_functions );
+
+        if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
+            m_sortedFunctions = sortTests( config, m_functions );
+            m_currentSortOrder = config.runOrder();
+        }
+        return m_sortedFunctions;
+    }
+
+    ///////////////////////////////////////////////////////////////////////////
+    TestInvokerAsFunction::TestInvokerAsFunction( void(*testAsFunction)() ) noexcept : m_testAsFunction( testAsFunction ) {}
+
+    void TestInvokerAsFunction::invoke() const {
+        m_testAsFunction();
+    }
+
+    std::string extractClassName( StringRef const& classOrQualifiedMethodName ) {
+        std::string className(classOrQualifiedMethodName);
+        if( startsWith( className, '&' ) )
+        {
+            std::size_t lastColons = className.rfind( "::" );
+            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
+            if( penultimateColons == std::string::npos )
+                penultimateColons = 1;
+            className = className.substr( penultimateColons, lastColons-penultimateColons );
+        }
+        return className;
+    }
+
+} // end namespace Catch
+// end catch_test_case_registry_impl.cpp
+// start catch_test_case_tracker.cpp
+
+#include <algorithm>
+#include <cassert>
+#include <stdexcept>
+#include <memory>
+#include <sstream>
+
+#if defined(__clang__)
+#    pragma clang diagnostic push
+#    pragma clang diagnostic ignored "-Wexit-time-destructors"
+#endif
+
+namespace Catch {
+namespace TestCaseTracking {
+
+    NameAndLocation::NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
+    :   name( _name ),
+        location( _location )
+    {}
+
+    ITracker::~ITracker() = default;
+
+    ITracker& TrackerContext::startRun() {
+        m_rootTracker = std::make_shared<SectionTracker>( NameAndLocation( "{root}", CATCH_INTERNAL_LINEINFO ), *this, nullptr );
+        m_currentTracker = nullptr;
+        m_runState = Executing;
+        return *m_rootTracker;
+    }
+
+    void TrackerContext::endRun() {
+        m_rootTracker.reset();
+        m_currentTracker = nullptr;
+        m_runState = NotStarted;
+    }
+
+    void TrackerContext::startCycle() {
+        m_currentTracker = m_rootTracker.get();
+        m_runState = Executing;
+    }
+    void TrackerContext::completeCycle() {
+        m_runState = CompletedCycle;
+    }
+
+    bool TrackerContext::completedCycle() const {
+        return m_runState == CompletedCycle;
+    }
+    ITracker& TrackerContext::currentTracker() {
+        return *m_currentTracker;
+    }
+    void TrackerContext::setCurrentTracker( ITracker* tracker ) {
+        m_currentTracker = tracker;
+    }
+
+    TrackerBase::TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
+    :   m_nameAndLocation( nameAndLocation ),
+        m_ctx( ctx ),
+        m_parent( parent )
+    {}
+
+    NameAndLocation const& TrackerBase::nameAndLocation() const {
+        return m_nameAndLocation;
+    }
+    bool TrackerBase::isComplete() const {
+        return m_runState == CompletedSuccessfully || m_runState == Failed;
+    }
+    bool TrackerBase::isSuccessfullyCompleted() const {
+        return m_runState == CompletedSuccessfully;
+    }
+    bool TrackerBase::isOpen() const {
+        return m_runState != NotStarted && !isComplete();
+    }
+    bool TrackerBase::hasChildren() const {
+        return !m_children.empty();
+    }
+
+    void TrackerBase::addChild( ITrackerPtr const& child ) {
+        m_children.push_back( child );
+    }
+
+    ITrackerPtr TrackerBase::findChild( NameAndLocation const& nameAndLocation ) {
+        auto it = std::find_if( m_children.begin(), m_children.end(),
+            [&nameAndLocation]( ITrackerPtr const& tracker ){
+                return
+                    tracker->nameAndLocation().location == nameAndLocation.location &&
+                    tracker->nameAndLocation().name == nameAndLocation.name;
+            } );
+        return( it != m_children.end() )
+            ? *it
+            : nullptr;
+    }
+    ITracker& TrackerBase::parent() {
+        assert( m_parent ); // Should always be non-null except for root
+        return *m_parent;
+    }
+
+    void TrackerBase::openChild() {
+        if( m_runState != ExecutingChildren ) {
+            m_runState = ExecutingChildren;
+            if( m_parent )
+                m_parent->openChild();
+        }
+    }
+
+    bool TrackerBase::isSectionTracker() const { return false; }
+    bool TrackerBase::isGeneratorTracker() const { return false; }
+
+    void TrackerBase::open() {
+        m_runState = Executing;
+        moveToThis();
+        if( m_parent )
+            m_parent->openChild();
+    }
+
+    void TrackerBase::close() {
+
+        // Close any still open children (e.g. generators)
+        while( &m_ctx.currentTracker() != this )
+            m_ctx.currentTracker().close();
+
+        switch( m_runState ) {
+            case NeedsAnotherRun:
+                break;
+
+            case Executing:
+                m_runState = CompletedSuccessfully;
+                break;
+            case ExecutingChildren:
+                if( std::all_of(m_children.begin(), m_children.end(), [](ITrackerPtr const& t){ return t->isComplete(); }) )
+                    m_runState = CompletedSuccessfully;
+                break;
+
+            case NotStarted:
+            case CompletedSuccessfully:
+            case Failed:
+                CATCH_INTERNAL_ERROR( "Illogical state: " << m_runState );
+
+            default:
+                CATCH_INTERNAL_ERROR( "Unknown state: " << m_runState );
+        }
+        moveToParent();
+        m_ctx.completeCycle();
+    }
+    void TrackerBase::fail() {
+        m_runState = Failed;
+        if( m_parent )
+            m_parent->markAsNeedingAnotherRun();
+        moveToParent();
+        m_ctx.completeCycle();
+    }
+    void TrackerBase::markAsNeedingAnotherRun() {
+        m_runState = NeedsAnotherRun;
+    }
+
+    void TrackerBase::moveToParent() {
+        assert( m_parent );
+        m_ctx.setCurrentTracker( m_parent );
+    }
+    void TrackerBase::moveToThis() {
+        m_ctx.setCurrentTracker( this );
+    }
+
+    SectionTracker::SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
+    :   TrackerBase( nameAndLocation, ctx, parent ),
+        m_trimmed_name(trim(nameAndLocation.name))
+    {
+        if( parent ) {
+            while( !parent->isSectionTracker() )
+                parent = &parent->parent();
+
+            SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
+            addNextFilters( parentSection.m_filters );
+        }
+    }
+
+    bool SectionTracker::isComplete() const {
+        bool complete = true;
+
+        if ((m_filters.empty() || m_filters[0] == "")
+            || std::find(m_filters.begin(), m_filters.end(), m_trimmed_name) != m_filters.end()) {
+            complete = TrackerBase::isComplete();
+        }
+        return complete;
+    }
+
+    bool SectionTracker::isSectionTracker() const { return true; }
+
+    SectionTracker& SectionTracker::acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
+        std::shared_ptr<SectionTracker> section;
+
+        ITracker& currentTracker = ctx.currentTracker();
+        if( ITrackerPtr childTracker = currentTracker.findChild( nameAndLocation ) ) {
+            assert( childTracker );
+            assert( childTracker->isSectionTracker() );
+            section = std::static_pointer_cast<SectionTracker>( childTracker );
+        }
+        else {
+            section = std::make_shared<SectionTracker>( nameAndLocation, ctx, &currentTracker );
+            currentTracker.addChild( section );
+        }
+        if( !ctx.completedCycle() )
+            section->tryOpen();
+        return *section;
+    }
+
+    void SectionTracker::tryOpen() {
+        if( !isComplete() )
+            open();
+    }
+
+    void SectionTracker::addInitialFilters( std::vector<std::string> const& filters ) {
+        if( !filters.empty() ) {
+            m_filters.reserve( m_filters.size() + filters.size() + 2 );
+            m_filters.emplace_back(""); // Root - should never be consulted
+            m_filters.emplace_back(""); // Test Case - not a section filter
+            m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
+        }
+    }
+    void SectionTracker::addNextFilters( std::vector<std::string> const& filters ) {
+        if( filters.size() > 1 )
+            m_filters.insert( m_filters.end(), filters.begin()+1, filters.end() );
+    }
+
+} // namespace TestCaseTracking
+
+using TestCaseTracking::ITracker;
+using TestCaseTracking::TrackerContext;
+using TestCaseTracking::SectionTracker;
+
+} // namespace Catch
+
+#if defined(__clang__)
+#    pragma clang diagnostic pop
+#endif
+// end catch_test_case_tracker.cpp
+// start catch_test_registry.cpp
+
+namespace Catch {
+
+    auto makeTestInvoker( void(*testAsFunction)() ) noexcept -> ITestInvoker* {
+        return new(std::nothrow) TestInvokerAsFunction( testAsFunction );
+    }
+
+    NameAndTags::NameAndTags( StringRef const& name_ , StringRef const& tags_ ) noexcept : name( name_ ), tags( tags_ ) {}
+
+    AutoReg::AutoReg( ITestInvoker* invoker, SourceLineInfo const& lineInfo, StringRef const& classOrMethod, NameAndTags const& nameAndTags ) noexcept {
+        CATCH_TRY {
+            getMutableRegistryHub()
+                    .registerTest(
+                        makeTestCase(
+                            invoker,
+                            extractClassName( classOrMethod ),
+                            nameAndTags,
+                            lineInfo));
+        } CATCH_CATCH_ALL {
+            // Do not throw when constructing global objects, instead register the exception to be processed later
+            getMutableRegistryHub().registerStartupException();
+        }
+    }
+
+    AutoReg::~AutoReg() = default;
+}
+// end catch_test_registry.cpp
+// start catch_test_spec.cpp
+
+#include <algorithm>
+#include <string>
+#include <vector>
+#include <memory>
+
+namespace Catch {
+
+    TestSpec::Pattern::Pattern( std::string const& name )
+    : m_name( name )
+    {}
+
+    TestSpec::Pattern::~Pattern() = default;
+
+    std::string const& TestSpec::Pattern::name() const {
+        return m_name;
+    }
+
+    TestSpec::NamePattern::NamePattern( std::string const& name, std::string const& filterString )
+    : Pattern( filterString )
+    , m_wildcardPattern( toLower( name ), CaseSensitive::No )
+    {}
+
+    bool TestSpec::NamePattern::matches( TestCaseInfo const& testCase ) const {
+        return m_wildcardPattern.matches( testCase.name );
+    }
+
+    TestSpec::TagPattern::TagPattern( std::string const& tag, std::string const& filterString )
+    : Pattern( filterString )
+    , m_tag( toLower( tag ) )
+    {}
+
+    bool TestSpec::TagPattern::matches( TestCaseInfo const& testCase ) const {
+        return std::find(begin(testCase.lcaseTags),
+                         end(testCase.lcaseTags),
+                         m_tag) != end(testCase.lcaseTags);
+    }
+
+    TestSpec::ExcludedPattern::ExcludedPattern( PatternPtr const& underlyingPattern )
+    : Pattern( underlyingPattern->name() )
+    , m_underlyingPattern( underlyingPattern )
+    {}
+
+    bool TestSpec::ExcludedPattern::matches( TestCaseInfo const& testCase ) const {
+        return !m_underlyingPattern->matches( testCase );
+    }
+
+    bool TestSpec::Filter::matches( TestCaseInfo const& testCase ) const {
+        return std::all_of( m_patterns.begin(), m_patterns.end(), [&]( PatternPtr const& p ){ return p->matches( testCase ); } );
+    }
+
+    std::string TestSpec::Filter::name() const {
+        std::string name;
+        for( auto const& p : m_patterns )
+            name += p->name();
+        return name;
+    }
+
+    bool TestSpec::hasFilters() const {
+        return !m_filters.empty();
+    }
+
+    bool TestSpec::matches( TestCaseInfo const& testCase ) const {
+        return std::any_of( m_filters.begin(), m_filters.end(), [&]( Filter const& f ){ return f.matches( testCase ); } );
+    }
+
+    TestSpec::Matches TestSpec::matchesByFilter( std::vector<TestCase> const& testCases, IConfig const& config ) const
+    {
+        Matches matches( m_filters.size() );
+        std::transform( m_filters.begin(), m_filters.end(), matches.begin(), [&]( Filter const& filter ){
+            std::vector<TestCase const*> currentMatches;
+            for( auto const& test : testCases )
+                if( isThrowSafe( test, config ) && filter.matches( test ) )
+                    currentMatches.emplace_back( &test );
+            return FilterMatch{ filter.name(), currentMatches };
+        } );
+        return matches;
+    }
+
+    const TestSpec::vectorStrings& TestSpec::getInvalidArgs() const{
+        return  (m_invalidArgs);
+    }
+
+}
+// end catch_test_spec.cpp
+// start catch_test_spec_parser.cpp
+
+namespace Catch {
+
+    TestSpecParser::TestSpecParser( ITagAliasRegistry const& tagAliases ) : m_tagAliases( &tagAliases ) {}
+
+    TestSpecParser& TestSpecParser::parse( std::string const& arg ) {
+        m_mode = None;
+        m_exclusion = false;
+        m_arg = m_tagAliases->expandAliases( arg );
+        m_escapeChars.clear();
+        m_substring.reserve(m_arg.size());
+        m_patternName.reserve(m_arg.size());
+        m_realPatternPos = 0;
+
+        for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
+          //if visitChar fails
+           if( !visitChar( m_arg[m_pos] ) ){
+               m_testSpec.m_invalidArgs.push_back(arg);
+               break;
+           }
+        endMode();
+        return *this;
+    }
+    TestSpec TestSpecParser::testSpec() {
+        addFilter();
+        return m_testSpec;
+    }
+    bool TestSpecParser::visitChar( char c ) {
+        if( (m_mode != EscapedName) && (c == '\\') ) {
+            escape();
+            addCharToPattern(c);
+            return true;
+        }else if((m_mode != EscapedName) && (c == ',') )  {
+            return separate();
+        }
+
+        switch( m_mode ) {
+        case None:
+            if( processNoneChar( c ) )
+                return true;
+            break;
+        case Name:
+            processNameChar( c );
+            break;
+        case EscapedName:
+            endMode();
+            addCharToPattern(c);
+            return true;
+        default:
+        case Tag:
+        case QuotedName:
+            if( processOtherChar( c ) )
+                return true;
+            break;
+        }
+
+        m_substring += c;
+        if( !isControlChar( c ) ) {
+            m_patternName += c;
+            m_realPatternPos++;
+        }
+        return true;
+    }
+    // Two of the processing methods return true to signal the caller to return
+    // without adding the given character to the current pattern strings
+    bool TestSpecParser::processNoneChar( char c ) {
+        switch( c ) {
+        case ' ':
+            return true;
+        case '~':
+            m_exclusion = true;
+            return false;
+        case '[':
+            startNewMode( Tag );
+            return false;
+        case '"':
+            startNewMode( QuotedName );
+            return false;
+        default:
+            startNewMode( Name );
+            return false;
+        }
+    }
+    void TestSpecParser::processNameChar( char c ) {
+        if( c == '[' ) {
+            if( m_substring == "exclude:" )
+                m_exclusion = true;
+            else
+                endMode();
+            startNewMode( Tag );
+        }
+    }
+    bool TestSpecParser::processOtherChar( char c ) {
+        if( !isControlChar( c ) )
+            return false;
+        m_substring += c;
+        endMode();
+        return true;
+    }
+    void TestSpecParser::startNewMode( Mode mode ) {
+        m_mode = mode;
+    }
+    void TestSpecParser::endMode() {
+        switch( m_mode ) {
+        case Name:
+        case QuotedName:
+            return addNamePattern();
+        case Tag:
+            return addTagPattern();
+        case EscapedName:
+            revertBackToLastMode();
+            return;
+        case None:
+        default:
+            return startNewMode( None );
+        }
+    }
+    void TestSpecParser::escape() {
+        saveLastMode();
+        m_mode = EscapedName;
+        m_escapeChars.push_back(m_realPatternPos);
+    }
+    bool TestSpecParser::isControlChar( char c ) const {
+        switch( m_mode ) {
+            default:
+                return false;
+            case None:
+                return c == '~';
+            case Name:
+                return c == '[';
+            case EscapedName:
+                return true;
+            case QuotedName:
+                return c == '"';
+            case Tag:
+                return c == '[' || c == ']';
+        }
+    }
+
+    void TestSpecParser::addFilter() {
+        if( !m_currentFilter.m_patterns.empty() ) {
+            m_testSpec.m_filters.push_back( m_currentFilter );
+            m_currentFilter = TestSpec::Filter();
+        }
+    }
+
+    void TestSpecParser::saveLastMode() {
+      lastMode = m_mode;
+    }
+
+    void TestSpecParser::revertBackToLastMode() {
+      m_mode = lastMode;
+    }
+
+    bool TestSpecParser::separate() {
+      if( (m_mode==QuotedName) || (m_mode==Tag) ){
+         //invalid argument, signal failure to previous scope.
+         m_mode = None;
+         m_pos = m_arg.size();
+         m_substring.clear();
+         m_patternName.clear();
+         m_realPatternPos = 0;
+         return false;
+      }
+      endMode();
+      addFilter();
+      return true; //success
+    }
+
+    std::string TestSpecParser::preprocessPattern() {
+        std::string token = m_patternName;
+        for (std::size_t i = 0; i < m_escapeChars.size(); ++i)
+            token = token.substr(0, m_escapeChars[i] - i) + token.substr(m_escapeChars[i] - i + 1);
+        m_escapeChars.clear();
+        if (startsWith(token, "exclude:")) {
+            m_exclusion = true;
+            token = token.substr(8);
+        }
+
+        m_patternName.clear();
+        m_realPatternPos = 0;
+
+        return token;
+    }
+
+    void TestSpecParser::addNamePattern() {
+        auto token = preprocessPattern();
+
+        if (!token.empty()) {
+            TestSpec::PatternPtr pattern = std::make_shared<TestSpec::NamePattern>(token, m_substring);
+            if (m_exclusion)
+                pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
+            m_currentFilter.m_patterns.push_back(pattern);
+        }
+        m_substring.clear();
+        m_exclusion = false;
+        m_mode = None;
+    }
+
+    void TestSpecParser::addTagPattern() {
+        auto token = preprocessPattern();
+
+        if (!token.empty()) {
+            // If the tag pattern is the "hide and tag" shorthand (e.g. [.foo])
+            // we have to create a separate hide tag and shorten the real one
+            if (token.size() > 1 && token[0] == '.') {
+                token.erase(token.begin());
+                TestSpec::PatternPtr pattern = std::make_shared<TestSpec::TagPattern>(".", m_substring);
+                if (m_exclusion) {
+                    pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
+                }
+                m_currentFilter.m_patterns.push_back(pattern);
+            }
+
+            TestSpec::PatternPtr pattern = std::make_shared<TestSpec::TagPattern>(token, m_substring);
+
+            if (m_exclusion) {
+                pattern = std::make_shared<TestSpec::ExcludedPattern>(pattern);
+            }
+            m_currentFilter.m_patterns.push_back(pattern);
+        }
+        m_substring.clear();
+        m_exclusion = false;
+        m_mode = None;
+    }
+
+    TestSpec parseTestSpec( std::string const& arg ) {
+        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
+    }
+
+} // namespace Catch
+// end catch_test_spec_parser.cpp
+// start catch_timer.cpp
+
+#include <chrono>
+
+static const uint64_t nanosecondsInSecond = 1000000000;
+
+namespace Catch {
+
+    auto getCurrentNanosecondsSinceEpoch() -> uint64_t {
+        return std::chrono::duration_cast<std::chrono::nanoseconds>( std::chrono::high_resolution_clock::now().time_since_epoch() ).count();
+    }
+
+    namespace {
+        auto estimateClockResolution() -> uint64_t {
+            uint64_t sum = 0;
+            static const uint64_t iterations = 1000000;
+
+            auto startTime = getCurrentNanosecondsSinceEpoch();
+
+            for( std::size_t i = 0; i < iterations; ++i ) {
+
+                uint64_t ticks;
+                uint64_t baseTicks = getCurrentNanosecondsSinceEpoch();
+                do {
+                    ticks = getCurrentNanosecondsSinceEpoch();
+                } while( ticks == baseTicks );
+
+                auto delta = ticks - baseTicks;
+                sum += delta;
+
+                // If we have been calibrating for over 3 seconds -- the clock
+                // is terrible and we should move on.
+                // TBD: How to signal that the measured resolution is probably wrong?
+                if (ticks > startTime + 3 * nanosecondsInSecond) {
+                    return sum / ( i + 1u );
+                }
+            }
+
+            // We're just taking the mean, here. To do better we could take the std. dev and exclude outliers
+            // - and potentially do more iterations if there's a high variance.
+            return sum/iterations;
+        }
+    }
+    auto getEstimatedClockResolution() -> uint64_t {
+        static auto s_resolution = estimateClockResolution();
+        return s_resolution;
+    }
+
+    void Timer::start() {
+       m_nanoseconds = getCurrentNanosecondsSinceEpoch();
+    }
+    auto Timer::getElapsedNanoseconds() const -> uint64_t {
+        return getCurrentNanosecondsSinceEpoch() - m_nanoseconds;
+    }
+    auto Timer::getElapsedMicroseconds() const -> uint64_t {
+        return getElapsedNanoseconds()/1000;
+    }
+    auto Timer::getElapsedMilliseconds() const -> unsigned int {
+        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
+    }
+    auto Timer::getElapsedSeconds() const -> double {
+        return getElapsedMicroseconds()/1000000.0;
+    }
+
+} // namespace Catch
+// end catch_timer.cpp
+// start catch_tostring.cpp
+
+#if defined(__clang__)
+#    pragma clang diagnostic push
+#    pragma clang diagnostic ignored "-Wexit-time-destructors"
+#    pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
+// Enable specific decls locally
+#if !defined(CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER)
+#define CATCH_CONFIG_ENABLE_CHRONO_STRINGMAKER
+#endif
+
+#include <cmath>
+#include <iomanip>
+
+namespace Catch {
+
+namespace Detail {
+
+    const std::string unprintableString = "{?}";
+
+    namespace {
+        const int hexThreshold = 255;
+
+        struct Endianness {
+            enum Arch { Big, Little };
+
+            static Arch which() {
+                int one = 1;
+                // If the lowest byte we read is non-zero, we can assume
+                // that little endian format is used.
+                auto value = *reinterpret_cast<char*>(&one);
+                return value ? Little : Big;
+            }
+        };
+    }
+
+    std::string rawMemoryToString( const void *object, std::size_t size ) {
+        // Reverse order for little endian architectures
+        int i = 0, end = static_cast<int>( size ), inc = 1;
+        if( Endianness::which() == Endianness::Little ) {
+            i = end-1;
+            end = inc = -1;
+        }
+
+        unsigned char const *bytes = static_cast<unsigned char const *>(object);
+        ReusableStringStream rss;
+        rss << "0x" << std::setfill('0') << std::hex;
+        for( ; i != end; i += inc )
+             rss << std::setw(2) << static_cast<unsigned>(bytes[i]);
+       return rss.str();
+    }
+}
+
+template<typename T>
+std::string fpToString( T value, int precision ) {
+    if (Catch::isnan(value)) {
+        return "nan";
+    }
+
+    ReusableStringStream rss;
+    rss << std::setprecision( precision )
+        << std::fixed
+        << value;
+    std::string d = rss.str();
+    std::size_t i = d.find_last_not_of( '0' );
+    if( i != std::string::npos && i != d.size()-1 ) {
+        if( d[i] == '.' )
+            i++;
+        d = d.substr( 0, i+1 );
+    }
+    return d;
+}
+
+//// ======================================================= ////
+//
+//   Out-of-line defs for full specialization of StringMaker
+//
+//// ======================================================= ////
+
+std::string StringMaker<std::string>::convert(const std::string& str) {
+    if (!getCurrentContext().getConfig()->showInvisibles()) {
+        return '"' + str + '"';
+    }
+
+    std::string s("\"");
+    for (char c : str) {
+        switch (c) {
+        case '\n':
+            s.append("\\n");
+            break;
+        case '\t':
+            s.append("\\t");
+            break;
+        default:
+            s.push_back(c);
+            break;
+        }
+    }
+    s.append("\"");
+    return s;
+}
+
+#ifdef CATCH_CONFIG_CPP17_STRING_VIEW
+std::string StringMaker<std::string_view>::convert(std::string_view str) {
+    return ::Catch::Detail::stringify(std::string{ str });
+}
+#endif
+
+std::string StringMaker<char const*>::convert(char const* str) {
+    if (str) {
+        return ::Catch::Detail::stringify(std::string{ str });
+    } else {
+        return{ "{null string}" };
+    }
+}
+std::string StringMaker<char*>::convert(char* str) {
+    if (str) {
+        return ::Catch::Detail::stringify(std::string{ str });
+    } else {
+        return{ "{null string}" };
+    }
+}
+
+#ifdef CATCH_CONFIG_WCHAR
+std::string StringMaker<std::wstring>::convert(const std::wstring& wstr) {
+    std::string s;
+    s.reserve(wstr.size());
+    for (auto c : wstr) {
+        s += (c <= 0xff) ? static_cast<char>(c) : '?';
+    }
+    return ::Catch::Detail::stringify(s);
+}
+
+# ifdef CATCH_CONFIG_CPP17_STRING_VIEW
+std::string StringMaker<std::wstring_view>::convert(std::wstring_view str) {
+    return StringMaker<std::wstring>::convert(std::wstring(str));
+}
+# endif
+
+std::string StringMaker<wchar_t const*>::convert(wchar_t const * str) {
+    if (str) {
+        return ::Catch::Detail::stringify(std::wstring{ str });
+    } else {
+        return{ "{null string}" };
+    }
+}
+std::string StringMaker<wchar_t *>::convert(wchar_t * str) {
+    if (str) {
+        return ::Catch::Detail::stringify(std::wstring{ str });
+    } else {
+        return{ "{null string}" };
+    }
+}
+#endif
+
+#if defined(CATCH_CONFIG_CPP17_BYTE)
+#include <cstddef>
+std::string StringMaker<std::byte>::convert(std::byte value) {
+    return ::Catch::Detail::stringify(std::to_integer<unsigned long long>(value));
+}
+#endif // defined(CATCH_CONFIG_CPP17_BYTE)
+
+std::string StringMaker<int>::convert(int value) {
+    return ::Catch::Detail::stringify(static_cast<long long>(value));
+}
+std::string StringMaker<long>::convert(long value) {
+    return ::Catch::Detail::stringify(static_cast<long long>(value));
+}
+std::string StringMaker<long long>::convert(long long value) {
+    ReusableStringStream rss;
+    rss << value;
+    if (value > Detail::hexThreshold) {
+        rss << " (0x" << std::hex << value << ')';
+    }
+    return rss.str();
+}
+
+std::string StringMaker<unsigned int>::convert(unsigned int value) {
+    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
+}
+std::string StringMaker<unsigned long>::convert(unsigned long value) {
+    return ::Catch::Detail::stringify(static_cast<unsigned long long>(value));
+}
+std::string StringMaker<unsigned long long>::convert(unsigned long long value) {
+    ReusableStringStream rss;
+    rss << value;
+    if (value > Detail::hexThreshold) {
+        rss << " (0x" << std::hex << value << ')';
+    }
+    return rss.str();
+}
+
+std::string StringMaker<bool>::convert(bool b) {
+    return b ? "true" : "false";
+}
+
+std::string StringMaker<signed char>::convert(signed char value) {
+    if (value == '\r') {
+        return "'\\r'";
+    } else if (value == '\f') {
+        return "'\\f'";
+    } else if (value == '\n') {
+        return "'\\n'";
+    } else if (value == '\t') {
+        return "'\\t'";
+    } else if ('\0' <= value && value < ' ') {
+        return ::Catch::Detail::stringify(static_cast<unsigned int>(value));
+    } else {
+        char chstr[] = "' '";
+        chstr[1] = value;
+        return chstr;
+    }
+}
+std::string StringMaker<char>::convert(char c) {
+    return ::Catch::Detail::stringify(static_cast<signed char>(c));
+}
+std::string StringMaker<unsigned char>::convert(unsigned char c) {
+    return ::Catch::Detail::stringify(static_cast<char>(c));
+}
+
+std::string StringMaker<std::nullptr_t>::convert(std::nullptr_t) {
+    return "nullptr";
+}
+
+int StringMaker<float>::precision = 5;
+
+std::string StringMaker<float>::convert(float value) {
+    return fpToString(value, precision) + 'f';
+}
+
+int StringMaker<double>::precision = 10;
+
+std::string StringMaker<double>::convert(double value) {
+    return fpToString(value, precision);
+}
+
+std::string ratio_string<std::atto>::symbol() { return "a"; }
+std::string ratio_string<std::femto>::symbol() { return "f"; }
+std::string ratio_string<std::pico>::symbol() { return "p"; }
+std::string ratio_string<std::nano>::symbol() { return "n"; }
+std::string ratio_string<std::micro>::symbol() { return "u"; }
+std::string ratio_string<std::milli>::symbol() { return "m"; }
+
+} // end namespace Catch
+
+#if defined(__clang__)
+#    pragma clang diagnostic pop
+#endif
+
+// end catch_tostring.cpp
+// start catch_totals.cpp
+
+namespace Catch {
+
+    Counts Counts::operator - ( Counts const& other ) const {
+        Counts diff;
+        diff.passed = passed - other.passed;
+        diff.failed = failed - other.failed;
+        diff.failedButOk = failedButOk - other.failedButOk;
+        return diff;
+    }
+
+    Counts& Counts::operator += ( Counts const& other ) {
+        passed += other.passed;
+        failed += other.failed;
+        failedButOk += other.failedButOk;
+        return *this;
+    }
+
+    std::size_t Counts::total() const {
+        return passed + failed + failedButOk;
+    }
+    bool Counts::allPassed() const {
+        return failed == 0 && failedButOk == 0;
+    }
+    bool Counts::allOk() const {
+        return failed == 0;
+    }
+
+    Totals Totals::operator - ( Totals const& other ) const {
+        Totals diff;
+        diff.assertions = assertions - other.assertions;
+        diff.testCases = testCases - other.testCases;
+        return diff;
+    }
+
+    Totals& Totals::operator += ( Totals const& other ) {
+        assertions += other.assertions;
+        testCases += other.testCases;
+        return *this;
+    }
+
+    Totals Totals::delta( Totals const& prevTotals ) const {
+        Totals diff = *this - prevTotals;
+        if( diff.assertions.failed > 0 )
+            ++diff.testCases.failed;
+        else if( diff.assertions.failedButOk > 0 )
+            ++diff.testCases.failedButOk;
+        else
+            ++diff.testCases.passed;
+        return diff;
+    }
+
+}
+// end catch_totals.cpp
+// start catch_uncaught_exceptions.cpp
+
+#include <exception>
+
+namespace Catch {
+    bool uncaught_exceptions() {
+#if defined(CATCH_CONFIG_CPP17_UNCAUGHT_EXCEPTIONS)
+        return std::uncaught_exceptions() > 0;
+#else
+        return std::uncaught_exception();
+#endif
+  }
+} // end namespace Catch
+// end catch_uncaught_exceptions.cpp
+// start catch_version.cpp
+
+#include <ostream>
+
+namespace Catch {
+
+    Version::Version
+        (   unsigned int _majorVersion,
+            unsigned int _minorVersion,
+            unsigned int _patchNumber,
+            char const * const _branchName,
+            unsigned int _buildNumber )
+    :   majorVersion( _majorVersion ),
+        minorVersion( _minorVersion ),
+        patchNumber( _patchNumber ),
+        branchName( _branchName ),
+        buildNumber( _buildNumber )
+    {}
+
+    std::ostream& operator << ( std::ostream& os, Version const& version ) {
+        os  << version.majorVersion << '.'
+            << version.minorVersion << '.'
+            << version.patchNumber;
+        // branchName is never null -> 0th char is \0 if it is empty
+        if (version.branchName[0]) {
+            os << '-' << version.branchName
+               << '.' << version.buildNumber;
+        }
+        return os;
+    }
+
+    Version const& libraryVersion() {
+        static Version version( 2, 12, 1, "", 0 );
+        return version;
+    }
+
+}
+// end catch_version.cpp
+// start catch_wildcard_pattern.cpp
+
+namespace Catch {
+
+    WildcardPattern::WildcardPattern( std::string const& pattern,
+                                      CaseSensitive::Choice caseSensitivity )
+    :   m_caseSensitivity( caseSensitivity ),
+        m_pattern( normaliseString( pattern ) )
+    {
+        if( startsWith( m_pattern, '*' ) ) {
+            m_pattern = m_pattern.substr( 1 );
+            m_wildcard = WildcardAtStart;
+        }
+        if( endsWith( m_pattern, '*' ) ) {
+            m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
+            m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
+        }
+    }
+
+    bool WildcardPattern::matches( std::string const& str ) const {
+        switch( m_wildcard ) {
+            case NoWildcard:
+                return m_pattern == normaliseString( str );
+            case WildcardAtStart:
+                return endsWith( normaliseString( str ), m_pattern );
+            case WildcardAtEnd:
+                return startsWith( normaliseString( str ), m_pattern );
+            case WildcardAtBothEnds:
+                return contains( normaliseString( str ), m_pattern );
+            default:
+                CATCH_INTERNAL_ERROR( "Unknown enum" );
+        }
+    }
+
+    std::string WildcardPattern::normaliseString( std::string const& str ) const {
+        return trim( m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str );
+    }
+}
+// end catch_wildcard_pattern.cpp
+// start catch_xmlwriter.cpp
+
+#include <iomanip>
+#include <type_traits>
+
+namespace Catch {
+
+namespace {
+
+    size_t trailingBytes(unsigned char c) {
+        if ((c & 0xE0) == 0xC0) {
+            return 2;
+        }
+        if ((c & 0xF0) == 0xE0) {
+            return 3;
+        }
+        if ((c & 0xF8) == 0xF0) {
+            return 4;
+        }
+        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
+    }
+
+    uint32_t headerValue(unsigned char c) {
+        if ((c & 0xE0) == 0xC0) {
+            return c & 0x1F;
+        }
+        if ((c & 0xF0) == 0xE0) {
+            return c & 0x0F;
+        }
+        if ((c & 0xF8) == 0xF0) {
+            return c & 0x07;
+        }
+        CATCH_INTERNAL_ERROR("Invalid multibyte utf-8 start byte encountered");
+    }
+
+    void hexEscapeChar(std::ostream& os, unsigned char c) {
+        std::ios_base::fmtflags f(os.flags());
+        os << "\\x"
+            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
+            << static_cast<int>(c);
+        os.flags(f);
+    }
+
+    bool shouldNewline(XmlFormatting fmt) {
+        return !!(static_cast<std::underlying_type<XmlFormatting>::type>(fmt & XmlFormatting::Newline));
+    }
+
+    bool shouldIndent(XmlFormatting fmt) {
+        return !!(static_cast<std::underlying_type<XmlFormatting>::type>(fmt & XmlFormatting::Indent));
+    }
+
+} // anonymous namespace
+
+    XmlFormatting operator | (XmlFormatting lhs, XmlFormatting rhs) {
+        return static_cast<XmlFormatting>(
+            static_cast<std::underlying_type<XmlFormatting>::type>(lhs) |
+            static_cast<std::underlying_type<XmlFormatting>::type>(rhs)
+        );
+    }
+
+    XmlFormatting operator & (XmlFormatting lhs, XmlFormatting rhs) {
+        return static_cast<XmlFormatting>(
+            static_cast<std::underlying_type<XmlFormatting>::type>(lhs) &
+            static_cast<std::underlying_type<XmlFormatting>::type>(rhs)
+        );
+    }
+
+    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )
+    :   m_str( str ),
+        m_forWhat( forWhat )
+    {}
+
+    void XmlEncode::encodeTo( std::ostream& os ) const {
+        // Apostrophe escaping not necessary if we always use " to write attributes
+        // (see: http://www.w3.org/TR/xml/#syntax)
+
+        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {
+            unsigned char c = m_str[idx];
+            switch (c) {
+            case '<':   os << "&lt;"; break;
+            case '&':   os << "&amp;"; break;
+
+            case '>':
+                // See: http://www.w3.org/TR/xml/#syntax
+                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')
+                    os << "&gt;";
+                else
+                    os << c;
+                break;
+
+            case '\"':
+                if (m_forWhat == ForAttributes)
+                    os << "&quot;";
+                else
+                    os << c;
+                break;
+
+            default:
+                // Check for control characters and invalid utf-8
+
+                // Escape control characters in standard ascii
+                // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
+                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {
+                    hexEscapeChar(os, c);
+                    break;
+                }
+
+                // Plain ASCII: Write it to stream
+                if (c < 0x7F) {
+                    os << c;
+                    break;
+                }
+
+                // UTF-8 territory
+                // Check if the encoding is valid and if it is not, hex escape bytes.
+                // Important: We do not check the exact decoded values for validity, only the encoding format
+                // First check that this bytes is a valid lead byte:
+                // This means that it is not encoded as 1111 1XXX
+                // Or as 10XX XXXX
+                if (c <  0xC0 ||
+                    c >= 0xF8) {
+                    hexEscapeChar(os, c);
+                    break;
+                }
+
+                auto encBytes = trailingBytes(c);
+                // Are there enough bytes left to avoid accessing out-of-bounds memory?
+                if (idx + encBytes - 1 >= m_str.size()) {
+                    hexEscapeChar(os, c);
+                    break;
+                }
+                // The header is valid, check data
+                // The next encBytes bytes must together be a valid utf-8
+                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)
+                bool valid = true;
+                uint32_t value = headerValue(c);
+                for (std::size_t n = 1; n < encBytes; ++n) {
+                    unsigned char nc = m_str[idx + n];
+                    valid &= ((nc & 0xC0) == 0x80);
+                    value = (value << 6) | (nc & 0x3F);
+                }
+
+                if (
+                    // Wrong bit pattern of following bytes
+                    (!valid) ||
+                    // Overlong encodings
+                    (value < 0x80) ||
+                    (0x80 <= value && value < 0x800   && encBytes > 2) ||
+                    (0x800 < value && value < 0x10000 && encBytes > 3) ||
+                    // Encoded value out of range
+                    (value >= 0x110000)
+                    ) {
+                    hexEscapeChar(os, c);
+                    break;
+                }
+
+                // If we got here, this is in fact a valid(ish) utf-8 sequence
+                for (std::size_t n = 0; n < encBytes; ++n) {
+                    os << m_str[idx + n];
+                }
+                idx += encBytes - 1;
+                break;
+            }
+        }
+    }
+
+    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
+        xmlEncode.encodeTo( os );
+        return os;
+    }
+
+    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer, XmlFormatting fmt )
+    :   m_writer( writer ),
+        m_fmt(fmt)
+    {}
+
+    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) noexcept
+    :   m_writer( other.m_writer ),
+        m_fmt(other.m_fmt)
+    {
+        other.m_writer = nullptr;
+        other.m_fmt = XmlFormatting::None;
+    }
+    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) noexcept {
+        if ( m_writer ) {
+            m_writer->endElement();
+        }
+        m_writer = other.m_writer;
+        other.m_writer = nullptr;
+        m_fmt = other.m_fmt;
+        other.m_fmt = XmlFormatting::None;
+        return *this;
+    }
+
+    XmlWriter::ScopedElement::~ScopedElement() {
+        if (m_writer) {
+            m_writer->endElement(m_fmt);
+        }
+    }
+
+    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, XmlFormatting fmt ) {
+        m_writer->writeText( text, fmt );
+        return *this;
+    }
+
+    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )
+    {
+        writeDeclaration();
+    }
+
+    XmlWriter::~XmlWriter() {
+        while (!m_tags.empty()) {
+            endElement();
+        }
+        newlineIfNecessary();
+    }
+
+    XmlWriter& XmlWriter::startElement( std::string const& name, XmlFormatting fmt ) {
+        ensureTagClosed();
+        newlineIfNecessary();
+        if (shouldIndent(fmt)) {
+            m_os << m_indent;
+            m_indent += "  ";
+        }
+        m_os << '<' << name;
+        m_tags.push_back( name );
+        m_tagIsOpen = true;
+        applyFormatting(fmt);
+        return *this;
+    }
+
+    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name, XmlFormatting fmt ) {
+        ScopedElement scoped( this, fmt );
+        startElement( name, fmt );
+        return scoped;
+    }
+
+    XmlWriter& XmlWriter::endElement(XmlFormatting fmt) {
+        m_indent = m_indent.substr(0, m_indent.size() - 2);
+
+        if( m_tagIsOpen ) {
+            m_os << "/>";
+            m_tagIsOpen = false;
+        } else {
+            newlineIfNecessary();
+            if (shouldIndent(fmt)) {
+                m_os << m_indent;
+            }
+            m_os << "</" << m_tags.back() << ">";
+        }
+        m_os << std::flush;
+        applyFormatting(fmt);
+        m_tags.pop_back();
+        return *this;
+    }
+
+    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {
+        if( !name.empty() && !attribute.empty() )
+            m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
+        return *this;
+    }
+
+    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {
+        m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
+        return *this;
+    }
+
+    XmlWriter& XmlWriter::writeText( std::string const& text, XmlFormatting fmt) {
+        if( !text.empty() ){
+            bool tagWasOpen = m_tagIsOpen;
+            ensureTagClosed();
+            if (tagWasOpen && shouldIndent(fmt)) {
+                m_os << m_indent;
+            }
+            m_os << XmlEncode( text );
+            applyFormatting(fmt);
+        }
+        return *this;
+    }
+
+    XmlWriter& XmlWriter::writeComment( std::string const& text, XmlFormatting fmt) {
+        ensureTagClosed();
+        if (shouldIndent(fmt)) {
+            m_os << m_indent;
+        }
+        m_os << "<!--" << text << "-->";
+        applyFormatting(fmt);
+        return *this;
+    }
+
+    void XmlWriter::writeStylesheetRef( std::string const& url ) {
+        m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
+    }
+
+    XmlWriter& XmlWriter::writeBlankLine() {
+        ensureTagClosed();
+        m_os << '\n';
+        return *this;
+    }
+
+    void XmlWriter::ensureTagClosed() {
+        if( m_tagIsOpen ) {
+            m_os << '>' << std::flush;
+            newlineIfNecessary();
+            m_tagIsOpen = false;
+        }
+    }
+
+    void XmlWriter::applyFormatting(XmlFormatting fmt) {
+        m_needsNewline = shouldNewline(fmt);
+    }
+
+    void XmlWriter::writeDeclaration() {
+        m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
+    }
+
+    void XmlWriter::newlineIfNecessary() {
+        if( m_needsNewline ) {
+            m_os << std::endl;
+            m_needsNewline = false;
+        }
+    }
+}
+// end catch_xmlwriter.cpp
+// start catch_reporter_bases.cpp
+
+#include <cstring>
+#include <cfloat>
+#include <cstdio>
+#include <cassert>
+#include <memory>
+
+namespace Catch {
+    void prepareExpandedExpression(AssertionResult& result) {
+        result.getExpandedExpression();
+    }
+
+    // Because formatting using c++ streams is stateful, drop down to C is required
+    // Alternatively we could use stringstream, but its performance is... not good.
+    std::string getFormattedDuration( double duration ) {
+        // Max exponent + 1 is required to represent the whole part
+        // + 1 for decimal point
+        // + 3 for the 3 decimal places
+        // + 1 for null terminator
+        const std::size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
+        char buffer[maxDoubleSize];
+
+        // Save previous errno, to prevent sprintf from overwriting it
+        ErrnoGuard guard;
+#ifdef _MSC_VER
+        sprintf_s(buffer, "%.3f", duration);
+#else
+        std::sprintf(buffer, "%.3f", duration);
+#endif
+        return std::string(buffer);
+    }
+
+    std::string serializeFilters( std::vector<std::string> const& container ) {
+        ReusableStringStream oss;
+        bool first = true;
+        for (auto&& filter : container)
+        {
+            if (!first)
+                oss << ' ';
+            else
+                first = false;
+
+            oss << filter;
+        }
+        return oss.str();
+    }
+
+    TestEventListenerBase::TestEventListenerBase(ReporterConfig const & _config)
+        :StreamingReporterBase(_config) {}
+
+    std::set<Verbosity> TestEventListenerBase::getSupportedVerbosities() {
+        return { Verbosity::Quiet, Verbosity::Normal, Verbosity::High };
+    }
+
+    void TestEventListenerBase::assertionStarting(AssertionInfo const &) {}
+
+    bool TestEventListenerBase::assertionEnded(AssertionStats const &) {
+        return false;
+    }
+
+} // end namespace Catch
+// end catch_reporter_bases.cpp
+// start catch_reporter_compact.cpp
+
+namespace {
+
+#ifdef CATCH_PLATFORM_MAC
+    const char* failedString() { return "FAILED"; }
+    const char* passedString() { return "PASSED"; }
+#else
+    const char* failedString() { return "failed"; }
+    const char* passedString() { return "passed"; }
+#endif
+
+    // Colour::LightGrey
+    Catch::Colour::Code dimColour() { return Catch::Colour::FileName; }
+
+    std::string bothOrAll( std::size_t count ) {
+        return count == 1 ? std::string() :
+               count == 2 ? "both " : "all " ;
+    }
+
+} // anon namespace
+
+namespace Catch {
+namespace {
+// Colour, message variants:
+// - white: No tests ran.
+// -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
+// - white: Passed [both/all] N test cases (no assertions).
+// -   red: Failed N tests cases, failed M assertions.
+// - green: Passed [both/all] N tests cases with M assertions.
+void printTotals(std::ostream& out, const Totals& totals) {
+    if (totals.testCases.total() == 0) {
+        out << "No tests ran.";
+    } else if (totals.testCases.failed == totals.testCases.total()) {
+        Colour colour(Colour::ResultError);
+        const std::string qualify_assertions_failed =
+            totals.assertions.failed == totals.assertions.total() ?
+            bothOrAll(totals.assertions.failed) : std::string();
+        out <<
+            "Failed " << bothOrAll(totals.testCases.failed)
+            << pluralise(totals.testCases.failed, "test case") << ", "
+            "failed " << qualify_assertions_failed <<
+            pluralise(totals.assertions.failed, "assertion") << '.';
+    } else if (totals.assertions.total() == 0) {
+        out <<
+            "Passed " << bothOrAll(totals.testCases.total())
+            << pluralise(totals.testCases.total(), "test case")
+            << " (no assertions).";
+    } else if (totals.assertions.failed) {
+        Colour colour(Colour::ResultError);
+        out <<
+            "Failed " << pluralise(totals.testCases.failed, "test case") << ", "
+            "failed " << pluralise(totals.assertions.failed, "assertion") << '.';
+    } else {
+        Colour colour(Colour::ResultSuccess);
+        out <<
+            "Passed " << bothOrAll(totals.testCases.passed)
+            << pluralise(totals.testCases.passed, "test case") <<
+            " with " << pluralise(totals.assertions.passed, "assertion") << '.';
+    }
+}
+
+// Implementation of CompactReporter formatting
+class AssertionPrinter {
+public:
+    AssertionPrinter& operator= (AssertionPrinter const&) = delete;
+    AssertionPrinter(AssertionPrinter const&) = delete;
+    AssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
+        : stream(_stream)
+        , result(_stats.assertionResult)
+        , messages(_stats.infoMessages)
+        , itMessage(_stats.infoMessages.begin())
+        , printInfoMessages(_printInfoMessages) {}
+
+    void print() {
+        printSourceInfo();
+
+        itMessage = messages.begin();
+
+        switch (result.getResultType()) {
+        case ResultWas::Ok:
+            printResultType(Colour::ResultSuccess, passedString());
+            printOriginalExpression();
+            printReconstructedExpression();
+            if (!result.hasExpression())
+                printRemainingMessages(Colour::None);
+            else
+                printRemainingMessages();
+            break;
+        case ResultWas::ExpressionFailed:
+            if (result.isOk())
+                printResultType(Colour::ResultSuccess, failedString() + std::string(" - but was ok"));
+            else
+                printResultType(Colour::Error, failedString());
+            printOriginalExpression();
+            printReconstructedExpression();
+            printRemainingMessages();
+            break;
+        case ResultWas::ThrewException:
+            printResultType(Colour::Error, failedString());
+            printIssue("unexpected exception with message:");
+            printMessage();
+            printExpressionWas();
+            printRemainingMessages();
+            break;
+        case ResultWas::FatalErrorCondition:
+            printResultType(Colour::Error, failedString());
+            printIssue("fatal error condition with message:");
+            printMessage();
+            printExpressionWas();
+            printRemainingMessages();
+            break;
+        case ResultWas::DidntThrowException:
+            printResultType(Colour::Error, failedString());
+            printIssue("expected exception, got none");
+            printExpressionWas();
+            printRemainingMessages();
+            break;
+        case ResultWas::Info:
+            printResultType(Colour::None, "info");
+            printMessage();
+            printRemainingMessages();
+            break;
+        case ResultWas::Warning:
+            printResultType(Colour::None, "warning");
+            printMessage();
+            printRemainingMessages();
+            break;
+        case ResultWas::ExplicitFailure:
+            printResultType(Colour::Error, failedString());
+            printIssue("explicitly");
+            printRemainingMessages(Colour::None);
+            break;
+            // These cases are here to prevent compiler warnings
+        case ResultWas::Unknown:
+        case ResultWas::FailureBit:
+        case ResultWas::Exception:
+            printResultType(Colour::Error, "** internal error **");
+            break;
+        }
+    }
+
+private:
+    void printSourceInfo() const {
+        Colour colourGuard(Colour::FileName);
+        stream << result.getSourceInfo() << ':';
+    }
+
+    void printResultType(Colour::Code colour, std::string const& passOrFail) const {
+        if (!passOrFail.empty()) {
+            {
+                Colour colourGuard(colour);
+                stream << ' ' << passOrFail;
+            }
+            stream << ':';
+        }
+    }
+
+    void printIssue(std::string const& issue) const {
+        stream << ' ' << issue;
+    }
+
+    void printExpressionWas() {
+        if (result.hasExpression()) {
+            stream << ';';
+            {
+                Colour colour(dimColour());
+                stream << " expression was:";
+            }
+            printOriginalExpression();
+        }
+    }
+
+    void printOriginalExpression() const {
+        if (result.hasExpression()) {
+            stream << ' ' << result.getExpression();
+        }
+    }
+
+    void printReconstructedExpression() const {
+        if (result.hasExpandedExpression()) {
+            {
+                Colour colour(dimColour());
+                stream << " for: ";
+            }
+            stream << result.getExpandedExpression();
+        }
+    }
+
+    void printMessage() {
+        if (itMessage != messages.end()) {
+            stream << " '" << itMessage->message << '\'';
+            ++itMessage;
+        }
+    }
+
+    void printRemainingMessages(Colour::Code colour = dimColour()) {
+        if (itMessage == messages.end())
+            return;
+
+        const auto itEnd = messages.cend();
+        const auto N = static_cast<std::size_t>(std::distance(itMessage, itEnd));
+
+        {
+            Colour colourGuard(colour);
+            stream << " with " << pluralise(N, "message") << ':';
+        }
+
+        while (itMessage != itEnd) {
+            // If this assertion is a warning ignore any INFO messages
+            if (printInfoMessages || itMessage->type != ResultWas::Info) {
+                printMessage();
+                if (itMessage != itEnd) {
+                    Colour colourGuard(dimColour());
+                    stream << " and";
+                }
+                continue;
+            }
+            ++itMessage;
+        }
+    }
+
+private:
+    std::ostream& stream;
+    AssertionResult const& result;
+    std::vector<MessageInfo> messages;
+    std::vector<MessageInfo>::const_iterator itMessage;
+    bool printInfoMessages;
+};
+
+} // anon namespace
+
+        std::string CompactReporter::getDescription() {
+            return "Reports test results on a single line, suitable for IDEs";
+        }
+
+        ReporterPreferences CompactReporter::getPreferences() const {
+            return m_reporterPrefs;
+        }
+
+        void CompactReporter::noMatchingTestCases( std::string const& spec ) {
+            stream << "No test cases matched '" << spec << '\'' << std::endl;
+        }
+
+        void CompactReporter::assertionStarting( AssertionInfo const& ) {}
+
+        bool CompactReporter::assertionEnded( AssertionStats const& _assertionStats ) {
+            AssertionResult const& result = _assertionStats.assertionResult;
+
+            bool printInfoMessages = true;
+
+            // Drop out if result was successful and we're not printing those
+            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
+                if( result.getResultType() != ResultWas::Warning )
+                    return false;
+                printInfoMessages = false;
+            }
+
+            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
+            printer.print();
+
+            stream << std::endl;
+            return true;
+        }
+
+        void CompactReporter::sectionEnded(SectionStats const& _sectionStats) {
+            if (m_config->showDurations() == ShowDurations::Always) {
+                stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
+            }
+        }
+
+        void CompactReporter::testRunEnded( TestRunStats const& _testRunStats ) {
+            printTotals( stream, _testRunStats.totals );
+            stream << '\n' << std::endl;
+            StreamingReporterBase::testRunEnded( _testRunStats );
+        }
+
+        CompactReporter::~CompactReporter() {}
+
+    CATCH_REGISTER_REPORTER( "compact", CompactReporter )
+
+} // end namespace Catch
+// end catch_reporter_compact.cpp
+// start catch_reporter_console.cpp
+
+#include <cfloat>
+#include <cstdio>
+
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
+ // Note that 4062 (not all labels are handled and default is missing) is enabled
+#endif
+
+#if defined(__clang__)
+#  pragma clang diagnostic push
+// For simplicity, benchmarking-only helpers are always enabled
+#  pragma clang diagnostic ignored "-Wunused-function"
+#endif
+
+namespace Catch {
+
+namespace {
+
+// Formatter impl for ConsoleReporter
+class ConsoleAssertionPrinter {
+public:
+    ConsoleAssertionPrinter& operator= (ConsoleAssertionPrinter const&) = delete;
+    ConsoleAssertionPrinter(ConsoleAssertionPrinter const&) = delete;
+    ConsoleAssertionPrinter(std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages)
+        : stream(_stream),
+        stats(_stats),
+        result(_stats.assertionResult),
+        colour(Colour::None),
+        message(result.getMessage()),
+        messages(_stats.infoMessages),
+        printInfoMessages(_printInfoMessages) {
+        switch (result.getResultType()) {
+        case ResultWas::Ok:
+            colour = Colour::Success;
+            passOrFail = "PASSED";
+            //if( result.hasMessage() )
+            if (_stats.infoMessages.size() == 1)
+                messageLabel = "with message";
+            if (_stats.infoMessages.size() > 1)
+                messageLabel = "with messages";
+            break;
+        case ResultWas::ExpressionFailed:
+            if (result.isOk()) {
+                colour = Colour::Success;
+                passOrFail = "FAILED - but was ok";
+            } else {
+                colour = Colour::Error;
+                passOrFail = "FAILED";
+            }
+            if (_stats.infoMessages.size() == 1)
+                messageLabel = "with message";
+            if (_stats.infoMessages.size() > 1)
+                messageLabel = "with messages";
+            break;
+        case ResultWas::ThrewException:
+            colour = Colour::Error;
+            passOrFail = "FAILED";
+            messageLabel = "due to unexpected exception with ";
+            if (_stats.infoMessages.size() == 1)
+                messageLabel += "message";
+            if (_stats.infoMessages.size() > 1)
+                messageLabel += "messages";
+            break;
+        case ResultWas::FatalErrorCondition:
+            colour = Colour::Error;
+            passOrFail = "FAILED";
+            messageLabel = "due to a fatal error condition";
+            break;
+        case ResultWas::DidntThrowException:
+            colour = Colour::Error;
+            passOrFail = "FAILED";
+            messageLabel = "because no exception was thrown where one was expected";
+            break;
+        case ResultWas::Info:
+            messageLabel = "info";
+            break;
+        case ResultWas::Warning:
+            messageLabel = "warning";
+            break;
+        case ResultWas::ExplicitFailure:
+            passOrFail = "FAILED";
+            colour = Colour::Error;
+            if (_stats.infoMessages.size() == 1)
+                messageLabel = "explicitly with message";
+            if (_stats.infoMessages.size() > 1)
+                messageLabel = "explicitly with messages";
+            break;
+            // These cases are here to prevent compiler warnings
+        case ResultWas::Unknown:
+        case ResultWas::FailureBit:
+        case ResultWas::Exception:
+            passOrFail = "** internal error **";
+            colour = Colour::Error;
+            break;
+        }
+    }
+
+    void print() const {
+        printSourceInfo();
+        if (stats.totals.assertions.total() > 0) {
+            printResultType();
+            printOriginalExpression();
+            printReconstructedExpression();
+        } else {
+            stream << '\n';
+        }
+        printMessage();
+    }
+
+private:
+    void printResultType() const {
+        if (!passOrFail.empty()) {
+            Colour colourGuard(colour);
+            stream << passOrFail << ":\n";
+        }
+    }
+    void printOriginalExpression() const {
+        if (result.hasExpression()) {
+            Colour colourGuard(Colour::OriginalExpression);
+            stream << "  ";
+            stream << result.getExpressionInMacro();
+            stream << '\n';
+        }
+    }
+    void printReconstructedExpression() const {
+        if (result.hasExpandedExpression()) {
+            stream << "with expansion:\n";
+            Colour colourGuard(Colour::ReconstructedExpression);
+            stream << Column(result.getExpandedExpression()).indent(2) << '\n';
+        }
+    }
+    void printMessage() const {
+        if (!messageLabel.empty())
+            stream << messageLabel << ':' << '\n';
+        for (auto const& msg : messages) {
+            // If this assertion is a warning ignore any INFO messages
+            if (printInfoMessages || msg.type != ResultWas::Info)
+                stream << Column(msg.message).indent(2) << '\n';
+        }
+    }
+    void printSourceInfo() const {
+        Colour colourGuard(Colour::FileName);
+        stream << result.getSourceInfo() << ": ";
+    }
+
+    std::ostream& stream;
+    AssertionStats const& stats;
+    AssertionResult const& result;
+    Colour::Code colour;
+    std::string passOrFail;
+    std::string messageLabel;
+    std::string message;
+    std::vector<MessageInfo> messages;
+    bool printInfoMessages;
+};
+
+std::size_t makeRatio(std::size_t number, std::size_t total) {
+    std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number / total : 0;
+    return (ratio == 0 && number > 0) ? 1 : ratio;
+}
+
+std::size_t& findMax(std::size_t& i, std::size_t& j, std::size_t& k) {
+    if (i > j && i > k)
+        return i;
+    else if (j > k)
+        return j;
+    else
+        return k;
+}
+
+struct ColumnInfo {
+    enum Justification { Left, Right };
+    std::string name;
+    int width;
+    Justification justification;
+};
+struct ColumnBreak {};
+struct RowBreak {};
+
+class Duration {
+    enum class Unit {
+        Auto,
+        Nanoseconds,
+        Microseconds,
+        Milliseconds,
+        Seconds,
+        Minutes
+    };
+    static const uint64_t s_nanosecondsInAMicrosecond = 1000;
+    static const uint64_t s_nanosecondsInAMillisecond = 1000 * s_nanosecondsInAMicrosecond;
+    static const uint64_t s_nanosecondsInASecond = 1000 * s_nanosecondsInAMillisecond;
+    static const uint64_t s_nanosecondsInAMinute = 60 * s_nanosecondsInASecond;
+
+    double m_inNanoseconds;
+    Unit m_units;
+
+public:
+    explicit Duration(double inNanoseconds, Unit units = Unit::Auto)
+        : m_inNanoseconds(inNanoseconds),
+        m_units(units) {
+        if (m_units == Unit::Auto) {
+            if (m_inNanoseconds < s_nanosecondsInAMicrosecond)
+                m_units = Unit::Nanoseconds;
+            else if (m_inNanoseconds < s_nanosecondsInAMillisecond)
+                m_units = Unit::Microseconds;
+            else if (m_inNanoseconds < s_nanosecondsInASecond)
+                m_units = Unit::Milliseconds;
+            else if (m_inNanoseconds < s_nanosecondsInAMinute)
+                m_units = Unit::Seconds;
+            else
+                m_units = Unit::Minutes;
+        }
+
+    }
+
+    auto value() const -> double {
+        switch (m_units) {
+        case Unit::Microseconds:
+            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMicrosecond);
+        case Unit::Milliseconds:
+            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMillisecond);
+        case Unit::Seconds:
+            return m_inNanoseconds / static_cast<double>(s_nanosecondsInASecond);
+        case Unit::Minutes:
+            return m_inNanoseconds / static_cast<double>(s_nanosecondsInAMinute);
+        default:
+            return m_inNanoseconds;
+        }
+    }
+    auto unitsAsString() const -> std::string {
+        switch (m_units) {
+        case Unit::Nanoseconds:
+            return "ns";
+        case Unit::Microseconds:
+            return "us";
+        case Unit::Milliseconds:
+            return "ms";
+        case Unit::Seconds:
+            return "s";
+        case Unit::Minutes:
+            return "m";
+        default:
+            return "** internal error **";
+        }
+
+    }
+    friend auto operator << (std::ostream& os, Duration const& duration) -> std::ostream& {
+        return os << duration.value() << ' ' << duration.unitsAsString();
+    }
+};
+} // end anon namespace
+
+class TablePrinter {
+    std::ostream& m_os;
+    std::vector<ColumnInfo> m_columnInfos;
+    std::ostringstream m_oss;
+    int m_currentColumn = -1;
+    bool m_isOpen = false;
+
+public:
+    TablePrinter( std::ostream& os, std::vector<ColumnInfo> columnInfos )
+    :   m_os( os ),
+        m_columnInfos( std::move( columnInfos ) ) {}
+
+    auto columnInfos() const -> std::vector<ColumnInfo> const& {
+        return m_columnInfos;
+    }
+
+    void open() {
+        if (!m_isOpen) {
+            m_isOpen = true;
+            *this << RowBreak();
+
+			Columns headerCols;
+			Spacer spacer(2);
+			for (auto const& info : m_columnInfos) {
+				headerCols += Column(info.name).width(static_cast<std::size_t>(info.width - 2));
+				headerCols += spacer;
+			}
+			m_os << headerCols << '\n';
+
+            m_os << Catch::getLineOfChars<'-'>() << '\n';
+        }
+    }
+    void close() {
+        if (m_isOpen) {
+            *this << RowBreak();
+            m_os << std::endl;
+            m_isOpen = false;
+        }
+    }
+
+    template<typename T>
+    friend TablePrinter& operator << (TablePrinter& tp, T const& value) {
+        tp.m_oss << value;
+        return tp;
+    }
+
+    friend TablePrinter& operator << (TablePrinter& tp, ColumnBreak) {
+        auto colStr = tp.m_oss.str();
+        const auto strSize = colStr.size();
+        tp.m_oss.str("");
+        tp.open();
+        if (tp.m_currentColumn == static_cast<int>(tp.m_columnInfos.size() - 1)) {
+            tp.m_currentColumn = -1;
+            tp.m_os << '\n';
+        }
+        tp.m_currentColumn++;
+
+        auto colInfo = tp.m_columnInfos[tp.m_currentColumn];
+        auto padding = (strSize + 1 < static_cast<std::size_t>(colInfo.width))
+            ? std::string(colInfo.width - (strSize + 1), ' ')
+            : std::string();
+        if (colInfo.justification == ColumnInfo::Left)
+            tp.m_os << colStr << padding << ' ';
+        else
+            tp.m_os << padding << colStr << ' ';
+        return tp;
+    }
+
+    friend TablePrinter& operator << (TablePrinter& tp, RowBreak) {
+        if (tp.m_currentColumn > 0) {
+            tp.m_os << '\n';
+            tp.m_currentColumn = -1;
+        }
+        return tp;
+    }
+};
+
+ConsoleReporter::ConsoleReporter(ReporterConfig const& config)
+    : StreamingReporterBase(config),
+    m_tablePrinter(new TablePrinter(config.stream(),
+        [&config]() -> std::vector<ColumnInfo> {
+        if (config.fullConfig()->benchmarkNoAnalysis())
+        {
+            return{
+                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
+                { "     samples", 14, ColumnInfo::Right },
+                { "  iterations", 14, ColumnInfo::Right },
+                { "        mean", 14, ColumnInfo::Right }
+            };
+        }
+        else
+        {
+            return{
+                { "benchmark name", CATCH_CONFIG_CONSOLE_WIDTH - 43, ColumnInfo::Left },
+                { "samples      mean       std dev", 14, ColumnInfo::Right },
+                { "iterations   low mean   low std dev", 14, ColumnInfo::Right },
+                { "estimated    high mean  high std dev", 14, ColumnInfo::Right }
+            };
+        }
+    }())) {}
+ConsoleReporter::~ConsoleReporter() = default;
+
+std::string ConsoleReporter::getDescription() {
+    return "Reports test results as plain lines of text";
+}
+
+void ConsoleReporter::noMatchingTestCases(std::string const& spec) {
+    stream << "No test cases matched '" << spec << '\'' << std::endl;
+}
+
+void ConsoleReporter::reportInvalidArguments(std::string const&arg){
+    stream << "Invalid Filter: " << arg << std::endl;
+}
+
+void ConsoleReporter::assertionStarting(AssertionInfo const&) {}
+
+bool ConsoleReporter::assertionEnded(AssertionStats const& _assertionStats) {
+    AssertionResult const& result = _assertionStats.assertionResult;
+
+    bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
+
+    // Drop out if result was successful but we're not printing them.
+    if (!includeResults && result.getResultType() != ResultWas::Warning)
+        return false;
+
+    lazyPrint();
+
+    ConsoleAssertionPrinter printer(stream, _assertionStats, includeResults);
+    printer.print();
+    stream << std::endl;
+    return true;
+}
+
+void ConsoleReporter::sectionStarting(SectionInfo const& _sectionInfo) {
+    m_tablePrinter->close();
+    m_headerPrinted = false;
+    StreamingReporterBase::sectionStarting(_sectionInfo);
+}
+void ConsoleReporter::sectionEnded(SectionStats const& _sectionStats) {
+    m_tablePrinter->close();
+    if (_sectionStats.missingAssertions) {
+        lazyPrint();
+        Colour colour(Colour::ResultError);
+        if (m_sectionStack.size() > 1)
+            stream << "\nNo assertions in section";
+        else
+            stream << "\nNo assertions in test case";
+        stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
+    }
+    if (m_config->showDurations() == ShowDurations::Always) {
+        stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
+    }
+    if (m_headerPrinted) {
+        m_headerPrinted = false;
+    }
+    StreamingReporterBase::sectionEnded(_sectionStats);
+}
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+void ConsoleReporter::benchmarkPreparing(std::string const& name) {
+	lazyPrintWithoutClosingBenchmarkTable();
+
+	auto nameCol = Column(name).width(static_cast<std::size_t>(m_tablePrinter->columnInfos()[0].width - 2));
+
+	bool firstLine = true;
+	for (auto line : nameCol) {
+		if (!firstLine)
+			(*m_tablePrinter) << ColumnBreak() << ColumnBreak() << ColumnBreak();
+		else
+			firstLine = false;
+
+		(*m_tablePrinter) << line << ColumnBreak();
+	}
+}
+
+void ConsoleReporter::benchmarkStarting(BenchmarkInfo const& info) {
+    (*m_tablePrinter) << info.samples << ColumnBreak()
+        << info.iterations << ColumnBreak();
+    if (!m_config->benchmarkNoAnalysis())
+        (*m_tablePrinter) << Duration(info.estimatedDuration) << ColumnBreak();
+}
+void ConsoleReporter::benchmarkEnded(BenchmarkStats<> const& stats) {
+    if (m_config->benchmarkNoAnalysis())
+    {
+        (*m_tablePrinter) << Duration(stats.mean.point.count()) << ColumnBreak();
+    }
+    else
+    {
+        (*m_tablePrinter) << ColumnBreak()
+            << Duration(stats.mean.point.count()) << ColumnBreak()
+            << Duration(stats.mean.lower_bound.count()) << ColumnBreak()
+            << Duration(stats.mean.upper_bound.count()) << ColumnBreak() << ColumnBreak()
+            << Duration(stats.standardDeviation.point.count()) << ColumnBreak()
+            << Duration(stats.standardDeviation.lower_bound.count()) << ColumnBreak()
+            << Duration(stats.standardDeviation.upper_bound.count()) << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak() << ColumnBreak();
+    }
+}
+
+void ConsoleReporter::benchmarkFailed(std::string const& error) {
+	Colour colour(Colour::Red);
+    (*m_tablePrinter)
+        << "Benchmark failed (" << error << ')'
+        << ColumnBreak() << RowBreak();
+}
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+void ConsoleReporter::testCaseEnded(TestCaseStats const& _testCaseStats) {
+    m_tablePrinter->close();
+    StreamingReporterBase::testCaseEnded(_testCaseStats);
+    m_headerPrinted = false;
+}
+void ConsoleReporter::testGroupEnded(TestGroupStats const& _testGroupStats) {
+    if (currentGroupInfo.used) {
+        printSummaryDivider();
+        stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
+        printTotals(_testGroupStats.totals);
+        stream << '\n' << std::endl;
+    }
+    StreamingReporterBase::testGroupEnded(_testGroupStats);
+}
+void ConsoleReporter::testRunEnded(TestRunStats const& _testRunStats) {
+    printTotalsDivider(_testRunStats.totals);
+    printTotals(_testRunStats.totals);
+    stream << std::endl;
+    StreamingReporterBase::testRunEnded(_testRunStats);
+}
+void ConsoleReporter::testRunStarting(TestRunInfo const& _testInfo) {
+    StreamingReporterBase::testRunStarting(_testInfo);
+    printTestFilters();
+}
+
+void ConsoleReporter::lazyPrint() {
+
+    m_tablePrinter->close();
+    lazyPrintWithoutClosingBenchmarkTable();
+}
+
+void ConsoleReporter::lazyPrintWithoutClosingBenchmarkTable() {
+
+    if (!currentTestRunInfo.used)
+        lazyPrintRunInfo();
+    if (!currentGroupInfo.used)
+        lazyPrintGroupInfo();
+
+    if (!m_headerPrinted) {
+        printTestCaseAndSectionHeader();
+        m_headerPrinted = true;
+    }
+}
+void ConsoleReporter::lazyPrintRunInfo() {
+    stream << '\n' << getLineOfChars<'~'>() << '\n';
+    Colour colour(Colour::SecondaryText);
+    stream << currentTestRunInfo->name
+        << " is a Catch v" << libraryVersion() << " host application.\n"
+        << "Run with -? for options\n\n";
+
+    if (m_config->rngSeed() != 0)
+        stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
+
+    currentTestRunInfo.used = true;
+}
+void ConsoleReporter::lazyPrintGroupInfo() {
+    if (!currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1) {
+        printClosedHeader("Group: " + currentGroupInfo->name);
+        currentGroupInfo.used = true;
+    }
+}
+void ConsoleReporter::printTestCaseAndSectionHeader() {
+    assert(!m_sectionStack.empty());
+    printOpenHeader(currentTestCaseInfo->name);
+
+    if (m_sectionStack.size() > 1) {
+        Colour colourGuard(Colour::Headers);
+
+        auto
+            it = m_sectionStack.begin() + 1, // Skip first section (test case)
+            itEnd = m_sectionStack.end();
+        for (; it != itEnd; ++it)
+            printHeaderString(it->name, 2);
+    }
+
+    SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
+
+    stream << getLineOfChars<'-'>() << '\n';
+    Colour colourGuard(Colour::FileName);
+    stream << lineInfo << '\n';
+    stream << getLineOfChars<'.'>() << '\n' << std::endl;
+}
+
+void ConsoleReporter::printClosedHeader(std::string const& _name) {
+    printOpenHeader(_name);
+    stream << getLineOfChars<'.'>() << '\n';
+}
+void ConsoleReporter::printOpenHeader(std::string const& _name) {
+    stream << getLineOfChars<'-'>() << '\n';
+    {
+        Colour colourGuard(Colour::Headers);
+        printHeaderString(_name);
+    }
+}
+
+// if string has a : in first line will set indent to follow it on
+// subsequent lines
+void ConsoleReporter::printHeaderString(std::string const& _string, std::size_t indent) {
+    std::size_t i = _string.find(": ");
+    if (i != std::string::npos)
+        i += 2;
+    else
+        i = 0;
+    stream << Column(_string).indent(indent + i).initialIndent(indent) << '\n';
+}
+
+struct SummaryColumn {
+
+    SummaryColumn( std::string _label, Colour::Code _colour )
+    :   label( std::move( _label ) ),
+        colour( _colour ) {}
+    SummaryColumn addRow( std::size_t count ) {
+        ReusableStringStream rss;
+        rss << count;
+        std::string row = rss.str();
+        for (auto& oldRow : rows) {
+            while (oldRow.size() < row.size())
+                oldRow = ' ' + oldRow;
+            while (oldRow.size() > row.size())
+                row = ' ' + row;
+        }
+        rows.push_back(row);
+        return *this;
+    }
+
+    std::string label;
+    Colour::Code colour;
+    std::vector<std::string> rows;
+
+};
+
+void ConsoleReporter::printTotals( Totals const& totals ) {
+    if (totals.testCases.total() == 0) {
+        stream << Colour(Colour::Warning) << "No tests ran\n";
+    } else if (totals.assertions.total() > 0 && totals.testCases.allPassed()) {
+        stream << Colour(Colour::ResultSuccess) << "All tests passed";
+        stream << " ("
+            << pluralise(totals.assertions.passed, "assertion") << " in "
+            << pluralise(totals.testCases.passed, "test case") << ')'
+            << '\n';
+    } else {
+
+        std::vector<SummaryColumn> columns;
+        columns.push_back(SummaryColumn("", Colour::None)
+                          .addRow(totals.testCases.total())
+                          .addRow(totals.assertions.total()));
+        columns.push_back(SummaryColumn("passed", Colour::Success)
+                          .addRow(totals.testCases.passed)
+                          .addRow(totals.assertions.passed));
+        columns.push_back(SummaryColumn("failed", Colour::ResultError)
+                          .addRow(totals.testCases.failed)
+                          .addRow(totals.assertions.failed));
+        columns.push_back(SummaryColumn("failed as expected", Colour::ResultExpectedFailure)
+                          .addRow(totals.testCases.failedButOk)
+                          .addRow(totals.assertions.failedButOk));
+
+        printSummaryRow("test cases", columns, 0);
+        printSummaryRow("assertions", columns, 1);
+    }
+}
+void ConsoleReporter::printSummaryRow(std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row) {
+    for (auto col : cols) {
+        std::string value = col.rows[row];
+        if (col.label.empty()) {
+            stream << label << ": ";
+            if (value != "0")
+                stream << value;
+            else
+                stream << Colour(Colour::Warning) << "- none -";
+        } else if (value != "0") {
+            stream << Colour(Colour::LightGrey) << " | ";
+            stream << Colour(col.colour)
+                << value << ' ' << col.label;
+        }
+    }
+    stream << '\n';
+}
+
+void ConsoleReporter::printTotalsDivider(Totals const& totals) {
+    if (totals.testCases.total() > 0) {
+        std::size_t failedRatio = makeRatio(totals.testCases.failed, totals.testCases.total());
+        std::size_t failedButOkRatio = makeRatio(totals.testCases.failedButOk, totals.testCases.total());
+        std::size_t passedRatio = makeRatio(totals.testCases.passed, totals.testCases.total());
+        while (failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH - 1)
+            findMax(failedRatio, failedButOkRatio, passedRatio)++;
+        while (failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH - 1)
+            findMax(failedRatio, failedButOkRatio, passedRatio)--;
+
+        stream << Colour(Colour::Error) << std::string(failedRatio, '=');
+        stream << Colour(Colour::ResultExpectedFailure) << std::string(failedButOkRatio, '=');
+        if (totals.testCases.allPassed())
+            stream << Colour(Colour::ResultSuccess) << std::string(passedRatio, '=');
+        else
+            stream << Colour(Colour::Success) << std::string(passedRatio, '=');
+    } else {
+        stream << Colour(Colour::Warning) << std::string(CATCH_CONFIG_CONSOLE_WIDTH - 1, '=');
+    }
+    stream << '\n';
+}
+void ConsoleReporter::printSummaryDivider() {
+    stream << getLineOfChars<'-'>() << '\n';
+}
+
+void ConsoleReporter::printTestFilters() {
+    if (m_config->testSpec().hasFilters()) {
+        Colour guard(Colour::BrightYellow);
+        stream << "Filters: " << serializeFilters(m_config->getTestsOrTags()) << '\n';
+    }
+}
+
+CATCH_REGISTER_REPORTER("console", ConsoleReporter)
+
+} // end namespace Catch
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+
+#if defined(__clang__)
+#  pragma clang diagnostic pop
+#endif
+// end catch_reporter_console.cpp
+// start catch_reporter_junit.cpp
+
+#include <cassert>
+#include <sstream>
+#include <ctime>
+#include <algorithm>
+
+namespace Catch {
+
+    namespace {
+        std::string getCurrentTimestamp() {
+            // Beware, this is not reentrant because of backward compatibility issues
+            // Also, UTC only, again because of backward compatibility (%z is C++11)
+            time_t rawtime;
+            std::time(&rawtime);
+            auto const timeStampSize = sizeof("2017-01-16T17:06:45Z");
+
+#ifdef _MSC_VER
+            std::tm timeInfo = {};
+            gmtime_s(&timeInfo, &rawtime);
+#else
+            std::tm* timeInfo;
+            timeInfo = std::gmtime(&rawtime);
+#endif
+
+            char timeStamp[timeStampSize];
+            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
+
+#ifdef _MSC_VER
+            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
+#else
+            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
+#endif
+            return std::string(timeStamp);
+        }
+
+        std::string fileNameTag(const std::vector<std::string> &tags) {
+            auto it = std::find_if(begin(tags),
+                                   end(tags),
+                                   [] (std::string const& tag) {return tag.front() == '#'; });
+            if (it != tags.end())
+                return it->substr(1);
+            return std::string();
+        }
+    } // anonymous namespace
+
+    JunitReporter::JunitReporter( ReporterConfig const& _config )
+        :   CumulativeReporterBase( _config ),
+            xml( _config.stream() )
+        {
+            m_reporterPrefs.shouldRedirectStdOut = true;
+            m_reporterPrefs.shouldReportAllAssertions = true;
+        }
+
+    JunitReporter::~JunitReporter() {}
+
+    std::string JunitReporter::getDescription() {
+        return "Reports test results in an XML format that looks like Ant's junitreport target";
+    }
+
+    void JunitReporter::noMatchingTestCases( std::string const& /*spec*/ ) {}
+
+    void JunitReporter::testRunStarting( TestRunInfo const& runInfo )  {
+        CumulativeReporterBase::testRunStarting( runInfo );
+        xml.startElement( "testsuites" );
+    }
+
+    void JunitReporter::testGroupStarting( GroupInfo const& groupInfo ) {
+        suiteTimer.start();
+        stdOutForSuite.clear();
+        stdErrForSuite.clear();
+        unexpectedExceptions = 0;
+        CumulativeReporterBase::testGroupStarting( groupInfo );
+    }
+
+    void JunitReporter::testCaseStarting( TestCaseInfo const& testCaseInfo ) {
+        m_okToFail = testCaseInfo.okToFail();
+    }
+
+    bool JunitReporter::assertionEnded( AssertionStats const& assertionStats ) {
+        if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
+            unexpectedExceptions++;
+        return CumulativeReporterBase::assertionEnded( assertionStats );
+    }
+
+    void JunitReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
+        stdOutForSuite += testCaseStats.stdOut;
+        stdErrForSuite += testCaseStats.stdErr;
+        CumulativeReporterBase::testCaseEnded( testCaseStats );
+    }
+
+    void JunitReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
+        double suiteTime = suiteTimer.getElapsedSeconds();
+        CumulativeReporterBase::testGroupEnded( testGroupStats );
+        writeGroup( *m_testGroups.back(), suiteTime );
+    }
+
+    void JunitReporter::testRunEndedCumulative() {
+        xml.endElement();
+    }
+
+    void JunitReporter::writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
+        XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
+
+        TestGroupStats const& stats = groupNode.value;
+        xml.writeAttribute( "name", stats.groupInfo.name );
+        xml.writeAttribute( "errors", unexpectedExceptions );
+        xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
+        xml.writeAttribute( "tests", stats.totals.assertions.total() );
+        xml.writeAttribute( "hostname", "tbd" ); // !TBD
+        if( m_config->showDurations() == ShowDurations::Never )
+            xml.writeAttribute( "time", "" );
+        else
+            xml.writeAttribute( "time", suiteTime );
+        xml.writeAttribute( "timestamp", getCurrentTimestamp() );
+
+        // Write properties if there are any
+        if (m_config->hasTestFilters() || m_config->rngSeed() != 0) {
+            auto properties = xml.scopedElement("properties");
+            if (m_config->hasTestFilters()) {
+                xml.scopedElement("property")
+                    .writeAttribute("name", "filters")
+                    .writeAttribute("value", serializeFilters(m_config->getTestsOrTags()));
+            }
+            if (m_config->rngSeed() != 0) {
+                xml.scopedElement("property")
+                    .writeAttribute("name", "random-seed")
+                    .writeAttribute("value", m_config->rngSeed());
+            }
+        }
+
+        // Write test cases
+        for( auto const& child : groupNode.children )
+            writeTestCase( *child );
+
+        xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite ), XmlFormatting::Newline );
+        xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite ), XmlFormatting::Newline );
+    }
+
+    void JunitReporter::writeTestCase( TestCaseNode const& testCaseNode ) {
+        TestCaseStats const& stats = testCaseNode.value;
+
+        // All test cases have exactly one section - which represents the
+        // test case itself. That section may have 0-n nested sections
+        assert( testCaseNode.children.size() == 1 );
+        SectionNode const& rootSection = *testCaseNode.children.front();
+
+        std::string className = stats.testInfo.className;
+
+        if( className.empty() ) {
+            className = fileNameTag(stats.testInfo.tags);
+            if ( className.empty() )
+                className = "global";
+        }
+
+        if ( !m_config->name().empty() )
+            className = m_config->name() + "." + className;
+
+        writeSection( className, "", rootSection );
+    }
+
+    void JunitReporter::writeSection(  std::string const& className,
+                        std::string const& rootName,
+                        SectionNode const& sectionNode ) {
+        std::string name = trim( sectionNode.stats.sectionInfo.name );
+        if( !rootName.empty() )
+            name = rootName + '/' + name;
+
+        if( !sectionNode.assertions.empty() ||
+            !sectionNode.stdOut.empty() ||
+            !sectionNode.stdErr.empty() ) {
+            XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
+            if( className.empty() ) {
+                xml.writeAttribute( "classname", name );
+                xml.writeAttribute( "name", "root" );
+            }
+            else {
+                xml.writeAttribute( "classname", className );
+                xml.writeAttribute( "name", name );
+            }
+            xml.writeAttribute( "time", ::Catch::Detail::stringify( sectionNode.stats.durationInSeconds ) );
+
+            writeAssertions( sectionNode );
+
+            if( !sectionNode.stdOut.empty() )
+                xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), XmlFormatting::Newline );
+            if( !sectionNode.stdErr.empty() )
+                xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), XmlFormatting::Newline );
+        }
+        for( auto const& childNode : sectionNode.childSections )
+            if( className.empty() )
+                writeSection( name, "", *childNode );
+            else
+                writeSection( className, name, *childNode );
+    }
+
+    void JunitReporter::writeAssertions( SectionNode const& sectionNode ) {
+        for( auto const& assertion : sectionNode.assertions )
+            writeAssertion( assertion );
+    }
+
+    void JunitReporter::writeAssertion( AssertionStats const& stats ) {
+        AssertionResult const& result = stats.assertionResult;
+        if( !result.isOk() ) {
+            std::string elementName;
+            switch( result.getResultType() ) {
+                case ResultWas::ThrewException:
+                case ResultWas::FatalErrorCondition:
+                    elementName = "error";
+                    break;
+                case ResultWas::ExplicitFailure:
+                case ResultWas::ExpressionFailed:
+                case ResultWas::DidntThrowException:
+                    elementName = "failure";
+                    break;
+
+                // We should never see these here:
+                case ResultWas::Info:
+                case ResultWas::Warning:
+                case ResultWas::Ok:
+                case ResultWas::Unknown:
+                case ResultWas::FailureBit:
+                case ResultWas::Exception:
+                    elementName = "internalError";
+                    break;
+            }
+
+            XmlWriter::ScopedElement e = xml.scopedElement( elementName );
+
+            xml.writeAttribute( "message", result.getExpression() );
+            xml.writeAttribute( "type", result.getTestMacroName() );
+
+            ReusableStringStream rss;
+            if (stats.totals.assertions.total() > 0) {
+                rss << "FAILED" << ":\n";
+                if (result.hasExpression()) {
+                    rss << "  ";
+                    rss << result.getExpressionInMacro();
+                    rss << '\n';
+                }
+                if (result.hasExpandedExpression()) {
+                    rss << "with expansion:\n";
+                    rss << Column(result.getExpandedExpression()).indent(2) << '\n';
+                }
+            } else {
+                rss << '\n';
+            }
+
+            if( !result.getMessage().empty() )
+                rss << result.getMessage() << '\n';
+            for( auto const& msg : stats.infoMessages )
+                if( msg.type == ResultWas::Info )
+                    rss << msg.message << '\n';
+
+            rss << "at " << result.getSourceInfo();
+            xml.writeText( rss.str(), XmlFormatting::Newline );
+        }
+    }
+
+    CATCH_REGISTER_REPORTER( "junit", JunitReporter )
+
+} // end namespace Catch
+// end catch_reporter_junit.cpp
+// start catch_reporter_listening.cpp
+
+#include <cassert>
+
+namespace Catch {
+
+    ListeningReporter::ListeningReporter() {
+        // We will assume that listeners will always want all assertions
+        m_preferences.shouldReportAllAssertions = true;
+    }
+
+    void ListeningReporter::addListener( IStreamingReporterPtr&& listener ) {
+        m_listeners.push_back( std::move( listener ) );
+    }
+
+    void ListeningReporter::addReporter(IStreamingReporterPtr&& reporter) {
+        assert(!m_reporter && "Listening reporter can wrap only 1 real reporter");
+        m_reporter = std::move( reporter );
+        m_preferences.shouldRedirectStdOut = m_reporter->getPreferences().shouldRedirectStdOut;
+    }
+
+    ReporterPreferences ListeningReporter::getPreferences() const {
+        return m_preferences;
+    }
+
+    std::set<Verbosity> ListeningReporter::getSupportedVerbosities() {
+        return std::set<Verbosity>{ };
+    }
+
+    void ListeningReporter::noMatchingTestCases( std::string const& spec ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->noMatchingTestCases( spec );
+        }
+        m_reporter->noMatchingTestCases( spec );
+    }
+
+    void ListeningReporter::reportInvalidArguments(std::string const&arg){
+        for ( auto const& listener : m_listeners ) {
+            listener->reportInvalidArguments( arg );
+        }
+        m_reporter->reportInvalidArguments( arg );
+    }
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+    void ListeningReporter::benchmarkPreparing( std::string const& name ) {
+		for (auto const& listener : m_listeners) {
+			listener->benchmarkPreparing(name);
+		}
+		m_reporter->benchmarkPreparing(name);
+	}
+    void ListeningReporter::benchmarkStarting( BenchmarkInfo const& benchmarkInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->benchmarkStarting( benchmarkInfo );
+        }
+        m_reporter->benchmarkStarting( benchmarkInfo );
+    }
+    void ListeningReporter::benchmarkEnded( BenchmarkStats<> const& benchmarkStats ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->benchmarkEnded( benchmarkStats );
+        }
+        m_reporter->benchmarkEnded( benchmarkStats );
+    }
+
+	void ListeningReporter::benchmarkFailed( std::string const& error ) {
+		for (auto const& listener : m_listeners) {
+			listener->benchmarkFailed(error);
+		}
+		m_reporter->benchmarkFailed(error);
+	}
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    void ListeningReporter::testRunStarting( TestRunInfo const& testRunInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testRunStarting( testRunInfo );
+        }
+        m_reporter->testRunStarting( testRunInfo );
+    }
+
+    void ListeningReporter::testGroupStarting( GroupInfo const& groupInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testGroupStarting( groupInfo );
+        }
+        m_reporter->testGroupStarting( groupInfo );
+    }
+
+    void ListeningReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testCaseStarting( testInfo );
+        }
+        m_reporter->testCaseStarting( testInfo );
+    }
+
+    void ListeningReporter::sectionStarting( SectionInfo const& sectionInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->sectionStarting( sectionInfo );
+        }
+        m_reporter->sectionStarting( sectionInfo );
+    }
+
+    void ListeningReporter::assertionStarting( AssertionInfo const& assertionInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->assertionStarting( assertionInfo );
+        }
+        m_reporter->assertionStarting( assertionInfo );
+    }
+
+    // The return value indicates if the messages buffer should be cleared:
+    bool ListeningReporter::assertionEnded( AssertionStats const& assertionStats ) {
+        for( auto const& listener : m_listeners ) {
+            static_cast<void>( listener->assertionEnded( assertionStats ) );
+        }
+        return m_reporter->assertionEnded( assertionStats );
+    }
+
+    void ListeningReporter::sectionEnded( SectionStats const& sectionStats ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->sectionEnded( sectionStats );
+        }
+        m_reporter->sectionEnded( sectionStats );
+    }
+
+    void ListeningReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testCaseEnded( testCaseStats );
+        }
+        m_reporter->testCaseEnded( testCaseStats );
+    }
+
+    void ListeningReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testGroupEnded( testGroupStats );
+        }
+        m_reporter->testGroupEnded( testGroupStats );
+    }
+
+    void ListeningReporter::testRunEnded( TestRunStats const& testRunStats ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->testRunEnded( testRunStats );
+        }
+        m_reporter->testRunEnded( testRunStats );
+    }
+
+    void ListeningReporter::skipTest( TestCaseInfo const& testInfo ) {
+        for ( auto const& listener : m_listeners ) {
+            listener->skipTest( testInfo );
+        }
+        m_reporter->skipTest( testInfo );
+    }
+
+    bool ListeningReporter::isMulti() const {
+        return true;
+    }
+
+} // end namespace Catch
+// end catch_reporter_listening.cpp
+// start catch_reporter_xml.cpp
+
+#if defined(_MSC_VER)
+#pragma warning(push)
+#pragma warning(disable:4061) // Not all labels are EXPLICITLY handled in switch
+                              // Note that 4062 (not all labels are handled
+                              // and default is missing) is enabled
+#endif
+
+namespace Catch {
+    XmlReporter::XmlReporter( ReporterConfig const& _config )
+    :   StreamingReporterBase( _config ),
+        m_xml(_config.stream())
+    {
+        m_reporterPrefs.shouldRedirectStdOut = true;
+        m_reporterPrefs.shouldReportAllAssertions = true;
+    }
+
+    XmlReporter::~XmlReporter() = default;
+
+    std::string XmlReporter::getDescription() {
+        return "Reports test results as an XML document";
+    }
+
+    std::string XmlReporter::getStylesheetRef() const {
+        return std::string();
+    }
+
+    void XmlReporter::writeSourceInfo( SourceLineInfo const& sourceInfo ) {
+        m_xml
+            .writeAttribute( "filename", sourceInfo.file )
+            .writeAttribute( "line", sourceInfo.line );
+    }
+
+    void XmlReporter::noMatchingTestCases( std::string const& s ) {
+        StreamingReporterBase::noMatchingTestCases( s );
+    }
+
+    void XmlReporter::testRunStarting( TestRunInfo const& testInfo ) {
+        StreamingReporterBase::testRunStarting( testInfo );
+        std::string stylesheetRef = getStylesheetRef();
+        if( !stylesheetRef.empty() )
+            m_xml.writeStylesheetRef( stylesheetRef );
+        m_xml.startElement( "Catch" );
+        if( !m_config->name().empty() )
+            m_xml.writeAttribute( "name", m_config->name() );
+        if (m_config->testSpec().hasFilters())
+            m_xml.writeAttribute( "filters", serializeFilters( m_config->getTestsOrTags() ) );
+        if( m_config->rngSeed() != 0 )
+            m_xml.scopedElement( "Randomness" )
+                .writeAttribute( "seed", m_config->rngSeed() );
+    }
+
+    void XmlReporter::testGroupStarting( GroupInfo const& groupInfo ) {
+        StreamingReporterBase::testGroupStarting( groupInfo );
+        m_xml.startElement( "Group" )
+            .writeAttribute( "name", groupInfo.name );
+    }
+
+    void XmlReporter::testCaseStarting( TestCaseInfo const& testInfo ) {
+        StreamingReporterBase::testCaseStarting(testInfo);
+        m_xml.startElement( "TestCase" )
+            .writeAttribute( "name", trim( testInfo.name ) )
+            .writeAttribute( "description", testInfo.description )
+            .writeAttribute( "tags", testInfo.tagsAsString() );
+
+        writeSourceInfo( testInfo.lineInfo );
+
+        if ( m_config->showDurations() == ShowDurations::Always )
+            m_testCaseTimer.start();
+        m_xml.ensureTagClosed();
+    }
+
+    void XmlReporter::sectionStarting( SectionInfo const& sectionInfo ) {
+        StreamingReporterBase::sectionStarting( sectionInfo );
+        if( m_sectionDepth++ > 0 ) {
+            m_xml.startElement( "Section" )
+                .writeAttribute( "name", trim( sectionInfo.name ) );
+            writeSourceInfo( sectionInfo.lineInfo );
+            m_xml.ensureTagClosed();
+        }
+    }
+
+    void XmlReporter::assertionStarting( AssertionInfo const& ) { }
+
+    bool XmlReporter::assertionEnded( AssertionStats const& assertionStats ) {
+
+        AssertionResult const& result = assertionStats.assertionResult;
+
+        bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
+
+        if( includeResults || result.getResultType() == ResultWas::Warning ) {
+            // Print any info messages in <Info> tags.
+            for( auto const& msg : assertionStats.infoMessages ) {
+                if( msg.type == ResultWas::Info && includeResults ) {
+                    m_xml.scopedElement( "Info" )
+                            .writeText( msg.message );
+                } else if ( msg.type == ResultWas::Warning ) {
+                    m_xml.scopedElement( "Warning" )
+                            .writeText( msg.message );
+                }
+            }
+        }
+
+        // Drop out if result was successful but we're not printing them.
+        if( !includeResults && result.getResultType() != ResultWas::Warning )
+            return true;
+
+        // Print the expression if there is one.
+        if( result.hasExpression() ) {
+            m_xml.startElement( "Expression" )
+                .writeAttribute( "success", result.succeeded() )
+                .writeAttribute( "type", result.getTestMacroName() );
+
+            writeSourceInfo( result.getSourceInfo() );
+
+            m_xml.scopedElement( "Original" )
+                .writeText( result.getExpression() );
+            m_xml.scopedElement( "Expanded" )
+                .writeText( result.getExpandedExpression() );
+        }
+
+        // And... Print a result applicable to each result type.
+        switch( result.getResultType() ) {
+            case ResultWas::ThrewException:
+                m_xml.startElement( "Exception" );
+                writeSourceInfo( result.getSourceInfo() );
+                m_xml.writeText( result.getMessage() );
+                m_xml.endElement();
+                break;
+            case ResultWas::FatalErrorCondition:
+                m_xml.startElement( "FatalErrorCondition" );
+                writeSourceInfo( result.getSourceInfo() );
+                m_xml.writeText( result.getMessage() );
+                m_xml.endElement();
+                break;
+            case ResultWas::Info:
+                m_xml.scopedElement( "Info" )
+                    .writeText( result.getMessage() );
+                break;
+            case ResultWas::Warning:
+                // Warning will already have been written
+                break;
+            case ResultWas::ExplicitFailure:
+                m_xml.startElement( "Failure" );
+                writeSourceInfo( result.getSourceInfo() );
+                m_xml.writeText( result.getMessage() );
+                m_xml.endElement();
+                break;
+            default:
+                break;
+        }
+
+        if( result.hasExpression() )
+            m_xml.endElement();
+
+        return true;
+    }
+
+    void XmlReporter::sectionEnded( SectionStats const& sectionStats ) {
+        StreamingReporterBase::sectionEnded( sectionStats );
+        if( --m_sectionDepth > 0 ) {
+            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
+            e.writeAttribute( "successes", sectionStats.assertions.passed );
+            e.writeAttribute( "failures", sectionStats.assertions.failed );
+            e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
+
+            if ( m_config->showDurations() == ShowDurations::Always )
+                e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
+
+            m_xml.endElement();
+        }
+    }
+
+    void XmlReporter::testCaseEnded( TestCaseStats const& testCaseStats ) {
+        StreamingReporterBase::testCaseEnded( testCaseStats );
+        XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
+        e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
+
+        if ( m_config->showDurations() == ShowDurations::Always )
+            e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
+
+        if( !testCaseStats.stdOut.empty() )
+            m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), XmlFormatting::Newline );
+        if( !testCaseStats.stdErr.empty() )
+            m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), XmlFormatting::Newline );
+
+        m_xml.endElement();
+    }
+
+    void XmlReporter::testGroupEnded( TestGroupStats const& testGroupStats ) {
+        StreamingReporterBase::testGroupEnded( testGroupStats );
+        // TODO: Check testGroupStats.aborting and act accordingly.
+        m_xml.scopedElement( "OverallResults" )
+            .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
+            .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
+            .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
+        m_xml.endElement();
+    }
+
+    void XmlReporter::testRunEnded( TestRunStats const& testRunStats ) {
+        StreamingReporterBase::testRunEnded( testRunStats );
+        m_xml.scopedElement( "OverallResults" )
+            .writeAttribute( "successes", testRunStats.totals.assertions.passed )
+            .writeAttribute( "failures", testRunStats.totals.assertions.failed )
+            .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
+        m_xml.endElement();
+    }
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+    void XmlReporter::benchmarkPreparing(std::string const& name) {
+        m_xml.startElement("BenchmarkResults")
+            .writeAttribute("name", name);
+    }
+
+    void XmlReporter::benchmarkStarting(BenchmarkInfo const &info) {
+        m_xml.writeAttribute("samples", info.samples)
+            .writeAttribute("resamples", info.resamples)
+            .writeAttribute("iterations", info.iterations)
+            .writeAttribute("clockResolution", info.clockResolution)
+            .writeAttribute("estimatedDuration", info.estimatedDuration)
+            .writeComment("All values in nano seconds");
+    }
+
+    void XmlReporter::benchmarkEnded(BenchmarkStats<> const& benchmarkStats) {
+        m_xml.startElement("mean")
+            .writeAttribute("value", benchmarkStats.mean.point.count())
+            .writeAttribute("lowerBound", benchmarkStats.mean.lower_bound.count())
+            .writeAttribute("upperBound", benchmarkStats.mean.upper_bound.count())
+            .writeAttribute("ci", benchmarkStats.mean.confidence_interval);
+        m_xml.endElement();
+        m_xml.startElement("standardDeviation")
+            .writeAttribute("value", benchmarkStats.standardDeviation.point.count())
+            .writeAttribute("lowerBound", benchmarkStats.standardDeviation.lower_bound.count())
+            .writeAttribute("upperBound", benchmarkStats.standardDeviation.upper_bound.count())
+            .writeAttribute("ci", benchmarkStats.standardDeviation.confidence_interval);
+        m_xml.endElement();
+        m_xml.startElement("outliers")
+            .writeAttribute("variance", benchmarkStats.outlierVariance)
+            .writeAttribute("lowMild", benchmarkStats.outliers.low_mild)
+            .writeAttribute("lowSevere", benchmarkStats.outliers.low_severe)
+            .writeAttribute("highMild", benchmarkStats.outliers.high_mild)
+            .writeAttribute("highSevere", benchmarkStats.outliers.high_severe);
+        m_xml.endElement();
+        m_xml.endElement();
+    }
+
+    void XmlReporter::benchmarkFailed(std::string const &error) {
+        m_xml.scopedElement("failed").
+            writeAttribute("message", error);
+        m_xml.endElement();
+    }
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+    CATCH_REGISTER_REPORTER( "xml", XmlReporter )
+
+} // end namespace Catch
+
+#if defined(_MSC_VER)
+#pragma warning(pop)
+#endif
+// end catch_reporter_xml.cpp
+
+namespace Catch {
+    LeakDetector leakDetector;
+}
+
+#ifdef __clang__
+#pragma clang diagnostic pop
+#endif
+
+// end catch_impl.hpp
+#endif
+
+#ifdef CATCH_CONFIG_MAIN
+// start catch_default_main.hpp
+
+#ifndef __OBJC__
+
+#if defined(CATCH_CONFIG_WCHAR) && defined(CATCH_PLATFORM_WINDOWS) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
+// Standard C/C++ Win32 Unicode wmain entry point
+extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
+#else
+// Standard C/C++ main entry point
+int main (int argc, char * argv[]) {
+#endif
+
+    return Catch::Session().run( argc, argv );
+}
+
+#else // __OBJC__
+
+// Objective-C entry point
+int main (int argc, char * const argv[]) {
+#if !CATCH_ARC_ENABLED
+    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
+#endif
+
+    Catch::registerTestMethods();
+    int result = Catch::Session().run( argc, (char**)argv );
+
+#if !CATCH_ARC_ENABLED
+    [pool drain];
+#endif
+
+    return result;
+}
+
+#endif // __OBJC__
+
+// end catch_default_main.hpp
+#endif
+
+#if !defined(CATCH_CONFIG_IMPL_ONLY)
+
+#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
+#  undef CLARA_CONFIG_MAIN
+#endif
+
+#if !defined(CATCH_CONFIG_DISABLE)
+//////
+// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
+#ifdef CATCH_CONFIG_PREFIX_ALL
+
+#define CATCH_REQUIRE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__ )
+#define CATCH_REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
+
+#define CATCH_REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
+#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
+#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
+#endif// CATCH_CONFIG_DISABLE_MATCHERS
+#define CATCH_REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
+
+#define CATCH_CHECK( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CATCH_CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
+#define CATCH_CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CATCH_CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CATCH_CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
+
+#define CATCH_CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
+#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CATCH_CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define CATCH_CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
+
+#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+
+#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
+#define CATCH_UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "CATCH_UNSCOPED_INFO", msg )
+#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
+#define CATCH_CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CATCH_CAPTURE",__VA_ARGS__ )
+
+#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
+#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
+#define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
+#define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
+#define CATCH_DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
+#define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
+#define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+
+#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
+#else
+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
+#endif
+
+#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
+#define CATCH_STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__ ,      #__VA_ARGS__ );     CATCH_SUCCEED( #__VA_ARGS__ )
+#define CATCH_STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); CATCH_SUCCEED( #__VA_ARGS__ )
+#else
+#define CATCH_STATIC_REQUIRE( ... )       CATCH_REQUIRE( __VA_ARGS__ )
+#define CATCH_STATIC_REQUIRE_FALSE( ... ) CATCH_REQUIRE_FALSE( __VA_ARGS__ )
+#endif
+
+// "BDD-style" convenience wrappers
+#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
+#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
+#define CATCH_GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
+#define CATCH_AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
+#define CATCH_WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
+#define CATCH_AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
+#define CATCH_THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
+#define CATCH_AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+#define CATCH_BENCHMARK(...) \
+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
+#define CATCH_BENCHMARK_ADVANCED(name) \
+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
+#else
+
+#define REQUIRE( ... ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, __VA_ARGS__  )
+#define REQUIRE_FALSE( ... ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
+
+#define REQUIRE_THROWS( ... ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, __VA_ARGS__ )
+#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
+#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "REQUIRE_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::Normal, matcher, expr )
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define REQUIRE_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, __VA_ARGS__ )
+
+#define CHECK( ... ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CHECK_FALSE( ... ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, __VA_ARGS__ )
+#define CHECKED_IF( ... ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CHECKED_ELSE( ... ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CHECK_NOFAIL( ... ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, __VA_ARGS__ )
+
+#define CHECK_THROWS( ... )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
+#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS_STR_MATCHES( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) INTERNAL_CATCH_THROWS_MATCHES( "CHECK_THROWS_MATCHES", exceptionType, Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define CHECK_NOTHROW( ... ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
+
+#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+
+#define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
+#define UNSCOPED_INFO( msg ) INTERNAL_CATCH_UNSCOPED_INFO( "UNSCOPED_INFO", msg )
+#define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
+#define CAPTURE( ... ) INTERNAL_CATCH_CAPTURE( INTERNAL_CATCH_UNIQUE_NAME(capturer), "CAPTURE",__VA_ARGS__ )
+
+#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
+#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
+#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
+#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
+#define DYNAMIC_SECTION( ... ) INTERNAL_CATCH_DYNAMIC_SECTION( __VA_ARGS__ )
+#define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
+#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
+#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE()
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ )
+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ )
+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE(__VA_ARGS__)
+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#else
+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ ) )
+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG( __VA_ARGS__ ) )
+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE( __VA_ARGS__ ) )
+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( __VA_ARGS__ ) )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, __VA_ARGS__ ) )
+#define TEMPLATE_LIST_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE( __VA_ARGS__ ) )
+#define TEMPLATE_LIST_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_LIST_TEST_CASE_METHOD( className, __VA_ARGS__ ) )
+#endif
+
+#if !defined(CATCH_CONFIG_RUNTIME_STATIC_REQUIRE)
+#define STATIC_REQUIRE( ... )       static_assert(   __VA_ARGS__,  #__VA_ARGS__ ); SUCCEED( #__VA_ARGS__ )
+#define STATIC_REQUIRE_FALSE( ... ) static_assert( !(__VA_ARGS__), "!(" #__VA_ARGS__ ")" ); SUCCEED( "!(" #__VA_ARGS__ ")" )
+#else
+#define STATIC_REQUIRE( ... )       REQUIRE( __VA_ARGS__ )
+#define STATIC_REQUIRE_FALSE( ... ) REQUIRE_FALSE( __VA_ARGS__ )
+#endif
+
+#endif
+
+#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
+
+// "BDD-style" convenience wrappers
+#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
+#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
+
+#define GIVEN( desc )     INTERNAL_CATCH_DYNAMIC_SECTION( "    Given: " << desc )
+#define AND_GIVEN( desc ) INTERNAL_CATCH_DYNAMIC_SECTION( "And given: " << desc )
+#define WHEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     When: " << desc )
+#define AND_WHEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( " And when: " << desc )
+#define THEN( desc )      INTERNAL_CATCH_DYNAMIC_SECTION( "     Then: " << desc )
+#define AND_THEN( desc )  INTERNAL_CATCH_DYNAMIC_SECTION( "      And: " << desc )
+
+#if defined(CATCH_CONFIG_ENABLE_BENCHMARKING)
+#define BENCHMARK(...) \
+    INTERNAL_CATCH_BENCHMARK(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), INTERNAL_CATCH_GET_1_ARG(__VA_ARGS__,,), INTERNAL_CATCH_GET_2_ARG(__VA_ARGS__,,))
+#define BENCHMARK_ADVANCED(name) \
+    INTERNAL_CATCH_BENCHMARK_ADVANCED(INTERNAL_CATCH_UNIQUE_NAME(____C_A_T_C_H____B_E_N_C_H____), name)
+#endif // CATCH_CONFIG_ENABLE_BENCHMARKING
+
+using Catch::Detail::Approx;
+
+#else // CATCH_CONFIG_DISABLE
+
+//////
+// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
+#ifdef CATCH_CONFIG_PREFIX_ALL
+
+#define CATCH_REQUIRE( ... )        (void)(0)
+#define CATCH_REQUIRE_FALSE( ... )  (void)(0)
+
+#define CATCH_REQUIRE_THROWS( ... ) (void)(0)
+#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
+#define CATCH_REQUIRE_THROWS_WITH( expr, matcher )     (void)(0)
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
+#endif// CATCH_CONFIG_DISABLE_MATCHERS
+#define CATCH_REQUIRE_NOTHROW( ... ) (void)(0)
+
+#define CATCH_CHECK( ... )         (void)(0)
+#define CATCH_CHECK_FALSE( ... )   (void)(0)
+#define CATCH_CHECKED_IF( ... )    if (__VA_ARGS__)
+#define CATCH_CHECKED_ELSE( ... )  if (!(__VA_ARGS__))
+#define CATCH_CHECK_NOFAIL( ... )  (void)(0)
+
+#define CATCH_CHECK_THROWS( ... )  (void)(0)
+#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
+#define CATCH_CHECK_THROWS_WITH( expr, matcher )     (void)(0)
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define CATCH_CHECK_NOTHROW( ... ) (void)(0)
+
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CATCH_CHECK_THAT( arg, matcher )   (void)(0)
+
+#define CATCH_REQUIRE_THAT( arg, matcher ) (void)(0)
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+
+#define CATCH_INFO( msg )          (void)(0)
+#define CATCH_UNSCOPED_INFO( msg ) (void)(0)
+#define CATCH_WARN( msg )          (void)(0)
+#define CATCH_CAPTURE( msg )       (void)(0)
+
+#define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define CATCH_METHOD_AS_TEST_CASE( method, ... )
+#define CATCH_REGISTER_TEST_CASE( Function, ... ) (void)(0)
+#define CATCH_SECTION( ... )
+#define CATCH_DYNAMIC_SECTION( ... )
+#define CATCH_FAIL( ... ) (void)(0)
+#define CATCH_FAIL_CHECK( ... ) (void)(0)
+#define CATCH_SUCCEED( ... ) (void)(0)
+
+#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#else
+#define CATCH_TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
+#define CATCH_TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) CATCH_TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define CATCH_TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) CATCH_TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#endif
+
+// "BDD-style" convenience wrappers
+#define CATCH_SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
+#define CATCH_GIVEN( desc )
+#define CATCH_AND_GIVEN( desc )
+#define CATCH_WHEN( desc )
+#define CATCH_AND_WHEN( desc )
+#define CATCH_THEN( desc )
+#define CATCH_AND_THEN( desc )
+
+#define CATCH_STATIC_REQUIRE( ... )       (void)(0)
+#define CATCH_STATIC_REQUIRE_FALSE( ... ) (void)(0)
+
+// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
+#else
+
+#define REQUIRE( ... )       (void)(0)
+#define REQUIRE_FALSE( ... ) (void)(0)
+
+#define REQUIRE_THROWS( ... ) (void)(0)
+#define REQUIRE_THROWS_AS( expr, exceptionType ) (void)(0)
+#define REQUIRE_THROWS_WITH( expr, matcher ) (void)(0)
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define REQUIRE_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define REQUIRE_NOTHROW( ... ) (void)(0)
+
+#define CHECK( ... ) (void)(0)
+#define CHECK_FALSE( ... ) (void)(0)
+#define CHECKED_IF( ... ) if (__VA_ARGS__)
+#define CHECKED_ELSE( ... ) if (!(__VA_ARGS__))
+#define CHECK_NOFAIL( ... ) (void)(0)
+
+#define CHECK_THROWS( ... )  (void)(0)
+#define CHECK_THROWS_AS( expr, exceptionType ) (void)(0)
+#define CHECK_THROWS_WITH( expr, matcher ) (void)(0)
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CHECK_THROWS_MATCHES( expr, exceptionType, matcher ) (void)(0)
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+#define CHECK_NOTHROW( ... ) (void)(0)
+
+#if !defined(CATCH_CONFIG_DISABLE_MATCHERS)
+#define CHECK_THAT( arg, matcher ) (void)(0)
+
+#define REQUIRE_THAT( arg, matcher ) (void)(0)
+#endif // CATCH_CONFIG_DISABLE_MATCHERS
+
+#define INFO( msg ) (void)(0)
+#define UNSCOPED_INFO( msg ) (void)(0)
+#define WARN( msg ) (void)(0)
+#define CAPTURE( msg ) (void)(0)
+
+#define TEST_CASE( ... )  INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+#define METHOD_AS_TEST_CASE( method, ... )
+#define REGISTER_TEST_CASE( Function, ... ) (void)(0)
+#define SECTION( ... )
+#define DYNAMIC_SECTION( ... )
+#define FAIL( ... ) (void)(0)
+#define FAIL_CHECK( ... ) (void)(0)
+#define SUCCEED( ... ) (void)(0)
+#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ))
+
+#ifndef CATCH_CONFIG_TRADITIONAL_MSVC_PREPROCESSOR
+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__)
+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__)
+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__)
+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#else
+#define TEMPLATE_TEST_CASE( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_NO_REGISTRATION(__VA_ARGS__) )
+#define TEMPLATE_TEST_CASE_SIG( ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_SIG_NO_REGISTRATION(__VA_ARGS__) )
+#define TEMPLATE_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_NO_REGISTRATION(className, __VA_ARGS__ ) )
+#define TEMPLATE_TEST_CASE_METHOD_SIG( className, ... ) INTERNAL_CATCH_EXPAND_VARGS( INTERNAL_CATCH_TEMPLATE_TEST_CASE_METHOD_SIG_NO_REGISTRATION(className, __VA_ARGS__ ) )
+#define TEMPLATE_PRODUCT_TEST_CASE( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_SIG( ... ) TEMPLATE_TEST_CASE( __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#define TEMPLATE_PRODUCT_TEST_CASE_METHOD_SIG( className, ... ) TEMPLATE_TEST_CASE_METHOD( className, __VA_ARGS__ )
+#endif
+
+#define STATIC_REQUIRE( ... )       (void)(0)
+#define STATIC_REQUIRE_FALSE( ... ) (void)(0)
+
+#endif
+
+#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION_NO_REG( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
+
+// "BDD-style" convenience wrappers
+#define SCENARIO( ... ) INTERNAL_CATCH_TESTCASE_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ) )
+#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TESTCASE_METHOD_NO_REGISTRATION(INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), className )
+
+#define GIVEN( desc )
+#define AND_GIVEN( desc )
+#define WHEN( desc )
+#define AND_WHEN( desc )
+#define THEN( desc )
+#define AND_THEN( desc )
+
+using Catch::Detail::Approx;
+
+#endif
+
+#endif // ! CATCH_CONFIG_IMPL_ONLY
+
+// start catch_reenable_warnings.h
+
+
+#ifdef __clang__
+#    ifdef __ICC // icpc defines the __clang__ macro
+#        pragma warning(pop)
+#    else
+#        pragma clang diagnostic pop
+#    endif
+#elif defined __GNUC__
+#    pragma GCC diagnostic pop
+#endif
+
+// end catch_reenable_warnings.h
+// end catch.hpp
+#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
+
diff --git a/unit-tests/filesystem.h b/unit-tests/filesystem.h
new file mode 100644
index 0000000..962dd2f
--- /dev/null
+++ b/unit-tests/filesystem.h
@@ -0,0 +1,295 @@
+// This file is part of OpenCV project.
+// It is subject to the license terms in the LICENSE file found in the top-level directory
+// of this distribution and at http://opencv.org/license.html.
+
+#pragma once
+
+#if defined _WIN32 || defined WINCE
+# include <windows.h>
+const char dir_separators[] = "/\\";
+
+namespace
+{
+    struct dirent
+    {
+        const char* d_name;
+    };
+
+    struct DIR
+    {
+#if defined(WINRT) || defined(_WIN32_WCE)
+        WIN32_FIND_DATAW data;
+#else
+        WIN32_FIND_DATAA data;
+#endif
+        HANDLE handle;
+        dirent ent;
+#ifdef WINRT
+        DIR() { }
+        ~DIR()
+        {
+            if( ent.d_name )
+                delete[] ent.d_name;
+        }
+#endif
+    };
+
+    DIR* opendir( const char* path )
+    {
+        DIR* dir = new DIR;
+        dir->ent.d_name = 0;
+#if defined(WINRT) || defined(_WIN32_WCE)
+        cv::String full_path = cv::String( path ) + "\\*";
+        wchar_t wfull_path[MAX_PATH];
+        size_t copied = mbstowcs( wfull_path, full_path.c_str(), MAX_PATH );
+        CV_Assert( (copied != MAX_PATH) && (copied != (size_t)-1) );
+        dir->handle = ::FindFirstFileExW( wfull_path, FindExInfoStandard,
+            &dir->data, FindExSearchNameMatch, NULL, 0 );
+#else
+        dir->handle = ::FindFirstFileExA( (std::string( path ) + "\\*").c_str(),
+            FindExInfoStandard, &dir->data, FindExSearchNameMatch, NULL, 0 );
+#endif
+        if( dir->handle == INVALID_HANDLE_VALUE )
+        {
+            /*closedir will do all cleanup*/
+            delete dir;
+            return 0;
+        }
+        return dir;
+    }
+
+    dirent* readdir( DIR* dir )
+    {
+#if defined(WINRT) || defined(_WIN32_WCE)
+        if( dir->ent.d_name != 0 )
+        {
+            if( ::FindNextFileW( dir->handle, &dir->data ) != TRUE )
+                return 0;
+        }
+        size_t asize = wcstombs( NULL, dir->data.cFileName, 0 );
+        CV_Assert( (asize != 0) && (asize != (size_t)-1) );
+        char* aname = new char[asize + 1];
+        aname[asize] = 0;
+        wcstombs( aname, dir->data.cFileName, asize );
+        dir->ent.d_name = aname;
+#else
+        if( dir->ent.d_name != 0 )
+        {
+            if( ::FindNextFileA( dir->handle, &dir->data ) != TRUE )
+                return 0;
+        }
+        dir->ent.d_name = dir->data.cFileName;
+#endif
+        return &dir->ent;
+    }
+
+    void closedir( DIR* dir )
+    {
+        ::FindClose( dir->handle );
+        delete dir;
+    }
+
+
+}
+#else
+# include <dirent.h>
+# include <sys/stat.h>
+const char dir_separators[] = "/";
+#endif
+
+
+#ifdef _WIN32
+static const char native_separator = '\\';
+#else
+static const char native_separator = '/';
+#endif
+
+static inline
+bool isPathSeparator( char c )
+{
+    return c == '/' || c == '\\';
+}
+
+std::string join( const std::string& base, const std::string& path )
+{
+    if( base.empty() )
+        return path;
+    if( path.empty() )
+        return base;
+
+    bool baseSep = isPathSeparator( base[base.size() - 1] );
+    bool pathSep = isPathSeparator( path[0] );
+    std::string result;
+    if( baseSep && pathSep )
+    {
+        result = base + path.substr( 1 );
+    }
+    else if( !baseSep && !pathSep )
+    {
+        result = base + native_separator + path;
+    }
+    else
+    {
+        result = base + path;
+    }
+    return result;
+}
+
+static bool wildcmp( const char *string, const char *wild )
+{
+    // Based on wildcmp written by Jack Handy - <A href="mailto:jakkhandy@hotmail.com">jakkhandy@hotmail.com</A>
+    const char *cp = 0, *mp = 0;
+
+    while( (*string) && (*wild != '*') )
+    {
+        if( (*wild != *string) && (*wild != '?') )
+        {
+            return false;
+        }
+
+        wild++;
+        string++;
+    }
+
+    while( *string )
+    {
+        if( *wild == '*' )
+        {
+            if( !*++wild )
+            {
+                return true;
+            }
+
+            mp = wild;
+            cp = string + 1;
+        }
+        else if( (*wild == *string) || (*wild == '?') )
+        {
+            wild++;
+            string++;
+        }
+        else
+        {
+            wild = mp;
+            string = cp++;
+        }
+    }
+
+    while( *wild == '*' )
+    {
+        wild++;
+    }
+
+    return *wild == 0;
+}
+
+
+static bool isDir( const std::string& path, DIR* dir )
+{
+#if defined _WIN32 || defined WINCE
+    DWORD attributes;
+    BOOL status = TRUE;
+    if( dir )
+        attributes = dir->data.dwFileAttributes;
+    else
+    {
+        WIN32_FILE_ATTRIBUTE_DATA all_attrs;
+#ifdef WINRT
+        wchar_t wpath[MAX_PATH];
+        size_t copied = mbstowcs( wpath, path.c_str(), MAX_PATH );
+        CV_Assert( (copied != MAX_PATH) && (copied != (size_t)-1) );
+        status = ::GetFileAttributesExW( wpath, GetFileExInfoStandard, &all_attrs );
+#else
+        status = ::GetFileAttributesExA( path.c_str(), GetFileExInfoStandard, &all_attrs );
+#endif
+        attributes = all_attrs.dwFileAttributes;
+    }
+
+    return status && ((attributes & FILE_ATTRIBUTE_DIRECTORY) != 0);
+#else
+    (void)dir;  // avoid warnings about unused params
+    struct stat stat_buf;
+    if( 0 != stat( path.c_str(), &stat_buf ) )
+        return false;
+    int is_dir = S_ISDIR( stat_buf.st_mode );
+    return is_dir != 0;
+#endif
+}
+
+static void glob_rec( const std::string & directory,
+    const std::string & wildchart,
+    std::vector<std::string>& result,
+    bool recursive,
+    bool includeDirectories,
+    const std::string & pathPrefix
+)
+{
+    DIR *dir;
+
+    if( (dir = opendir( directory.c_str() )) != 0 )
+    {
+        /* find all the files and directories within directory */
+        try
+        {
+            struct dirent *ent;
+            while( (ent = readdir( dir )) != 0 )
+            {
+                const char* name = ent->d_name;
+                if( (name[0] == 0) || (name[0] == '.' && name[1] == 0) || (name[0] == '.' && name[1] == '.' && name[2] == 0) )
+                    continue;
+
+                std::string path = join( directory, name );
+                std::string entry = join( pathPrefix, name );
+
+                if( isDir( path, dir ) )
+                {
+                    if( recursive )
+                        glob_rec( path, wildchart, result, recursive, includeDirectories, entry );
+                    if( !includeDirectories )
+                        continue;
+                }
+
+                if( wildchart.empty() || wildcmp( name, wildchart.c_str() ) )
+                    result.push_back( entry );
+            }
+        }
+        catch( ... )
+        {
+            closedir( dir );
+            throw;
+        }
+        closedir( dir );
+    }
+    else
+    {
+        throw std::runtime_error( to_string() << "could not open directory: " << directory.c_str() );
+    }
+}
+
+static void glob(
+    const std::string & directory,
+    const std::string & spec,
+    std::function< void( std::string const & ) > fn,
+    bool recursive = true,
+    bool includeDirectories = false
+)
+{
+    std::vector< std::string > results;
+    glob_rec( directory, spec, results, recursive, includeDirectories, "" );
+    for( auto r : results )
+        fn( r );
+}
+
+static
+std::string get_parent( std::string const & path, std::string * basename = nullptr )
+{
+    // Returns the parent and leaf for the given path:
+    //     /foo/bar/  ->  '/foo/bar' and '' (empty)
+    //     blah/..    ->  'blah'     and '..'
+    auto x = path.find_last_of( dir_separators );
+    if( x == std::string::npos )
+        return std::string();
+    if( basename )
+        *basename = path.substr( x + 1 );
+    return std::string( path, 0, x );
+}
diff --git a/unit-tests/internal/CMakeLists.txt b/unit-tests/internal/CMakeLists.txt
index 5280c73..e06092d 100644
--- a/unit-tests/internal/CMakeLists.txt
+++ b/unit-tests/internal/CMakeLists.txt
@@ -12,6 +12,8 @@ set (INTERNAL_TESTS_SOURCES
     internal-tests-types.cpp
     internal-tests-uv-map.cpp
     internal-tests-class-logic.cpp
+    ../catch.h
+    ../approx.h
 )
 
 add_executable(${PROJECT_NAME} ${INTERNAL_TESTS_SOURCES})
diff --git a/unit-tests/internal/internal-tests-class-logic.cpp b/unit-tests/internal/internal-tests-class-logic.cpp
index e2dfd94..873d87f 100644
--- a/unit-tests/internal/internal-tests-class-logic.cpp
+++ b/unit-tests/internal/internal-tests-class-logic.cpp
@@ -1,7 +1,7 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include "catch/catch.hpp"
+#include "catch.h"
 #include <cmath>
 #include <iostream>
 #include "./../src/api.h"
diff --git a/unit-tests/internal/internal-tests-extrinsic.cpp b/unit-tests/internal/internal-tests-extrinsic.cpp
index ff2fc93..a2bfa38 100644
--- a/unit-tests/internal/internal-tests-extrinsic.cpp
+++ b/unit-tests/internal/internal-tests-extrinsic.cpp
@@ -1,7 +1,7 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include "catch/catch.hpp"
+#include "approx.h"
 #include <cmath>
 #include <iostream>
 #include <chrono>
@@ -25,7 +25,7 @@ inline void require_zero_vector(const float(&vector)[3])
 inline void require_identity_matrix(const float(&matrix)[9])
 {
     static const float identity_matrix_3x3[] = { 1,0,0, 0,1,0, 0,0,1 };
-    for (int i = 0; i < 9; ++i) REQUIRE(matrix[i] == Approx(identity_matrix_3x3[i]));
+    for (int i = 0; i < 9; ++i) REQUIRE(matrix[i] == approx(identity_matrix_3x3[i]));
 }
 
 TEST_CASE("Extrinsic graph management", "[live][multicam]")
diff --git a/unit-tests/internal/internal-tests-main.cpp b/unit-tests/internal/internal-tests-main.cpp
index 9c893eb..903526f 100644
--- a/unit-tests/internal/internal-tests-main.cpp
+++ b/unit-tests/internal/internal-tests-main.cpp
@@ -1,5 +1,4 @@
 #define CATCH_CONFIG_RUNNER
-#include "catch/catch.hpp"
 #include "unit-tests-common.h"
 #include <iostream>
 
diff --git a/unit-tests/internal/internal-tests-types.cpp b/unit-tests/internal/internal-tests-types.cpp
index 499dbe3..f9238ab 100644
--- a/unit-tests/internal/internal-tests-types.cpp
+++ b/unit-tests/internal/internal-tests-types.cpp
@@ -1,7 +1,7 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include "catch/catch.hpp"
+#include "catch.h"
 #include <cmath>
 #include <iostream>
 #include <chrono>
diff --git a/unit-tests/internal/internal-tests-usb.cpp b/unit-tests/internal/internal-tests-usb.cpp
index 437fc05..4dfa3ad 100644
--- a/unit-tests/internal/internal-tests-usb.cpp
+++ b/unit-tests/internal/internal-tests-usb.cpp
@@ -1,7 +1,7 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include "catch/catch.hpp"
+#include "catch.h"
 #include "usb/usb-enumerator.h"
 #include "usb/usb-device.h"
 #include "hw-monitor.h"
diff --git a/unit-tests/internal/internal-tests-uv-map.cpp b/unit-tests/internal/internal-tests-uv-map.cpp
index 67a5f5b..84a50e1 100644
--- a/unit-tests/internal/internal-tests-uv-map.cpp
+++ b/unit-tests/internal/internal-tests-uv-map.cpp
@@ -1,7 +1,7 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
 
-#include "catch/catch.hpp"
+#include "catch.h"
 #include <cmath>
 #include <iostream>
 #include <chrono>
diff --git a/unit-tests/log/log-common.h b/unit-tests/log/log-common.h
index ae962fb..2e07cf3 100644
--- a/unit-tests/log/log-common.h
+++ b/unit-tests/log/log-common.h
@@ -5,6 +5,10 @@
 
 #include <librealsense2/rs.hpp>   // Include RealSense Cross Platform API
 
+// Let Catch define its own main() function
+#define CATCH_CONFIG_MAIN
+#include "../catch.h"
+
 #include <easylogging++.h>
 #ifdef BUILD_SHARED_LIBS
 // With static linkage, ELPP is initialized by librealsense, so doing it here will
@@ -13,13 +17,6 @@
 INITIALIZE_EASYLOGGINGPP
 #endif
 
-// Catch also defines CHECK(), and so we have to undefine it or we get compilation errors!
-#undef CHECK
-
-// Let Catch define its own main() function
-#define CATCH_CONFIG_MAIN
-#include "../catch/catch.hpp"
-
 // Define our own logging macro for debugging to stdout
 // Can possibly turn it on automatically based on the Catch options supplied
 // on the command-line, with a custom main():
diff --git a/unit-tests/log/test-vs-LOG-static.cpp b/unit-tests/log/test-vs-LOG-static.cpp
index f0b1600..fa2654c 100644
--- a/unit-tests/log/test-vs-LOG-static.cpp
+++ b/unit-tests/log/test-vs-LOG-static.cpp
@@ -7,7 +7,7 @@
 // Catch also defines CHECK(), and so we have to undefine it or we get compilation errors!
 #undef CHECK
 #define CATCH_CONFIG_MAIN
-#include "../catch/catch.hpp"
+#include "../catch.h"
  
 // With Catch2, turn this into SCOPED_INFO (right now, does not work)
 #if 1
@@ -45,15 +45,15 @@ TEST_CASE( "rs2_log vs LOG() - internal", "[log]" )
     el::Helpers::uninstallLogDispatchCallback< el::base::DefaultLogDispatchCallback >( "DefaultLogDispatchCallback" );
 
     // LOG(XXX) should log to the default logger, which is NOT the librealsense logger
-    REQUIRE_NOTHROW( LOG(INFO) << "Log message to default logger" );
+    LOG(INFO) << "Log message to default logger";
     REQUIRE( n_callbacks == 1 );
 
     // CLOG(XXX,"librealsense") is the librealsense logger
-    REQUIRE_NOTHROW( CLOG(INFO, "librealsense") << "Log message to \"librealsense\" logger" );
+    CLOG(INFO, "librealsense") << "Log message to \"librealsense\" logger";
     REQUIRE( n_callbacks == 2 );
 
     // LOG_XXX() is same as CLOG( ..., "librealsense" )
-    REQUIRE_NOTHROW( LOG_INFO( "Log message using LOG_INFO()" ) );
+    LOG_INFO( "Log message using LOG_INFO()" );
     REQUIRE( n_callbacks == 3 );
 
     // LOG_XXX() is same as CLOG( ..., "librealsense" )
diff --git a/unit-tests/trace.h b/unit-tests/trace.h
new file mode 100644
index 0000000..f106a3f
--- /dev/null
+++ b/unit-tests/trace.h
@@ -0,0 +1,16 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+
+// Define our own logging macro for debugging to stdout
+// Can possibly turn it on automatically based on the Catch options supplied
+// on the command-line, with a custom main():
+//     Catch::Session catch_session;
+//     int main (int argc, char * const argv[]) {
+//         return catch_session.run( argc, argv );
+//     }
+//     #define TRACE(X) if( catch_session.configData().verbosity == ... ) {}
+// With Catch2, we can turn this into SCOPED_INFO.
+#define TRACE(X) std::cout << (std::string)( librealsense::to_string() << X ) << std::endl
diff --git a/unit-tests/types/rot.h b/unit-tests/types/rot.h
new file mode 100644
index 0000000..96c0585
--- /dev/null
+++ b/unit-tests/types/rot.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#define _USE_MATH_DEFINES
+#include <math.h>
+
+inline
+float3x3 rotx( float a )
+{
+    double rad = a * M_PI / 180.;
+    return { 
+        { 1,      0,               0           },
+        { 0, float(cos(rad)), float(-sin(rad)) },
+        { 0, float(sin(rad)), float(cos(rad))  }
+    };
+}
+
+
+
+
diff --git a/unit-tests/types/test-pose.cpp b/unit-tests/types/test-pose.cpp
new file mode 100644
index 0000000..5ad1714
--- /dev/null
+++ b/unit-tests/types/test-pose.cpp
@@ -0,0 +1,261 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include <easylogging++.h>
+#ifdef BUILD_SHARED_LIBS
+// With static linkage, ELPP is initialized by librealsense, so doing it here will
+// create errors. When we're using the shared .so/.dll, the two are separate and we have
+// to initialize ours if we want to use the APIs!
+INITIALIZE_EASYLOGGINGPP
+#endif
+
+// Let Catch define its own main() function
+#define CATCH_CONFIG_MAIN
+#include "../catch.h"
+
+#include "../approx.h"
+
+//#cmake:add-file ../../src/types.h
+#include <types.h>
+
+using namespace librealsense;
+
+#include "rot.h"
+
+
+TEST_CASE( "pose vs extrinsics", "[types]" )
+{
+    pose const POSE = { { {0,1,2}, {3,4,5}, {6,7,8} }, { 0,0,1 } };
+    rs2_extrinsics const EXTR = { { 0,1,2,3,4,5,6,7,8 }, {0,0,1} };
+
+    // Pose memory layout same exact as extrinsics:
+    CHECK( 0 == memcmp( &POSE, &EXTR, 9 * sizeof( float ) ) );
+    pose p = to_pose( EXTR );
+    CHECK( 0 == memcmp( &p, &EXTR, 9 * sizeof( float ) ) );
+
+    // To/from pose do nothing, really!
+    CHECK( to_pose( EXTR ) == POSE );
+    CHECK( from_pose( POSE ) == EXTR );
+    CHECK( to_pose( from_pose( POSE )) == POSE );
+}
+
+TEST_CASE( "float3x3 operator()", "[types]" )
+{
+    float3x3 m = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
+
+    // column-major, meaning first number is the column!
+    INFO( m );
+    INFO( "(0,0) " << m( 0, 0 ) << " (0,1) " << m( 0, 1 ) << " (0,2) " << m( 0, 2 ) );
+    INFO( "(1,0) " << m( 1, 0 ) << " (1,1) " << m( 1, 1 ) << " (1,2) " << m( 1, 2 ) );
+    INFO( "(2,0) " << m( 2, 0 ) << " (2,1) " << m( 2, 1 ) << " (2,2) " << m( 2, 2 ) );
+
+    CHECK( m( 1, 0 ) == 2 );
+}
+
+
+// These check for approximate equality for the different types
+inline bool eq( float3 const & a, float3 const & b )
+{
+    return a.x == approx( b.x ) && a.y == approx( b.y ) && a.z == approx( b.z );
+}
+inline bool eq( float3x3 const & a, float3x3 const & b )
+{
+    return eq( a.x, b.x ) && eq( a.y, b.y ) && eq( a.z, b.z );
+}
+inline bool eq( pose const & a, pose const & b )
+{
+    return eq( a.orientation, b.orientation ) && eq( a.position, b.position );
+}
+inline bool eq( rs2_extrinsics const & a, rs2_extrinsics const & b )
+{
+    return eq( *(pose const *)&a, *(pose const *)&b );
+}
+
+float dot( float3 const & a, float3 const & b )
+{
+    return a.x * b.x + a.y * b.y + a.z * b.z;
+}
+float3 mult( const float3x3 & a, const float3 & b )
+{
+    // This is the version in the "World's tiniest linear algebra library":
+    //     return a.x*b.x + a.y*b.y + a.z*b.z;
+    // And this is the conventional way:
+    return { dot( a.x,b ), dot( a.y,b ), dot( a.z,b ) };
+}
+
+TEST_CASE( "m*v", "[types]" )
+{
+    float3x3 m = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
+    float3   v = { 1, -2, 3 };
+
+    INFO( m );
+    INFO( v );
+ 
+    // This fails (but shouldn't) with our matrix math:
+    //FAILS:CHECK( m * v == mult( m, v ) );
+
+    // Our math is all transposed! (e.g., see rs2_transform_point_to_point)
+    // So intead we have:
+    CHECK( transpose( m ) * v == mult( m, v ) );
+}
+
+TEST_CASE( "m*v (rotation matrix)", "[types]" )
+{
+    float3x3 m = rotx( 30 );
+    float3   v = { 1, -2, 3 };
+
+    INFO( m );
+    INFO( "(0,0) " << m( 0, 0 ) << " (0,1) " << m( 0, 1 ) << " (0,2) " << m( 0, 2 ) );
+    INFO( "(1,0) " << m( 1, 0 ) << " (1,1) " << m( 1, 1 ) << " (1,2) " << m( 1, 2 ) );
+    INFO( "(2,0) " << m( 2, 0 ) << " (2,1) " << m( 2, 1 ) << " (2,2) " << m( 2, 2 ) );
+ 
+    //FAILS:CHECK( m * v == mult( m, v ) );
+    //FAILS:CHECK_FALSE( transpose( m ) * v == mult( m, v ) );
+}
+
+float determinant( float3x3 const & r )
+{
+    // |A| = aei + bfg + cdh - ceg - bdi - afh
+    return r.x.x * r.y.y * r.z.z  // aei
+        + r.x.y * r.y.z * r.z.x   // bfg
+        + r.x.z * r.y.x * r.z.y   // cdh
+        - r.x.z * r.y.y * r.z.x   // ceg
+        - r.x.y * r.y.x * r.z.z   // bdi
+        - r.x.x * r.y.z * r.z.y;  // afh
+}
+
+TEST_CASE( "rotation matrix", "[types]" )
+{
+    float3x3 I = { {1,0,0}, {0,1,0}, {0,0,1} };
+    float3x3 rot = rotx( 30 );
+
+    // A valid rotation matrix must satisfy:
+    //     transpose(r)*r == identity
+    //     determinant(r) == 1
+    INFO( "\nrot=\n" << rot );
+    INFO( "\nrot_T=\n" << transpose( rot ) );
+    CHECK( transpose( rot ) * rot == I );
+    CHECK( determinant( rot ) == 1 );
+}
+
+/*
+[ux vx wx tx] -1   ( [1 0 0 tx]   [ux vx wx 0] ) -1
+[uy vy wy ty]      ( [0 1 0 ty]   [uy vy wy 0] )
+[uz vz wz tz]    = ( [0 0 1 tz] * [uz vz wz 0] )
+[ 0  0  0  1]      ( [0 0 0  1]   [ 0  0  0 1] )
+
+To place an object at a given position and orientation, you first rotate the object,
+then second translate it to its new position. This corresponds to placing the rotation
+matrix on the right and the translation matrix on the left.
+
+                   [ux vx wx 0] -1   [1 0 0 tx] -1
+                   [uy vy wy 0]      [0 1 0 ty]
+                 = [ux vz wz 0]    * [0 0 1 tz]
+                   [ 0  0  0 1]      [0 0 0  1]
+
+The inverse of a matrix product is the product of the inverse matrices ordered in reverse.
+
+                   [ux uy uz 0]   [1 0 0 -tx]
+                   [vx vy vz 0]   [0 1 0 -ty]
+                 = [wx wy wz 0] * [0 0 1 -tz]
+                   [ 0  0  0 1]   [0 0 0  1 ]
+
+The inverse of a rotation matrix is the rotation matrix's transpose.
+The inverse of a translation matrix is the translation matrix with the opposite signs
+on each of the translation components.
+
+                   [ux uy uz -ux*tx-uy*ty-uz*tz]
+                   [vx vy vz -vx*tx-vy*ty-vz*tz]
+                 = [wx wy wz -wx*tx-wy*ty-wz*tz]
+                   [ 0  0  0          1        ]
+
+                   [ux uy uz -dot(u,t)]
+                   [vx vy vz -dot(v,t)]
+                 = [wx wy wz -dot(w,t)]
+                   [ 0  0  0     1    ]
+*/
+
+pose inv( pose const & p )
+{
+    // This is the version in the "World's tiniest linear algebra library":
+    //     auto inv = transpose(a.orientation); return{ inv, inv * a.position * -1 };
+    // But it's built on a mult that's transposed so in essence the 't' part is wrong:
+    auto ot = transpose( p.orientation );
+    return{ ot, mult( ot, p.position ) * -1 };
+}
+TEST_CASE( "inverse != inv", "[types]" )
+{
+    float3x3 rot = {
+        { 0.999899744987488f,  0.014070882461965f, -0.001586908474565f},
+        {-0.014017328619957f,  0.999457061290741f,  0.029818318784237f},
+        { 0.002005616901442f, -0.029793085530400f,  0.999554097652435f}
+    };
+    float3 tran = { -0.000100966520607471f, 0.013899585723876953f, -0.004260723590850830f };
+
+    auto p = pose{ rot, tran };
+
+    INFO( "\np= " << std::setprecision( 15 ) << p );
+    INFO( "\ninv(p)= " << std::setprecision( 15 ) << inv( p ) );
+    INFO( "\ninverse(p)= " << std::setprecision( 15 ) << inverse( p ) );
+    //FAILS:CHECK( eq( inverse( p ), inv( p ) ) );
+    CHECK_FALSE( eq( inverse( p ), inv( p ) ) );
+}
+
+pose inv2( pose const & p )
+{
+    // This version negates the position before multiplication; should be the same
+    auto ot = transpose( p.orientation );
+    return{ ot, mult( ot, p.position * -1 ) };
+}
+TEST_CASE( "inv == inv2", "[types]" )
+{
+    float3x3 rot = {
+        { 0.999899744987488f,  0.014070882461965f, -0.001586908474565f},
+        {-0.014017328619957f,  0.999457061290741f,  0.029818318784237f},
+        { 0.002005616901442f, -0.029793085530400f,  0.999554097652435f}
+    };
+    float3 tran = { -0.000100966520607471f, 0.013899585723876953f, -0.004260723590850830f };
+    auto p = pose{ rot, tran };
+
+    INFO( "\np= " << std::setprecision( 15 ) << p );
+    INFO( "\ninv(p)= " << std::setprecision( 15 ) << inv( p ) );
+    INFO( "\ninv2(p)= " << std::setprecision( 15 ) << inv2( p ) );
+    CHECK( inv2( p ) == inv( p ) );
+    CHECK( eq( inv2( inv2( p ) ), p ) );
+}
+
+TEST_CASE( "inverse of inverse (not a rot mat)", "[types]" )
+{
+    // the rotation matrix here is not valid (has no inverse)
+    rs2_extrinsics extr{ { 0,1,2,3,4,5,6,7,8 }, {1,2,3} };
+    pose p = to_pose( extr );
+    CHECK_FALSE( inverse( inverse( p ) ) == p );
+}
+
+TEST_CASE( "inverse of inverse (rot mat)", "[types]" )
+{
+    float3x3 rot = rotx( 30 );
+    float3 tran = { -0.100967f, 13.899586f, -4.260724f };
+
+    pose p = { rot, tran };
+
+    INFO( "\np=\n" << std::setprecision( 15 ) << p );
+    INFO( "\ninv(p)=\n" << std::setprecision( 15 ) << inv( p ) );
+    INFO( "\ninv(inv(p))=\n" << inv( inv( p ) ) );
+    INFO( "\ninverse(inverse(p))=\n" << inverse( inverse( p ) ) );
+    CHECK( inverse( inverse( p ) ) == p );
+}
+
+TEST_CASE( "inverse of inverse (extr)", "[types]" )
+{
+    float3x3 rot = {
+        { 0.999899744987488f,  0.014070882461965f, -0.001586908474565f},
+        {-0.014017328619957f,  0.999457061290741f,  0.029818318784237f},
+        { 0.002005616901442f, -0.029793085530400f,  0.999554097652435f}
+    };
+    float3 tran = { -0.000100966520607471f, 0.013899585723876953f, -0.004260723590850830f };
+
+    rs2_extrinsics extr = from_pose( { rot, tran } );
+
+    CHECK( eq( inverse( inverse( extr ) ), extr ) );
+}
diff --git a/unit-tests/unit-test-config.py b/unit-tests/unit-test-config.py
index 0d84919..6a2b615 100644
--- a/unit-tests/unit-test-config.py
+++ b/unit-tests/unit-test-config.py
@@ -15,6 +15,7 @@
 #
 
 import sys, os, subprocess, locale, re
+from glob import glob
 
 if len(sys.argv) != 3:
     ourname = os.path.basename(sys.argv[0])
@@ -51,11 +52,14 @@ def find( dir, mask ):
         if pattern.search( leaf ):
             debug(leaf)
             yield leaf
+
+
 def remove_newlines (lines):
     for line in lines:
         if line[-1] == '\n':
             line = line[:-1]    # excluding the endline
         yield line
+
 def grep_( pattern, lines, context ):
     index = 0
     matches = 0
@@ -73,6 +77,7 @@ def grep_( pattern, lines, context ):
         del context['line']
         del context['match']
     # UnicodeDecodeError can be thrown in binary files
+
 def grep( expr, *args ):
     #debug( f"grep {expr} {args}" )
     pattern = re.compile( expr )
@@ -106,6 +111,28 @@ set_target_properties( ''' + testname + ''' PROPERTIES FOLDER "Unit-Tests/''' +
 
 ''' )
     handle.close()
+
+# Recursively searches a .cpp file for #include directives and returns
+# a set of all of them.
+#
+# Only directives that are relative to the current path (#include "<path>")
+# are looked for!
+#
+def find_includes( filepath ):
+    filelist = set()
+    filedir = os.path.dirname(filepath)
+    for context in grep( '^\s*#\s*include\s+"(.*)"\s*$', filepath ):
+        m = context['match']
+        index = context['index']
+        include = m.group(1)
+        if not os.path.isabs( include ):
+            include = os.path.normpath( filedir + '/' + include )
+        include = include.replace( '\\', '/' )
+        if os.path.exists( include ):
+            filelist.add( include )
+            filelist |= find_includes( include )
+    return filelist
+
 def process_cpp( dir, builddir ):
     found = []
     shareds = []
@@ -120,6 +147,8 @@ def process_cpp( dir, builddir ):
         # Build the list of files we want in the project:
         # At a minimum, we have the original file, plus any common files
         filelist = [ dir + '/' + f, '${ELPP_FILES}', '${CATCH_FILES}' ]
+        # Add any "" includes specified in the .cpp that we can find
+        includes = find_includes( dir + '/' + f )
         # Add any files explicitly listed in the .cpp itself, like this:
         #         //#cmake:add-file <filename>
         # Any files listed are relative to $dir
@@ -131,15 +160,22 @@ def process_cpp( dir, builddir ):
             cmd, *rest = context['line'][m.end():].split()
             if cmd == 'add-file':
                 for additional_file in rest:
-                    abs_file = additional_file
+                    files = additional_file
                     if not os.path.isabs( additional_file ):
-                        abs_file = os.path.normpath( dir + '/' + testparent + '/' + additional_file )
-                    abs_file = abs_file.replace( '\\', '/' )
-                    if not os.path.exists( abs_file ):
-                        error( f + '+' + str(index) + ': file not found "' + additional_file + '"' )
-                    else:
+                        files = dir + '/' + testparent + '/' + additional_file
+                    files = glob( files )
+                    if not files:
+                        error( f + '+' + str(index) + ': no files match "' + additional_file + '"' )
+                    for abs_file in files:
+                        abs_file = os.path.normpath( abs_file )
+                        abs_file = abs_file.replace( '\\', '/' )
+                        if not os.path.exists( abs_file ):
+                            error( f + '+' + str(index) + ': file not found "' + additional_file + '"' )
                         debug( '   add file:', abs_file )
                         filelist.append( abs_file )
+                        if( os.path.splitext( abs_file )[0] == 'cpp' ):
+                            # Add any "" includes specified in the .cpp that we can find
+                            includes |= find_includes( abs_file )
             elif cmd == 'static!':
                 if len(rest):
                     error( f + '+' + str(index) + ': unexpected arguments past \'' + cmd + '\'' )
@@ -156,6 +192,8 @@ def process_cpp( dir, builddir ):
                     shared = True
             else:
                 error( f + '+' + str(index) + ': unknown cmd \'' + cmd + '\' (should be \'add-file\', \'static!\', or \'shared!\')' )
+        for include in includes:
+            filelist.append( include )
         generate_cmake( builddir, testdir, testname, filelist )
         if static:
             statics.append( testdir )
diff --git a/unit-tests/unit-tests-common.h b/unit-tests/unit-tests-common.h
index 8f322c3..28b5f99 100644
--- a/unit-tests/unit-tests-common.h
+++ b/unit-tests/unit-tests-common.h
@@ -1,10 +1,11 @@
 // License: Apache 2.0. See LICENSE file in root directory.
 // Copyright(c) 2015 Intel Corporation. All Rights Reserved.
+
 #pragma once
 #ifndef LIBREALSENSE_UNITTESTS_COMMON_H
 #define LIBREALSENSE_UNITTESTS_COMMON_H
 
-#include "catch/catch.hpp"
+#include "approx.h"
 #include "../include/librealsense2/rs.hpp"
 #include "../include/librealsense2/hpp/rs_context.hpp"
 #include "../include/librealsense2/hpp/rs_internal.hpp"
@@ -426,9 +427,9 @@ inline float vector_length(const float(&v)[3])
 // Require that r = cross(a, b)
 inline void require_cross_product(const float(&r)[3], const float(&a)[3], const float(&b)[3])
 {
-    REQUIRE(r[0] == Approx(a[1] * b[2] - a[2] * b[1]));
-    REQUIRE(r[1] == Approx(a[2] * b[0] - a[0] * b[2]));
-    REQUIRE(r[2] == Approx(a[0] * b[1] - a[1] * b[0]));
+    REQUIRE(r[0] == approx(a[1] * b[2] - a[2] * b[1]));
+    REQUIRE(r[1] == approx(a[2] * b[0] - a[0] * b[2]));
+    REQUIRE(r[2] == approx(a[0] * b[1] - a[1] * b[0]));
 }
 
 // Require that vector is exactly the zero vector
@@ -440,15 +441,15 @@ inline void require_zero_vector(const float(&vector)[3])
 // Require that a == transpose(b)
 inline void require_transposed(const float(&a)[9], const float(&b)[9])
 {
-    REQUIRE(a[0] == Approx(b[0]));
-    REQUIRE(a[1] == Approx(b[3]));
-    REQUIRE(a[2] == Approx(b[6]));
-    REQUIRE(a[3] == Approx(b[1]));
-    REQUIRE(a[4] == Approx(b[4]));
-    REQUIRE(a[5] == Approx(b[7]));
-    REQUIRE(a[6] == Approx(b[2]));
-    REQUIRE(a[7] == Approx(b[5]));
-    REQUIRE(a[8] == Approx(b[8]));
+    REQUIRE(a[0] == approx(b[0]));
+    REQUIRE(a[1] == approx(b[3]));
+    REQUIRE(a[2] == approx(b[6]));
+    REQUIRE(a[3] == approx(b[1]));
+    REQUIRE(a[4] == approx(b[4]));
+    REQUIRE(a[5] == approx(b[7]));
+    REQUIRE(a[6] == approx(b[2]));
+    REQUIRE(a[7] == approx(b[5]));
+    REQUIRE(a[8] == approx(b[8]));
 }
 
 // Require that matrix is an orthonormal 3x3 matrix
@@ -457,21 +458,23 @@ inline void require_rotation_matrix(const float(&matrix)[9])
     const float row0[] = { matrix[0], matrix[3], matrix[6] };
     const float row1[] = { matrix[1], matrix[4], matrix[7] };
     const float row2[] = { matrix[2], matrix[5], matrix[8] };
-    CAPTURE(row0[0]);
-    CAPTURE(row0[1]);
-    CAPTURE(row0[2]);
-    CAPTURE(row1[0]);
-    CAPTURE(row1[1]);
-    CAPTURE(row1[2]);
-    CAPTURE(row2[0]);
-    CAPTURE(row2[1]);
-    CAPTURE(row2[2]);
-    REQUIRE(dot_product(row0, row0) == Approx(1));
-    REQUIRE(dot_product(row1, row1) == Approx(1));
-    REQUIRE(dot_product(row2, row2) == Approx(1));
-    REQUIRE(dot_product(row0, row1) == Approx(0));
-    REQUIRE(dot_product(row1, row2) == Approx(0));
-    REQUIRE(dot_product(row2, row0) == Approx(0));
+    CAPTURE( full_precision( row0[0] ));
+    CAPTURE( full_precision( row0[1] ));
+    CAPTURE( full_precision( row0[2] ));
+    CAPTURE( full_precision( row1[0] ));
+    CAPTURE( full_precision( row1[1] ));
+    CAPTURE( full_precision( row1[2] ));
+    CAPTURE( full_precision( row2[0] ));
+    CAPTURE( full_precision( row2[1] ));
+    CAPTURE( full_precision( row2[2] ));
+    CHECK(dot_product(row0, row0) == approx(1.f));
+    CAPTURE( full_precision( dot_product( row1, row1 )));
+    CHECK( dot_product( row1, row1 ) == approx( 1.f ) );     // this line is problematic, and needs higher epsilon!!
+    CHECK_THAT(dot_product(row1, row1), approx_equals(1.f));
+    CHECK(dot_product(row2, row2) == approx(1.f));
+    CHECK(dot_product(row0, row1) == approx(0.f));
+    CHECK(dot_product(row1, row2) == approx(0.f));
+    CHECK(dot_product(row2, row0) == approx(0.f));
     require_cross_product(row0, row1, row2);
     require_cross_product(row0, row1, row2);
     require_cross_product(row0, row1, row2);
@@ -481,7 +484,8 @@ inline void require_rotation_matrix(const float(&matrix)[9])
 inline void require_identity_matrix(const float(&matrix)[9])
 {
     static const float identity_matrix_3x3[] = { 1,0,0, 0,1,0, 0,0,1 };
-    for (int i = 0; i < 9; ++i) REQUIRE(matrix[i] == Approx(identity_matrix_3x3[i]));
+    for (int i = 0; i < 9; ++i)
+        REQUIRE(matrix[i] == approx(identity_matrix_3x3[i]));
 }
 
 struct test_duration {
diff --git a/unit-tests/unit-tests-internal.cpp b/unit-tests/unit-tests-internal.cpp
index 03dc87e..23405dd 100644
--- a/unit-tests/unit-tests-internal.cpp
+++ b/unit-tests/unit-tests-internal.cpp
@@ -688,9 +688,9 @@ TEST_CASE("Extrinsic transformation between two streams is a rigid transform", "
                     REQUIRE_NOTHROW(b_to_a = profs_b[0].get_extrinsics_to(profs_a[0]));
 
                     require_transposed(a_to_b.rotation, b_to_a.rotation);
-                    REQUIRE(b_to_a.rotation[0] * a_to_b.translation[0] + b_to_a.rotation[3] * a_to_b.translation[1] + b_to_a.rotation[6] * a_to_b.translation[2] == Approx(-b_to_a.translation[0]));
-                    REQUIRE(b_to_a.rotation[1] * a_to_b.translation[0] + b_to_a.rotation[4] * a_to_b.translation[1] + b_to_a.rotation[7] * a_to_b.translation[2] == Approx(-b_to_a.translation[1]));
-                    REQUIRE(b_to_a.rotation[2] * a_to_b.translation[0] + b_to_a.rotation[5] * a_to_b.translation[1] + b_to_a.rotation[8] * a_to_b.translation[2] == Approx(-b_to_a.translation[2]));
+                    REQUIRE(b_to_a.rotation[0] * a_to_b.translation[0] + b_to_a.rotation[3] * a_to_b.translation[1] + b_to_a.rotation[6] * a_to_b.translation[2] == approx(-b_to_a.translation[0]));
+                    REQUIRE(b_to_a.rotation[1] * a_to_b.translation[0] + b_to_a.rotation[4] * a_to_b.translation[1] + b_to_a.rotation[7] * a_to_b.translation[2] == approx(-b_to_a.translation[1]));
+                    REQUIRE(b_to_a.rotation[2] * a_to_b.translation[0] + b_to_a.rotation[5] * a_to_b.translation[1] + b_to_a.rotation[8] * a_to_b.translation[2] == approx(-b_to_a.translation[2]));
                 }
             }
         }
@@ -744,20 +744,20 @@ TEST_CASE("Extrinsic transformations are transitive", "[live]")
                         }
 
                         // a_to_c.rotation == a_to_b.rotation * b_to_c.rotation
-                        REQUIRE(a_to_c.rotation[0] == Approx(a_to_b.rotation[0] * b_to_c.rotation[0] + a_to_b.rotation[3] * b_to_c.rotation[1] + a_to_b.rotation[6] * b_to_c.rotation[2]));
-                        REQUIRE(a_to_c.rotation[2] == Approx(a_to_b.rotation[2] * b_to_c.rotation[0] + a_to_b.rotation[5] * b_to_c.rotation[1] + a_to_b.rotation[8] * b_to_c.rotation[2]));
-                        REQUIRE(a_to_c.rotation[1] == Approx(a_to_b.rotation[1] * b_to_c.rotation[0] + a_to_b.rotation[4] * b_to_c.rotation[1] + a_to_b.rotation[7] * b_to_c.rotation[2]));
-                        REQUIRE(a_to_c.rotation[3] == Approx(a_to_b.rotation[0] * b_to_c.rotation[3] + a_to_b.rotation[3] * b_to_c.rotation[4] + a_to_b.rotation[6] * b_to_c.rotation[5]));
-                        REQUIRE(a_to_c.rotation[4] == Approx(a_to_b.rotation[1] * b_to_c.rotation[3] + a_to_b.rotation[4] * b_to_c.rotation[4] + a_to_b.rotation[7] * b_to_c.rotation[5]));
-                        REQUIRE(a_to_c.rotation[5] == Approx(a_to_b.rotation[2] * b_to_c.rotation[3] + a_to_b.rotation[5] * b_to_c.rotation[4] + a_to_b.rotation[8] * b_to_c.rotation[5]));
-                        REQUIRE(a_to_c.rotation[6] == Approx(a_to_b.rotation[0] * b_to_c.rotation[6] + a_to_b.rotation[3] * b_to_c.rotation[7] + a_to_b.rotation[6] * b_to_c.rotation[8]));
-                        REQUIRE(a_to_c.rotation[7] == Approx(a_to_b.rotation[1] * b_to_c.rotation[6] + a_to_b.rotation[4] * b_to_c.rotation[7] + a_to_b.rotation[7] * b_to_c.rotation[8]));
-                        REQUIRE(a_to_c.rotation[8] == Approx(a_to_b.rotation[2] * b_to_c.rotation[6] + a_to_b.rotation[5] * b_to_c.rotation[7] + a_to_b.rotation[8] * b_to_c.rotation[8]));
+                        REQUIRE(a_to_c.rotation[0] == approx(a_to_b.rotation[0] * b_to_c.rotation[0] + a_to_b.rotation[3] * b_to_c.rotation[1] + a_to_b.rotation[6] * b_to_c.rotation[2]));
+                        REQUIRE(a_to_c.rotation[2] == approx(a_to_b.rotation[2] * b_to_c.rotation[0] + a_to_b.rotation[5] * b_to_c.rotation[1] + a_to_b.rotation[8] * b_to_c.rotation[2]));
+                        REQUIRE(a_to_c.rotation[1] == approx(a_to_b.rotation[1] * b_to_c.rotation[0] + a_to_b.rotation[4] * b_to_c.rotation[1] + a_to_b.rotation[7] * b_to_c.rotation[2]));
+                        REQUIRE(a_to_c.rotation[3] == approx(a_to_b.rotation[0] * b_to_c.rotation[3] + a_to_b.rotation[3] * b_to_c.rotation[4] + a_to_b.rotation[6] * b_to_c.rotation[5]));
+                        REQUIRE(a_to_c.rotation[4] == approx(a_to_b.rotation[1] * b_to_c.rotation[3] + a_to_b.rotation[4] * b_to_c.rotation[4] + a_to_b.rotation[7] * b_to_c.rotation[5]));
+                        REQUIRE(a_to_c.rotation[5] == approx(a_to_b.rotation[2] * b_to_c.rotation[3] + a_to_b.rotation[5] * b_to_c.rotation[4] + a_to_b.rotation[8] * b_to_c.rotation[5]));
+                        REQUIRE(a_to_c.rotation[6] == approx(a_to_b.rotation[0] * b_to_c.rotation[6] + a_to_b.rotation[3] * b_to_c.rotation[7] + a_to_b.rotation[6] * b_to_c.rotation[8]));
+                        REQUIRE(a_to_c.rotation[7] == approx(a_to_b.rotation[1] * b_to_c.rotation[6] + a_to_b.rotation[4] * b_to_c.rotation[7] + a_to_b.rotation[7] * b_to_c.rotation[8]));
+                        REQUIRE(a_to_c.rotation[8] == approx(a_to_b.rotation[2] * b_to_c.rotation[6] + a_to_b.rotation[5] * b_to_c.rotation[7] + a_to_b.rotation[8] * b_to_c.rotation[8]));
 
                         // a_to_c.translation = a_to_b.transform(b_to_c.translation)
-                        REQUIRE(a_to_c.translation[0] == Approx(a_to_b.rotation[0] * b_to_c.translation[0] + a_to_b.rotation[3] * b_to_c.translation[1] + a_to_b.rotation[6] * b_to_c.translation[2] + a_to_b.translation[0]));
-                        REQUIRE(a_to_c.translation[1] == Approx(a_to_b.rotation[1] * b_to_c.translation[0] + a_to_b.rotation[4] * b_to_c.translation[1] + a_to_b.rotation[7] * b_to_c.translation[2] + a_to_b.translation[1]));
-                        REQUIRE(a_to_c.translation[2] == Approx(a_to_b.rotation[2] * b_to_c.translation[0] + a_to_b.rotation[5] * b_to_c.translation[1] + a_to_b.rotation[8] * b_to_c.translation[2] + a_to_b.translation[2]));
+                        REQUIRE(a_to_c.translation[0] == approx(a_to_b.rotation[0] * b_to_c.translation[0] + a_to_b.rotation[3] * b_to_c.translation[1] + a_to_b.rotation[6] * b_to_c.translation[2] + a_to_b.translation[0]));
+                        REQUIRE(a_to_c.translation[1] == approx(a_to_b.rotation[1] * b_to_c.translation[0] + a_to_b.rotation[4] * b_to_c.translation[1] + a_to_b.rotation[7] * b_to_c.translation[2] + a_to_b.translation[1]));
+                        REQUIRE(a_to_c.translation[2] == approx(a_to_b.rotation[2] * b_to_c.translation[0] + a_to_b.rotation[5] * b_to_c.translation[1] + a_to_b.rotation[8] * b_to_c.translation[2] + a_to_b.translation[2]));
                     }
                 }
             }
@@ -1478,9 +1478,9 @@ TEST_CASE("Check option API", "[live][options]")
                         REQUIRE(value <= range.max);
 
                         // value doesn't change between two gets (if no additional threads are calling set)
-                        REQUIRE(dev.get_option(opt) == Approx(value));
+                        REQUIRE(dev.get_option(opt) == approx(value));
 
-                        // REQUIRE(value == Approx(range.def)); // Not sure if this is a reasonable check
+                        // REQUIRE(value == approx(range.def)); // Not sure if this is a reasonable check
                         // TODO: make sure value == range.min + k*range.step for some k?
                     }
                 }
@@ -1524,15 +1524,15 @@ TEST_CASE("Check option API", "[live][options]")
 
                     // setting a valid value lets you get that value back
                     dev.set_option(opt, range.min);
-                    REQUIRE(dev.get_option(opt) == Approx(range.min));
+                    REQUIRE(dev.get_option(opt) == approx(range.min));
 
                     // setting an invalid value returns the last set valid value.
                     REQUIRE_THROWS(dev.set_option(opt, range.max + range.step));
-                    REQUIRE(dev.get_option(opt) == Approx(range.min));
+                    REQUIRE(dev.get_option(opt) == approx(range.min));
 
                     dev.set_option(opt, range.max);
                     REQUIRE_THROWS(dev.set_option(opt, range.min - range.step));
-                    REQUIRE(dev.get_option(opt) == Approx(range.max));
+                    REQUIRE(dev.get_option(opt) == approx(range.max));
 
                 }
                 SECTION("get_description returns a non-empty, non-null string") {
diff --git a/unit-tests/unit-tests-live.cpp b/unit-tests/unit-tests-live.cpp
index 7a73f6c..8ba70c4 100644
--- a/unit-tests/unit-tests-live.cpp
+++ b/unit-tests/unit-tests-live.cpp
@@ -614,9 +614,9 @@ TEST_CASE("Extrinsic transformation between two streams is a rigid transform", "
                     REQUIRE_NOTHROW(b_to_a = profs_b[0].get_extrinsics_to(profs_a[0]));
 
                     require_transposed(a_to_b.rotation, b_to_a.rotation);
-                    REQUIRE(b_to_a.rotation[0] * a_to_b.translation[0] + b_to_a.rotation[3] * a_to_b.translation[1] + b_to_a.rotation[6] * a_to_b.translation[2] == Approx(-b_to_a.translation[0]));
-                    REQUIRE(b_to_a.rotation[1] * a_to_b.translation[0] + b_to_a.rotation[4] * a_to_b.translation[1] + b_to_a.rotation[7] * a_to_b.translation[2] == Approx(-b_to_a.translation[1]));
-                    REQUIRE(b_to_a.rotation[2] * a_to_b.translation[0] + b_to_a.rotation[5] * a_to_b.translation[1] + b_to_a.rotation[8] * a_to_b.translation[2] == Approx(-b_to_a.translation[2]));
+                    REQUIRE(b_to_a.rotation[0] * a_to_b.translation[0] + b_to_a.rotation[3] * a_to_b.translation[1] + b_to_a.rotation[6] * a_to_b.translation[2] == approx(-b_to_a.translation[0]));
+                    REQUIRE(b_to_a.rotation[1] * a_to_b.translation[0] + b_to_a.rotation[4] * a_to_b.translation[1] + b_to_a.rotation[7] * a_to_b.translation[2] == approx(-b_to_a.translation[1]));
+                    REQUIRE(b_to_a.rotation[2] * a_to_b.translation[0] + b_to_a.rotation[5] * a_to_b.translation[1] + b_to_a.rotation[8] * a_to_b.translation[2] == approx(-b_to_a.translation[2]));
                 }
             }
         }
@@ -671,20 +671,20 @@ TEST_CASE("Extrinsic transformations are transitive", "[live]")
 
                         // a_to_c.rotation == a_to_b.rotation * b_to_c.rotation
                         auto&& epsilon = 0.0001;
-                        REQUIRE(a_to_c.rotation[0] == Approx((float)(a_to_b.rotation[0] * b_to_c.rotation[0] + a_to_b.rotation[3] * b_to_c.rotation[1] + a_to_b.rotation[6] * b_to_c.rotation[2])).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[2] == Approx(a_to_b.rotation[2] * b_to_c.rotation[0] + a_to_b.rotation[5] * b_to_c.rotation[1] + a_to_b.rotation[8] * b_to_c.rotation[2]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[1] == Approx(a_to_b.rotation[1] * b_to_c.rotation[0] + a_to_b.rotation[4] * b_to_c.rotation[1] + a_to_b.rotation[7] * b_to_c.rotation[2]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[3] == Approx(a_to_b.rotation[0] * b_to_c.rotation[3] + a_to_b.rotation[3] * b_to_c.rotation[4] + a_to_b.rotation[6] * b_to_c.rotation[5]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[4] == Approx(a_to_b.rotation[1] * b_to_c.rotation[3] + a_to_b.rotation[4] * b_to_c.rotation[4] + a_to_b.rotation[7] * b_to_c.rotation[5]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[5] == Approx(a_to_b.rotation[2] * b_to_c.rotation[3] + a_to_b.rotation[5] * b_to_c.rotation[4] + a_to_b.rotation[8] * b_to_c.rotation[5]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[6] == Approx(a_to_b.rotation[0] * b_to_c.rotation[6] + a_to_b.rotation[3] * b_to_c.rotation[7] + a_to_b.rotation[6] * b_to_c.rotation[8]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[7] == Approx(a_to_b.rotation[1] * b_to_c.rotation[6] + a_to_b.rotation[4] * b_to_c.rotation[7] + a_to_b.rotation[7] * b_to_c.rotation[8]).epsilon(epsilon));
-                        REQUIRE(a_to_c.rotation[8] == Approx(a_to_b.rotation[2] * b_to_c.rotation[6] + a_to_b.rotation[5] * b_to_c.rotation[7] + a_to_b.rotation[8] * b_to_c.rotation[8]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[0] == approx((float)(a_to_b.rotation[0] * b_to_c.rotation[0] + a_to_b.rotation[3] * b_to_c.rotation[1] + a_to_b.rotation[6] * b_to_c.rotation[2])).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[2] == approx(a_to_b.rotation[2] * b_to_c.rotation[0] + a_to_b.rotation[5] * b_to_c.rotation[1] + a_to_b.rotation[8] * b_to_c.rotation[2]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[1] == approx(a_to_b.rotation[1] * b_to_c.rotation[0] + a_to_b.rotation[4] * b_to_c.rotation[1] + a_to_b.rotation[7] * b_to_c.rotation[2]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[3] == approx(a_to_b.rotation[0] * b_to_c.rotation[3] + a_to_b.rotation[3] * b_to_c.rotation[4] + a_to_b.rotation[6] * b_to_c.rotation[5]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[4] == approx(a_to_b.rotation[1] * b_to_c.rotation[3] + a_to_b.rotation[4] * b_to_c.rotation[4] + a_to_b.rotation[7] * b_to_c.rotation[5]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[5] == approx(a_to_b.rotation[2] * b_to_c.rotation[3] + a_to_b.rotation[5] * b_to_c.rotation[4] + a_to_b.rotation[8] * b_to_c.rotation[5]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[6] == approx(a_to_b.rotation[0] * b_to_c.rotation[6] + a_to_b.rotation[3] * b_to_c.rotation[7] + a_to_b.rotation[6] * b_to_c.rotation[8]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[7] == approx(a_to_b.rotation[1] * b_to_c.rotation[6] + a_to_b.rotation[4] * b_to_c.rotation[7] + a_to_b.rotation[7] * b_to_c.rotation[8]).epsilon(epsilon));
+                        REQUIRE(a_to_c.rotation[8] == approx(a_to_b.rotation[2] * b_to_c.rotation[6] + a_to_b.rotation[5] * b_to_c.rotation[7] + a_to_b.rotation[8] * b_to_c.rotation[8]).epsilon(epsilon));
 
                         // a_to_c.translation = a_to_b.transform(b_to_c.translation)
-                        REQUIRE(a_to_c.translation[0] == Approx(a_to_b.rotation[0] * b_to_c.translation[0] + a_to_b.rotation[3] * b_to_c.translation[1] + a_to_b.rotation[6] * b_to_c.translation[2] + a_to_b.translation[0]).epsilon(epsilon));
-                        REQUIRE(a_to_c.translation[1] == Approx(a_to_b.rotation[1] * b_to_c.translation[0] + a_to_b.rotation[4] * b_to_c.translation[1] + a_to_b.rotation[7] * b_to_c.translation[2] + a_to_b.translation[1]).epsilon(epsilon));
-                        REQUIRE(a_to_c.translation[2] == Approx(a_to_b.rotation[2] * b_to_c.translation[0] + a_to_b.rotation[5] * b_to_c.translation[1] + a_to_b.rotation[8] * b_to_c.translation[2] + a_to_b.translation[2]).epsilon(epsilon));
+                        REQUIRE(a_to_c.translation[0] == approx(a_to_b.rotation[0] * b_to_c.translation[0] + a_to_b.rotation[3] * b_to_c.translation[1] + a_to_b.rotation[6] * b_to_c.translation[2] + a_to_b.translation[0]).epsilon(epsilon));
+                        REQUIRE(a_to_c.translation[1] == approx(a_to_b.rotation[1] * b_to_c.translation[0] + a_to_b.rotation[4] * b_to_c.translation[1] + a_to_b.rotation[7] * b_to_c.translation[2] + a_to_b.translation[1]).epsilon(epsilon));
+                        REQUIRE(a_to_c.translation[2] == approx(a_to_b.rotation[2] * b_to_c.translation[0] + a_to_b.rotation[5] * b_to_c.translation[1] + a_to_b.rotation[8] * b_to_c.translation[2] + a_to_b.translation[2]).epsilon(epsilon));
                     }
                 }
             }
@@ -1396,7 +1396,7 @@ TEST_CASE("get_active_streams sanity check", "[live]")
             for (size_t bits=(1 << n_streams)-1; bits>0; --bits) {
                 std::vector<rs2::stream_profile> opened_profiles;
                 for (int i = 0; i < n_streams; ++i) {
-                    if (bits&(1 << i)) opened_profiles.push_back(profiles[i]);
+                    if (bits&(1ULL << i)) opened_profiles.push_back(profiles[i]);
                 }
                 REQUIRE_NOTHROW(sensor.open(opened_profiles));
                 std::vector<rs2::stream_profile> reported_profiles;
@@ -1469,9 +1469,9 @@ TEST_CASE("Check option API", "[live][options]")
                         REQUIRE(value <= range.max);
 
                         // value doesn't change between two gets (if no additional threads are calling set)
-                        REQUIRE(dev.get_option(opt) == Approx(value));
+                        REQUIRE(dev.get_option(opt) == approx(value));
 
-                        // REQUIRE(value == Approx(range.def)); // Not sure if this is a reasonable check
+                        // REQUIRE(value == approx(range.def)); // Not sure if this is a reasonable check
                         // TODO: make sure value == range.min + k*range.step for some k?
                     }
                 }
@@ -1515,15 +1515,15 @@ TEST_CASE("Check option API", "[live][options]")
 
                     // setting a valid value lets you get that value back
                     dev.set_option(opt, range.min);
-                    REQUIRE(dev.get_option(opt) == Approx(range.min));
+                    REQUIRE(dev.get_option(opt) == approx(range.min));
 
                     // setting an invalid value returns the last set valid value.
                     REQUIRE_THROWS(dev.set_option(opt, range.max + range.step));
-                    REQUIRE(dev.get_option(opt) == Approx(range.min));
+                    REQUIRE(dev.get_option(opt) == approx(range.min));
 
                     dev.set_option(opt, range.max);
                     REQUIRE_THROWS(dev.set_option(opt, range.min - range.step));
-                    REQUIRE(dev.get_option(opt) == Approx(range.max));
+                    REQUIRE(dev.get_option(opt) == approx(range.max));
 
                 }
                 SECTION("get_description returns a non-empty, non-null string") {
@@ -2980,7 +2980,7 @@ static const std::map< dev_type, device_profiles> pipeline_default_configuration
 /* SR300*/              { { "0AA5", true } ,{ { { RS2_STREAM_DEPTH, RS2_FORMAT_Z16, 640, 480, 0 },{ RS2_STREAM_COLOR, RS2_FORMAT_RGB8, 1920, 1080, 0 } }, 30, true } },
 };
 
-TEST_CASE("Pipeline wait_for_frames", "[live][pipeline][using_pipeline]") {
+TEST_CASE("Pipeline wait_for_frames", "[live][pipeline][using_pipeline][!mayfail]") {
 
     rs2::context ctx;
 
@@ -3046,7 +3046,7 @@ TEST_CASE("Pipeline wait_for_frames", "[live][pipeline][using_pipeline]") {
     }
 }
 
-TEST_CASE("Pipeline poll_for_frames", "[live][pipeline][using_pipeline]")
+TEST_CASE("Pipeline poll_for_frames", "[live][pipeline][using_pipeline][!mayfail]")
 {
     rs2::context ctx;
 
@@ -3311,7 +3311,7 @@ TEST_CASE("Pipeline enable stream auto complete", "[live][pipeline][using_pipeli
     }
 }
 
-TEST_CASE("Pipeline disable_all", "[live][pipeline][using_pipeline]") {
+TEST_CASE("Pipeline disable_all", "[live][pipeline][using_pipeline][!mayfail]") {
 
     auto not_default_configurations = pipeline_custom_configurations;
     auto default_configurations = pipeline_default_configurations;
@@ -4442,7 +4442,7 @@ TEST_CASE("Empty Pipeline Profile", "[live][pipeline][using_pipeline]") {
 
     if (make_context(SECTION_FROM_TEST_NAME, &ctx, "2.13.0"))
     {
-        REQUIRE_NOTHROW(rs2::pipeline_profile p);
+        REQUIRE_NOTHROW(rs2::pipeline_profile());
         rs2::pipeline_profile prof;
         REQUIRE_FALSE(prof);
         rs2::device dev;
@@ -4520,7 +4520,7 @@ TEST_CASE("Pipeline empty Config", "[live][pipeline][using_pipeline]") {
 
     if (make_context(SECTION_FROM_TEST_NAME, &ctx, "2.13.0"))
     {
-        REQUIRE_NOTHROW(rs2::config c);
+        REQUIRE_NOTHROW(rs2::config());
         //Empty config
         rs2::pipeline p(ctx);
         rs2::config c1;
@@ -4541,8 +4541,6 @@ TEST_CASE("Pipeline 2 Configs", "[live][pipeline][using_pipeline]") {
     if (make_context(SECTION_FROM_TEST_NAME, &ctx, "2.13.0"))
     {
         rs2::pipeline p(ctx);
-        REQUIRE_NOTHROW(rs2::config c1);
-        REQUIRE_NOTHROW(rs2::config c2);
         rs2::config c1;
         rs2::config c2;
         bool can_resolve1 = false;
@@ -4732,7 +4730,7 @@ TEST_CASE("Pipeline stream enable hierarchy", "[pipeline]")
     }
 }
 
-TEST_CASE("Pipeline stream with callback", "[live][pipeline][using_pipeline]")
+TEST_CASE("Pipeline stream with callback", "[live][pipeline][using_pipeline][!mayfail]")
 {
     rs2::context ctx;
 
@@ -5636,7 +5634,7 @@ TEST_CASE("Positional_Sensors_API", "[live]")
         {
             CAPTURE(dev);
             REQUIRE(dev.is<rs2::tm2>());
-            REQUIRE_NOTHROW(auto tmp_pos = dev.first<rs2::pose_sensor>());
+            REQUIRE_NOTHROW(dev.first<rs2::pose_sensor>());
             auto pose_snr = dev.first<rs2::pose_sensor>();
             CAPTURE(pose_snr);
             REQUIRE(pose_snr);
@@ -5725,13 +5723,13 @@ TEST_CASE("Positional_Sensors_API", "[live]")
                     CAPTURE(vnv_pose);
                     CAPTURE(vnv_or);
                     CAPTURE(res);
-                    REQUIRE(test_pose.x == Approx(vnv_pose.x));
-                    REQUIRE(test_pose.y == Approx(vnv_pose.y));
-                    REQUIRE(test_pose.z == Approx(vnv_pose.z));
-                    REQUIRE(test_or.x == Approx(vnv_or.x));
-                    REQUIRE(test_or.y == Approx(vnv_or.y));
-                    REQUIRE(test_or.z == Approx(vnv_or.z));
-                    REQUIRE(test_or.w == Approx(vnv_or.w));
+                    REQUIRE(test_pose.x == approx(vnv_pose.x));
+                    REQUIRE(test_pose.y == approx(vnv_pose.y));
+                    REQUIRE(test_pose.z == approx(vnv_pose.z));
+                    REQUIRE(test_or.x == approx(vnv_or.x));
+                    REQUIRE(test_or.y == approx(vnv_or.y));
+                    REQUIRE(test_or.z == approx(vnv_or.z));
+                    REQUIRE(test_or.w == approx(vnv_or.w));
 
                     REQUIRE_NOTHROW(res = pose_snr.remove_static_node("wp1"));
                     REQUIRE_NOTHROW(!(res = pose_snr.remove_static_node("wp1")));
@@ -5832,7 +5830,7 @@ TEST_CASE("Wheel_Odometry_API", "[live]")
 }
 
 
-TEST_CASE("get_sensor_from_frame", "[live][using_pipeline]")
+TEST_CASE("get_sensor_from_frame", "[live][using_pipeline][!mayfail]")
 {
     // Require at least one device to be plugged in
     rs2::context ctx;
@@ -5937,8 +5935,8 @@ TEST_CASE("l500_presets_set_preset", "[live]")
             std::vector<int> resolutions{ RS2_SENSOR_MODE_XGA, RS2_SENSOR_MODE_VGA };
             for (auto res : resolutions)
             {
-                ds.set_option(RS2_OPTION_SENSOR_MODE, res);
-                ds.set_option(RS2_OPTION_VISUAL_PRESET, i.first);
+                ds.set_option(RS2_OPTION_SENSOR_MODE, (float)res);
+                ds.set_option(RS2_OPTION_VISUAL_PRESET, (float)i.first);
                 CAPTURE(ds.get_option(RS2_OPTION_AMBIENT_LIGHT));
                 REQUIRE(ds.get_option(RS2_OPTION_AMBIENT_LIGHT) == i.second);
                 apd_per_ambient[ds.get_option(RS2_OPTION_AMBIENT_LIGHT)] = ds.get_option(RS2_OPTION_AVALANCHE_PHOTO_DIODE);
diff --git a/unit-tests/unit-tests-main.cpp b/unit-tests/unit-tests-main.cpp
index 863fe4f..0fc866f 100644
--- a/unit-tests/unit-tests-main.cpp
+++ b/unit-tests/unit-tests-main.cpp
@@ -1,5 +1,4 @@
 #define CATCH_CONFIG_RUNNER
-#include "catch/catch.hpp"
 #include "unit-tests-common.h"
 #include <iostream>
 
diff --git a/unit-tests/unit-tests-post-processing.cpp b/unit-tests/unit-tests-post-processing.cpp
index 13ed62b..e2c4527 100644
--- a/unit-tests/unit-tests-post-processing.cpp
+++ b/unit-tests/unit-tests-post-processing.cpp
@@ -654,15 +654,15 @@ TEST_CASE("Align Processing Block", "[live][pipeline][post-processing-filters][!
             const auto align_dpt_intr = aligned_dpth_video_pf.get_intrinsics();
             for (auto i = 0; i < 5; i++)
             {
-                REQUIRE(ref_intr.coeffs[i] == Approx(align_dpt_intr.coeffs[i]));
+                REQUIRE(ref_intr.coeffs[i] == approx(align_dpt_intr.coeffs[i]));
             }
-            REQUIRE(ref_intr.fx == Approx(align_dpt_intr.fx));
-            REQUIRE(ref_intr.fy == Approx(align_dpt_intr.fy));
-            REQUIRE(ref_intr.ppx == Approx(align_dpt_intr.ppx));
-            REQUIRE(ref_intr.ppy == Approx(align_dpt_intr.ppy));
-            REQUIRE(ref_intr.model == Approx(align_dpt_intr.model));
-            REQUIRE(ref_intr.width == Approx(align_dpt_intr.width));
-            REQUIRE(ref_intr.height == Approx(align_dpt_intr.height));
+            REQUIRE(ref_intr.fx == approx(align_dpt_intr.fx));
+            REQUIRE(ref_intr.fy == approx(align_dpt_intr.fy));
+            REQUIRE(ref_intr.ppx == approx(align_dpt_intr.ppx));
+            REQUIRE(ref_intr.ppy == approx(align_dpt_intr.ppy));
+            REQUIRE(ref_intr.model == align_dpt_intr.model);
+            REQUIRE(ref_intr.width == align_dpt_intr.width);
+            REQUIRE(ref_intr.height == align_dpt_intr.height);
 
             // Extrinsic tests: Aligned_depth_extrinsic == Target frame extrinsic
             rs2_extrinsics actual_extrinsics = ref_video_profile.get_extrinsics_to(aligned_dpt_profile);
@@ -671,11 +671,11 @@ TEST_CASE("Align Processing Block", "[live][pipeline][post-processing-filters][!
             CAPTURE(actual_extrinsics.translation);
             for (auto i = 0; i < 9; i++)
             {
-                REQUIRE(actual_extrinsics.rotation[i] == Approx(expected_extrinsics.rotation[i]));
+                REQUIRE(actual_extrinsics.rotation[i] == approx(expected_extrinsics.rotation[i]));
             }
             for (auto i = 0; i < 3; i++)
             {
-                REQUIRE(actual_extrinsics.translation[i] == Approx(expected_extrinsics.translation[i]));
+                REQUIRE(actual_extrinsics.translation[i] == approx(expected_extrinsics.translation[i]));
             }
         }
 
@@ -707,15 +707,15 @@ TEST_CASE("Align Processing Block", "[live][pipeline][post-processing-filters][!
             const auto align_2D_intr = aligned_2D_profile.get_intrinsics();
             for (auto i = 0; i < 5; i++)
             {
-                REQUIRE(ref_intr.coeffs[i] == Approx(align_2D_intr.coeffs[i]));
+                REQUIRE(ref_intr.coeffs[i] == approx(align_2D_intr.coeffs[i]));
             }
-            REQUIRE(ref_intr.fx == Approx(align_2D_intr.fx));
-            REQUIRE(ref_intr.fy == Approx(align_2D_intr.fy));
-            REQUIRE(ref_intr.ppx == Approx(align_2D_intr.ppx));
-            REQUIRE(ref_intr.ppy == Approx(align_2D_intr.ppy));
-            REQUIRE(ref_intr.model == Approx(align_2D_intr.model));
-            REQUIRE(ref_intr.width == Approx(align_2D_intr.width));
-            REQUIRE(ref_intr.height == Approx(align_2D_intr.height));
+            REQUIRE(ref_intr.fx == approx(align_2D_intr.fx));
+            REQUIRE(ref_intr.fy == approx(align_2D_intr.fy));
+            REQUIRE(ref_intr.ppx == approx(align_2D_intr.ppx));
+            REQUIRE(ref_intr.ppy == approx(align_2D_intr.ppy));
+            REQUIRE(ref_intr.model == align_2D_intr.model);
+            REQUIRE(ref_intr.width == align_2D_intr.width);
+            REQUIRE(ref_intr.height == align_2D_intr.height);
 
             // Extrinsic tests: Aligned_depth_extrinsic == Target frame extrinsic
             rs2_extrinsics actual_extrinsics = aligned_2D_profile.get_extrinsics_to(ref_video_profile);
@@ -724,11 +724,11 @@ TEST_CASE("Align Processing Block", "[live][pipeline][post-processing-filters][!
             CAPTURE(actual_extrinsics.translation);
             for (auto i = 0; i < 9; i++)
             {
-                REQUIRE(actual_extrinsics.rotation[i] == Approx(expected_extrinsics.rotation[i]));
+                REQUIRE(actual_extrinsics.rotation[i] == approx(expected_extrinsics.rotation[i]));
             }
             for (auto i = 0; i < 3; i++)
             {
-                REQUIRE(actual_extrinsics.translation[i] == Approx(expected_extrinsics.translation[i]));
+                REQUIRE(actual_extrinsics.translation[i] == approx(expected_extrinsics.translation[i]));
             }
         }
     }
diff --git a/unit-tests/unit-tests-post-processing.h b/unit-tests/unit-tests-post-processing.h
index 90be0f3..3f00461 100644
--- a/unit-tests/unit-tests-post-processing.h
+++ b/unit-tests/unit-tests-post-processing.h
@@ -252,7 +252,7 @@ inline bool load_test_configuration(const std::string test_name, ppf_test_config
     for (auto i = 0; i < test_config.frames_sequence_size; i++)
     {
         CAPTURE(test_config._input_frames[i].size());
-        CAPTURE(test_config._output_frames[i].size())
+        CAPTURE(test_config._output_frames[i].size());
     }
 
     CAPTURE(test_config.output_res_x);
@@ -380,10 +380,8 @@ inline bool profile_diffs(const std::string& plot_name, std::vector<T>& distance
     CAPTURE(max_allowed_std);
     CAPTURE(frame_idx);
 
-    INTERNAL_CATCH_TEST((standard_deviation <= max_allowed_std), Catch::ResultDisposition::ContinueOnFailure, "CHECK");
-    INTERNAL_CATCH_TEST((fabs((max_val)) <= outlier), Catch::ResultDisposition::ContinueOnFailure, "CHECK");
-    //REQUIRE(standard_deviation <= max_allowed_std);
-    //REQUIRE(fabs((max_val)) <= outlier);
+    CHECK( standard_deviation <= max_allowed_std );
+    CHECK( fabs(max_val) <= outlier );
 
     return ((fabs(max_val) <= outlier) && (standard_deviation <= max_allowed_std));
 }
diff --git a/wrappers/android/examples/capture/src/main/java/com/intel/realsense/capture/MainActivity.java b/wrappers/android/examples/capture/src/main/java/com/intel/realsense/capture/MainActivity.java
index cca968e..ae52529 100644
--- a/wrappers/android/examples/capture/src/main/java/com/intel/realsense/capture/MainActivity.java
+++ b/wrappers/android/examples/capture/src/main/java/com/intel/realsense/capture/MainActivity.java
@@ -144,7 +144,7 @@ public class MainActivity extends AppCompatActivity {
         @Override
         public void run() {
             try {
-                try(FrameSet frames = mPipeline.waitForFrames(1000)) {
+                try(FrameSet frames = mPipeline.waitForFrames()) {
                     try(FrameSet processed = frames.applyFilter(mColorizer)) {
                         mGLSurfaceView.upload(processed);
                     }
diff --git a/wrappers/android/examples/multicam/src/main/java/com/intel/realsense/multicam/MainActivity.java b/wrappers/android/examples/multicam/src/main/java/com/intel/realsense/multicam/MainActivity.java
index 625ea82..64caa92 100644
--- a/wrappers/android/examples/multicam/src/main/java/com/intel/realsense/multicam/MainActivity.java
+++ b/wrappers/android/examples/multicam/src/main/java/com/intel/realsense/multicam/MainActivity.java
@@ -129,7 +129,7 @@ public class MainActivity extends AppCompatActivity {
         public void run() {
             try {
                 for(int i = 0; i < mPipelines.size(); i++) {
-                    try (FrameSet frames = mPipelines.get(i).waitForFrames(1000)) {
+                    try (FrameSet frames = mPipelines.get(i).waitForFrames()) {
                         try (FrameSet processed = frames.applyFilter(mColorizers.get(i))) {
                             mGLSurfaceView.upload(processed);
                         }
diff --git a/wrappers/android/examples/playback/src/main/java/com/intel/realsense/playback/MainActivity.java b/wrappers/android/examples/playback/src/main/java/com/intel/realsense/playback/MainActivity.java
index 4acc544..f176610 100644
--- a/wrappers/android/examples/playback/src/main/java/com/intel/realsense/playback/MainActivity.java
+++ b/wrappers/android/examples/playback/src/main/java/com/intel/realsense/playback/MainActivity.java
@@ -105,7 +105,7 @@ public class MainActivity extends AppCompatActivity {
                             // try statement needed here to release resources allocated by the Pipeline:start() method
                             try (PipelineProfile pp = pipeline.start(config)) {}
                             while (!mStreaming.isInterrupted()) {
-                                try (FrameSet frames = pipeline.waitForFrames(1000)) {
+                                try (FrameSet frames = pipeline.waitForFrames()) {
                                     try (FrameSet processed = frames.applyFilter(colorizer)) {
                                         mGLSurfaceView.upload(processed);
                                     }
diff --git a/wrappers/android/examples/processing/src/main/java/com/intel/realsense/processing/MainActivity.java b/wrappers/android/examples/processing/src/main/java/com/intel/realsense/processing/MainActivity.java
index ab5551d..a34b61c 100644
--- a/wrappers/android/examples/processing/src/main/java/com/intel/realsense/processing/MainActivity.java
+++ b/wrappers/android/examples/processing/src/main/java/com/intel/realsense/processing/MainActivity.java
@@ -194,7 +194,7 @@ public class MainActivity extends AppCompatActivity {
         public void run() {
             try {
                 try(FrameReleaser fr = new FrameReleaser()){
-                    FrameSet frames = mPipeline.waitForFrames(1000).releaseWith(fr);
+                    FrameSet frames = mPipeline.waitForFrames().releaseWith(fr);
                     FrameSet orgSet = frames.applyFilter(mColorizerOrg).releaseWith(fr);
                     FrameSet processedSet = frames.applyFilter(mDecimationFilter).releaseWith(fr).
                             applyFilter(mHoleFillingFilter).releaseWith(fr).
diff --git a/wrappers/android/examples/recording/src/main/java/com/intel/realsense/recording/MainActivity.java b/wrappers/android/examples/recording/src/main/java/com/intel/realsense/recording/MainActivity.java
index f20e21b..01d2156 100644
--- a/wrappers/android/examples/recording/src/main/java/com/intel/realsense/recording/MainActivity.java
+++ b/wrappers/android/examples/recording/src/main/java/com/intel/realsense/recording/MainActivity.java
@@ -195,7 +195,7 @@ public class MainActivity extends AppCompatActivity {
         @Override
         public void run() {
             try {
-                try(FrameSet frames = mPipeline.waitForFrames(1000)) {
+                try(FrameSet frames = mPipeline.waitForFrames()) {
                     mGLSurfaceView.upload(frames);
                 }
                 mHandler.post(mStreaming);
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Device.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Device.java
index 24e658b..f1e431b 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Device.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Device.java
@@ -51,6 +51,7 @@ public class Device extends LrsClass {
             case UPDATABLE: return (T) new Updatable(mHandle);
             case UPDATE_DEVICE: return (T) new UpdateDevice(mHandle);
             case DEBUG: return (T) new DebugProtocol(mHandle);
+            case FW_LOGGER: return (T) new FwLogger(mHandle);
         }
         throw new RuntimeException("this device is not extendable to " + extension.name());
     }
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/DistortionType.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/DistortionType.java
new file mode 100644
index 0000000..d18f399
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/DistortionType.java
@@ -0,0 +1,16 @@
+package com.intel.realsense.librealsense;
+
+public enum DistortionType {
+    NONE(0),
+    MODIFIED_BROWN_CONRADY(1),
+    INVERSE_BROWN_CONRADY(2),
+    FTHETA(3),
+    BROWN_CONRADY(4),
+    KANNALA_BRANDT4(5),
+    COUNT(6);
+
+    private final int mValue;
+
+    DistortionType(int value) { mValue = value; }
+    public int value() { return mValue; }
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extension.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extension.java
index 24bb008..8af8e8b 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extension.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extension.java
@@ -46,7 +46,10 @@ public enum Extension {
     COLOR_SENSOR(42),
     MOTION_SENSOR(43),
     FISHEYE_SENSOR(44),
-    DEPTH_HUFFMAN_DECODER(45);
+    DEPTH_HUFFMAN_DECODER(45),
+    SERIALIZABLE(46),
+    FW_LOGGER(47);
+
 
     private final int mValue;
 
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extrinsic.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extrinsic.java
new file mode 100644
index 0000000..5b771e8
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Extrinsic.java
@@ -0,0 +1,17 @@
+package com.intel.realsense.librealsense;
+
+public class Extrinsic {
+
+    private float[] mRotation; // Column-major 3x3 rotation matrix
+    private float[] mTranslation;  // Three-element translation vector, in meters
+
+    public Extrinsic(){
+        mRotation = new float[9];
+        mTranslation = new float[3];
+    }
+
+    public Extrinsic(float[] rotation, float[] translation){
+        this.mRotation = rotation;
+        this.mTranslation = translation;
+    }
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FrameQueue.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FrameQueue.java
index cfd9e7d..a0e8fcb 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FrameQueue.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FrameQueue.java
@@ -36,7 +36,7 @@ public class FrameQueue extends LrsClass {
     }
 
     public FrameSet waitForFrames() {
-        return waitForFrames(5000);
+        return waitForFrames();
     }
 
     public FrameSet waitForFrames(int timeout) {
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogMsg.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogMsg.java
new file mode 100644
index 0000000..ed5d17d
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogMsg.java
@@ -0,0 +1,40 @@
+package com.intel.realsense.librealsense;
+
+public class FwLogMsg extends LrsClass{
+
+    FwLogMsg(long handle){
+        mHandle = handle;
+    }
+
+    public enum LogSeverity {
+        DEBUG(0),
+        INFO(1),
+        WARN(2),
+        ERROR(4),
+        FATAL(5);
+
+        private final int mValue;
+
+        private LogSeverity(int value) { mValue = value; }
+        public int value() { return mValue; }
+    }
+
+    @Override
+    public void close() {
+        nRelease(mHandle);
+    }
+
+    public LogSeverity getSeverity() { return LogSeverity.values()[nGetSeverity(mHandle)]; }
+    public String getSeverityStr(){ return nGetSeverityStr(mHandle); }
+    public long getTimestamp(){return nGetTimestamp(mHandle);}
+    public byte[] getData(byte[] buffer){ return nGetData(mHandle, buffer);}
+    public int getSize() { return nGetSize(mHandle);}
+
+
+    private native static void nRelease(long handle);
+    private native static int nGetSeverity(long handle);
+    private native static String nGetSeverityStr(long handle);
+    private native static long nGetTimestamp(long handle);
+    private native static byte[] nGetData(long handle, byte[] buffer);
+    private native static int nGetSize(long handle);
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogParsedMsg.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogParsedMsg.java
new file mode 100644
index 0000000..39226d8
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogParsedMsg.java
@@ -0,0 +1,29 @@
+package com.intel.realsense.librealsense;
+
+public class FwLogParsedMsg extends LrsClass {
+
+    FwLogParsedMsg(long handle){
+        mHandle = handle;
+    }
+
+    @Override
+    public void close() {
+        nRelease(mHandle);
+    }
+
+    public String getMessage() { return nGetMessage(mHandle); }
+    public String getFileName() {return nGetFileName(mHandle);}
+    public String getThreadName() {return nGetThreadName(mHandle);}
+    public String getSeverity() {return nGetSeverity(mHandle);}
+    public int getLine() {return nGetLine(mHandle);}
+    public long getTimestamp(){return nGetTimestamp(mHandle);}
+
+
+    private native static void nRelease(long handle);
+    private native static String nGetMessage(long handle);
+    private native static String nGetFileName(long handle);
+    private native static String nGetThreadName(long handle);
+    private native static String nGetSeverity(long handle);
+    private native static int nGetLine(long handle);
+    private native static long nGetTimestamp(long handle);
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogger.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogger.java
dissimilarity index 83%
index 6ecf6ce..693bdff 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogger.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/FwLogger.java
@@ -1,15 +1,58 @@
-package com.intel.realsense.librealsense;
-
-public class FwLogger {
-
-    public static void startFwLogging(String filePath) {
-        nStartReadingFwLogs(filePath);
-    }
-
-    public static void stopFwLogging() {
-        nStopReadingFwLogs();
-    }
-
-    private static native void nStartReadingFwLogs(String filePath);
-    private static native void nStopReadingFwLogs();
-}
+package com.intel.realsense.librealsense;
+
+import java.io.File;
+import java.util.Scanner;
+
+
+
+public class FwLogger extends Device {
+
+    private boolean mIsParserAvailable = false;
+    private boolean mFwLogPullingStatus = false;
+
+    FwLogger(long handle){
+        super(handle);
+        mOwner = false;
+    }
+
+    public boolean initParser(String xml_path) {
+        // checking the input file path for parsing logs
+        if (!xml_path.contentEquals("") ) {
+            try{
+                try (Scanner scanner = new Scanner( new File(xml_path), "UTF-8" )) {
+                    String xml_content_raw = scanner.useDelimiter("\\A").next();
+                    String xml_content = xml_content_raw.replaceAll("\r\n", "\n" );
+                    if (nInitParser(mHandle, xml_content)) {
+                        mIsParserAvailable = true;
+                    }
+                }
+            }
+            catch(Exception e){
+                throw new RuntimeException("path to fw logs xml did not succeed: " + e.getMessage());
+            }
+        }
+        return mIsParserAvailable;
+    }
+
+    public FwLogMsg getFwLog(){
+        mFwLogPullingStatus = false;
+        return new FwLogMsg(nGetFwLog(mHandle));
+    }
+
+    public FwLogMsg getFwLogsFromFlash() {
+        mFwLogPullingStatus = false;
+        return new FwLogMsg(nGetFlashLog(mHandle));
+    }
+
+    public boolean getFwLogPullingStatus() { return mFwLogPullingStatus; }
+
+    public FwLogParsedMsg parseFwLog(FwLogMsg msg) {
+        return new FwLogParsedMsg(nParseFwLog(mHandle, msg.getHandle()));
+    }
+
+
+    private native long nGetFwLog(long handle);
+    private native long nGetFlashLog(long handle);
+    private static native boolean nInitParser(long handle, String xml_content);
+    private static native long nParseFwLog(long handle, long fw_log_msg_handle);
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Intrinsic.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Intrinsic.java
new file mode 100644
index 0000000..0b490a5
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Intrinsic.java
@@ -0,0 +1,38 @@
+package com.intel.realsense.librealsense;
+
+public class Intrinsic {
+    private int mWidth;
+    private int mHeight;
+    private float mPpx;
+    private float mPpy;
+    private float mFx;
+    private float mFy;
+    private DistortionType mModel;
+    private int mModelValue;
+    private float[] mCoeffs;
+
+
+    public Intrinsic(){
+        mCoeffs = new float[5];
+    }
+
+    public Intrinsic(int width, int height,
+                     float ppx, float ppy,
+                     float fx, float fy,
+                     int model,
+                     float[] coeffs){
+        this.mWidth = width;
+        this.mHeight = height;
+        this.mPpx = ppx;
+        this.mPpy = ppy;
+        this.mFx = fx;
+        this.mFy = fy;
+        this.mModel = DistortionType.values()[model];
+        this.mModelValue = model;
+        this.mCoeffs = coeffs;
+    }
+
+    public void SetModel(){
+        this.mModel = DistortionType.values()[mModelValue];
+    }
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionIntrinsic.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionIntrinsic.java
new file mode 100644
index 0000000..14d0427
--- /dev/null
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionIntrinsic.java
@@ -0,0 +1,25 @@
+package com.intel.realsense.librealsense;
+
+public class MotionIntrinsic {
+
+    /* mData matrix description:
+     * Scale X       cross axis  cross axis  Bias X \n
+     * cross axis    Scale Y     cross axis  Bias Y \n
+     * cross axis    cross axis  Scale Z     Bias Z */
+    private float[][] mData;
+    private float[] mNoiseVariances; // Variance of noise for X, Y, and Z axis
+    private float[] mBiasVariances;  // Variance of bias for X, Y, and Z axis
+
+
+    public MotionIntrinsic(){
+        mData = new float[3][4];
+        mNoiseVariances = new float[3];
+        mBiasVariances = new float[3];
+    }
+
+    public MotionIntrinsic(float[][] data, float[] noiseVariances, float[] biasVariances){
+        this.mData = data;
+        this.mNoiseVariances = noiseVariances;
+        this.mBiasVariances = biasVariances;
+    }
+}
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionStreamProfile.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionStreamProfile.java
index 71b4b62..4f45ca5 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionStreamProfile.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/MotionStreamProfile.java
@@ -1,8 +1,22 @@
 package com.intel.realsense.librealsense;
 
 public class MotionStreamProfile extends StreamProfile {
+
+    private MotionIntrinsic mIntrinsic;
+
     MotionStreamProfile(long handle) {
         super(handle);
         mOwner = false;
+        mIntrinsic = null;
     }
+
+    public MotionIntrinsic getIntrinsic() throws Exception {
+        if(mIntrinsic == null){
+            mIntrinsic = new MotionIntrinsic();
+            nGetIntrinsic(mHandle, mIntrinsic);
+        }
+        return mIntrinsic;
+    }
+
+    private static native void nGetIntrinsic(long handle, MotionIntrinsic intrinsic);
 }
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Option.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Option.java
index 84fbf87..2b21306 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Option.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Option.java
@@ -73,8 +73,9 @@ public enum Option {
     AMBIENT_LIGHT(69),
     SENSOR_MODE(70),
     EMITTER_ALWAYS_ON(71),
-    THERMAL_COMPENSATION(72);
-
+    THERMAL_COMPENSATION(72),
+    TRIGGER_CAMERA_ACCURACY_HEALTH(73),
+    RESET_CAMERA_ACCURACY_HEALTH(74);
     private final int mValue;
 
     private Option(int value) { mValue = value; }
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Pipeline.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Pipeline.java
index 1c1826c..e6f9036 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Pipeline.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/Pipeline.java
@@ -24,7 +24,7 @@ public class Pipeline extends LrsClass{
     }
 
     public FrameSet waitForFrames() throws Exception {
-        return waitForFrames(5000);
+        return waitForFrames(5000); //defining default timeout
     }
 
     public FrameSet waitForFrames (int timeoutMilliseconds) throws Exception{
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/StreamProfile.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/StreamProfile.java
index f23f373..03eda57 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/StreamProfile.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/StreamProfile.java
@@ -43,6 +43,17 @@ public class StreamProfile extends LrsClass {
         return mPp.frameRate;
     }
 
+    public Extrinsic getExtrinsicTo(StreamProfile other) throws Exception {
+        Extrinsic extrinsic = new Extrinsic();
+        nGetExtrinsicTo(mHandle, other.mHandle, extrinsic);
+        return extrinsic;
+    }
+
+    public void registerExtrinsic(StreamProfile other, Extrinsic extrinsic)
+    {
+        nRegisterExtrinsic(mHandle, other.mHandle, extrinsic);
+    }
+
     public boolean is(Extension extension) {
         return nIsProfileExtendableTo(mHandle, extension.value());
     }
@@ -64,4 +75,6 @@ public class StreamProfile extends LrsClass {
     private static native boolean nIsProfileExtendableTo(long handle, int extension);
     private static native void nGetProfile(long handle, ProfileParams params);
     private static native void nDelete(long handle);
+    private static native void nGetExtrinsicTo(long handle, long otherHandle, Extrinsic extrinsic);
+    private static native void nRegisterExtrinsic(long handle, long otherHandle, Extrinsic extrinsic);
 }
diff --git a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/VideoStreamProfile.java b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/VideoStreamProfile.java
index b6c2d6c..8f5c10f 100644
--- a/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/VideoStreamProfile.java
+++ b/wrappers/android/librealsense/src/main/java/com/intel/realsense/librealsense/VideoStreamProfile.java
@@ -2,6 +2,7 @@ package com.intel.realsense.librealsense;
 
 public class VideoStreamProfile extends StreamProfile {
     ResolutionParams mResolutionParams;
+    private Intrinsic mIntrinsic;
 
     private class ResolutionParams {
         public int width;
@@ -13,6 +14,16 @@ public class VideoStreamProfile extends StreamProfile {
         mOwner = false;
         mResolutionParams = new ResolutionParams();
         nGetResolution(mHandle, mResolutionParams);
+        mIntrinsic = null;
+    }
+
+    public Intrinsic getIntrinsic() throws Exception {
+        if(mIntrinsic == null){
+            mIntrinsic = new Intrinsic();
+            nGetIntrinsic(mHandle, mIntrinsic);
+            mIntrinsic.SetModel();
+        }
+        return mIntrinsic;
     }
 
     public int getWidth() {
@@ -24,4 +35,5 @@ public class VideoStreamProfile extends StreamProfile {
     }
 
     private static native void nGetResolution(long handle, ResolutionParams params);
+    private static native void nGetIntrinsic(long handle, Intrinsic intrinsic);
 }
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
index a997a66..ae98812 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
@@ -128,12 +128,7 @@ public class DetachedActivity extends AppCompatActivity {
                     if (!validateFwVersion(d))
                         return;
                     mDetached = false;
-                    SharedPreferences sharedPref = getSharedPreferences(getString(R.string.app_settings), Context.MODE_PRIVATE);
-                    boolean fw_logging_enabled = sharedPref.getBoolean(getString(R.string.fw_logging), false);
-                    String fw_logging_file_path = sharedPref.getString(getString(R.string.fw_logging_file_path), "");
-                    if(fw_logging_enabled && !fw_logging_file_path.equals("")){
-                        FwLogger.startFwLogging(fw_logging_file_path);
-                    }
+
                     finish();
                     Intent intent = new Intent(this, PreviewActivity.class);
                     startActivity(intent);
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/FwLogsThread.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/FwLogsThread.java
new file mode 100644
index 0000000..664d680
--- /dev/null
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/FwLogsThread.java
@@ -0,0 +1,140 @@
+package com.intel.realsense.camera;
+
+import android.util.Log;
+
+import com.intel.realsense.librealsense.Device;
+import com.intel.realsense.librealsense.DeviceList;
+import com.intel.realsense.librealsense.Extension;
+import com.intel.realsense.librealsense.FwLogMsg;
+import com.intel.realsense.librealsense.FwLogParsedMsg;
+import com.intel.realsense.librealsense.FwLogger;
+import com.intel.realsense.librealsense.RsContext;
+
+public class FwLogsThread extends Thread{
+    private static final String TAG = "librs_fwLogsThread";
+    private FwLogger mFwLoggerDevice;
+    private volatile boolean mAreFwLogsRequested;
+    private String mFwLogsParsingFilePath = "";
+    private boolean mIsParsingFileInitialized = false;
+    private boolean mAllFlashLogsAlreadyPulled = false;
+
+    @Override
+    public void run() {
+        mAreFwLogsRequested = true;
+        try(RsContext ctx = new RsContext()) {
+            try (DeviceList devices = ctx.queryDevices()) {
+                if (devices.getDeviceCount() > 0) {
+                    // only device 0 is taken care of, as the camera app is supposed to work only with one device
+                    try (Device device = devices.createDevice(0)) {
+                        if (device != null) {
+                            try (final FwLogger fwLoggerDevice = device.as(Extension.FW_LOGGER)) {
+                                mFwLoggerDevice = fwLoggerDevice;
+                                if (mFwLogsParsingFilePath != "")
+                                    mIsParsingFileInitialized = mFwLoggerDevice.initParser(mFwLogsParsingFilePath);
+                                while (mAreFwLogsRequested) {
+                                    String logReceived = "";
+                                    try (FwLogMsg logMsg = mFwLoggerDevice.getFwLog()) {
+                                        if (mFwLoggerDevice.getFwLogPullingStatus()) {
+                                            if (mIsParsingFileInitialized) {
+                                                try (FwLogParsedMsg parsedMsg = mFwLoggerDevice.parseFwLog(logMsg)) {
+                                                    logReceived = parsedMsg.getTimestamp() + " - " +
+                                                            parsedMsg.getSeverity() + " " +
+                                                            parsedMsg.getFileName() + " " +
+                                                            parsedMsg.getLine() + " " +
+                                                            parsedMsg.getThreadName() + " " +
+                                                            parsedMsg.getMessage();
+                                                    Log.d(TAG, logReceived);
+                                                }
+                                            } else {
+                                                logReceived = logMsg.getTimestamp() + " " +
+                                                        logMsg.getSeverityStr() + " ";
+                                                int logMsgSize = logMsg.getSize();
+                                                byte[] buffer = new byte[logMsgSize];
+                                                buffer = logMsg.getData(buffer);
+                                                for (byte b : buffer) {
+                                                    logReceived += String.format("%02X", b) + " ";
+                                                }
+                                                Log.d(TAG, logReceived);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public void init(String fw_logging_file_path)
+    {
+        mFwLogsParsingFilePath = fw_logging_file_path;
+    }
+
+
+    public void stopLogging()
+    {
+        mAreFwLogsRequested = false;
+    }
+
+    public void getFwLogsFromFlash()
+    {
+        if(!mAllFlashLogsAlreadyPulled){
+            try(RsContext ctx = new RsContext()){
+                try(DeviceList devices = ctx.queryDevices()) {
+                    if (devices.getDeviceCount() > 0) {
+                        // only device 0 is taken care of, as the camera app is supposed to work only with one device
+                        try (Device device = devices.createDevice(0)) {
+                            if(device != null) {
+                                try(final FwLogger fwLoggerDevice = device.as(Extension.FW_LOGGER)){
+                                    mFwLoggerDevice = fwLoggerDevice;
+                                    if (mFwLogsParsingFilePath != "")
+                                        mIsParsingFileInitialized = mFwLoggerDevice.initParser(mFwLogsParsingFilePath);
+                                    Log.d(TAG, "-------------------flash logs retrieval--------------------");
+                                    while (true) {
+                                        String logReceived = "";
+                                        try (FwLogMsg logMsg = mFwLoggerDevice.getFwLogsFromFlash()) {
+                                            if (mFwLoggerDevice.getFwLogPullingStatus()) {
+                                                if (mIsParsingFileInitialized) {
+                                                    try (FwLogParsedMsg parsedMsg = mFwLoggerDevice.parseFwLog(logMsg)) {
+                                                        logReceived = parsedMsg.getTimestamp() + " - " +
+                                                                parsedMsg.getSeverity() + " " +
+                                                                parsedMsg.getFileName() + " " +
+                                                                parsedMsg.getLine() + " " +
+                                                                parsedMsg.getThreadName() + " " +
+                                                                parsedMsg.getMessage();
+                                                        Log.d(TAG, logReceived);
+                                                    }
+                                                } else {
+                                                    logReceived = logMsg.getTimestamp() + " " +
+                                                            logMsg.getSeverityStr() + " ";
+                                                    int logMsgSize = logMsg.getSize();
+                                                    byte[] buffer = new byte[logMsgSize];
+                                                    buffer = logMsg.getData(buffer);
+                                                    for (byte b : buffer) {
+                                                        logReceived += String.format("%02X", b) + " ";
+                                                    }
+                                                    Log.d(TAG, logReceived);
+                                                }
+                                            }
+                                            else {
+                                                Log.d(TAG, "No more fw logs in flash");
+                                                mAllFlashLogsAlreadyPulled = true;
+                                                break;
+                                            }
+                                        }
+                                    }
+                                    Log.d(TAG, "-------------------flash logs finished--------------------");
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        else {
+            Log.d(TAG, "Flash logs already pulled");
+        }
+    }
+}
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
index dfb005c..7caa494 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
@@ -13,8 +13,6 @@ import android.util.Pair;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.WindowManager;
-import android.widget.CheckBox;
-import android.widget.CompoundButton;
 import android.widget.RadioButton;
 import android.widget.RelativeLayout;
 import android.widget.TextView;
@@ -23,8 +21,6 @@ import android.widget.Toast;
 import com.intel.realsense.librealsense.Config;
 import com.intel.realsense.librealsense.Device;
 import com.intel.realsense.librealsense.DeviceList;
-import com.intel.realsense.librealsense.Frame;
-import com.intel.realsense.librealsense.FrameCallback;
 import com.intel.realsense.librealsense.FrameSet;
 import com.intel.realsense.librealsense.GLRsSurfaceView;
 import com.intel.realsense.librealsense.Option;
@@ -52,6 +48,9 @@ public class PreviewActivity extends AppCompatActivity {
     private Streamer mStreamer;
     private StreamingStats mStreamingStats;
 
+    private FwLogsThread mFwLogsThread;
+    private boolean mFwLogsRunning = false;
+
     private boolean statsToggle = false;
     private boolean mShow3D = false;
 
@@ -212,7 +211,6 @@ public class PreviewActivity extends AppCompatActivity {
 
             }
 
-
             @Override
             public void onFrameset(final FrameSet frameSet) {
                 mStreamingStats.onFrameset(frameSet);
@@ -246,6 +244,8 @@ public class PreviewActivity extends AppCompatActivity {
             Intent intent = new Intent(PreviewActivity.this, SettingsActivity.class);
             startActivity(intent);
         }
+
+        resumeBackgroundTasks();
     }
 
     @Override
@@ -257,6 +257,8 @@ public class PreviewActivity extends AppCompatActivity {
             mStreamer.stop();
         if(mGLSurfaceView != null)
             mGLSurfaceView.clear();
+
+        pauseBackgroundTasks();
     }
 
     public void onRadioButtonClicked(View view) {
@@ -320,4 +322,42 @@ public class PreviewActivity extends AppCompatActivity {
         else
             Toast.makeText(this, "This control is not supported by this device", Toast.LENGTH_LONG).show();
     }
+
+    private synchronized void resumeBackgroundTasks() {
+        resumeFwLogger();
+    }
+
+    private synchronized void pauseBackgroundTasks() {
+        pauseFwLogger();
+    }
+
+    private synchronized void resumeFwLogger() {
+        if (!mFwLogsRunning)
+        {
+            SharedPreferences sharedPref = getSharedPreferences(getString(R.string.app_settings), Context.MODE_PRIVATE);
+            boolean fw_logging_enabled = sharedPref.getBoolean(getString(R.string.fw_logging), false);
+            String fw_logging_file_path = sharedPref.getString(getString(R.string.fw_logging_file_path), "");
+
+            if (fw_logging_enabled) {
+                mFwLogsThread = new FwLogsThread();
+                if(!fw_logging_file_path.equals("")){
+                    mFwLogsThread.init(fw_logging_file_path);
+                }
+                mFwLogsThread.start();
+                mFwLogsRunning = true;
+            }
+        }
+    }
+
+    private synchronized void pauseFwLogger(){
+        SharedPreferences sharedPref = getSharedPreferences(getString(R.string.app_settings), Context.MODE_PRIVATE);
+        boolean fw_logging_enabled = sharedPref.getBoolean(getString(R.string.fw_logging), false);
+        if (fw_logging_enabled) {
+            mFwLogsThread.stopLogging();
+        }
+        if(mFwLogsThread != null && mFwLogsThread.isAlive()) {
+            mFwLogsThread.interrupt();
+        }
+        mFwLogsRunning = false;
+    }
 }
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/SettingsActivity.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/SettingsActivity.java
index 5c3ba1b..b858779 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/SettingsActivity.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/SettingsActivity.java
@@ -348,10 +348,7 @@ public class SettingsActivity extends AppCompatActivity {
             startActivityForResult(intent, OPEN_FW_FILE_REQUEST_CODE);
             return;
         }
-        if(fw_logging_enabled)
-            FwLogger.stopFwLogging();
-        else
-            FwLogger.startFwLogging(fw_logging_file_path);
+
         SharedPreferences.Editor editor = sharedPref.edit();
         editor.putBoolean(getString(R.string.fw_logging), !fw_logging_enabled);
         editor.commit();
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/Streamer.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/Streamer.java
index 133f035..8764cd6 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/Streamer.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/Streamer.java
@@ -53,7 +53,7 @@ public class Streamer {
         @Override
         public void run() {
             try {
-                try(FrameSet frames = mPipeline.waitForFrames(1000)) {
+                try(FrameSet frames = mPipeline.waitForFrames()) {
                     mListener.onFrameset(frames);
                 }
                 mHandler.post(mStreaming);
diff --git a/wrappers/csharp/Intel.RealSense/Devices/CMakeLists.txt b/wrappers/csharp/Intel.RealSense/Devices/CMakeLists.txt
index b8c37ac..9693738 100644
--- a/wrappers/csharp/Intel.RealSense/Devices/CMakeLists.txt
+++ b/wrappers/csharp/Intel.RealSense/Devices/CMakeLists.txt
@@ -1,6 +1,7 @@
 target_sources(${LRS_DOTNET_TARGET}
     PRIVATE
         "${CMAKE_CURRENT_LIST_DIR}/AdvancedDevice.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/DebugDevice.cs"
         "${CMAKE_CURRENT_LIST_DIR}/Device.cs"
         "${CMAKE_CURRENT_LIST_DIR}/DeviceList.cs"
         "${CMAKE_CURRENT_LIST_DIR}/PlaybackDevice.cs"
@@ -8,4 +9,5 @@ target_sources(${LRS_DOTNET_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/SoftwareDevice.cs"
         "${CMAKE_CURRENT_LIST_DIR}/UpdatableDevice.cs"
         "${CMAKE_CURRENT_LIST_DIR}/UpdateDevice.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/FirmwareLogsDevice.cs"
 )
diff --git a/wrappers/csharp/Intel.RealSense/Devices/DebugDevice.cs b/wrappers/csharp/Intel.RealSense/Devices/DebugDevice.cs
new file mode 100644
index 0000000..947a8dd
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Devices/DebugDevice.cs
@@ -0,0 +1,58 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    using System;
+    using System.Runtime.InteropServices;
+
+    public class DebugDevice : Device
+    {
+
+        internal DebugDevice(IntPtr dev)
+            : base(dev)
+        { }
+
+        /// <summary>
+        /// Create an <see cref="DebugDevice"/> from existing <see cref="Device"/>
+        /// </summary>
+        /// <param name="dev">a device that supports <see cref="Extension.Debug"/></param>
+        /// <returns>a new <see cref="DebugDevice"/></returns>
+        /// <exception cref="ArgumentException">Thrown when <paramref name="dev"/> does not support <see cref="Extension.FirmwareLogger"/></exception>
+        public static DebugDevice FromDevice(Device dev)
+        {
+            object error;
+            if (NativeMethods.rs2_is_device_extendable_to(dev.Handle, Extension.Debug, out error) == 0)
+            {
+                throw new ArgumentException($"Device does not support {nameof(Extension.Debug)}");
+            }
+
+            return Device.Create<DebugDevice>(dev.Handle);
+        }
+
+        public byte[] SendReceiveRawData(byte[] command_bytes)
+        {
+            IntPtr nativeBytes = IntPtr.Zero;
+            try
+            {
+                nativeBytes = Marshal.AllocHGlobal(command_bytes.Length);
+                Marshal.Copy(command_bytes, 0, nativeBytes, command_bytes.Length);
+                object error;
+                IntPtr rawDataBuffer = NativeMethods.rs2_send_and_receive_raw_data(Handle, nativeBytes, (uint)command_bytes.Length, out error);
+
+                IntPtr start = NativeMethods.rs2_get_raw_data(rawDataBuffer, out error);
+                int size = NativeMethods.rs2_get_raw_data_size(rawDataBuffer, out error);
+
+                byte[] managedBytes = new byte[size];
+                Marshal.Copy(start, managedBytes, 0, size);
+                NativeMethods.rs2_delete_raw_data(rawDataBuffer);
+
+                return managedBytes;
+            }
+            finally
+            {
+                Marshal.FreeHGlobal(nativeBytes);
+            }
+        }
+    }
+}
diff --git a/wrappers/csharp/Intel.RealSense/Devices/FirmwareLogsDevice.cs b/wrappers/csharp/Intel.RealSense/Devices/FirmwareLogsDevice.cs
new file mode 100644
index 0000000..7a8fcda
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Devices/FirmwareLogsDevice.cs
@@ -0,0 +1,73 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    using System;
+    using System.Runtime.InteropServices;
+
+    public class FirmwareLogsDevice : Device
+    {
+
+        internal FirmwareLogsDevice(IntPtr dev)
+            : base(dev)
+        { }
+
+        /// <summary>
+        /// Create an <see cref="FirmwareLogsDevice"/> from existing <see cref="Device"/>
+        /// </summary>
+        /// <param name="dev">a device that supports <see cref="Extension.FirmwareLogger"/></param>
+        /// <returns>a new <see cref="FirmwareLogsDevice"/></returns>
+        /// <exception cref="ArgumentException">Thrown when <paramref name="dev"/> does not support <see cref="Extension.FirmwareLogger"/></exception>
+        public static FirmwareLogsDevice FromDevice(Device dev)
+        {
+            object error;
+            if (NativeMethods.rs2_is_device_extendable_to(dev.Handle, Extension.FirmwareLogger, out error) == 0)
+            {
+                throw new ArgumentException($"Device does not support {nameof(Extension.FirmwareLogger)}");
+            }
+
+            return Device.Create<FirmwareLogsDevice>(dev.Handle);
+        }
+
+        public FwLog CreateFwLog()
+        {
+            object error;
+            return FwLog.Create(NativeMethods.rs2_create_fw_log_message(Handle, out error));
+        }
+
+        public FwParsedLog CreateFwParsedLog()
+        {
+            object error;
+            return FwParsedLog.Create(NativeMethods.rs2_create_fw_log_parsed_message(Handle, out error));
+        }
+
+        public bool GetFwLog(ref FwLog fwLog)
+        {
+            object error;
+            bool result = Convert.ToBoolean(NativeMethods.rs2_get_fw_log(Handle, fwLog.Handle, out error));
+            return result;
+        }
+
+        public bool GetFlashLog(ref FwLog fwLog)
+        {
+            object error;
+            bool result = Convert.ToBoolean(NativeMethods.rs2_get_flash_log(Handle, fwLog.Handle, out error));
+            return result;
+        }
+
+        public bool InitParser(string xml_content)
+        {
+            object error;
+            bool result = Convert.ToBoolean(NativeMethods.rs2_init_fw_log_parser(Handle, xml_content, out error));
+            return result;
+        }
+
+        public bool ParseFwLog(FwLog fwLog, ref FwParsedLog fwParsedLog)
+        {
+            object error;
+            bool result = Convert.ToBoolean(NativeMethods.rs2_parse_firmware_log(Handle, fwLog.Handle, fwParsedLog.Handle, out error));
+            return result;
+        }
+    }
+}
diff --git a/wrappers/csharp/Intel.RealSense/NativeMethods.cs b/wrappers/csharp/Intel.RealSense/NativeMethods.cs
index e78885a..0addf7e 100644
--- a/wrappers/csharp/Intel.RealSense/NativeMethods.cs
+++ b/wrappers/csharp/Intel.RealSense/NativeMethods.cs
@@ -677,6 +677,7 @@ namespace Intel.RealSense
         [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
         internal static extern IntPtr rs2_create_mock_context(int api_version, [MarshalAs(UnmanagedType.LPStr)] string filename, [MarshalAs(UnmanagedType.LPStr)] string section, [MarshalAs(UnmanagedType.LPStr)] string min_api_version, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
 
+        #region software_device
         [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
         internal static extern IntPtr rs2_create_software_device([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
 
@@ -712,9 +713,82 @@ namespace Intel.RealSense
 
         [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
         internal static extern void rs2_software_sensor_update_read_only_option(IntPtr sensor, Option option, float val, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+        #endregion
+        #region fw_logs
 
-#endregion
-#region rs_pipeline
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_create_fw_log_message(IntPtr device, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern void rs2_delete_fw_log_message(IntPtr fw_log);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_get_fw_log(IntPtr device, IntPtr fw_log_, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_get_flash_log(IntPtr device, IntPtr fw_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_fw_log_message_data(IntPtr fw_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_fw_log_message_size(IntPtr fw_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern uint rs2_fw_log_message_timestamp(IntPtr fw_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_fw_log_message_severity(IntPtr fw_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_init_fw_log_parser(IntPtr device, [MarshalAs(UnmanagedType.LPStr)] string xml_content, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_create_fw_log_parsed_message(IntPtr device, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern void rs2_delete_fw_log_parsed_message(IntPtr fw__parsed_log);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_parse_firmware_log(IntPtr device, IntPtr fw_log, IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_get_fw_log_parsed_message(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_get_fw_log_parsed_file_name(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_get_fw_log_parsed_thread_name(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern int rs2_get_fw_log_parsed_severity(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern uint rs2_get_fw_log_parsed_line(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern uint rs2_get_fw_log_parsed_timestamp(IntPtr fw_parsed_log, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+        #endregion
+        #region terminal_parser
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_create_terminal_parser([MarshalAs(UnmanagedType.LPStr)] string xml_content, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern void rs2_delete_terminal_parser(IntPtr terminal_parser);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_terminal_parse_command(IntPtr terminal_parser, [MarshalAs(UnmanagedType.LPStr)] string command, uint size_of_command,
+            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
+        internal static extern IntPtr rs2_terminal_parse_response(IntPtr terminal_parser, [MarshalAs(UnmanagedType.LPStr)] string command, uint size_of_command,
+            IntPtr response_bytes, uint size_of_response,
+            [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
+
+        #endregion
+        #endregion
+        #region rs_pipeline
         [DllImport(dllName, CallingConvention = CallingConvention.Cdecl)]
         internal static extern IntPtr rs2_create_pipeline(IntPtr ctx, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(ErrorMarshaler))] out object error);
 
diff --git a/wrappers/csharp/Intel.RealSense/Types/CMakeLists.txt b/wrappers/csharp/Intel.RealSense/Types/CMakeLists.txt
index 09ffc6a..fe65804 100644
--- a/wrappers/csharp/Intel.RealSense/Types/CMakeLists.txt
+++ b/wrappers/csharp/Intel.RealSense/Types/CMakeLists.txt
@@ -17,4 +17,7 @@ target_sources(${LRS_DOTNET_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/SoftwareMotionFrame.cs"
         "${CMAKE_CURRENT_LIST_DIR}/Pose.cs"
         "${CMAKE_CURRENT_LIST_DIR}/InfoCollection.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/FwLog.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/FwParsedLog.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/TerminalParser.cs"
 )
diff --git a/wrappers/csharp/Intel.RealSense/Types/Enums/CMakeLists.txt b/wrappers/csharp/Intel.RealSense/Types/Enums/CMakeLists.txt
index d52e6a9..70cf0ab 100644
--- a/wrappers/csharp/Intel.RealSense/Types/Enums/CMakeLists.txt
+++ b/wrappers/csharp/Intel.RealSense/Types/Enums/CMakeLists.txt
@@ -13,6 +13,7 @@ target_sources(${LRS_DOTNET_TARGET}
         "${CMAKE_CURRENT_LIST_DIR}/RecordingMode.cs"
         "${CMAKE_CURRENT_LIST_DIR}/Rs400VisualPreset.cs"
         "${CMAKE_CURRENT_LIST_DIR}/Sr300VisualPreset.cs"
+        "${CMAKE_CURRENT_LIST_DIR}/L500VisualPreset.cs"
         "${CMAKE_CURRENT_LIST_DIR}/Stream.cs"
         "${CMAKE_CURRENT_LIST_DIR}/TimestampDomain.cs"
         "${CMAKE_CURRENT_LIST_DIR}/CameraInfo.cs"
diff --git a/wrappers/csharp/Intel.RealSense/Types/Enums/Extension.cs b/wrappers/csharp/Intel.RealSense/Types/Enums/Extension.cs
index e5d0063..c9fefa4 100644
--- a/wrappers/csharp/Intel.RealSense/Types/Enums/Extension.cs
+++ b/wrappers/csharp/Intel.RealSense/Types/Enums/Extension.cs
@@ -53,6 +53,8 @@ namespace Intel.RealSense
         ColorSensor = 42,
         MotionSensor = 43,
         FisheyeSensor = 44,
-        DepthHuffmanDecoder = 45
+        DepthHuffmanDecoder = 45,
+        Serializable = 46,
+        FirmwareLogger = 47
     }
 }
diff --git a/wrappers/csharp/Intel.RealSense/Types/Enums/L500VisualPreset.cs b/wrappers/csharp/Intel.RealSense/Types/Enums/L500VisualPreset.cs
new file mode 100644
index 0000000..a075c06
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Types/Enums/L500VisualPreset.cs
@@ -0,0 +1,18 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2017 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    /// <summary>
+    /// For L500 devices: provides optimized settings (presets) for specific types of usage.
+    /// </summary>
+    public enum L500VisualPreset
+    {
+        Custom = 0,
+        Default = 1,
+        NoAmbient = 2,
+        LowAmbient = 3,
+        MaxRange = 4,
+        ShortRange = 5,
+    }
+}
diff --git a/wrappers/csharp/Intel.RealSense/Types/FwLog.cs b/wrappers/csharp/Intel.RealSense/Types/FwLog.cs
new file mode 100644
index 0000000..930522b
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Types/FwLog.cs
@@ -0,0 +1,49 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    using System;
+    using System.Runtime.InteropServices;
+
+    public class FwLog : Base.Object
+    {
+
+        internal FwLog(IntPtr fw_log_ptr)
+            : base(fw_log_ptr, NativeMethods.rs2_delete_fw_log_message)
+        { }
+
+        public static FwLog Create(IntPtr handle)
+        {
+            return new FwLog(handle);
+        }
+
+        public byte[] GetData()
+        {
+            int size = GetSize();
+            object error;
+            IntPtr start = NativeMethods.rs2_fw_log_message_data(Handle, out error);
+            byte[] managedBytes = new byte[size];
+            Marshal.Copy(start, managedBytes, 0, size);
+            return managedBytes;
+        }
+
+        public int GetSize()
+        {
+            object error;
+            return NativeMethods.rs2_fw_log_message_size(Handle, out error);
+        }
+
+        public uint GetTimestamp()
+        {
+            object error;
+            return NativeMethods.rs2_fw_log_message_timestamp(Handle, out error);
+        }
+
+        public LogSeverity GetSeverity()
+        {
+            object error;
+            return (LogSeverity)NativeMethods.rs2_fw_log_message_severity(Handle, out error);
+        }
+    }
+}
diff --git a/wrappers/csharp/Intel.RealSense/Types/FwParsedLog.cs b/wrappers/csharp/Intel.RealSense/Types/FwParsedLog.cs
new file mode 100644
index 0000000..7be09c0
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Types/FwParsedLog.cs
@@ -0,0 +1,62 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    using System;
+    using System.Runtime.InteropServices;
+
+    public class FwParsedLog : Base.Object
+    {
+
+        internal FwParsedLog(IntPtr ptr)
+            : base(ptr, NativeMethods.rs2_delete_fw_log_parsed_message)
+        { }
+
+        public static FwParsedLog Create(IntPtr handle)
+        {
+            return new FwParsedLog(handle);
+        }
+
+        public string GetMessage()
+        {
+            object error;
+            var p = NativeMethods.rs2_get_fw_log_parsed_message(Handle, out error);
+            return Marshal.PtrToStringAnsi(p);
+        }
+
+        public string GetFileName()
+        {
+            object error;
+            var p = NativeMethods.rs2_get_fw_log_parsed_file_name(Handle, out error);
+            return Marshal.PtrToStringAnsi(p);
+        }
+
+        public string GetThreadName()
+        {
+            object error;
+            var p = NativeMethods.rs2_get_fw_log_parsed_thread_name(Handle, out error);
+            return Marshal.PtrToStringAnsi(p);
+        }
+
+        public LogSeverity GetSeverity()
+        {
+            object error;
+            return (LogSeverity)NativeMethods.rs2_get_fw_log_parsed_severity(Handle, out error);
+        }
+
+        public uint GetLine()
+        {
+            object error;
+            return NativeMethods.rs2_get_fw_log_parsed_line(Handle, out error);
+        }
+
+        public uint GetTimestamp()
+        {
+            object error;
+            return NativeMethods.rs2_get_fw_log_parsed_timestamp(Handle, out error);
+        }
+
+
+    }
+}
diff --git a/wrappers/csharp/Intel.RealSense/Types/TerminalParser.cs b/wrappers/csharp/Intel.RealSense/Types/TerminalParser.cs
new file mode 100644
index 0000000..642390d
--- /dev/null
+++ b/wrappers/csharp/Intel.RealSense/Types/TerminalParser.cs
@@ -0,0 +1,64 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+namespace Intel.RealSense
+{
+    using System;
+    using System.Runtime.InteropServices;
+
+    public class TerminalParser : Base.Object
+    {
+        public TerminalParser(string xml_content)
+            : base(Create(xml_content), NativeMethods.rs2_delete_terminal_parser)
+        { }
+
+
+        internal static IntPtr Create(string xml_content)
+        {
+            object error;
+            return NativeMethods.rs2_create_terminal_parser(xml_content, out error);
+        }
+
+
+        public byte[] ParseCommand(string command)
+        {
+            object error;
+            IntPtr rawDataBuffer = NativeMethods.rs2_terminal_parse_command(Handle, command, (uint)command.Length, out error);
+
+            IntPtr start = NativeMethods.rs2_get_raw_data(rawDataBuffer, out error);
+            int size = NativeMethods.rs2_get_raw_data_size(rawDataBuffer, out error);
+
+            byte[] managedBytes = new byte[size];
+            Marshal.Copy(start, managedBytes, 0, size);
+            NativeMethods.rs2_delete_raw_data(rawDataBuffer);
+
+            return managedBytes;
+        }
+
+        public string ParseResponse(string command, byte[] response_bytes)
+        {
+            IntPtr nativeBytes = IntPtr.Zero;
+            try
+            {
+                nativeBytes = Marshal.AllocHGlobal(response_bytes.Length);
+                Marshal.Copy(response_bytes, 0, nativeBytes, response_bytes.Length);
+                object error;
+                IntPtr rawDataBuffer = NativeMethods.rs2_terminal_parse_response(Handle, command, (uint)command.Length, 
+                    nativeBytes, (uint)response_bytes.Length, out error);
+
+                IntPtr start = NativeMethods.rs2_get_raw_data(rawDataBuffer, out error);
+                int size = NativeMethods.rs2_get_raw_data_size(rawDataBuffer, out error);
+
+                byte[] managedBytes = new byte[size];
+                Marshal.Copy(start, managedBytes, 0, size);
+                NativeMethods.rs2_delete_raw_data(rawDataBuffer);
+
+                return System.Text.Encoding.Default.GetString(managedBytes);
+            }
+            finally
+            {
+                Marshal.FreeHGlobal(nativeBytes);
+            }
+        }
+    }
+}
diff --git a/wrappers/nodejs/src/addon.cpp b/wrappers/nodejs/src/addon.cpp
index 17c592c..2aa8b58 100644
--- a/wrappers/nodejs/src/addon.cpp
+++ b/wrappers/nodejs/src/addon.cpp
@@ -4699,6 +4699,8 @@ void InitModule(v8::Local<v8::Object> exports) {
   _FORCE_SET_ENUM(RS2_OPTION_SENSOR_MODE);
   _FORCE_SET_ENUM(RS2_OPTION_EMITTER_ALWAYS_ON);
   _FORCE_SET_ENUM(RS2_OPTION_THERMAL_COMPENSATION);
+  _FORCE_SET_ENUM(RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH);
+  _FORCE_SET_ENUM(RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH);
   _FORCE_SET_ENUM(RS2_OPTION_COUNT);
 
   // rs2_camera_info
diff --git a/wrappers/opencv/dnn/rs-dnn.cpp b/wrappers/opencv/dnn/rs-dnn.cpp
index e9cdd76..c14028a 100644
--- a/wrappers/opencv/dnn/rs-dnn.cpp
+++ b/wrappers/opencv/dnn/rs-dnn.cpp
@@ -107,7 +107,7 @@ int main(int argc, char** argv) try
                 // Calculate mean depth inside the detection region
                 // This is a very naive way to estimate objects depth
                 // but it is intended to demonstrate how one might 
-                // use depht data in general
+                // use depth data in general
                 Scalar m = mean(depth_mat(object));
 
                 std::ostringstream ss;
diff --git a/wrappers/python/CMakeLists.txt b/wrappers/python/CMakeLists.txt
index c2941bb..b3bab2e 100644
--- a/wrappers/python/CMakeLists.txt
+++ b/wrappers/python/CMakeLists.txt
@@ -7,6 +7,17 @@ if (NOT BUILD_PYTHON_BINDINGS)
     message(WARNING "Python Bindings being built despite unset option because they are required for python documentation")
 endif()
 
+if (CMAKE_VERSION VERSION_LESS 3.12)
+  find_package(PythonInterp REQUIRED)
+  find_package(PythonLibs REQUIRED)
+  set(PYTHON_INSTALL_DIR "${CMAKE_INSTALL_LIBDIR}/python${PYTHON_VERSION_MAJOR}.${PYTHON_VERSION_MINOR}/pyrealsense2" CACHE PATH "Installation directory for Python bindings")
+  set(CMAKECONFIG_PY_INSTALL_DIR "${CMAKE_INSTALL_LIBDIR}/cmake/pyrealsense2")
+else()
+  find_package(Python REQUIRED COMPONENTS Interpreter Development)
+  set(PYTHON_INSTALL_DIR "${Python_SITEARCH}/pyrealsense2" CACHE PATH "Installation directory for Python bindings")
+  set(CMAKECONFIG_PY_INSTALL_DIR "${CMAKE_INSTALL_LIBDIR}/cmake/pyrealsense2")
+endif()
+
 set(DEPENDENCIES realsense2)
 
 add_subdirectory(third_party/pybind11)
@@ -34,11 +45,6 @@ target_link_libraries(pyrealsense2 PRIVATE ${DEPENDENCIES})
 set_target_properties(pyrealsense2 PROPERTIES VERSION
     ${REALSENSE_VERSION_STRING} SOVERSION "${REALSENSE_VERSION_MAJOR}.${REALSENSE_VERSION_MINOR}")
 set_target_properties(pyrealsense2 PROPERTIES FOLDER Wrappers/python)
-install(TARGETS pyrealsense2 EXPORT realsense2Targets
-        RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-)
 
 set(RAW_RS
     pybackend.cpp
@@ -128,13 +134,36 @@ set_target_properties(pybackend2 PROPERTIES
 set_target_properties(pybackend2 PROPERTIES FOLDER Wrappers/python)
 include_directories(pybackend2 ../../include)
 
-install(TARGETS pybackend2
-        EXPORT realsense2Targets
+write_basic_package_version_file("${CMAKE_CURRENT_BINARY_DIR}/pyrealsense2ConfigVersion.cmake"
+    VERSION ${REALSENSE_VERSION_STRING} COMPATIBILITY AnyNewerVersion)
+
+configure_package_config_file(../../CMake/pyrealsense2Config.cmake.in pyrealsense2Config.cmake
+    INSTALL_DESTINATION ${CMAKECONFIG_PY_INSTALL_DIR}
+    INSTALL_PREFIX ${CMAKE_INSTALL_PREFIX}/bin
+    PATH_VARS CMAKE_INSTALL_INCLUDEDIR
+)
+
+install(TARGETS pybackend2 pyrealsense2
+        EXPORT pyrealsense2Targets
         RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-        LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-        ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+        LIBRARY DESTINATION ${PYTHON_INSTALL_DIR}
+        ARCHIVE DESTINATION ${PYTHON_INSTALL_DIR}
 )
 
+install(EXPORT pyrealsense2Targets
+  FILE pyrealsense2Targets.cmake
+  NAMESPACE pyrealsense2::
+  DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/pyrealsense2")
+
+install(FILES "${CMAKE_BINARY_DIR}/wrappers/python/pyrealsense2Config.cmake"
+  DESTINATION ${CMAKECONFIG_PY_INSTALL_DIR}
+)
+
+install(FILES "${CMAKE_BINARY_DIR}/wrappers/python/pyrealsense2ConfigVersion.cmake"
+  DESTINATION ${CMAKECONFIG_PY_INSTALL_DIR}
+)
+
+
 if (BUILD_PYTHON_DOCS)
     add_subdirectory(docs)
 endif()
diff --git a/wrappers/python/c_files.cpp b/wrappers/python/c_files.cpp
index 7ef8ede..106852e 100644
--- a/wrappers/python/c_files.cpp
+++ b/wrappers/python/c_files.cpp
@@ -3,6 +3,8 @@ Copyright(c) 2017 Intel Corporation. All Rights Reserved. */
 
 #include "python.hpp"
 #include "../include/librealsense2/rs.h"
+#include <iomanip>
+#include "types.h"
 
 std::string make_pythonic_str(std::string str)
 {
@@ -33,6 +35,8 @@ void init_c_files(py::module &m) {
     // rs2_sr300_visual_preset
     // rs2_rs400_visual_preset
     BIND_ENUM(m, rs2_playback_status, RS2_PLAYBACK_STATUS_COUNT, "") // No docstring in C++
+    BIND_ENUM(m, rs2_calibration_type, RS2_CALIBRATION_TYPE_COUNT, "Calibration type for use in device_calibration")
+    BIND_ENUM_CUSTOM(m, rs2_calibration_status, RS2_CALIBRATION_STATUS_FIRST, RS2_CALIBRATION_STATUS_LAST, "Calibration callback status for use in device_calibration.trigger_device_calibration")
 
     /** rs_types.h **/
     py::class_<rs2_intrinsics> intrinsics(m, "intrinsics", "Video stream intrinsics.");
@@ -46,18 +50,36 @@ void init_c_files(py::module &m) {
         .def_readwrite("model", &rs2_intrinsics::model, "Distortion model of the image")
         .def_property(BIND_RAW_ARRAY_PROPERTY(rs2_intrinsics, coeffs, float, 5), "Distortion coefficients")
         .def("__repr__", [](const rs2_intrinsics& self) {
-            std::stringstream ss;
-            ss << "width: " << self.width << ", ";
-            ss << "height: " << self.height << ", ";
-            ss << "ppx: " << self.ppx << ", ";
-            ss << "ppy: " << self.ppy << ", ";
-            ss << "fx: " << self.fx << ", ";
-            ss << "fy: " << self.fy << ", ";
-            ss << "model: " << self.model << ", ";
-            ss << "coeffs: " << array_to_string(self.coeffs);
+            std::ostringstream ss;
+            ss << self;
             return ss.str();
         });
 
+    py::class_<rs2_dsm_params> dsm_params( m, "dsm_params", "Video stream DSM parameters" );
+    dsm_params.def( py::init<>() )
+        .def_readonly( "timestamp", &rs2_dsm_params::timestamp, "seconds since epoch" )
+        .def_readonly( "version", &rs2_dsm_params::version, "major<<12 | minor<<4 | patch" )
+        .def_readwrite( "model", &rs2_dsm_params::model, "correction model (0/1/2 none/AOT/TOA)" )
+        .def_property( BIND_RAW_ARRAY_PROPERTY( rs2_dsm_params, flags, uint8_t, sizeof( rs2_dsm_params::flags )), "flags" )
+        .def_readwrite( "h_scale", &rs2_dsm_params::h_scale, "horizontal DSM scale" )
+        .def_readwrite( "v_scale", &rs2_dsm_params::v_scale, "vertical DSM scale" )
+        .def_readwrite( "h_offset", &rs2_dsm_params::h_offset, "horizontal DSM offset" )
+        .def_readwrite( "v_offset", &rs2_dsm_params::v_offset, "vertical DSM offset" )
+        .def_readwrite( "rtd_offset", &rs2_dsm_params::rtd_offset, "the Round-Trip-Distance delay" )
+        .def_property_readonly( "temp", 
+            []( rs2_dsm_params const & self ) -> float {
+                           return float( self.temp_x2 ) / 2;
+                       },
+            "temperature (LDD for depth; HUM for color)" )
+        .def_property( BIND_RAW_ARRAY_PROPERTY( rs2_dsm_params, reserved, uint8_t, sizeof( rs2_dsm_params::reserved )), "reserved" )
+        .def( "__repr__",
+            []( const rs2_dsm_params & self )
+            {
+                std::ostringstream ss;
+                ss << self;
+                return ss.str();
+            } );
+
     py::class_<rs2_motion_device_intrinsic> motion_device_intrinsic(m, "motion_device_intrinsic", "Motion device intrinsics: scale, bias, and variances.");
     motion_device_intrinsic.def(py::init<>())
         .def_property(BIND_RAW_2D_ARRAY_PROPERTY(rs2_motion_device_intrinsic, data, float, 3, 4), "3x4 matrix with 3x3 scale and cross axis and 3x1 biases")
diff --git a/wrappers/python/pyrs_device.cpp b/wrappers/python/pyrs_device.cpp
index 12a52f8..d547da1 100644
--- a/wrappers/python/pyrs_device.cpp
+++ b/wrappers/python/pyrs_device.cpp
@@ -2,6 +2,7 @@
 Copyright(c) 2017 Intel Corporation. All Rights Reserved. */
 
 #include "python.hpp"
+#include "../include/librealsense2/hpp/rs_internal.hpp"
 #include "../include/librealsense2/hpp/rs_device.hpp"
 #include "../include/librealsense2/hpp/rs_record_playback.hpp" // for downcasts
 
@@ -31,6 +32,8 @@ void init_device(py::module &m) {
         .def(BIND_DOWNCAST(device, updatable))
         .def(BIND_DOWNCAST(device, update_device))
         .def(BIND_DOWNCAST(device, auto_calibrated_device))
+        .def(BIND_DOWNCAST(device, device_calibration))
+        .def(BIND_DOWNCAST(device, firmware_logger))
         .def("__repr__", [](const rs2::device &self) {
             std::stringstream ss;
             ss << "<" SNAME ".device: " << self.get_info(RS2_CAMERA_INFO_NAME)
@@ -91,6 +94,31 @@ void init_device(py::module &m) {
         .def("set_calibration_table", &rs2::auto_calibrated_device::set_calibration_table, "Set current table to dynamic area.")
         .def("reset_to_factory_calibration", &rs2::auto_calibrated_device::reset_to_factory_calibration, "Reset device to factory calibration.");
 
+    py::class_<rs2::device_calibration, rs2::device> device_calibration( m, "device_calibration" );
+    device_calibration.def( py::init<rs2::device>(), "device"_a )
+        .def( "trigger_device_calibration", &rs2::device_calibration::trigger_device_calibration, "TODO", "calibration_type"_a )
+        .def( "register_calibration_change_callback",
+            []( rs2::device_calibration& self, std::function<void( rs2_calibration_status )> callback )
+            {
+                self.register_calibration_change_callback( 
+                    [callback]( rs2_calibration_status status )
+                    {
+                        try
+                        {
+                            // "When calling a C++ function from Python, the GIL is always held"
+                            // -- since we're not being called from Python but instead are calling it,
+                            // we need to acquire it to not have issues with other threads...
+                            py::gil_scoped_acquire gil;
+                            callback( status );
+                        }
+                        catch( ... )
+                        {
+                            std::cerr << "?!?!?!!? exception in python register_calibration_change_callback ?!?!?!?!?" << std::endl;
+                        }
+                    } );
+            },
+            "TODO", "callback"_a );
+
 
     py::class_<rs2::debug_protocol> debug_protocol(m, "debug_protocol"); // No docstring in C++
     debug_protocol.def(py::init<rs2::device>())
diff --git a/wrappers/python/pyrs_frame.cpp b/wrappers/python/pyrs_frame.cpp
index 7be2c17..6edd89e 100644
--- a/wrappers/python/pyrs_frame.cpp
+++ b/wrappers/python/pyrs_frame.cpp
@@ -130,8 +130,26 @@ void init_frame(py::module &m) {
         .def(BIND_DOWNCAST(frame, video_frame))
         .def(BIND_DOWNCAST(frame, depth_frame))
         .def(BIND_DOWNCAST(frame, motion_frame))
-        .def(BIND_DOWNCAST(frame, pose_frame));
+        .def(BIND_DOWNCAST(frame, pose_frame))
         // No apply_filter?
+        .def( "__repr__", []( const rs2::frame &self )
+        {
+            std::stringstream ss;
+            ss << "<" << SNAME << ".frame";
+            if( auto fs = self.as< rs2::frameset >() )
+            {
+                ss << "set";
+                for( auto sf : fs )
+                    ss << " " << rs2_format_to_string( sf.get_profile().format() );
+            }
+            else
+            {
+                ss << " " << rs2_format_to_string( self.get_profile().format() );
+            }
+            ss << " #" << self.get_frame_number();
+            ss << ">";
+            return ss.str();
+        });
 
     py::class_<rs2::video_frame, rs2::frame> video_frame(m, "video_frame", "Extends the frame class with additional video related attributes and functions.");
     video_frame.def(py::init<rs2::frame>())
diff --git a/wrappers/python/pyrs_internal.cpp b/wrappers/python/pyrs_internal.cpp
index 01c68e7..f62b6b7 100644
--- a/wrappers/python/pyrs_internal.cpp
+++ b/wrappers/python/pyrs_internal.cpp
@@ -152,5 +152,40 @@ void init_internal(py::module &m) {
              "info"_a, "val"_a);
         //.def("create_matcher", &rs2::software_device::create_matcher, "Set the wanted matcher type that will "
         //     "be used by the syncer", "matcher"_a) // TODO: bind rs2_matchers enum.
+
+    // rs2::firmware_log_message
+    py::class_<rs2::firmware_log_message> firmware_log_message(m, "firmware_log_message");
+    firmware_log_message.def("get_severity", &rs2::firmware_log_message::get_severity, "Get severity ")
+        .def("get_severity_str", &rs2::firmware_log_message::get_severity_str, "Get severity string ")
+        .def("get_timestamp", &rs2::firmware_log_message::get_timestamp, "Get timestamp ")
+        .def("get_data", &rs2::firmware_log_message::data, "Get data ")
+        .def("get_size", &rs2::firmware_log_message::size, "Get size ");
+
+    // rs2::firmware_log_parsed_message
+    py::class_<rs2::firmware_log_parsed_message> firmware_log_parsed_message(m, "firmware_log_parsed_message");
+    firmware_log_parsed_message.def("get_message", &rs2::firmware_log_parsed_message::message, "Get message ")
+        .def("get_file_name", &rs2::firmware_log_parsed_message::file_name, "Get file name ")
+        .def("get_thread_name", &rs2::firmware_log_parsed_message::thread_name, "Get thread name ")
+        .def("get_severity", &rs2::firmware_log_parsed_message::severity, "Get severity ")
+        .def("get_line", &rs2::firmware_log_parsed_message::line, "Get line ")
+        .def("get_timestamp", &rs2::firmware_log_parsed_message::timestamp, "Get timestamp ");
+
+    // rs2::firmware_logger
+    py::class_<rs2::firmware_logger, rs2::device> firmware_logger(m, "firmware_logger");
+    firmware_logger.def(py::init<rs2::device>(), "device"_a)
+        .def("create_message", &rs2::firmware_logger::create_message, "Create FW Log")
+        .def("create_parsed_message", &rs2::firmware_logger::create_parsed_message, "Create FW Parsed Log")
+        .def("get_firmware_log", &rs2::firmware_logger::get_firmware_log, "Get FW Log", "msg"_a)
+        .def("get_flash_log", &rs2::firmware_logger::get_flash_log, "Get Flash Log", "msg"_a)
+        .def("init_parser", &rs2::firmware_logger::init_parser, "Initialize Parser with content of xml file",
+            "xml_content"_a)
+        .def("parse_log", &rs2::firmware_logger::parse_log, "Parse Fw Log ", "msg"_a, "parsed_msg"_a);
+
+    // rs2::terminal_parser
+    py::class_<rs2::terminal_parser> terminal_parser(m, "terminal_parser");
+    terminal_parser.def(py::init<const std::string&>(), "xml_content"_a) 
+        .def("parse_command", &rs2::terminal_parser::parse_command, "Parse Command ", "cmd"_a)
+        .def("parse_response", &rs2::terminal_parser::parse_response, "Parse Response ", "cmd"_a, "response"_a);
+
     /** end rs_internal.hpp **/
 }
diff --git a/wrappers/python/pyrs_sensor.cpp b/wrappers/python/pyrs_sensor.cpp
index add34f8..dbfd4bc 100644
--- a/wrappers/python/pyrs_sensor.cpp
+++ b/wrappers/python/pyrs_sensor.cpp
@@ -3,6 +3,7 @@ Copyright(c) 2017 Intel Corporation. All Rights Reserved. */
 
 #include "python.hpp"
 #include "../include/librealsense2/hpp/rs_sensor.hpp"
+#include "calibrated-sensor.h"
 
 void init_sensor(py::module &m) {
     /** rs_sensor.hpp **/
@@ -61,6 +62,7 @@ void init_sensor(py::module &m) {
         }, "start passing frames into specified frame_queue", "queue"_a)
         .def("stop", &rs2::sensor::stop, "Stop streaming.", py::call_guard<py::gil_scoped_release>())
         .def("get_stream_profiles", &rs2::sensor::get_stream_profiles, "Retrieves the list of stream profiles supported by the sensor.")
+        .def("get_active_streams", &rs2::sensor::get_active_streams, "Retrieves the list of stream profiles currently streaming on the sensor.")
         .def_property_readonly("profiles", &rs2::sensor::get_stream_profiles, "The list of stream profiles supported by the sensor. Identical to calling get_stream_profiles")
         .def("get_recommended_filters", &rs2::sensor::get_recommended_filters, "Return the recommended list of filters by the sensor.")
         .def(py::init<>())
@@ -71,6 +73,7 @@ void init_sensor(py::module &m) {
         .def(BIND_DOWNCAST(sensor, motion_sensor))
         .def(BIND_DOWNCAST(sensor, fisheye_sensor))
         .def(BIND_DOWNCAST(sensor, pose_sensor))
+        .def(BIND_DOWNCAST(sensor, calibrated_sensor))
         .def(BIND_DOWNCAST(sensor, wheel_odometer));
 
     // rs2::sensor_from_frame [frame.def("get_sensor", ...)?
@@ -100,6 +103,15 @@ void init_sensor(py::module &m) {
     fisheye_sensor.def(py::init<rs2::sensor>(), "sensor"_a)
         .def("__nonzero__", &rs2::fisheye_sensor::operator bool); // No docstring in C++
 
+    py::class_<rs2::calibrated_sensor, rs2::sensor> cal_sensor( m, "calibrated_sensor" );
+    cal_sensor.def( py::init<rs2::sensor>(), "sensor"_a )
+        .def( "override_intrinsics", &rs2::calibrated_sensor::override_intrinsics, "intrinsics"_a )
+        .def( "override_extrinsics", &rs2::calibrated_sensor::override_extrinsics, "extrinsics"_a )
+        .def( "get_dsm_params", &rs2::calibrated_sensor::get_dsm_params )
+        .def( "override_dsm_params", &rs2::calibrated_sensor::override_dsm_params, "dsm_params"_a )
+        .def( "reset_calibration", &rs2::calibrated_sensor::reset_calibration )
+        .def( "__nonzero__", &rs2::calibrated_sensor::operator bool );
+
     // rs2::depth_stereo_sensor
     py::class_<rs2::depth_stereo_sensor, rs2::depth_sensor> depth_stereo_sensor(m, "depth_stereo_sensor"); // No docstring in C++
     depth_stereo_sensor.def(py::init<rs2::sensor>())
diff --git a/wrappers/python/python.cpp b/wrappers/python/python.cpp
index ad92616..29e6050 100644
--- a/wrappers/python/python.cpp
+++ b/wrappers/python/python.cpp
@@ -4,6 +4,7 @@ Copyright(c) 2017 Intel Corporation. All Rights Reserved. */
 #include "python.hpp"
 #include "../include/librealsense2/rs.hpp"
 #include "../include/librealsense2/hpp/rs_export.hpp"
+#include "types.h"
 
 PYBIND11_MODULE(NAME, m) {
     m.doc() = R"pbdoc(
@@ -37,10 +38,11 @@ PYBIND11_MODULE(NAME, m) {
         .def_property_readonly_static("option_ply_normals", [](py::object) { return rs2::save_to_ply::OPTION_PLY_NORMALS; })
         .def_property_readonly_static("option_ply_threshold", [](py::object) { return rs2::save_to_ply::OPTION_PLY_THRESHOLD; });
 
-    /** rs.hpp **/
     m.def("log_to_console", &rs2::log_to_console, "min_severity"_a);
     m.def("log_to_file", &rs2::log_to_file, "min_severity"_a, "file_path"_a);
 
+	// Access to log_message is only from a callback (see log_to_callback below) and so already
+	// should have the GIL acquired
     py::class_<rs2::log_message> log_message(m, "log_message");
     log_message.def("line_number", &rs2::log_message::line_number)
         .def("filename", &rs2::log_message::filename)
@@ -49,12 +51,26 @@ PYBIND11_MODULE(NAME, m) {
         .def("__str__", &rs2::log_message::raw)
         .def("__repr__", &rs2::log_message::full);
 
-    m.def("log_to_callback", [](rs2_log_severity min_severity, std::function<void(rs2_log_severity, rs2::log_message)> callback)
-    {
-        rs2::log_to_callback(min_severity, callback);
-    }, "min_severity"_a, "callback"_a);
-    m.def("log", &rs2::log, "severity"_a, "message"_a);
-
-    // rs2::log?
-    /** end rs.hpp **/
+    m.def("log_to_callback",
+        [](rs2_log_severity min_severity, std::function<void(rs2_log_severity, rs2::log_message)> callback)
+        {
+            rs2::log_to_callback( min_severity,
+                [callback]( rs2_log_severity severity, rs2::log_message const & msg ) noexcept
+                {
+                    try
+                    {
+                        // We're not being called from Python but instead are calling it,
+                        // we need to acquire it to not have issues with other threads...
+                        py::gil_scoped_acquire gil;
+                        callback( severity, msg );
+                    }
+                    catch( ... )
+                    {
+                        std::cerr << "?!?!?!!? exception in python log_to_callback callback ?!?!?!?!?" << std::endl;
+                    }
+                } );
+        }, "min_severity"_a, "callback"_a);
+    // A call to rs.log() will cause a callback to get called! We should already own the GIL, but
+    // release it just in case to let others do their thing...
+    m.def("log", &rs2::log, "severity"_a, "message"_a, py::call_guard<py::gil_scoped_release>());
 }
diff --git a/wrappers/python/python.hpp b/wrappers/python/python.hpp
index c14e3ab..88e227d 100644
--- a/wrappers/python/python.hpp
+++ b/wrappers/python/python.hpp
@@ -35,12 +35,13 @@ using namespace pybind11::literals;
 // Binding enums
 const std::string rs2_prefix{ "rs2_" };
 std::string make_pythonic_str(std::string str);
-#define BIND_ENUM(module, rs2_enum_type, RS2_ENUM_COUNT, docstring)                                                         \
+#define BIND_ENUM(module, rs2_enum_type, RS2_ENUM_COUNT, docstring) BIND_ENUM_CUSTOM( module, rs2_enum_type, 0, RS2_ENUM_COUNT-1, docstring)
+#define BIND_ENUM_CUSTOM(module, rs2_enum_type, FIRST, LAST, docstring)                                                     \
     static std::string rs2_enum_type##pyclass_name = std::string(#rs2_enum_type).substr(rs2_prefix.length());               \
     /* Above 'static' is required in order to keep the string alive since py::class_ does not copy it */                    \
     py::enum_<rs2_enum_type> py_##rs2_enum_type(module, rs2_enum_type##pyclass_name.c_str(), docstring);                    \
     /* std::cout << std::endl << "## " << rs2_enum_type##pyclass_name  << ":" << std::endl; */                              \
-    for (int i = 0; i < static_cast<int>(RS2_ENUM_COUNT); i++)                                                              \
+    for (int i = FIRST; i <= LAST; i++)                                                                                     \
     {                                                                                                                       \
         rs2_enum_type v = static_cast<rs2_enum_type>(i);                                                                    \
         const char* enum_name = rs2_enum_type##_to_string(v);                                                               \
diff --git a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepth.asset b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepth.asset
index ced8a27..905ab2f 100644
--- a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepth.asset
+++ b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepth.asset
@@ -45,4 +45,4 @@ MonoBehaviour:
   enabled: 1
   TextureStream: 1
   TextureFormat: 1
-  _occlusionRemoval: 0
+  _occlusionRemoval: 1
diff --git a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepthAndColor.asset b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepthAndColor.asset
index 10405f0..79ef06f 100644
--- a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepthAndColor.asset
+++ b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudDepthAndColor.asset
@@ -27,4 +27,4 @@ MonoBehaviour:
   enabled: 1
   TextureStream: 2
   TextureFormat: 5
-  _occlusionRemoval: 0
+  _occlusionRemoval: 1
diff --git a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudProcessingBlocks.asset b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudProcessingBlocks.asset
index c28970e..a53e2b8 100644
--- a/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudProcessingBlocks.asset
+++ b/wrappers/unity/Assets/RealSenseSDK2.0/ProcessingPipe/PointCloudProcessingBlocks.asset
@@ -138,7 +138,7 @@ MonoBehaviour:
   enabled: 1
   TextureStream: 1
   TextureFormat: 5
-  _occlusionRemoval: 0
+  _occlusionRemoval: 1
 --- !u!114 &114947088938950326
 MonoBehaviour:
   m_ObjectHideFlags: 0
diff --git a/wrappers/unity/Assets/RealSenseSDK2.0/Scripts/ProcessingBlocks/RsPointCloud.cs b/wrappers/unity/Assets/RealSenseSDK2.0/Scripts/ProcessingBlocks/RsPointCloud.cs
index ba2fe28..60328f0 100644
--- a/wrappers/unity/Assets/RealSenseSDK2.0/Scripts/ProcessingBlocks/RsPointCloud.cs
+++ b/wrappers/unity/Assets/RealSenseSDK2.0/Scripts/ProcessingBlocks/RsPointCloud.cs
@@ -5,9 +5,8 @@ public class RsPointCloud : RsProcessingBlock
 {
     public enum OcclusionRemoval
     {
-        Off = 0,
-        Heuristic = 1,
-        Exhaustive = 2
+        Off = 1,
+        On = 2
     }
 
     public Stream TextureStream = Stream.Color;
diff --git a/wrappers/unrealengine4/Plugins/RealSense/Source/RealSense/Public/RealSenseTypes.h b/wrappers/unrealengine4/Plugins/RealSense/Source/RealSense/Public/RealSenseTypes.h
index 9181fbf..9236fb0 100755
--- a/wrappers/unrealengine4/Plugins/RealSense/Source/RealSense/Public/RealSenseTypes.h
+++ b/wrappers/unrealengine4/Plugins/RealSense/Source/RealSense/Public/RealSenseTypes.h
@@ -126,6 +126,8 @@ enum class ERealSenseOptionType : uint8
     SENSOR_MODE                                , /**< The resolution mode: see rs2_sensor_mode for values */
     EMITTER_ALWAYS_ON                          , /**< Enable Laser On constantly (GS SKU Only) */
     THERMAL_COMPENSATION                       , /**< Depth Thermal Compensation for selected D400 SKUs */
+    TRIGGER_CAMERA_ACCURACY_HEALTH             ,
+    RESET_CAMERA_ACCURACY_HEALTH               ,
 };
 
 UENUM(Blueprintable)
-- 
2.17.1

