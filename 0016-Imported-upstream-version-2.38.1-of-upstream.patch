From 0292fe416dac847f0bc36b0b3ba404592b1bbf12 Mon Sep 17 00:00:00 2001
From: doronhi <doron_hirshberg@hotmail.com>
Date: Wed, 9 Sep 2020 10:14:54 +0300
Subject: [PATCH 16/18] Imported upstream version '2.38.1' of 'upstream'

---
 CMake/lrs_options.cmake                       |    2 +-
 NOTICE                                        |   35 +
 common/CMakeLists.txt                         |    4 +
 common/cah-model.cpp                          |  218 ++
 common/cah-model.h                            |   62 +
 common/fw-update-helper.cpp                   |   31 +-
 common/fw-update-helper.h                     |   11 +-
 common/fw/CMakeLists.txt                      |    4 +-
 common/fw/firmware-version.h                  |    4 +-
 common/metadata-helper.cpp                    |    2 +-
 common/model-views.cpp                        |  278 +--
 common/model-views.h                          |   36 +-
 common/output-model.cpp                       |   91 +-
 common/output-model.h                         |   10 +-
 common/sw-update/dev-updates-profile.cpp      |    6 +-
 common/updates-model.cpp                      |    8 +-
 common/updates-model.h                        |    4 +-
 common/ux-window.cpp                          |   16 +-
 common/viewer.cpp                             |   10 +-
 include/librealsense2/h/rs_device.h           |   29 +-
 include/librealsense2/h/rs_option.h           |   10 +
 include/librealsense2/rs.h                    |    4 +-
 package.xml                                   |    2 +-
 .../calibration-types.h                       |    3 +
 .../depth-to-rgb-calibration/frame-data.h     |  137 +-
 .../depth-to-rgb-calibration/k-to-dsm.cpp     |   68 +-
 src/algo/depth-to-rgb-calibration/k-to-dsm.h  |    4 +-
 .../depth-to-rgb-calibration/optimizer.cpp    |  917 +++++--
 src/algo/depth-to-rgb-calibration/optimizer.h |  116 +-
 src/algo/depth-to-rgb-calibration/utils.h     |    4 +
 .../valid-results.cpp                         |   88 +-
 .../depth-to-rgb-calibration/valid-scene.cpp  |  538 +++-
 src/android/jni/device.cpp                    |    7 +-
 src/android/jni/sensor.cpp                    |    8 +-
 src/concurrency.h                             |   15 +-
 src/depth-to-rgb-calibration.cpp              |   89 +-
 src/depth-to-rgb-calibration.h                |   16 +-
 src/ds5/ds5-active.cpp                        |   11 +-
 src/ds5/ds5-device.cpp                        |   38 +-
 src/ds5/ds5-private.h                         |    2 +-
 src/firmware_logger_device.cpp                |    2 -
 src/frame-archive.h                           |    2 +-
 src/global_timestamp_reader.cpp               |   93 +-
 src/global_timestamp_reader.h                 |    9 +-
 src/l500/ac-trigger.cpp                       | 1075 ++++++--
 src/l500/ac-trigger.h                         |   78 +-
 src/l500/l500-color.cpp                       |  144 +-
 src/l500/l500-color.h                         |   71 +-
 src/l500/l500-depth.cpp                       |   95 +-
 src/l500/l500-device.cpp                      |   72 +-
 src/l500/l500-device.h                        |    5 +-
 src/l500/l500-private.h                       |   15 +-
 src/linux/backend-v4l2.cpp                    |    1 -
 src/linux/backend-v4l2.h                      |    1 -
 src/mf/mf-backend.cpp                         |    7 +-
 src/mf/mf-hid.h                               |    8 +-
 src/mf/mf-uvc.h                               |    5 +-
 src/pipeline/pipeline.cpp                     |   18 +-
 src/proc/occlusion-filter.cpp                 |   70 +-
 src/rs.cpp                                    |    3 +-
 src/software-device.cpp                       |    5 +-
 src/software-device.h                         |   16 +
 src/types.cpp                                 |   41 +-
 src/types.h                                   |   10 +-
 src/uvc/uvc-device.cpp                        |    2 +-
 src/uvc/uvc-streamer.cpp                      |   20 +-
 src/uvc/uvc-streamer.h                        |    2 +
 tools/depth-quality/depth-quality-model.cpp   |    3 +-
 tools/fw-logger/rs-fw-logger.cpp              |    4 +-
 tools/realsense-viewer/realsense-viewer.cpp   |    7 +-
 tools/rs-imu-calibration/README.md            |    7 +-
 unit-tests/algo/d2rgb/ac-logger.h             |   19 +-
 unit-tests/algo/d2rgb/compare-scene.h         | 2159 +++++++++++------
 unit-tests/algo/d2rgb/compare-to-bin-file.h   |   22 +-
 unit-tests/algo/d2rgb/d2rgb-common.h          |   33 +-
 unit-tests/algo/d2rgb/scene-data.h            |    7 +-
 unit-tests/algo/d2rgb/test-reproduction.cpp   |  198 +-
 unit-tests/algo/d2rgb/test-scenes.cpp         |   28 +-
 unit-tests/profiler.h                         |   90 +
 unit-tests/unit-test-long.cpp                 |  218 +-
 .../tools/camera/src/main/AndroidManifest.xml |    3 +-
 .../realsense/camera/DetachedActivity.java    |   84 +-
 .../realsense/camera/PreviewActivity.java     |   33 +
 .../box_dimensioner_multicam/readme.md        |    2 +-
 wrappers/python/pyrs_device.cpp               |   10 +-
 wrappers/python/pyrs_sensor.cpp               |   23 +-
 86 files changed, 5565 insertions(+), 2193 deletions(-)
 create mode 100644 common/cah-model.cpp
 create mode 100644 common/cah-model.h
 rewrite unit-tests/algo/d2rgb/compare-scene.h (83%)
 create mode 100644 unit-tests/profiler.h

diff --git a/CMake/lrs_options.cmake b/CMake/lrs_options.cmake
index 8d13e25..8b78aa7 100644
--- a/CMake/lrs_options.cmake
+++ b/CMake/lrs_options.cmake
@@ -31,5 +31,5 @@ option(BUILD_NETWORK_DEVICE "Build Network Device support" OFF)
 option(FORCE_LIBUVC "Explicitly turn-on libuvc backend - deprecated, use FORCE_RSUSB_BACKEND instead" OFF)
 option(FORCE_WINUSB_UVC "Explicitly turn-on winusb_uvc (for win7) backend - deprecated, use FORCE_RSUSB_BACKEND instead" OFF)
 option(ANDROID_USB_HOST_UVC "Build UVC backend for Android - deprecated, use FORCE_RSUSB_BACKEND instead" OFF)
-option(ENABLE_L500_DEPTH_INVALIDATION "Turn on the depth frame validator to automatically catch corrupted frames and restart the sensor" ON)
+option(ENABLE_L500_DEPTH_INVALIDATION "Turn on the depth frame validator to automatically catch corrupted frames and restart the sensor" OFF)
 option(CHECK_FOR_UPDATES "Checks for versions updates" OFF)
diff --git a/NOTICE b/NOTICE
index 9e0e29b..c467da0 100644
--- a/NOTICE
+++ b/NOTICE
@@ -253,6 +253,41 @@ FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.
 
+OpenCV (3-clause BSD License), https://opencv.org/
+===============================================================================
+Copyright (C) 2000-2019, Intel Corporation, all rights reserved.
+Copyright (C) 2009-2011, Willow Garage Inc., all rights reserved.
+Copyright (C) 2009-2016, NVIDIA Corporation, all rights reserved.
+Copyright (C) 2010-2013, Advanced Micro Devices, Inc., all rights reserved.
+Copyright (C) 2015-2016, OpenCV Foundation, all rights reserved.
+Copyright (C) 2015-2016, Itseez Inc., all rights reserved.
+Copyright (C) 2019-2020, Xperience AI, all rights reserved.
+
+Third party copyrights are property of their respective owners.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution.
+* Neither the names of the copyright holders nor the names of the contributors
+may be used to endorse or promote products derived from this software without
+specific prior written permission.
+
+This software is provided by the copyright holders and contributors “as is” and
+any express or implied warranties, including, but not limited to, the implied
+warranties of merchantability and fitness for a particular purpose are
+disclaimed. In no event shall copyright holders or contributors be liable for
+any direct, indirect, incidental, special, exemplary, or consequential damages
+(including, but not limited to, procurement of substitute goods or services;
+loss of use, data, or profits; or business interruption) however caused and on
+any theory of liability, whether in contract, strict liability, or tort
+(including negligence or otherwise) arising in any way out of the use of this
+software, even if advised of the possibility of such damage.
+
 easyloggingpp (The MIT License), https://github.com/easylogging/easyloggingpp/
 ===============================================================================
 Copyright (c) 2015 muflihun.com
diff --git a/common/CMakeLists.txt b/common/CMakeLists.txt
index 8e7d0bc..e86b4d3 100644
--- a/common/CMakeLists.txt
+++ b/common/CMakeLists.txt
@@ -36,6 +36,10 @@ set(COMMON_SRC
         "${CMAKE_CURRENT_LIST_DIR}/decompress-huffman.h"
         "${CMAKE_CURRENT_LIST_DIR}/updates-model.h"
         "${CMAKE_CURRENT_LIST_DIR}/updates-model.cpp"
+        "${CMAKE_CURRENT_LIST_DIR}/cah-model.h"
+        "${CMAKE_CURRENT_LIST_DIR}/cah-model.cpp"
+        
+        
 )
 
     set(SW_UPDATE_FILES
diff --git a/common/cah-model.cpp b/common/cah-model.cpp
new file mode 100644
index 0000000..c3edbda
--- /dev/null
+++ b/common/cah-model.cpp
@@ -0,0 +1,218 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#include <algorithm>
+#include "cah-model.h"
+#include "model-views.h"
+ 
+using namespace rs2;
+
+// This variable is global for protecting the case when the callback will be called when the device model no longer exist.
+// TODO: Refactor for handling multiple L515 devices support.
+static std::atomic<rs2_calibration_status> global_calib_status; 
+
+cah_model::cah_model(device_model & dev_model, viewer_model& viewer) :
+    _dev_model(dev_model),
+    _viewer(viewer),
+    _state(model_state_type::TRIGGER_MODAL),
+    _process_started(false), 
+    _process_timeout()
+{
+    global_calib_status = RS2_CALIBRATION_NOT_NEEDED;
+
+    // Register AC status change callback
+    device_calibration dev_cal(dev_model.dev);
+    dev_cal.register_calibration_change_callback([&](rs2_calibration_status cal_status)
+    {
+        global_calib_status = cal_status;
+    });
+}
+
+
+bool cah_model::prompt_trigger_popup(ux_window& window, std::string& error_message)
+{
+    // This process is built from a 2 stages windows, first a yes/no window and then a process window
+    bool keep_showing = true;
+    bool yes_was_chosen = false;
+
+    switch (_state.load())
+    {
+    case model_state_type::TRIGGER_MODAL:
+    {
+        // Make sure the firmware meets the minimal version for Trigger Camera Accuracy features
+        const std::string& min_fw_version("1.5.0.0");
+        auto fw_upgrade_needed = is_upgradeable(_dev_model.dev.get_info(rs2_camera_info::RS2_CAMERA_INFO_FIRMWARE_VERSION), min_fw_version);
+        bool is_depth_streaming = std::any_of(_dev_model.subdevices.begin(), _dev_model.subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<depth_sensor>(); });
+        bool is_color_streaming = std::any_of(_dev_model.subdevices.begin(), _dev_model.subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<color_sensor>(); });
+        bool auto_cah_is_working = RS2_CALIBRATION_SUCCESSFUL != global_calib_status
+                                && RS2_CALIBRATION_FAILED != global_calib_status
+                                && RS2_CALIBRATION_NOT_NEEDED != global_calib_status
+                                && RS2_CALIBRATION_BAD_CONDITIONS != global_calib_status;
+
+        std::string message_text = "Camera Accuracy Health will ensure you get the highest accuracy from your camera.\n\n"
+            "This process may take several minutes and requires special setup to get good results.\n"
+            "While it is working, the viewer will not be usable.";
+
+        std::string disable_reason_text;
+        if (fw_upgrade_needed)
+        {
+            disable_reason_text = "Camera Accuracy Health requires a minimal FW version of " + min_fw_version +
+                "\n\nPlease update your firmware and try again. ";
+        }
+        else if (!is_depth_streaming || !is_color_streaming)
+        {
+            disable_reason_text = "Camera Accuracy Health cannot be triggered : both depth & RGB streams must be active.";
+        }
+        else if (auto_cah_is_working)
+        {
+            disable_reason_text = "Camera Accuracy Health is already in progress in the background.\n"
+                            "Please try again in a few minutes. ";
+        }
+        else
+        {
+            message_text += "\n\nAre you sure you want to continue?";
+        }
+
+        bool option_disabled = !is_depth_streaming || !is_color_streaming || auto_cah_is_working || fw_upgrade_needed;
+        if (yes_no_dialog("Camera Accuracy Health Trigger", message_text, yes_was_chosen, window, error_message, option_disabled, disable_reason_text))
+        {
+            if (yes_was_chosen)
+            {
+
+                auto itr = std::find_if(_dev_model.subdevices.begin(), _dev_model.subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
+                {
+                    if (sub->s->as<depth_sensor>())
+                        return true;
+                    return false;
+                });
+
+
+                if (is_depth_streaming && is_color_streaming && itr != _dev_model.subdevices.end())
+                {
+                    auto sd = *itr;
+                    global_calib_status = RS2_CALIBRATION_RETRY; // To indicate in progress state
+                    try
+                    {
+                        sd->s->set_option(RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH, static_cast<float>(RS2_CAH_TRIGGER_NOW));
+                    }
+                    catch( std::exception const & e )
+                    {
+                        error_message = to_string() << "Trigger calibration failure:\n" << e.what();
+                        _process_started = false;
+                        global_calib_status = RS2_CALIBRATION_FAILED;
+                        return false;
+                    }
+                    
+                    _state = model_state_type::PROCESS_MODAL;
+                    // We switch to process state without a guarantee that the process really started,
+                    // Set a timeout to make sure if it is not started we will allow closing the window.
+                    _process_timeout.start( std::chrono::seconds( 30 ) );
+
+                }
+            }
+            else
+            {
+                keep_showing = false;
+            }
+        }
+    }
+    break;
+
+    case model_state_type::PROCESS_MODAL:
+    {
+        if (!_process_started)
+        {
+            // Indication of calibration process start
+            _process_started = global_calib_status == RS2_CALIBRATION_TRIGGERED
+                            || global_calib_status == RS2_CALIBRATION_SPECIAL_FRAME
+                            || global_calib_status == RS2_CALIBRATION_STARTED;
+        }
+
+        bool process_finished = global_calib_status == RS2_CALIBRATION_SUCCESSFUL
+                             || global_calib_status == RS2_CALIBRATION_FAILED
+                             || global_calib_status == RS2_CALIBRATION_NOT_NEEDED
+                             || global_calib_status == RS2_CALIBRATION_BAD_CONDITIONS;
+
+        static std::map<rs2_calibration_status, std::string> status_map{
+            {RS2_CALIBRATION_TRIGGERED      , "In Progress" },
+            {RS2_CALIBRATION_SPECIAL_FRAME  , "In Progress" },
+            {RS2_CALIBRATION_STARTED        , "In Progress" },
+            {RS2_CALIBRATION_NOT_NEEDED     , "Ended" },
+            {RS2_CALIBRATION_SUCCESSFUL     , "Ended Successfully" },
+            {RS2_CALIBRATION_BAD_CONDITIONS , "Invalid Conditions" },
+            {RS2_CALIBRATION_RETRY          , "In Progress" },
+            {RS2_CALIBRATION_FAILED         , "Ended With Failure" },
+            {RS2_CALIBRATION_SCENE_INVALID  , "In Progress" },
+            {RS2_CALIBRATION_BAD_RESULT     , "In Progress" } };
+
+        rs2_calibration_status calibration_status = global_calib_status;
+
+        // We don't know if AC really started working so we add a timeout for not blocking the viewer forever.
+        if (!_process_started)
+        {
+            if (_process_timeout.has_expired())
+            {
+                process_finished = true; // on timeout display failure and allow closing the window
+                calibration_status = RS2_CALIBRATION_FAILED;
+            }
+        }
+
+        const std::string & message = process_finished ? "                                                               " :
+                                                         "Camera Accuracy Health is In progress, this may take a while...";
+        if (status_dialog("Camera Accuracy Health Status", message, status_map[calibration_status], process_finished, window))
+        {
+            keep_showing = false;
+        }
+    }
+    break;
+    default:
+        break;
+
+    }
+
+    //reset internal elements for next process
+    if (!keep_showing)
+    {
+        _state = model_state_type::TRIGGER_MODAL;
+        _process_started = false;
+    }
+    return keep_showing;
+}
+
+bool cah_model::prompt_reset_popup(ux_window& window, std::string& error_message)
+{
+    bool keep_showing = true;
+    bool yes_was_chosen = false;
+
+    std::string message_text("This will reset the camera settings to their factory-calibrated state.\nYou will lose any improvements made with Camera Accuracy Health.\n\n Are you sure?");
+    if (yes_no_dialog("Camera Accuracy Health Reset", message_text, yes_was_chosen, window, error_message))
+    {
+        if (yes_was_chosen)
+        {
+            auto itr = std::find_if(_dev_model.subdevices.begin(), _dev_model.subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
+            {
+                if (sub->s->as<depth_sensor>())
+                    return true;
+                return false;
+            });
+
+
+            if (itr != _dev_model.subdevices.end())
+            {
+                auto sd = *itr;
+                // Trigger CAH process
+                try
+                {
+                    sd->s->set_option(RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH, 1.0f);
+                }
+                catch (std::exception const & e)
+                {
+                    error_message = to_string() << "Calibration reset failure:\n" << e.what();
+                }
+            }
+        }
+        keep_showing = false;
+    }
+
+    return keep_showing;
+}
diff --git a/common/cah-model.h b/common/cah-model.h
new file mode 100644
index 0000000..71fe17d
--- /dev/null
+++ b/common/cah-model.h
@@ -0,0 +1,62 @@
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+#pragma once
+
+#include <string>
+#include <chrono>
+#include <atomic>
+
+namespace rs2
+{
+    class ux_window;
+    class viewer_model;
+    class device_model;
+
+    // Helper class for setting , starting and checking a timeout.
+    // Inner units are [ms] , API units are seconds.
+    // This class is not thread safe and should not be passed between threads.
+    class timeout
+    {
+    public:
+        timeout() : timeout_delay_ms(0), start_time_ms(0) {};
+
+        // Start timer from current time
+        // Can be called with std::chrono::hours/minutes/seconds/milliseconds/microseconds/nanoseconds type
+        void start(std::chrono::seconds timeout)
+        {
+            using namespace std::chrono;
+            start_time_ms = duration_cast<milliseconds>(high_resolution_clock::now().time_since_epoch()).count();
+            timeout_delay_ms = duration_cast<milliseconds>(timeout).count();
+        }
+
+        // Check if timeout expired
+        bool has_expired() const
+        {
+            using namespace std::chrono;
+            auto curr_time = duration_cast<milliseconds>(high_resolution_clock::now().time_since_epoch()).count();
+            return curr_time - start_time_ms >= timeout_delay_ms;
+        }
+
+    private:
+        long long timeout_delay_ms;
+        long long start_time_ms;
+    };
+
+    class cah_model // CAH = Camera Accuracy Health
+    {
+    public:
+        cah_model(device_model & dev_model, viewer_model& viewer);
+
+        bool prompt_trigger_popup(ux_window& window, std::string& error_message);
+        bool prompt_reset_popup(ux_window& window, std::string& error_message);
+    private:
+
+        device_model & _dev_model;
+        viewer_model& _viewer;
+        enum class model_state_type { TRIGGER_MODAL, PROCESS_MODAL };
+        std::atomic<model_state_type> _state; // will be set from a different thread callback function
+        bool _process_started;
+        timeout _process_timeout;
+    };
+}
diff --git a/common/fw-update-helper.cpp b/common/fw-update-helper.cpp
index 15ce626..eb0344e 100644
--- a/common/fw-update-helper.cpp
+++ b/common/fw-update-helper.cpp
@@ -2,14 +2,16 @@
 // Copyright(c) 2017 Intel Corporation. All Rights Reserved.
 #include <glad/glad.h>
 
-#include "fw-update-helper.h"
 
 #include <map>
 #include <vector>
 #include <string>
 #include <thread>
 #include <condition_variable>
-#include <model-views.h>
+
+#include "fw-update-helper.h"
+#include "model-views.h"
+#include "viewer.h"
 
 #include "os.h"
 
@@ -379,12 +381,33 @@ namespace rs2
 
                 if (ImGui::Button(button_name.c_str(), { float(bar_width), 20.f }) || update_manager->started())
                 {
+                    // stopping stream before starting fw update
+                    auto fw_update_manager = dynamic_cast<firmware_update_manager*>(update_manager.get());
+                    std::for_each(fw_update_manager->get_device_model().subdevices.begin(),
+                        fw_update_manager->get_device_model().subdevices.end(),
+                        [&](const std::shared_ptr<subdevice_model>& sm)
+                        {
+                            if (sm->streaming)
+                            {
+                                try
+                                {
+                                    sm->stop(fw_update_manager->get_viewer_model());
+                                }
+                                catch (...) 
+                                { 
+                                    // avoiding exception that can be sent by stop method
+                                    // this could happen if the sensor is not streaming and the stop method is called - for example 
+                                }
+                            }   
+                        });
+
                     auto _this = shared_from_this();
                     auto invoke = [_this](std::function<void()> action) {
                         _this->invoke(action);
                     };
-                    
-                    if (!update_manager->started()) update_manager->start(invoke);
+
+                    if (!update_manager->started()) 
+                        update_manager->start(invoke);
 
                     update_state = RS2_FWU_STATE_IN_PROGRESS;
                     enable_dismiss = false;
diff --git a/common/fw-update-helper.h b/common/fw-update-helper.h
index 602f5e9..9fb5de5 100644
--- a/common/fw-update-helper.h
+++ b/common/fw-update-helper.h
@@ -5,8 +5,11 @@
 
 #include "notifications.h"
 
+
 namespace rs2
 {
+    class viewer_model;
+
     int parse_product_line(std::string id);
     std::string get_available_firmware_version(int product_line);
     std::map<int, std::vector<uint8_t>> create_default_fw_table();
@@ -17,10 +20,13 @@ namespace rs2
     class firmware_update_manager : public process_manager
     {
     public:
-        firmware_update_manager(device_model& model, device dev, context ctx, std::vector<uint8_t> fw, bool is_signed) 
-            : process_manager("Firmware Update"), _model(model),
+        firmware_update_manager(viewer_model& viewer, device_model& model, device dev, context ctx, std::vector<uint8_t> fw, bool is_signed)
+            : process_manager("Firmware Update"), _viewer(viewer), _model(model),
               _fw(fw), _is_signed(is_signed), _dev(dev), _ctx(ctx) {}
 
+        const device_model& get_device_model() const { return _model; }
+        viewer_model& get_viewer_model() { return _viewer; }
+
     private:
         void process_flow(std::function<void()> cleanup, 
             invoker invoke) override;
@@ -28,6 +34,7 @@ namespace rs2
             std::function<bool()> action, std::function<void()> cleanup,
             std::chrono::system_clock::duration delta);
 
+        viewer_model& _viewer;
         device _dev;
         context _ctx;
         std::vector<uint8_t> _fw;
diff --git a/common/fw/CMakeLists.txt b/common/fw/CMakeLists.txt
index aff05eb..1420e85 100644
--- a/common/fw/CMakeLists.txt
+++ b/common/fw/CMakeLists.txt
@@ -14,7 +14,7 @@ set(REALSENSE_FIRMWARE_URL "http://realsense-hw-public.s3.amazonaws.com" CACHE S
 string(REGEX MATCH "D4XX_RECOMMENDED_FIRMWARE_VERSION \"([0-9]+.[0-9]+.[0-9]+.[0-9]+)\"" _ ${ver})
 set(D4XX_FW_VERSION ${CMAKE_MATCH_1})
 message(STATUS "D4XX_FW_VERSION: ${D4XX_FW_VERSION}")
-set(D4XX_FW_SHA1 b8161801bffb8880952b23c12c52581a4c62adb6)
+set(D4XX_FW_SHA1 dc690d0a6ed113eee8ed41a0c1589c58975bd724)
 set(D4XX_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/RS4xx/FW")
 
 
@@ -33,7 +33,7 @@ set(T26X_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/TM2/FW/target/${T26X_FW_VERS
 string(REGEX MATCH "L5XX_RECOMMENDED_FIRMWARE_VERSION \"([0-9]+.[0-9]+.[0-9]+.[0-9]+)\"" _ ${ver})
 set(L5XX_FW_VERSION ${CMAKE_MATCH_1})
 message(STATUS "L5XX_FW_VERSION: ${L5XX_FW_VERSION}")
-set(L5XX_FW_SHA1 7e92856a80e7b63a9976718a56b6fb7e51af714f)
+set(L5XX_FW_SHA1 024cc496856db78569edecbbbf681aafd566b41d)
 set(L5XX_FW_URL "${REALSENSE_FIRMWARE_URL}/Releases/L5xx/FW")
 
 add_library(${PROJECT_NAME} STATIC empty.c)
diff --git a/common/fw/firmware-version.h b/common/fw/firmware-version.h
index c0ca060..c2914b7 100644
--- a/common/fw/firmware-version.h
+++ b/common/fw/firmware-version.h
@@ -3,7 +3,7 @@
 
 #pragma once
 
-#define D4XX_RECOMMENDED_FIRMWARE_VERSION "5.12.6.0"
+#define D4XX_RECOMMENDED_FIRMWARE_VERSION "5.12.7.100"
 #define SR3XX_RECOMMENDED_FIRMWARE_VERSION "3.26.1.0"
 #define T26X_FIRMWARE_VERSION "0.2.0.951"
-#define L5XX_RECOMMENDED_FIRMWARE_VERSION "1.4.1.2"
+#define L5XX_RECOMMENDED_FIRMWARE_VERSION "1.5.0.0"
diff --git a/common/metadata-helper.cpp b/common/metadata-helper.cpp
index 7182b27..cef49c6 100644
--- a/common/metadata-helper.cpp
+++ b/common/metadata-helper.cpp
@@ -53,7 +53,7 @@ namespace rs2
     public:
         static bool parse_device_id(const std::string& id, device_id* res)
         {
-            static const std::regex regex("pid_([0-9a-f]+)&mi_([0-9]+)#[0-9]&([0-9a-f]+)&[\\s\\S]*\\{([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\\}", std::regex_constants::icase);
+            static const std::regex regex("pid_([0-9a-f]+)&mi_([0-9]+)#[0-9a-f]&([0-9a-f]+)&[\\s\\S]*\\{([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})\\}", std::regex_constants::icase);
 
             std::match_results<std::string::const_iterator> match;
 
diff --git a/common/model-views.cpp b/common/model-views.cpp
index fcdc96f..9fc8984 100644
--- a/common/model-views.cpp
+++ b/common/model-views.cpp
@@ -3278,7 +3278,8 @@ namespace rs2
 
         check_for_device_updates(viewer.ctx, viewer.updates);
 
-        if ((bool)config_file::instance().get(configurations::update::recommend_updates))
+        // Inhibit for DQT
+        if ((bool)config_file::instance().get(configurations::update::recommend_updates) && _allow_remove)
         {
             bool fw_update_required = false;
             for (auto&& sub : dev.query_sensors())
@@ -3304,7 +3305,7 @@ namespace rs2
 
                         static auto table = create_default_fw_table();
 
-                        manager = std::make_shared<firmware_update_manager>(*this, dev, viewer.ctx, table[product_line], true);
+                        manager = std::make_shared<firmware_update_manager>(viewer, *this, dev, viewer.ctx, table[product_line], true);
                     }
 
                     if (is_upgradeable(fw, recommended))
@@ -3371,14 +3372,20 @@ namespace rs2
         }
     }
 
-    device_model::device_model(device& dev, std::string& error_message, viewer_model& viewer)
+    device_model::device_model(device& dev, std::string& error_message, viewer_model& viewer, bool remove)
         : dev(dev),
         _calib_model(dev),
         syncer(viewer.syncer),
         _update_readonly_options_timer(std::chrono::seconds(6))
         , _detected_objects(std::make_shared< atomic_objects_in_frame >()),
-        _updates(viewer.updates)
+        _updates(viewer.updates),
+        _allow_remove(remove)
     {
+        if( dev.supports( RS2_CAMERA_INFO_FIRMWARE_VERSION ) && dev.is< device_calibration >() )
+        {
+            _accuracy_health_model = std::unique_ptr< cah_model >( new cah_model( *this, viewer ) );
+        }
+
         auto name = get_device_name(dev);
         id = to_string() << name.first << ", " << name.second;
 
@@ -3815,7 +3822,10 @@ namespace rs2
             }
             auto curr_frame = p.get_position();
             uint64_t step = uint64_t(1000.0 / (float)fps * 1e6);
-            p.seek(std::chrono::nanoseconds(curr_frame - step));
+            if (curr_frame >= step)
+            {
+                p.seek(std::chrono::nanoseconds(curr_frame - step));
+            }
         }
         if (ImGui::IsItemHovered())
         {
@@ -4126,7 +4136,7 @@ namespace rs2
         return device_names;
     }
 
-    bool yes_no_dialog(const std::string& title, const std::string& message_text, bool& approved, ux_window& window, const std::string& error_message, bool disabled = false)
+    bool yes_no_dialog(const std::string& title, const std::string& message_text, bool& approved, ux_window& window, const std::string& error_message, bool disabled, const std::string& disabled_reason)
     {
         ImGui_ScopePushFont(window.get_font());
         ImGui_ScopePushStyleColor(ImGuiCol_Button, button_color);
@@ -4153,7 +4163,7 @@ namespace rs2
                 ImGui_ScopePushStyleColor(ImGuiCol_Text, light_grey);
                 ImGui::Separator();
                 ImGui::SetWindowFontScale(1.1f);
-                ImGui::Text("\n%s\n\n", message_text.c_str());
+                ImGui::Text("\n%s\n", message_text.c_str());
 
                 if (!disabled)
                 {
@@ -4179,6 +4189,10 @@ namespace rs2
                 else
                 {
                     ImGui::NewLine();
+                    {
+                        ImGui_ScopePushStyleColor(ImGuiCol_Text, red);
+                        ImGui::Text("%s\n\n", disabled_reason.c_str());
+                    }
                     auto window_width = ImGui::GetWindowWidth();
                     ImGui::SetCursorPosX(ImGui::GetCursorPosX() + window_width / 2.f - 30.f - ImGui::GetStyle().WindowPadding.x);
                     if (ImGui::Button("Close", ImVec2(60, 30)))
@@ -4270,178 +4284,7 @@ namespace rs2
         return keep_showing;
     }
 
-    bool device_model::prompt_trigger_camera_accuracy_health(ux_window& window, viewer_model& viewer, const std::string& error_message)
-    {
-        // This process is built from a 2 stages windows, first a yes/no window and then a process window
-        bool keep_showing = true;
-        bool yes_was_chosen = false;
-
-        switch (cah_model.cah_state.load())
-        {
-        case camera_accuracy_health_model::model_state_type::TRIGGER_MODAL:
-        {
-            // Make sure the firmware meets the minimal version for Trigger Camera Accuracy features
-            const std::string& min_fw_version("1.4.1.0");
-            auto fw_upgrade_needed = is_upgradeable(dev.get_info(rs2_camera_info::RS2_CAMERA_INFO_FIRMWARE_VERSION), min_fw_version);
-            bool is_depth_streaming(false);
-            bool is_color_streaming(false);
-
-            std::string message_text = "Camera Accuracy Health will ensure you get the highest accuracy from your camera.\n\n"
-                "This process may take several minutes and requires special setup to get good results.\n"
-                "While it is working, the viewer will not be usable.\n\n";
-
-            if (fw_upgrade_needed)
-            {
-                std::string fw_upgrade_message = "Camera Accuracy Health requires a minimal FW version of " + min_fw_version +
-                    "\n\nPlease update your firmware and try again. ";
-
-                message_text += fw_upgrade_message;
-            }
-            else
-            {
-                is_depth_streaming = std::any_of(subdevices.begin(), subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<depth_sensor>(); });
-                is_color_streaming = std::any_of(subdevices.begin(), subdevices.end(), [](const std::shared_ptr<subdevice_model>& sm) { return sm->streaming && sm->s->as<color_sensor>(); });
-
-                if (is_depth_streaming && is_color_streaming)
-                {
-                    message_text += "Are you sure you want to continue?";
-                }
-                else
-                {
-                    std::string stream_missing_message = "Camera Accuracy Health cannot be triggered : both depth & RGB streams must be active.";
-                    message_text += stream_missing_message;
-                }
-
-            }
-
-            bool option_disabled = !is_depth_streaming || !is_color_streaming || fw_upgrade_needed;
-            if (yes_no_dialog("Camera Accuracy Health Trigger", message_text, yes_was_chosen, window, error_message, option_disabled))
-            {
-                if (yes_was_chosen)
-                {
-
-                    auto itr = std::find_if(subdevices.begin(), subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
-                    {
-                        if (sub->s->as<depth_sensor>())
-                            return true;
-                        return false;
-                    });
-
-
-                    if (is_depth_streaming && is_color_streaming && itr != subdevices.end())
-                    {
-                        auto sd = *itr;
-                        sd->s->set_option(RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH, 1.0f);
-                        device_calibration dev_cal(dev);
-                        // Register AC status change callback
-                        if (!cah_model.registered_to_callback)
-                        {
-                            cah_model.registered_to_callback = true;
-                            cah_model.cah_state = camera_accuracy_health_model::model_state_type::PROCESS_MODAL;
-                            cah_model.cah_process_start_time = std::chrono::high_resolution_clock::now();
-                            dev_cal.register_calibration_change_callback([&](rs2_calibration_status cal_status)
-                            {
-                                cah_model.calib_status = cal_status; 
-                            });
-                        }
-
-                    }
-                }
-                else
-                {
-                    keep_showing = false;
-                }
-            }
-        }
-        break;
-
-        case camera_accuracy_health_model::model_state_type::PROCESS_MODAL:
-        {
-            if (!cah_model.process_started)
-            {
-                cah_model.process_started = (cah_model.calib_status == RS2_CALIBRATION_SPECIAL_FRAME || cah_model.calib_status == RS2_CALIBRATION_STARTED);
-            }
-
-            bool process_finished(cah_model.calib_status == RS2_CALIBRATION_SUCCESSFUL || cah_model.calib_status == RS2_CALIBRATION_FAILED || cah_model.calib_status == RS2_CALIBRATION_NOT_NEEDED);
-
-            static std::map<rs2_calibration_status, std::string> status_map{
-                {RS2_CALIBRATION_SPECIAL_FRAME  , "In Progress" },
-                {RS2_CALIBRATION_STARTED        , "In Progress" },
-                {RS2_CALIBRATION_NOT_NEEDED     , "Ended" },
-                {RS2_CALIBRATION_SUCCESSFUL     , "Ended Successfully" },
-                {RS2_CALIBRATION_RETRY          , "In Progress" },
-                {RS2_CALIBRATION_FAILED         , "Ended With Failure" },
-                {RS2_CALIBRATION_SCENE_INVALID  , "In Progress" },
-                {RS2_CALIBRATION_BAD_RESULT     , "In Progress" } };
-
-            rs2_calibration_status calibration_status = cah_model.calib_status;
-
-            // We don't know if AC really started working so we add a timeout for not blocking the viewer forever.
-            if (!cah_model.process_started)
-            {
-                auto now = std::chrono::high_resolution_clock::now();
-                if (now > (cah_model.cah_process_start_time + std::chrono::seconds(30)))
-                {
-                    process_finished = true; // timeout
-                    calibration_status = RS2_CALIBRATION_FAILED;
-                }
-            }
-
-            const std::string & message = process_finished ?    "                                                               " : 
-                                                                "Camera Accuracy Health is In progress, this may take a while...";
-            if (status_dialog("Camera Accuracy Health Status", message, status_map[calibration_status], process_finished, window))
-            {
-                keep_showing = false;
-            }
-        }
-        break;
-        default:
-            break;
-
-        }
-
-        //reset internal elements
-        if (!keep_showing)
-        {
-            cah_model.cah_state = camera_accuracy_health_model::model_state_type::TRIGGER_MODAL;
-            cah_model.calib_status = RS2_CALIBRATION_RETRY;
-            cah_model.process_started = false;
-            cah_model.registered_to_callback = false;
-        }
-        return keep_showing;
-    }
-
-    bool device_model::prompt_reset_camera_accuracy_health(ux_window& window, const std::string& error_message)
-    {
-        bool keep_showing = true;
-        bool yes_was_chosen = false;
-
-        std::string message_text("This will reset the camera settings to their factory-calibrated state.\nYou will lose any improvements made with Camera Accuracy Health.\n\n Are you sure?");
-        if (yes_no_dialog("Camera Accuracy Health Reset", message_text, yes_was_chosen, window,error_message))
-        {
-            if (yes_was_chosen)
-            {
-                auto itr = std::find_if(subdevices.begin(), subdevices.end(), [](std::shared_ptr<subdevice_model> sub)
-                {
-                    if (sub->s->as<depth_sensor>())
-                        return true;
-                    return false;
-                });
-
-
-                if (itr != subdevices.end())
-                {
-                    auto sd = *itr;
-                    sd->s->set_option(RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH, 1.0f);
-
-                }
-            }
-            keep_showing = false;
-        }
-
-        return keep_showing;
-    }
-
+   
     bool device_model::draw_advanced_controls(viewer_model& view, ux_window& window, std::string& error_message)
     {
         bool was_set = false;
@@ -4530,7 +4373,7 @@ namespace rs2
 
             else return; // Aborted by the user
 
-            auto manager = std::make_shared<firmware_update_manager>(*this, dev, viewer.ctx, data, false);
+            auto manager = std::make_shared<firmware_update_manager>(viewer, *this, dev, viewer.ctx, data, false);
 
             auto n = std::make_shared<fw_update_notification_model>(
                 "Manual Update requested", manager, true);
@@ -4580,7 +4423,7 @@ namespace rs2
                 else return; // Aborted by the user
             }
 
-            auto manager = std::make_shared<firmware_update_manager>(*this, dev, viewer.ctx, data, true);
+            auto manager = std::make_shared<firmware_update_manager>(viewer, *this, dev, viewer.ctx, data, true);
 
             auto n = std::make_shared<fw_update_notification_model>(
                 "Manual Update requested", manager, true);
@@ -4717,7 +4560,7 @@ namespace rs2
                 std::string default_path = config_file::instance().get(configurations::record::default_path);
                 if (!ends_with(default_path, "/") && !ends_with(default_path, "\\")) default_path += "/";
                 std::string default_filename = rs2::get_timestamped_file_name() + ".bag";
-                if (recording_setting == 0)
+                if (recording_setting == 0 && default_path.size() > 1 )
                 {
                     path = default_path + default_filename;
                 }
@@ -4873,7 +4716,7 @@ namespace rs2
             }
 
 
-            if (allow_remove)
+            if (_allow_remove)
             {
                 something_to_show = true;
 
@@ -4906,18 +4749,25 @@ namespace rs2
                     }
                 }
 
+                // fw update disabled when any sensor is streaming
+                ImGuiSelectableFlags updateFwFlags = (is_streaming) ? ImGuiSelectableFlags_Disabled : 0;
+
                 if (dev.is<rs2::updatable>() || dev.is<rs2::update_device>())
                 {
-                    if (ImGui::Selectable("Update Firmware..."))
+                    if (ImGui::Selectable("Update Firmware...", false, updateFwFlags))
                     {
                         begin_update({}, viewer, error_message);
                     }
                     if (ImGui::IsItemHovered())
-                        ImGui::SetTooltip("Install official signed firmware from file to the device");
+                    {
+                        std::string tooltip = to_string() << "Install official signed firmware from file to the device" << (is_streaming ? " (Disabled while streaming)" : "");
+                        ImGui::SetTooltip("%s", tooltip.c_str());
+                    }
 
                     if (dev.supports(RS2_CAMERA_INFO_PRODUCT_LINE) && is_recommended_fw_available(dev.get_info(RS2_CAMERA_INFO_PRODUCT_LINE)))
                     {
-                        if (ImGui::Selectable("Install Recommended Firmware "))
+                        
+                        if (ImGui::Selectable("Install Recommended Firmware ", false, updateFwFlags))
                         {
                             auto sensors = dev.query_sensors();
                             auto product_line_str = "";
@@ -4934,7 +4784,10 @@ namespace rs2
                     }
 
                     if (ImGui::IsItemHovered())
-                        ImGui::SetTooltip("Install default recommended firmware for this device");
+                    {
+                        std::string tooltip = to_string() <<"Install default recommended firmware for this device" << (is_streaming ? " (Disabled while streaming)" : "");
+                        ImGui::SetTooltip("%s", tooltip.c_str());
+                    }
                 }
 
                 bool is_locked = true;
@@ -4943,36 +4796,20 @@ namespace rs2
 
                 if (dev.is<rs2::updatable>() && !is_locked)
                 {
-                    if (ImGui::Selectable("Update Unsigned Firmware..."))
+                    if (ImGui::Selectable("Update Unsigned Firmware...", false, updateFwFlags))
                     {
                         begin_update_unsigned(viewer, error_message);
                     }
                     if (ImGui::IsItemHovered())
-                        ImGui::SetTooltip("Install non official unsigned firmware from file to the device");
-                }
-            }
-
-#if 0 // Currently disable triggering/reseting CAH from UI
-            if (dev.supports(RS2_CAMERA_INFO_PRODUCT_LINE) && dev.supports(RS2_CAMERA_INFO_FIRMWARE_VERSION))
-            { 
-                auto product_line_str = dev.get_info(RS2_CAMERA_INFO_PRODUCT_LINE);
-                if (RS2_PRODUCT_LINE_L500 == parse_product_line(product_line_str))
-                {
-                    if (ImGui::Selectable("Trigger Camera Accuracy Health"))
                     {
-                        // We cannot open a pop up window here since we are already in a pop up window
-                        // we trigger the pop up and activate it outside the menu pop up
-                        cah_model.show_trigger_camera_accuracy_health_popup = true;
-                    }
-
-                    if (ImGui::Selectable("Reset Camera Accuracy Health"))
-                    {
-                        cah_model.show_reset_camera_accuracy_health_popup = true;
+                        std::string tooltip = to_string() << "Install non official unsigned firmware from file to the device" << (is_streaming ? " (Disabled while streaming)" : "");
+                        ImGui::SetTooltip("%s", tooltip.c_str());
                     }
                 }
             }
-#endif
-            
+
+
+                
             bool has_autocalib = false;
             for (auto&& sub : subdevices)
             {
@@ -5138,14 +4975,20 @@ namespace rs2
         }
 
 
-        if (cah_model.show_trigger_camera_accuracy_health_popup)
+        if (show_trigger_camera_accuracy_health_popup)
         {
-            cah_model.show_trigger_camera_accuracy_health_popup = prompt_trigger_camera_accuracy_health(window, viewer, error_message);
+            if (_accuracy_health_model)
+            {
+                show_trigger_camera_accuracy_health_popup = _accuracy_health_model->prompt_trigger_popup(window, error_message);
+            }
         }
 
-        if (cah_model.show_reset_camera_accuracy_health_popup)
+        if (show_reset_camera_accuracy_health_popup)
         {
-            cah_model.show_reset_camera_accuracy_health_popup = prompt_reset_camera_accuracy_health(window, error_message);
+            if (_accuracy_health_model)
+            {
+                show_reset_camera_accuracy_health_popup = _accuracy_health_model->prompt_reset_popup(window, error_message);
+            }
         }
 
         if (keep_showing_advanced_mode_modal)
@@ -5623,7 +5466,12 @@ namespace rs2
         if (advanced_dev)
         {
             is_advanced_device = true;
-            is_advanced_mode_enabled = advanced_dev.is_enabled();
+            try
+            {
+                // Prevent intermittent errors in polling mode to keep imgui in sync
+                is_advanced_mode_enabled = advanced_dev.is_enabled();
+            }
+            catch (...){}
         }
 
         ImGui::SetCursorPosX(ImGui::GetCursorPosX() + 3);
@@ -5844,7 +5692,7 @@ namespace rs2
         ImGui::PushStyleColor(ImGuiCol_PopupBg, almost_white_bg);
         ImGui::PushStyleColor(ImGuiCol_HeaderHovered, light_blue);
         ImGui::PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2(5, 5));
-        if (allow_remove)
+        if (_allow_remove)
         {
             ImGui::Columns(1);
             float horizontal_distance_from_right_side_of_panel = 47;
diff --git a/common/model-views.h b/common/model-views.h
index 9f44ccc..57d62f5 100644
--- a/common/model-views.h
+++ b/common/model-views.h
@@ -27,6 +27,7 @@
 #include "fw-update-helper.h"
 #include "updates-model.h"
 #include "calibration-model.h"
+#include "cah-model.h"
 
 ImVec4 from_rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a, bool consistent_color = false);
 ImVec4 operator+(const ImVec4& c, float v);
@@ -483,6 +484,9 @@ namespace rs2
         std::string icon[2];
     };
 
+    bool yes_no_dialog(const std::string& title, const std::string& message_text, bool& approved, ux_window& window, const std::string& error_message, bool disabled = false, const std::string& disabled_reason = "");
+    bool status_dialog(const std::string& title, const std::string& process_topic_text, const std::string& process_status_text, bool enable_close, ux_window& window);
+
     class tm2_model
     {
     public:
@@ -745,7 +749,7 @@ namespace rs2
         typedef std::function<void(std::function<void()> load)> json_loading_func;
 
         void reset();
-        explicit device_model(device& dev, std::string& error_message, viewer_model& viewer);
+        explicit device_model(device& dev, std::string& error_message, viewer_model& viewer, bool allow_remove=true);
         ~device_model();
         void start_recording(const std::string& path, std::string& error_message);
         void stop_recording(viewer_model& viewer);
@@ -773,6 +777,7 @@ namespace rs2
 
 
         std::shared_ptr< atomic_objects_in_frame > get_detected_objects() const { return _detected_objects; }
+        bool is_cah_model_enabled() const { return _accuracy_health_model ? true : false; }
 
         std::vector<std::shared_ptr<subdevice_model>> subdevices;
         std::shared_ptr<syncer_model> syncer;
@@ -788,7 +793,7 @@ namespace rs2
         bool _playback_repeat = true;
         bool _should_replay = false;
         bool show_device_info = false;
-        bool allow_remove = true;
+        bool _allow_remove = true;
         bool show_depth_only = false;
         bool show_stream_selection = true;
         std::vector<std::pair<std::string, std::string>> infos;
@@ -798,30 +803,17 @@ namespace rs2
 
         std::vector<std::shared_ptr<notification_model>> related_notifications;
 
+        bool show_trigger_camera_accuracy_health_popup = false;
+        bool show_reset_camera_accuracy_health_popup = false;
+
     private:
         // This class is in charge of camera accuracy health window parameters,
         // Needed as a member for reseting the window memory on device disconnection.
-        class camera_accuracy_health_model
-        {
-        public:
-            enum class model_state_type { TRIGGER_MODAL, PROCESS_MODAL };
-            std::atomic<model_state_type> cah_state; // will be set from a different thread callback function
-            std::atomic<rs2_calibration_status> calib_status; // will be set from a different thread callback function
-            bool show_trigger_camera_accuracy_health_popup;
-            bool show_reset_camera_accuracy_health_popup;
-            bool registered_to_callback;
-            std::chrono::high_resolution_clock::time_point cah_process_start_time;
-            bool process_started;
-
-
-            camera_accuracy_health_model():cah_state(model_state_type::TRIGGER_MODAL), calib_status(RS2_CALIBRATION_RETRY),
-                show_trigger_camera_accuracy_health_popup(false), show_reset_camera_accuracy_health_popup(false),
-                registered_to_callback(false), cah_process_start_time(), process_started(false)
-            {}
+       
 
-        };
+        std::unique_ptr< cah_model > _accuracy_health_model;  // If this device does not support CAH feature,
+                                                              // the pointer will point to nullptr
 
-        camera_accuracy_health_model cah_model;
         void draw_info_icon(ux_window& window, ImFont* font, const ImVec2& size);
         int draw_seek_bar();
         int draw_playback_controls(ux_window& window, ImFont* font, viewer_model& view);
@@ -844,8 +836,6 @@ namespace rs2
             viewer_model& view,
             ux_window& window,
             const std::string& error_message);
-        bool prompt_trigger_camera_accuracy_health(ux_window& window, viewer_model& viewer,  const std::string& error_message);
-        bool prompt_reset_camera_accuracy_health(ux_window& window, const std::string& error_message);
 
         void load_viewer_configurations(const std::string& json_str);
         void save_viewer_configurations(std::ofstream& outfile, nlohmann::json& j);
diff --git a/common/output-model.cpp b/common/output-model.cpp
index 89747b4..41a2649 100644
--- a/common/output-model.cpp
+++ b/common/output-model.cpp
@@ -22,7 +22,7 @@ void output_model::thread_loop()
             dev_copy = devices;
         }
         if (enable_firmware_logs)
-            for (auto&& dev : devices)
+            for (auto&& dev : dev_copy)
             {
                 try
                 {
@@ -91,7 +91,7 @@ output_model::~output_model()
     fw_logger.join();
 }
 
-output_model::output_model() : fw_logger([this](){ thread_loop(); })
+output_model::output_model() : fw_logger([this](){ thread_loop(); }) , incoming_log_queue(100)
 {
     is_output_open = config_file::instance().get_or_default(
             configurations::viewer::output_open, false);
@@ -158,7 +158,7 @@ void output_model::open(ux_window& win)
     new_log = true;
 }
 
-void output_model::draw(ux_window& win, rect view_rect, std::vector<rs2::device> devices)
+void output_model::draw(ux_window& win, rect view_rect, device_models_list & device_models)
 {
     ImGui::PushStyleColor(ImGuiCol_FrameBg, scrollbar_bg);
 
@@ -583,7 +583,7 @@ void output_model::draw(ux_window& win, rect view_rect, std::vector<rs2::device>
         {
             if (commands_histroy.size() > 100) commands_histroy.pop_back();
             commands_histroy.push_front(command_line);
-            run_command(command_line, devices);
+            run_command(command_line, device_models);
             command_line = "";
             command_focus = true;
         }
@@ -685,7 +685,9 @@ void output_model::draw(ux_window& win, rect view_rect, std::vector<rs2::device>
 
     {
         std::lock_guard<std::mutex> lock(devices_mutex);
-        this->devices = devices;
+        this->devices.clear();
+        for (auto && dev_model : device_models)
+            this->devices.push_back(dev_model->dev);
     }
 }
 
@@ -751,7 +753,7 @@ void output_model::add_log(rs2_log_severity severity, std::string filename, int
     new_log = true;
 }
 
-void output_model::run_command(std::string command, std::vector<rs2::device> devices)
+void output_model::run_command(std::string command, device_models_list & device_models)
 {
     try
     {
@@ -771,7 +773,10 @@ void output_model::run_command(std::string command, std::vector<rs2::device> dev
             return;
         }
 
-        std::regex e("([0-9A-Fa-f]{2}\\s)+");
+        if( user_defined_command( command, device_models ) )
+            return;
+
+        std::regex e( "([0-9A-Fa-f]{2}\\s)+" );
 
         if (std::regex_match(command, e))
         {
@@ -863,10 +868,80 @@ void output_model::run_command(std::string command, std::vector<rs2::device> dev
     } 
     catch(const std::exception& ex)
     {
-        add_log(RS2_LOG_SEVERITY_ERROR, __FILE__, __LINE__, ex.what());
+        add_log( RS2_LOG_SEVERITY_ERROR, __FILE__, __LINE__, ex.what() );
     }
 }
 
+bool output_model::user_defined_command( std::string command, device_models_list & device_models )
+{
+    bool user_defined_command_detected = false;
+    bool user_defined_command_activated = false;
+
+    // If a known command is detected , it will treated as a user_defined_command and will not be
+    // passed to the FW commands check logic.
+    // Note: For now we find the first device that supports the command and activate the command only on it.
+
+    if( to_lower( command ) == "trigger-camera-accuracy-health" )
+    {
+        user_defined_command_detected = true;
+
+        for( auto && dev_model : device_models )
+        {
+            if( dev_model->is_cah_model_enabled() && !user_defined_command_activated)
+            {
+                dev_model->show_trigger_camera_accuracy_health_popup = true;
+                user_defined_command_activated = true;
+            }
+        }
+    }
+    else if( to_lower( command ) == "reset-camera-accuracy-health" )
+    {
+        user_defined_command_detected = true;
+
+        for( auto && dev_model : device_models )
+        {
+            if( dev_model->is_cah_model_enabled() && !user_defined_command_activated)
+            {
+                dev_model->show_reset_camera_accuracy_health_popup = true;
+                user_defined_command_activated = true;
+            }
+        }
+    }
+    else if( to_lower( command ) == "get-nest" )
+    {
+        user_defined_command_detected = true;
+
+        for( auto && dev : devices )
+        {
+            if( auto dbg = dev.as< rs2::debug_protocol >() )
+            {
+                if( dev.supports( RS2_CAMERA_INFO_FIRMWARE_VERSION ) )
+                {  // Verify minimal version for handling this command
+                    if( ! is_upgradeable( dev.get_info( RS2_CAMERA_INFO_FIRMWARE_VERSION ), "01.05.0.0" ) )
+                    {
+                        std::vector< uint8_t > special_command
+                            = { 'G', 'E', 'T', '-', 'N', 'E', 'S', 'T' };
+                        auto res = dbg.send_and_receive_raw_data( special_command );
+                        user_defined_command_activated = true;
+                    }
+                }
+            }
+        }
+    }
+
+    // Log a warning if a known command was not activated
+    if( user_defined_command_detected && ! user_defined_command_activated )
+    {
+        add_log( RS2_LOG_SEVERITY_WARN,
+                 __FILE__,
+                 __LINE__,
+                 to_string() << "None of the connected devices supports '" << command << "'" );
+    }
+
+    return user_defined_command_detected;
+}
+
+
 void output_model::update_dashboards(rs2::frame f)
 {
     for (auto&& d : dashboards)
diff --git a/common/output-model.h b/common/output-model.h
index b1c9028..b6e101b 100644
--- a/common/output-model.h
+++ b/common/output-model.h
@@ -13,6 +13,8 @@
 
 namespace rs2
 {
+    class device_model;
+
     class stream_dashboard
     {
     public:
@@ -29,7 +31,7 @@ namespace rs2
 
         virtual void draw(ux_window& win, rect r) = 0;
 
-        virtual int get_height() const { return 150.f; }
+        virtual int get_height() const { return 150; }
 
         virtual void clear(bool full = false) {}
 
@@ -123,11 +125,13 @@ namespace rs2
 
         void add_log(rs2_log_severity severity, std::string filename, int line_number, std::string line);
 
-        void draw(ux_window& win, rect view_rect, std::vector<rs2::device> devices);
+        void draw(ux_window& win, rect view_rect, std::vector<std::unique_ptr<device_model>> &  device_models);
 
         int get_output_height() const { return default_log_h; }
 
-        void run_command(std::string command, std::vector<rs2::device> devices);
+        void run_command(std::string command, std::vector<std::unique_ptr<device_model>> & device_models);
+        bool user_defined_command(std::string command, std::vector<std::unique_ptr<device_model>> & device_models);
+
 
     private:
         void open(ux_window& win);
diff --git a/common/sw-update/dev-updates-profile.cpp b/common/sw-update/dev-updates-profile.cpp
index 8d65a4c..7633c99 100644
--- a/common/sw-update/dev-updates-profile.cpp
+++ b/common/sw-update/dev-updates-profile.cpp
@@ -71,9 +71,9 @@ namespace rs2
             bool query_ok = up_handler.query_versions(dev_name, part, policy, required_version);
             if (query_ok)
             {
-                //auto dl_link_ok = up_handler.get_version_download_link(part, required_version, result.download_link);
-                //auto rel_ok = up_handler.get_version_release_notes(part, required_version, result.release_page);
-                //auto desc_ok = up_handler.get_version_description(part, required_version, result.description);
+                up_handler.get_version_download_link(part, required_version, result.download_link);
+                up_handler.get_version_release_notes(part, required_version, result.release_page);
+                up_handler.get_version_description(part, required_version, result.description);
                 result.ver = required_version;
 
                 std::stringstream ss;
diff --git a/common/updates-model.cpp b/common/updates-model.cpp
index 094a71d..a18bf9c 100644
--- a/common/updates-model.cpp
+++ b/common/updates-model.cpp
@@ -13,7 +13,7 @@ using namespace rs2;
 using namespace sw_update;
 using namespace http;
 
-void updates_model::draw(ux_window& window, std::string& error_message)
+void updates_model::draw(viewer_model& viewer, ux_window& window, std::string& error_message)
 {
     // Protect resources
     static std::vector<update_profile_model> updates_copy;
@@ -140,7 +140,7 @@ void updates_model::draw(ux_window& window, std::string& error_message)
             // ===========================================================================
             // Draw Firmware update Pane
             // ===========================================================================
-            fw_update_needed = draw_firmware_section(window_name, update, positions, window);
+            fw_update_needed = draw_firmware_section(viewer, window_name, update, positions, window);
 
         }
         else 
@@ -496,7 +496,7 @@ bool updates_model::draw_software_section(const char * window_name, update_profi
     }
     return essential_sw_update_needed;
 }
-bool updates_model::draw_firmware_section(const char * window_name, update_profile_model& selected_profile, position_params& pos, ux_window& window)
+bool updates_model::draw_firmware_section(viewer_model& viewer, const char * window_name, update_profile_model& selected_profile, position_params& pos, ux_window& window)
 {
     bool essential_fw_update_needed(false);
     bool recommended_fw_update_needed(false);
@@ -765,7 +765,7 @@ bool updates_model::draw_firmware_section(const char * window_name, update_profi
             {
                 _fw_update_state = fw_update_states::started;
 
-                _update_manager = std::make_shared<firmware_update_manager>(
+                _update_manager = std::make_shared<firmware_update_manager>(viewer,
                     *selected_profile.dev_model, selected_profile.profile.dev, selected_profile.ctx, _fw_image, true
                     );
                 auto invoke = [](std::function<void()> action) { action(); };
diff --git a/common/updates-model.h b/common/updates-model.h
index 714d019..800e730 100644
--- a/common/updates-model.h
+++ b/common/updates-model.h
@@ -75,7 +75,7 @@ namespace rs2
                 it->profile.dev_active = active;
         }
 
-        void draw(ux_window& window, std::string& error_message);
+        void draw(viewer_model& viewer, ux_window& window, std::string& error_message);
     private:
         struct position_params
         {
@@ -89,7 +89,7 @@ namespace rs2
         };
 
         bool draw_software_section(const char * window_name, update_profile_model& selected_profile, position_params& pos_params , ux_window& window);
-        bool draw_firmware_section(const char * window_name, update_profile_model& selected_profile, position_params& pos_params, ux_window& window);
+        bool draw_firmware_section(viewer_model& viewer, const char * window_name, update_profile_model& selected_profile, position_params& pos_params, ux_window& window);
 
 
         int selected_index = 0;
diff --git a/common/ux-window.cpp b/common/ux-window.cpp
index 656d5ae..1440efd 100644
--- a/common/ux-window.cpp
+++ b/common/ux-window.cpp
@@ -57,7 +57,6 @@ namespace rs2
         config_file::instance().set_default(configurations::window::saved_size, false);
 
         config_file::instance().set_default(configurations::viewer::is_measuring, false);
-        config_file::instance().set_default(configurations::viewer::log_filename, get_folder_path(special_folder::user_documents) + "librealsense.log");
         config_file::instance().set_default(configurations::viewer::log_to_console, true);
         config_file::instance().set_default(configurations::viewer::log_to_file, false);
         config_file::instance().set_default(configurations::viewer::log_severity, 2);
@@ -65,7 +64,6 @@ namespace rs2
         config_file::instance().set_default(configurations::viewer::ground_truth_r, 2500);
 
         config_file::instance().set_default(configurations::record::compression_mode, 2); // Let the device decide
-        config_file::instance().set_default(configurations::record::default_path, get_folder_path(special_folder::user_documents));
         config_file::instance().set_default(configurations::record::file_save_mode, 0); // Auto-select name
 
         config_file::instance().set_default(configurations::performance::show_fps, false);
@@ -79,6 +77,20 @@ namespace rs2
         config_file::instance().set_default(configurations::viewer::commands_xml, "./Commands.xml");
         config_file::instance().set_default(configurations::viewer::hwlogger_xml, "./HWLoggerEvents.xml");
 
+        std::string path;
+        try
+        {
+            path = get_folder_path(special_folder::user_documents);
+        }
+        catch (const std::exception& e)
+        {
+            std::string msg = "Failed to get Documents folder";
+            rs2::log(RS2_LOG_SEVERITY_INFO, msg.c_str());
+            path = "";
+        }
+        config_file::instance().set_default(configurations::viewer::log_filename, path + "librealsense.log");
+        config_file::instance().set_default(configurations::record::default_path, path);
+
 #ifdef __APPLE__
 
         config_file::instance().set_default(configurations::performance::font_oversample, 2);
diff --git a/common/viewer.cpp b/common/viewer.cpp
index 020b8fb..9edc4f7 100644
--- a/common/viewer.cpp
+++ b/common/viewer.cpp
@@ -2926,6 +2926,14 @@ namespace rs2
                 
                 ImGui::Text("Copyright 2018 Intel Corporation.");
 
+                if( RS2_API_BUILD_VERSION )
+                {
+                    ImGui::Text( "---" );
+                    ImGui::Text( "Full version: " );
+                    ImGui::SameLine();
+                    ImGui::Text( RS2_API_FULL_VERSION_STR );
+                }
+
                 ImGui::PushStyleColor(ImGuiCol_Button, sensor_bg);
                 ImGui::PushStyleColor(ImGuiCol_ButtonHovered, sensor_bg);
                 ImGui::PushStyleColor(ImGuiCol_ButtonActive, sensor_bg);
@@ -3218,7 +3226,7 @@ namespace rs2
         ux_window& window, int devices, std::string& error_message, 
         std::shared_ptr<texture_buffer> texture, points points)
     {
-        updates->draw(window, error_message);
+        updates->draw(*this, window, error_message);
 
         static bool first = true;
         if (first)
diff --git a/include/librealsense2/h/rs_device.h b/include/librealsense2/h/rs_device.h
index 3ed6031..7303817 100644
--- a/include/librealsense2/h/rs_device.h
+++ b/include/librealsense2/h/rs_device.h
@@ -317,7 +317,8 @@ const rs2_raw_data_buffer* rs2_run_tare_calibration_cpp(rs2_device* dev, float g
  */
 typedef enum rs2_calibration_type
 {
-    RS2_CALIBRATION_DEPTH_TO_RGB,
+    RS2_CALIBRATION_AUTO_DEPTH_TO_RGB,
+    RS2_CALIBRATION_MANUAL_DEPTH_TO_RGB,
     RS2_CALIBRATION_TYPE_COUNT
 } rs2_calibration_type;
 const char* rs2_calibration_type_to_string( rs2_calibration_type );
@@ -328,18 +329,20 @@ const char* rs2_calibration_type_to_string( rs2_calibration_type );
 typedef enum rs2_calibration_status
 {
     // Anything >= 0 is not an issue
-    RS2_CALIBRATION_SPECIAL_FRAME =  0,  // Special frame received; expect a frame-drop!
-    RS2_CALIBRATION_STARTED       =  1,  // Have all frames in hand; starting processing
-    RS2_CALIBRATION_NOT_NEEDED    =  2,  // Finished; existing calibration within tolerances; nothing done!
-    RS2_CALIBRATION_SUCCESSFUL    =  3,  // Finished; have new calibration in-hand
-
-    RS2_CALIBRATION_RETRY         = -1,  // Initiating retry (asked for a new special frame)
-    RS2_CALIBRATION_FAILED        = -2,
-    RS2_CALIBRATION_SCENE_INVALID = -3,  // Scene was not good enough for calibration; will retry
-    RS2_CALIBRATION_BAD_RESULT    = -4,  // Calibration finished, but results aren't good; will retry
-
-    RS2_CALIBRATION_STATUS_FIRST  = -4,
-    RS2_CALIBRATION_STATUS_LAST   =  3,
+    RS2_CALIBRATION_TRIGGERED      =  0,  // AC triggered and is active; conditions are valid
+    RS2_CALIBRATION_SPECIAL_FRAME  =  1,  // Special frame received; expect a frame-drop!
+    RS2_CALIBRATION_STARTED        =  2,  // Have all frames in hand; starting processing
+    RS2_CALIBRATION_NOT_NEEDED     =  3,  // Finished; existing calibration within tolerances; nothing done!
+    RS2_CALIBRATION_SUCCESSFUL     =  4,  // Finished; have new calibration in-hand
+
+    RS2_CALIBRATION_RETRY          = -1,  // Initiating retry (asked for a new special frame)
+    RS2_CALIBRATION_FAILED         = -2,  // Unexpected: exception, device removed, stream stopped, etc.
+    RS2_CALIBRATION_SCENE_INVALID  = -3,  // Scene was not good enough for calibration; will retry
+    RS2_CALIBRATION_BAD_RESULT     = -4,  // Calibration finished, but results aren't good; will retry
+    RS2_CALIBRATION_BAD_CONDITIONS = -5,  // Trigger was attempted but conditions (temp/APD) were invalid (still inactive)
+
+    RS2_CALIBRATION_STATUS_FIRST   = -5,
+    RS2_CALIBRATION_STATUS_LAST    =  4,
     RS2_CALIBRATION_STATUS_COUNT = RS2_CALIBRATION_STATUS_LAST - RS2_CALIBRATION_STATUS_FIRST + 1,
 } rs2_calibration_status;
 const char* rs2_calibration_status_to_string( rs2_calibration_status );
diff --git a/include/librealsense2/h/rs_option.h b/include/librealsense2/h/rs_option.h
index ad6e5a2..f7b4fe5 100644
--- a/include/librealsense2/h/rs_option.h
+++ b/include/librealsense2/h/rs_option.h
@@ -165,6 +165,16 @@ extern "C" {
     } rs2_ambient_light;
     const char* rs2_ambient_light_to_string(rs2_ambient_light preset);
 
+    /** \brief values for RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH option. */
+    typedef enum rs2_cah_trigger
+    {
+        RS2_CAH_TRIGGER_MANUAL = 0,  /**< not triggered until you give _NOW */
+        RS2_CAH_TRIGGER_NOW    = 1,  /**< triggers CAH and leaves previous value intact! */
+        RS2_CAH_TRIGGER_AUTO   = 2,  /**< triggered periodically or with certain conditions */
+        RS2_CAH_TRIGGER_COUNT        /**< Number of enumeration values. Not a valid input: intended to be used in for-loops. */
+    } rs2_cah_trigger;
+    const char* rs2_cah_trigger_to_string( rs2_cah_trigger preset );
+
     /**
     * check if an option is read-only
     * \param[in] options  the options container
diff --git a/include/librealsense2/rs.h b/include/librealsense2/rs.h
index 72e0a8e..8cba8e4 100644
--- a/include/librealsense2/rs.h
+++ b/include/librealsense2/rs.h
@@ -23,8 +23,8 @@ extern "C" {
 #include "h/rs_sensor.h"
 
 #define RS2_API_MAJOR_VERSION    2
-#define RS2_API_MINOR_VERSION    37
-#define RS2_API_PATCH_VERSION    0
+#define RS2_API_MINOR_VERSION    38
+#define RS2_API_PATCH_VERSION    1
 #define RS2_API_BUILD_VERSION    0
 
 #ifndef STRINGIFY
diff --git a/package.xml b/package.xml
index d2fa474..337293c 100644
--- a/package.xml
+++ b/package.xml
@@ -7,7 +7,7 @@
 <package format="2">
   <name>librealsense2</name>
   <!-- The version tag needs to be updated with each new release of librealsense -->
-  <version>2.37.0</version>
+  <version>2.38.1</version>
   <description>
   Library for capturing data from the Intel(R) RealSense(TM) SR300, D400 Depth cameras and T2xx Tracking devices. This effort was initiated to better support researchers, creative coders, and app developers in domains such as robotics, virtual reality, and the internet of things. Several often-requested features of RealSense(TM); devices are implemented in this project.
   </description>
diff --git a/src/algo/depth-to-rgb-calibration/calibration-types.h b/src/algo/depth-to-rgb-calibration/calibration-types.h
index cfec12b..2ec3b52 100644
--- a/src/algo/depth-to-rgb-calibration/calibration-types.h
+++ b/src/algo/depth-to-rgb-calibration/calibration-types.h
@@ -127,6 +127,9 @@ namespace depth_to_rgb_calibration {
         deg_315, //
         deg_none
     };
+
+    const int N_BASIC_DIRECTIONS = direction::deg_180;
+
     enum svm_model :uint8_t
     {
         linear,
diff --git a/src/algo/depth-to-rgb-calibration/frame-data.h b/src/algo/depth-to-rgb-calibration/frame-data.h
index 309527e..1c6a3d4 100644
--- a/src/algo/depth-to-rgb-calibration/frame-data.h
+++ b/src/algo/depth-to-rgb-calibration/frame-data.h
@@ -28,30 +28,27 @@ namespace depth_to_rgb_calibration {
     struct ir_frame_data : frame_data
     {
         std::vector< ir_t > ir_frame;
-        std::vector<double> edges;
+        std::vector<double> edges; // for debug
         std::vector< double > local_edges;
 
         // smearing
-        std::vector<double> gradient_x;
-        std::vector<double> gradient_y;
-        std::vector< byte > section_map_depth;
-        std::vector< byte > valid_edge_pixels_by_ir;
-        std::vector<byte> valid_section_map;
-        std::vector<double>valid_gradient_x;
-        std::vector<double>valid_gradient_y;
-        std::vector<direction> directions;
-        std::vector<double> direction_deg;
-        std::vector<double> valid_location_rc_x;
-        std::vector<double> valid_location_rc_y;
-        std::vector<double> valid_location_rc;
-        std::vector<double> direction_per_pixel;
-        std::vector<double> direction_per_pixel_x; //for debug
-        std::vector<double> direction_per_pixel_y; // for debug
-        std::vector<double> local_region[4];
-        std::vector<double> local_region_x[4];//for debug
+        std::vector<double> gradient_x; // for debug
+        std::vector<double> gradient_y; // for debug
+        std::vector< byte > valid_edge_pixels_by_ir; // for debug
+        std::vector<byte> valid_section_map; // for debug
+        std::vector<double>valid_gradient_x; // for debug
+        std::vector<double>valid_gradient_y; // for debug
+        std::vector<direction> directions; // for debug
+        std::vector<double> direction_deg; // for debug
+        std::vector<double> valid_location_rc_x; // for debug
+        std::vector<double> valid_location_rc_y; // for debug
+        std::vector<double> valid_location_rc; // for debug
+        std::vector<double> direction_per_pixel; // for debug
+        std::vector< double > local_region[4]; // for debug
+        std::vector<double> local_region_x[4]; //for debug
         std::vector<double> local_region_y[4]; // for debug
         std::vector< byte > is_supressed;
-        std::vector<double> fraq_step;
+        std::vector<double> fraq_step; // for debug
 
     };
 
@@ -65,50 +62,42 @@ namespace depth_to_rgb_calibration {
         float depth_units;
 
         std::vector< z_t > frame;
-        std::vector<double> gradient_x;
-        std::vector<double> gradient_y;
-        std::vector<double> edges;
+        std::vector<double> gradient_x; // for debug
+        std::vector<double> gradient_y; // for debug
+        std::vector<double> edges; // for debug
         std::vector< byte > supressed_edges;
         size_t n_strong_edges;
         std::vector<double> subpixels_x;
         std::vector<double> subpixels_y;
-        std::vector<double> subpixels_y_round;
-        std::vector<double> subpixels_x_round;
-        std::vector<double> valid_weights;
+        std::vector<double> subpixels_y_round; // for debug
+        std::vector<double> subpixels_x_round; // for debug
         std::vector<uint8_t> relevant_pixels_image;
 
         std::vector<double> weights;
-        std::vector<double> direction_deg;
-        std::vector<double3> vertices_all; 
 
         //smearing
-        std::vector< byte > section_map_depth;
-        std::vector< byte > section_map_depth_inside;
-        std::vector<double> local_x;
-        std::vector<double> local_y;
-        std::vector<double> gradient;
-        std::vector<double> local_values;
-        std::vector<double> grad_in_direction;
-        std::vector<double> grad_in_direction_valid;
-        std::vector<double> grad_in_direction_inside;
-        std::vector<double> values_for_subedges;
+        std::vector< byte > section_map_depth; // for debug
+        std::vector< double > local_x; // for debug
+        std::vector< double > local_y; // for debug
+        std::vector< double > gradient; // for debug
+        std::vector< double > local_values; // for debug
+        std::vector< double > grad_in_direction; // for debug
+        std::vector< double > grad_in_direction_valid; // for debug
+        std::vector<double> values_for_subedges; // for debug
         std::vector<double> closest;
-        std::vector<double> direction_per_pixel;
-        std::vector<double> valid_direction_per_pixel;
-        std::vector<byte> valid_section_map;
-        std::vector<double> local_rc_subpixel;
-        std::vector<double> edge_sub_pixel;
-        std::vector<double> valid_directions;
+        std::vector<double> valid_direction_per_pixel; // for debug
+        std::vector< byte > valid_section_map; // for debug
+        std::vector< double > local_rc_subpixel; // for debug
+        std::vector<double> edge_sub_pixel; // for debug
+        std::vector<double> valid_directions; // for debug
         std::vector<double> directions;
-        std::vector<double> valid_edge_sub_pixel;
-        std::vector<double > valid_edge_sub_pixel_x;
-        std::vector<double > valid_edge_sub_pixel_y;
-        std::vector<double> sub_points;
-        std::vector<double3> vertices;
+        std::vector< double > valid_edge_sub_pixel; // for debug
+        std::vector<double> sub_points; // for debug
+        std::vector<double3> vertices; // for debug
         std::vector<double3> orig_vertices;
-        std::vector<double> vertices3;
-        std::vector<double2> uvmap;
-        std::vector< byte > is_inside;
+        //std::vector<double> vertices3;
+        std::vector< double2 > uvmap; // for debug
+        std::vector< byte > is_inside; // for debug
         // input validation
         std::vector<byte> section_map;
         bool is_edge_distributed;
@@ -121,27 +110,51 @@ namespace depth_to_rgb_calibration {
 
         //svm
         double dir_ratio1;
+        k_matrix k_depth_pinv;
     };
 
-    struct yuy2_frame_data : frame_data
+    struct movement_inputs_for_frame
+    {
+        std::vector<double> const& edges;
+        std::vector<uint8_t> const& lum_frame;
+    };
+
+    struct movement_result_data
     {
-        std::vector< yuy_t > orig_frame;
-        std::vector< yuy_t > prev_frame;
-        std::vector<uint8_t> lum_frame;
-        std::vector<uint8_t> prev_lum_frame;
-        std::vector<double> yuy_diff;
         std::vector<uint8_t> dilated_image;
+        std::vector<uint8_t> logic_edges;
+        std::vector<double> yuy_diff;
         std::vector<double> gaussian_filtered_image;
         std::vector<double> gaussian_diff_masked;
         std::vector<uint8_t> move_suspect;
-        std::vector<double> edges;                          // W*H, pre-smearing
-        std::vector<double> prev_edges;                     // W*H, for prev_frame
-        std::vector<uint8_t> logic_edges;
-        std::vector<uint8_t> prev_logic_edges;
+    };
+
+    struct yuy2_frame_data : frame_data
+    {
+        std::vector< yuy_t > orig_frame;
+        std::vector< yuy_t > prev_frame;
+        std::vector< yuy_t > last_successful_frame;
+     
+        struct
+        {
+            std::vector< uint8_t > lum_frame;
+            std::vector< uint8_t > prev_lum_frame;
+            std::vector< uint8_t > last_successful_lum_frame;
+
+            movement_result_data movement_result;
+            movement_result_data movement_prev_valid_result;
+
+            std::vector< double > edges;  // W*H, pre-smearing
+        }
+        debug;
+
+        bool movement_from_prev_frame;
+        bool movement_from_last_success;
+
         std::vector<double> edges_IDT;                      // W*H, smeared, for cost
         std::vector<double> edges_IDTx;                     // W*H, smeared, dedge/dx, for gradients
         std::vector<double> edges_IDTy;                     // W*H, smeared, dedge/dy, for gradients
-        std::vector<unsigned char> section_map;
+        std::vector< byte > section_map_edges;              // > params.gradRgbTh
         bool is_edge_distributed;
         std::vector<double>sum_weights_per_section;
         double min_max_ratio;
diff --git a/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp b/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
index d2c8b59..556629c 100644
--- a/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
+++ b/src/algo/depth-to-rgb-calibration/k-to-dsm.cpp
@@ -238,28 +238,16 @@ rs2_dsm_params_double k_to_DSM::convert_new_k_to_DSM
 
     for (auto i = 0; i < new_vertices.size(); i++)
     {
-        new_vertices[i].x = new_vertices[i].x / new_vertices[i].z* sc_vertices[i].z;
-        new_vertices[i].y = new_vertices[i].y / new_vertices[i].z* sc_vertices[i].z;
-        new_vertices[i].z = new_vertices[i].z / new_vertices[i].z* sc_vertices[i].z;
+        new_vertices[i].x = new_vertices[i].x / new_vertices[i].z * sc_vertices[i].z;
+        new_vertices[i].y = new_vertices[i].y / new_vertices[i].z * sc_vertices[i].z;
+        new_vertices[i].z = new_vertices[i].z / new_vertices[i].z * sc_vertices[i].z;
 
         new_vertices[i].x *= -1;
         new_vertices[i].y *= -1;
     }
 
-    std::vector<double3> projed(new_vertices.size());
-    std::vector<double> xim_new(new_vertices.size());
-    std::vector<double> yim_new(new_vertices.size());
-
-    for (auto i = 0; i < new_vertices.size(); i++)
-    {
-        projed[i].x = new_vertices[i].x*old_k.fx + new_vertices[i].z*old_k.ppx;
-        projed[i].y = new_vertices[i].y*old_k.fy + new_vertices[i].z*old_k.ppy;
-        projed[i].z = new_vertices[i].z;
-
-        xim_new[i] = projed[i].x / projed[i].z;
-        yim_new[i] = projed[i].y / projed[i].z;
-    }
-    AC_LOG( DEBUG, "    new DSM params: " << AC_D_PREC << ac_data_cand );
+    AC_LOG( DEBUG,
+            "    new DSM params: " << AC_D_PREC << ac_data_cand << "; vertices are changed" );
     new_dsm_regs = dsm_regs_cand;
     return ac_data_cand;
 }
@@ -437,6 +425,16 @@ double2 k_to_DSM::run_scaling_optimization_step
     double quad_coef[6];
     direct_inv_6x6(sg_mat_tag_x_sg_mat, sg_mat_tag_x_err_l2, quad_coef);
 
+   
+
+    double A[4] = { quad_coef[0], quad_coef[2] / 2, quad_coef[2] / 2, quad_coef[1] };
+    double B[2] = { quad_coef[3] , quad_coef[4] };
+    double opt_scaling[2];
+
+    direct_inv_2x2(A, B, opt_scaling);
+    opt_scaling[0] = -opt_scaling[0] / 2;
+    opt_scaling[1] = -opt_scaling[1] / 2;
+
     if (data)
     {
         data->k2dsm_data_p.errL2 = std::vector<double>(std::begin(err_l2), std::end(err_l2));
@@ -454,16 +452,8 @@ double2 k_to_DSM::run_scaling_optimization_step
         data->k2dsm_data_p.sg_mat_tag_x_sg_mat = std::vector<double>(std::begin(sg_mat_tag_x_sg_mat), std::end(sg_mat_tag_x_sg_mat));
         data->k2dsm_data_p.sg_mat_tag_x_err_l2 = std::vector<double>(std::begin(sg_mat_tag_x_err_l2), std::end(sg_mat_tag_x_err_l2));
         data->k2dsm_data_p.quad_coef = std::vector<double>(std::begin(quad_coef), std::end(quad_coef));
+        data->k2dsm_data_p.opt_scaling_1 = { opt_scaling[0], opt_scaling[1] };
     }
-
-    double A[4] = { quad_coef[0], quad_coef[2] / 2, quad_coef[2] / 2, quad_coef[1] };
-    double B[2] = { quad_coef[3] / 2, quad_coef[4] / 2 };
-    double opt_scaling[2];
-
-    direct_inv_2x2(A, B, opt_scaling);
-    opt_scaling[0] = -opt_scaling[0];
-    opt_scaling[1] = -opt_scaling[1];
-
     // sanity check
 
     double min_x, min_y, max_x, max_y;
@@ -486,7 +476,7 @@ double2 k_to_DSM::run_scaling_optimization_step
     }
 
     auto is_pos_def = (quad_coef[0] + quad_coef[1]) > 0 && (quad_coef[0] * quad_coef[1] - quad_coef[2] * quad_coef[2] / 4) > 0;
-    auto is_with_in_lims = (opt_scaling[0] > min_x) && (opt_scaling[0] < max_y) && (opt_scaling[1] > min_y) && (opt_scaling[1] < max_y);
+    auto is_with_in_lims = (opt_scaling[0] > min_x) && (opt_scaling[0] < max_x) && (opt_scaling[1] > min_y) && (opt_scaling[1] < max_y);
 
     if (!is_pos_def || !is_with_in_lims)
     {
@@ -713,7 +703,7 @@ std::vector<double2> k_to_DSM::convert_norm_vertices_to_los
 (
     algo_calibration_info const &regs,
     algo_calibration_registers const &dsm_regs,
-    std::vector<double3> vertices,
+    std::vector< double3 > const & vertices,
     convert_norm_vertices_to_los_data* data
 )
 {
@@ -833,8 +823,8 @@ std::vector<double2> k_to_DSM::convert_norm_vertices_to_los
     }
     for (auto i = 0; i < res.size(); i++)
     {
-        res[i].x = (dsm_x[i] + (double)2047) / (double)dsm_regs.EXTLdsmXscale - (double)dsm_regs.EXTLdsmXoffset;
-        res[i].y = (dsm_y[i] + (double)2047) / (double)dsm_regs.EXTLdsmYscale - (double)dsm_regs.EXTLdsmYoffset;
+        res[i].x = (dsm_x[i] + 2047.) / (double)dsm_regs.EXTLdsmXscale - (double)dsm_regs.EXTLdsmXoffset;
+        res[i].y = (dsm_y[i] + 2047.) / (double)dsm_regs.EXTLdsmYscale - (double)dsm_regs.EXTLdsmYoffset;
     }
     return res;
 }
@@ -850,14 +840,14 @@ double3 k_to_DSM::laser_incident_direction(double2 angle_rad)
     return laser_incident_direction;
 }
 
-std::vector<double3> k_to_DSM::transform_to_direction(std::vector<double3> vec)
+std::vector< double3 > k_to_DSM::transform_to_direction( std::vector< double3 > const & vec )
 {
-   std::vector<double3> res(vec.size());
-
-   for (auto i = 0; i < vec.size(); i++)
-   {
-       auto norm = sqrt(vec[i].x*vec[i].x + vec[i].y*vec[i].y + vec[i].z*vec[i].z);
-       res[i] = { vec[i].x / norm, vec[i].y / norm, vec[i].z / norm };
-   }
-   return res;
+    std::vector< double3 > res( vec.size() );
+
+    for( auto i = 0; i < vec.size(); i++ )
+    {
+        auto norm = sqrt( vec[i].x * vec[i].x + vec[i].y * vec[i].y + vec[i].z * vec[i].z );
+        res[i] = { vec[i].x / norm, vec[i].y / norm, vec[i].z / norm };
+    }
+    return res;
 }
diff --git a/src/algo/depth-to-rgb-calibration/k-to-dsm.h b/src/algo/depth-to-rgb-calibration/k-to-dsm.h
index ddb1c5d..27c90d7 100644
--- a/src/algo/depth-to-rgb-calibration/k-to-dsm.h
+++ b/src/algo/depth-to-rgb-calibration/k-to-dsm.h
@@ -244,11 +244,11 @@ namespace depth_to_rgb_calibration {
 
         std::vector<double2> convert_norm_vertices_to_los(const algo_calibration_info& regs, 
             const algo_calibration_registers& algo_calibration_registers, 
-            std::vector<double3> vertices, 
+            std::vector<double3> const & vertices, 
             convert_norm_vertices_to_los_data* data = nullptr);
 
         double3 laser_incident_direction(double2 angle_rad);
-        std::vector<double3> transform_to_direction(std::vector<double3>);
+        std::vector< double3 > transform_to_direction( std::vector< double3 > const & );
         
         pre_process_data _pre_process_data;
 
diff --git a/src/algo/depth-to-rgb-calibration/optimizer.cpp b/src/algo/depth-to-rgb-calibration/optimizer.cpp
index e1449d3..7a0777d 100644
--- a/src/algo/depth-to-rgb-calibration/optimizer.cpp
+++ b/src/algo/depth-to-rgb-calibration/optimizer.cpp
@@ -66,9 +66,7 @@ namespace
 
                 }
                 auto mid = (i + mask_height / 2) * image_width + j + mask_width / 2;
-
                 res[mid] = convolution_operation(sub_image);
-
             }
         }
         return res;
@@ -119,8 +117,27 @@ namespace
 }
 
 
-optimizer::optimizer()
+std::string optimizer::settings::to_string() const
 {
+    return librealsense::to_string()
+        << '[' << ( is_manual_trigger ? "MANUAL" : "AUTO" ) << ' ' << hum_temp << "degC"
+        << " ambience="
+        << ( ambient == RS2_AMBIENT_LIGHT_NO_AMBIENT    ? "none/long"
+             : ambient == RS2_AMBIENT_LIGHT_LOW_AMBIENT ? "low/short"
+                                                        : "??" )
+        << " gain=" << receiver_gain << ']';
+}
+
+
+optimizer::optimizer( settings const & s, bool debug_mode )
+    : _settings( s )
+    , _debug_mode( debug_mode )
+{
+    AC_LOG( DEBUG, "Optimizer settings are " << _settings.to_string() );
+    if( _settings.is_manual_trigger )
+        adjust_params_to_manual_mode();
+    else
+        adjust_params_to_auto_mode();
 }
 
 static std::vector< double > get_direction_deg(
@@ -217,24 +234,23 @@ std::pair< int, int > get_next_index(
     return { edge_plus_idx, edge_plus_idy };
 }
 
-void set_margin(
-    std::vector<double>& gradient,
-    double margin,
-    size_t width,
-    size_t height)
+void zero_margin( std::vector< double > & gradient, size_t margin, size_t width, size_t height )
 {
     auto it = gradient.begin();
-    for (auto i = 0; i < width; i++)
-    {
-        // zero mask of 2nd row, and row before the last
-        *(it + width + i) = 0;
-        *(it + width*(height-2) + i) = 0;
-    }
-    for (auto i = 0; i < height; i++)
+    for( auto m = 0; m < margin; ++m )
     {
-        // zero mask of 2nd column, and column before the last
-        *(it + i*width+1) = 0;
-        *(it + i * width + (width-2)) = 0;
+        for( auto i = 0; i < width; i++ )
+        {
+            // zero mask of 2nd row, and row before the last
+            *( it + m * width + i ) = 0;
+            *( it + width * ( height - m - 1 ) + i ) = 0;
+        }
+        for( auto i = 0; i < height; i++ )
+        {
+            // zero mask of 2nd column, and column before the last
+            *( it + i * width + m ) = 0;
+            *( it + i * width + ( width - m - 1 ) ) = 0;
+        }
     }
 }
 
@@ -292,15 +308,18 @@ void grid_xy(
         }
     }
 }
+
 template<class T>
 std::vector< double > interpolation( std::vector< T > const & grid_points,
-                                     std::vector< double > const x[], std::vector< double > const y[],
-                                     size_t dim, size_t valid_size, size_t valid_width )
+                                     std::vector< double > const x[],
+                                     std::vector< double > const y[],
+                                     size_t dim,
+                                     size_t valid_size,
+                                     size_t valid_width )
 {
-    // interpolation 
-
     std::vector<double> local_interp;
-    auto iedge_it = grid_points.begin();// iEdge   
+    local_interp.reserve( valid_size * dim );
+    auto iedge_it = grid_points.begin();
     std::vector<double>::const_iterator loc_reg_x[4];
     std::vector<double>::const_iterator loc_reg_y[4];
     for( auto i = 0; i < dim; i++ )
@@ -338,9 +357,11 @@ std::vector<uint8_t> is_suppressed(std::vector<double> const & local_edges, size
     return is_supressed;
 }
 
-std::vector<double> depth_mean(std::vector<double>& local_x, std::vector<double>& local_y)
+static std::vector< double > depth_mean( std::vector< double > const & local_x,
+                                         std::vector< double > const & local_y )
 {
     std::vector<double> res;
+    res.reserve( local_x.size() );
     size_t size = local_x.size() / 2;
     auto itx = local_x.begin();
     auto ity = local_y.begin();
@@ -354,10 +375,13 @@ std::vector<double> depth_mean(std::vector<double>& local_x, std::vector<double>
 
     return res;
 }
-std::vector<double> sum_gradient_depth(std::vector<double> &gradient, std::vector<double> &direction_per_pixel)
+
+static std::vector< double > sum_gradient_depth( std::vector< double > const & gradient,
+                                                 std::vector< double > const & direction_per_pixel )
 {
     std::vector<double> res;
     size_t size = direction_per_pixel.size() / 2;
+    res.reserve( size );
     auto it_dir = direction_per_pixel.begin();
     auto it_grad = gradient.begin();
     for (auto i = 0; i < size; i++, it_dir+=2, it_grad+=2)
@@ -371,28 +395,48 @@ std::vector<double> sum_gradient_depth(std::vector<double> &gradient, std::vecto
     return res;
 }
 
+
 std::vector< byte > find_valid_depth_edges( std::vector< double > const & grad_in_direction,
                                             std::vector< byte > const & is_supressed,
                                             std::vector< double > const & values_for_subedges,
-                                            int const gradZTh )
+                                            std::vector< double > const & ir_local_edges,
+                                            const params & p )
 {
     std::vector< byte > res;
     res.reserve( grad_in_direction.size() );
     //%validEdgePixels = zGradInDirection > params.gradZTh & isSupressed & zValuesForSubEdges > 0;
-    for (int i = 0; i < grad_in_direction.size(); i++)
+    if (p.use_enhanced_preprocessing)
     {
-        bool cond1 = grad_in_direction[i] > gradZTh;
-        bool cond2 = is_supressed[i];
-        bool cond3 = values_for_subedges[i] > 0;
-        res.push_back( cond1 && cond2 && cond3 );
+        for (int i = 0; i < grad_in_direction.size(); i++)
+        {
+            bool cond1 = (grad_in_direction[i] > p.grad_z_low_th  && ir_local_edges[i * 4 + 2] > p.grad_ir_high_th) ||
+                         (grad_in_direction[i] > p.grad_z_high_th && ir_local_edges[i * 4 + 2] > p.grad_ir_low_th);
+
+            bool cond2 = is_supressed[i];
+            bool cond3 = values_for_subedges[i] > 0;
+            res.push_back(cond1 && cond2 && cond3);
+        }
+    }
+    else
+    {
+        for (int i = 0; i < grad_in_direction.size(); i++)
+        {
+            bool cond1 = grad_in_direction[i] > p.grad_z_threshold;
+            bool cond2 = is_supressed[i];
+            bool cond3 = values_for_subedges[i] > 0;
+            res.push_back(cond1 && cond2 && cond3);
+        }
     }
+   
     return res;
 }
 
-std::vector<double> find_local_values_min(std::vector<double>& local_values)
+
+static std::vector< double > find_local_values_min( std::vector< double > const & local_values )
 {
     std::vector<double> res;
     size_t size = local_values.size() / 4;
+    res.reserve( size );
     auto it = local_values.begin();
     for (auto i = 0; i < size; i++)
     {
@@ -406,6 +450,8 @@ std::vector<double> find_local_values_min(std::vector<double>& local_values)
     }
     return res;
 }
+
+
 void optimizer::set_z_data( std::vector< z_t > && depth_data,
                             rs2_intrinsics_double const & depth_intrinsics,
                             rs2_dsm_params const & dsm_params,
@@ -418,7 +464,7 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
     /*[zEdge,Zx,Zy] = OnlineCalibration.aux.edgeSobelXY(uint16(frame.z),2); % Added the second input - margin to zero out
     [iEdge,Ix,Iy] = OnlineCalibration.aux.edgeSobelXY(uint16(frame.i),2); % Added the second input - margin to zero out
     validEdgePixelsByIR = iEdge>params.gradITh; */
-    _params.set_depth_resolution(depth_intrinsics.width, depth_intrinsics.height);
+    _params.set_depth_resolution(depth_intrinsics.width, depth_intrinsics.height, _settings.ambient);
     _z.width = depth_intrinsics.width;
     _z.height = depth_intrinsics.height;
     _z.orig_intrinsics = depth_intrinsics;
@@ -427,56 +473,87 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
 
     _z.frame = std::move(depth_data);
 
-    _z.gradient_x = calc_vertical_gradient(_z.frame, depth_intrinsics.width, depth_intrinsics.height);
-    _z.gradient_y = calc_horizontal_gradient(_z.frame, depth_intrinsics.width, depth_intrinsics.height);
-    _ir.gradient_x = calc_vertical_gradient(_ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height);
-    _ir.gradient_y = calc_horizontal_gradient(_ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height);
+    auto z_gradient_x = calc_vertical_gradient(_z.frame, depth_intrinsics.width, depth_intrinsics.height);
+    auto z_gradient_y = calc_horizontal_gradient( _z.frame, depth_intrinsics.width, depth_intrinsics.height );
+    auto ir_gradient_x = calc_vertical_gradient( _ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height );
+    auto ir_gradient_y = calc_horizontal_gradient( _ir.ir_frame, depth_intrinsics.width, depth_intrinsics.height );
 
     // set margin of 2 pixels to 0
-    set_margin(_z.gradient_x, 2, _z.width, _z.height);
-    set_margin(_z.gradient_y, 2, _z.width, _z.height);
-    set_margin(_ir.gradient_x, 2, _z.width, _z.height);
-    set_margin(_ir.gradient_y, 2, _z.width, _z.height);
+    zero_margin( z_gradient_x, 2, _z.width, _z.height );
+    zero_margin( z_gradient_y, 2, _z.width, _z.height );
+    zero_margin( ir_gradient_x, 2, _z.width, _z.height );
+    zero_margin( ir_gradient_y, 2, _z.width, _z.height );
 
-    _z.edges = calc_intensity(_z.gradient_x, _z.gradient_y);
-    _ir.edges = calc_intensity(_ir.gradient_x, _ir.gradient_y);
+    auto ir_edges = calc_intensity( ir_gradient_x, ir_gradient_y );
+    std::vector< byte > valid_edge_pixels_by_ir;
+    {
+        auto z_edges = calc_intensity( z_gradient_x, z_gradient_y );
+        valid_edge_pixels_by_ir.reserve( ir_edges.size() );
+        
+        for( auto ir = ir_edges.begin(), z = z_edges.begin();
+             ir < ir_edges.end() && z < z_edges.end();
+             ir++, z++ )
+        {
+            bool valid_edge;
+            if( _params.use_enhanced_preprocessing )
+            {
+                valid_edge = ( *ir > _params.grad_ir_high_th && *z > _params.grad_z_low_th )
+                          || ( *ir > _params.grad_ir_low_th && *z > _params.grad_z_high_th );
+            }
+            else
+            {
+                valid_edge = ( *ir > _params.grad_ir_threshold );
+            }
+            valid_edge_pixels_by_ir.push_back( valid_edge );
+        }
 
-    for( auto it = _ir.edges.begin(); it < _ir.edges.end(); it++ )
-        _ir.valid_edge_pixels_by_ir.push_back( *it > _params.grad_ir_threshold );
+        if( _debug_mode )
+            _z.edges = std::move( z_edges );
+    }
+        
 
     /*sz = size(frame.i);
     [gridX,gridY] = meshgrid(1:sz(2),1:sz(1)); % gridX/Y contains the indices of the pixels
     sectionMapDepth = OnlineCalibration.aux.sectionPerPixel(params);
     */
     // Get a map for each pixel to its corresponding section
-    _z.section_map_depth.resize(_z.width * _z.height);
+    std::vector< byte > section_map_depth;
+    section_map_depth.resize(_z.width * _z.height);
     size_t const section_w = _params.num_of_sections_for_edge_distribution_x;  //% params.numSectionsH
     size_t const section_h = _params.num_of_sections_for_edge_distribution_y;  //% params.numSectionsH
-    section_per_pixel(_z, section_w, section_h, _z.section_map_depth.data());
+    section_per_pixel(_z, section_w, section_h, section_map_depth.data());
 
     //%locRC = [sampleByMask( gridY, validEdgePixelsByIR ), sampleByMask( gridX, validEdgePixelsByIR )];
     //%sectionMapValid = sampleByMask( sectionMapDepth, validEdgePixelsByIR );
     //%IxValid = sampleByMask( Ix, validEdgePixelsByIR );
     //%IyValid = sampleByMask( Iy, validEdgePixelsByIR );
 
-    std::vector<double> grid_x;
-    std::vector<double> grid_y;
-    grid_xy(grid_x, grid_y, _z.width, _z.height);
+    std::vector< double > valid_location_rc_x;
+    std::vector< double > valid_location_rc_y;
+    {
+        std::vector< double > grid_x, grid_y;
+        grid_xy( grid_x, grid_y, _z.width, _z.height );
+        sample_by_mask( valid_location_rc_x, grid_x, valid_edge_pixels_by_ir, _z.width, _z.height );
+        sample_by_mask( valid_location_rc_y, grid_y, valid_edge_pixels_by_ir, _z.width, _z.height );
+    }
+    std::vector< byte > valid_section_map;
+    std::vector< double > valid_gradient_x;
+    std::vector< double > valid_gradient_y;
+
+    sample_by_mask( valid_section_map,  section_map_depth, valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( valid_gradient_x, ir_gradient_x, valid_edge_pixels_by_ir, _z.width, _z.height );
+    sample_by_mask( valid_gradient_y, ir_gradient_y, valid_edge_pixels_by_ir, _z.width, _z.height );
 
-    sample_by_mask( _ir.valid_location_rc_x, grid_x, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
-    sample_by_mask( _ir.valid_location_rc_y, grid_y, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
-    sample_by_mask( _ir.valid_section_map, _z.section_map_depth, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
-    sample_by_mask( _ir.valid_gradient_x, _ir.gradient_x, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
-    sample_by_mask( _ir.valid_gradient_y, _ir.gradient_y, _ir.valid_edge_pixels_by_ir, _z.width, _z.height );
+    auto itx = valid_location_rc_x.begin();
+    auto ity = valid_location_rc_y.begin();
 
-    auto itx = _ir.valid_location_rc_x.begin();
-    auto ity = _ir.valid_location_rc_y.begin();
-    for (auto i = 0; i < _ir.valid_location_rc_x.size(); i++)
+    std::vector< double > valid_location_rc;
+    for (auto i = 0; i < valid_location_rc_x.size(); i++)
     {
         auto x = *(itx + i);
         auto y = *(ity + i);
-        _ir.valid_location_rc.push_back(y);
-        _ir.valid_location_rc.push_back(x);
+        valid_location_rc.push_back(y);
+        valid_location_rc.push_back(x);
     }
 
     /*
@@ -485,8 +562,10 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
     [~,directionIndex] = min(abs(directionInDeg - [0:45:315]),[],2); % Quantize the direction to 4 directions (don't care about the sign)
     */
 
-    _ir.direction_deg = get_direction_deg2(_ir.valid_gradient_x, _ir.valid_gradient_y); // used for debug only
-    _ir.directions = get_direction2(_ir.valid_gradient_x, _ir.valid_gradient_y);
+    if( _debug_mode )
+        _ir.direction_deg = get_direction_deg2( valid_gradient_x, valid_gradient_y );
+
+    std::vector< direction > dirs = get_direction2( valid_gradient_x, valid_gradient_y );
 
     /*dirsVec = [0,1; 1,1; 1,0; 1,-1]; % These are the 4 directions
     dirsVec = [dirsVec;-dirsVec];
@@ -502,41 +581,50 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
 
         locRCsub = locRC + fraqStep.*dirPerPixel;*/
     double directions[8][2] = { {0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1} };
-    std::vector<double> direction_per_pixel_x; //used later when finding valid direction per pixel
-    for (auto i = 0; i < _ir.directions.size(); i++)
+
+    std::vector< double > direction_per_pixel;
+    std::vector< double > direction_per_pixel_x;  //used later when finding valid direction per pixel
+
+    for( auto i = 0; i < dirs.size(); i++ )
     {
-        int idx = _ir.directions[i];
-        _ir.direction_per_pixel.push_back(directions[idx][0]);
-        _ir.direction_per_pixel.push_back(directions[idx][1]);
+        int idx = dirs[i];
+        direction_per_pixel.push_back(directions[idx][0]);
+        direction_per_pixel.push_back(directions[idx][1]);
         direction_per_pixel_x.push_back(directions[idx][0]);
     }
     double vec[4] = { -2,-1,0,1 }; // one pixel along gradient direction, 2 pixels against gradient direction
 
-    auto loc_it = _ir.valid_location_rc.begin();
-    auto dir_pp_it = _ir.direction_per_pixel.begin();
+    auto loc_it = valid_location_rc.begin();
+    auto dir_pp_it = direction_per_pixel.begin();
 
-    for (auto k = 0; k < 4; k++)
+    std::vector< double > local_region[4];
+    for( auto k = 0; k < 4; k++ )
     {
-        for (auto i = 0; i < _ir.direction_per_pixel.size(); i++)
+        local_region[k].reserve( direction_per_pixel.size() );
+        for( auto i = 0; i < direction_per_pixel.size(); i++ )
         {
-            double val = *(loc_it + i) + *(dir_pp_it + i) * vec[k];
-            _ir.local_region[k].push_back(val);
+            double val = *( loc_it + i ) + *( dir_pp_it + i ) * vec[k];
+            local_region[k].push_back( val );
         }
     }
-    for (auto k = 0; k < 4; k++)
+    std::vector< double > local_region_x[4];
+    std::vector< double > local_region_y[4];
+    for( auto k = 0; k < 4; k++ )
     {
-        for (auto i = 0; i < 2 * _ir.valid_location_rc_x.size(); i++)
+        local_region_x[k].reserve( 2 * valid_location_rc_x.size() );
+        local_region_y[k].reserve( 2 * valid_location_rc_x.size() );
+        for( auto i = 0; i < 2 * valid_location_rc_x.size(); i++ )
         {
-            _ir.local_region_y[k].push_back(*(_ir.local_region[k].begin() + i));
+            local_region_y[k].push_back( *( local_region[k].begin() + i ) );
             i++;
-            _ir.local_region_x[k].push_back(*(_ir.local_region[k].begin() + i));
+            local_region_x[k].push_back( *( local_region[k].begin() + i ) );
         }
     }
     // interpolation 
-    _ir.local_edges = interpolation(_ir.edges, _ir.local_region_x, _ir.local_region_y, 4, _ir.valid_location_rc_x.size(), _ir.width);
+    _ir.local_edges = interpolation(ir_edges,local_region_x, local_region_y, 4,  valid_location_rc_x.size(), _ir.width);
 
     // is suppressed
-    _ir.is_supressed = is_suppressed(_ir.local_edges, _ir.valid_location_rc_x.size());
+    _ir.is_supressed = is_suppressed(_ir.local_edges,  valid_location_rc_x.size());
 
 
     /*fraqStep = (-0.5*(localEdges(:,4)-localEdges(:,2))./(localEdges(:,4)+localEdges(:,2)-2*localEdges(:,3))); % The step we need to move to reach the subpixel gradient i nthe gradient direction
@@ -556,14 +644,16 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
        edgeSubPixel = fliplr(locRCsub);% From Row-Col to XY*/
 
     std::vector< double > ::iterator loc_edg_it = _ir.local_edges.begin();
-    //std::vector<double > ::iterator loc_rc_sub_it = _depth.local_rc_subpixel.begin(); // locRCsub
-    auto valid_loc_rc = _ir.valid_location_rc.begin(); // locRC
-    auto dir_per_pixel_it = _ir.direction_per_pixel.begin(); // dirPerPixel
+    auto valid_loc_rc = valid_location_rc.begin(); // locRC
+    auto dir_per_pixel_it = direction_per_pixel.begin(); // dirPerPixel
 
     std::vector< double > edge_sub_pixel_x;
     std::vector< double > edge_sub_pixel_y;
+    std::vector< double > fraq_step;          // debug only
+    std::vector< double > local_rc_subpixel;  // debug only
+    std::vector< double > edge_sub_pixel;     // debug only
 
-    for (auto i = 0; i < _ir.valid_location_rc_x.size(); i++)
+    for( auto i = 0; i < valid_location_rc_x.size(); i++ )
     {
         double vec2 = *(loc_edg_it + 1);
         double vec3 = *(loc_edg_it + 2);
@@ -575,7 +665,6 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
         //%fraqStep( (localEdges(:,4) + localEdges(:,2) - 2 * localEdges(:,3)) == 0 ) = 0;
         double const denom = vec4 + vec2 - 2 * vec3;
         double const res = ( denom == 0 ) ? 0 : ( -0.5 * ( vec4 - vec2 ) / denom );
-        _ir.fraq_step.push_back( res );
 
         auto valx = *valid_loc_rc + *dir_per_pixel_it * res;
         valid_loc_rc++;
@@ -583,23 +672,61 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
         auto valy = *valid_loc_rc + *dir_per_pixel_it * res;
         valid_loc_rc++;
         dir_per_pixel_it++;
-        _z.local_rc_subpixel.push_back(valx);
-        _z.local_rc_subpixel.push_back(valy);
 
-        _z.edge_sub_pixel.push_back(valy);
-        _z.edge_sub_pixel.push_back(valx);
+        if( _debug_mode )
+        {
+            fraq_step.push_back( res );
+            local_rc_subpixel.push_back( valx );
+            local_rc_subpixel.push_back( valy );
+            edge_sub_pixel.push_back( valy );
+            edge_sub_pixel.push_back( valx );
+        }
         edge_sub_pixel_x.push_back(valy);
         edge_sub_pixel_y.push_back(valx);
     }
+    _z.edge_sub_pixel = std::move( edge_sub_pixel );
+    _z.local_rc_subpixel = std::move( local_rc_subpixel );
+    _ir.fraq_step = std::move( fraq_step );
 
-    std::vector<double> local_region_x[2] = { _ir.local_region_x[1] ,_ir.local_region_x[2] };
-    std::vector<double> local_region_y[2] = { _ir.local_region_y[1] ,_ir.local_region_y[2] };
-    _z.local_x = interpolation(_z.gradient_x, local_region_x, local_region_y, 2, _ir.valid_location_rc_x.size(), _z.width);
-    _z.local_y = interpolation(_z.gradient_y, local_region_x, local_region_y, 2, _ir.valid_location_rc_x.size(), _z.width);
-    _z.gradient = depth_mean(_z.local_x, _z.local_y);
-    _z.grad_in_direction = sum_gradient_depth(_z.gradient, _ir.direction_per_pixel);
-    _z.local_values = interpolation(_z.frame, _ir.local_region_x, _ir.local_region_y, 4, _ir.valid_location_rc_x.size(), _z.width);
-    _z.values_for_subedges = find_local_values_min(_z.local_values);
+    std::vector< double > grad_in_direction;
+    {
+        std::vector< double > local_x;
+        std::vector< double > local_y;
+        std::vector< double > gradient;
+
+        local_x = interpolation( z_gradient_x,
+                                 local_region_x + 1,
+                                 local_region_y + 1,
+                                 2,
+                                 valid_location_rc_x.size(),
+                                 _z.width );
+        local_y = interpolation( z_gradient_y,
+                                 local_region_x + 1,
+                                 local_region_y + 1,
+                                 2,
+                                 valid_location_rc_x.size(),
+                                 _z.width );
+        gradient = depth_mean( local_x, local_y );
+        grad_in_direction = sum_gradient_depth( gradient, direction_per_pixel );
+        if( _debug_mode )
+        {
+            _z.local_x = std::move( local_x );
+            _z.local_y = std::move( local_y );
+            _z.gradient = std::move( gradient );
+        }
+    }
+    std::vector< double > values_for_subedges;
+    {
+        std::vector< double > local_values = interpolation( _z.frame,
+                                                            local_region_x,
+                                                            local_region_y,
+                                                            4,
+                                                            valid_location_rc_x.size(),
+                                                            _z.width );
+        values_for_subedges = find_local_values_min( local_values );
+        if( _debug_mode )
+            _z.local_values = std::move( local_values );
+    }
 
     //_params.alpha;
     /* validEdgePixels = zGradInDirection > params.gradZTh & isSupressed & zValuesForSubEdges > 0;
@@ -612,41 +739,43 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
    directionIndex = directionIndex(validEdgePixels);
    directionIndex(directionIndex>4) = directionIndex(directionIndex>4)-4;% Like taking abosoulte value on the direction
    */
-    _z.supressed_edges = find_valid_depth_edges( _z.grad_in_direction,
+    _z.supressed_edges = find_valid_depth_edges(  grad_in_direction,
                                                  _ir.is_supressed,
-                                                 _z.values_for_subedges,
-                                                 _params.grad_z_threshold );
-    std::vector<double> valid_values_for_subedges;
-
+                                                 values_for_subedges,
+                                                 _ir.local_edges,
+                                                 _params);
 
-
-    depth_filter(_z.grad_in_direction_valid, _z.grad_in_direction, _z.supressed_edges, 1, _z.supressed_edges.size());
-    depth_filter(_z.valid_edge_sub_pixel_x, edge_sub_pixel_x, _z.supressed_edges, 1, _z.supressed_edges.size()); //edgeSubPixel = edgeSubPixel(validEdgePixels,:);
-    depth_filter(_z.valid_edge_sub_pixel_y, edge_sub_pixel_y, _z.supressed_edges, 1, _z.supressed_edges.size());
-    for (auto i = 0; i < _z.valid_edge_sub_pixel_x.size(); i++)
+    if( _debug_mode )
     {
-        _z.valid_edge_sub_pixel.push_back(*(_z.valid_edge_sub_pixel_x.begin() + i));
-        _z.valid_edge_sub_pixel.push_back(*(_z.valid_edge_sub_pixel_y.begin() + i));
-        // subPoints : subPoints = [xim,yim,ones(size(yim))];
-        _z.sub_points.push_back(*(_z.valid_edge_sub_pixel_x.begin() + i)-1);
-        _z.sub_points.push_back(*(_z.valid_edge_sub_pixel_y.begin() + i)-1);
-        _z.sub_points.push_back(1);
+        depth_filter( _z.grad_in_direction_valid,
+                      grad_in_direction,
+                      _z.supressed_edges,
+                      1,
+                      _z.supressed_edges.size() );
     }
-    depth_filter(valid_values_for_subedges, _z.values_for_subedges, _z.supressed_edges, 1, _z.supressed_edges.size());
-    depth_filter(_z.valid_direction_per_pixel, direction_per_pixel_x, _z.supressed_edges, 1, _z.supressed_edges.size());
-    depth_filter(_z.valid_section_map, _ir.valid_section_map, _z.supressed_edges, 1, _z.supressed_edges.size());
-    std::vector<double> edited_ir_directions;
 
-    for (auto i = 0; i < _ir.directions.size(); i++)
+    std::vector< double > valid_edge_sub_pixel_x;
+    std::vector< double > valid_edge_sub_pixel_y;
+    depth_filter( valid_edge_sub_pixel_x,
+                  edge_sub_pixel_x,
+                  _z.supressed_edges,
+                  1,
+                  _z.supressed_edges.size() );
+    depth_filter( valid_edge_sub_pixel_y,
+                  edge_sub_pixel_y,
+                  _z.supressed_edges,
+                  1,
+                  _z.supressed_edges.size() );
+
     {
-        auto val = double(*(_ir.directions.begin() + i));
-        val = val + 1;// +1 to align with matlab
-        val = val > 4 ? val - 4 : val;
-        edited_ir_directions.push_back(val);
+        std::vector< double > valid_values_for_subedges;
+        depth_filter( valid_values_for_subedges,  // out
+                      values_for_subedges,        // in
+                      _z.supressed_edges,
+                      1,
+                      _z.supressed_edges.size() );
+        values_for_subedges = valid_values_for_subedges;
     }
-    depth_filter(_z.valid_directions, edited_ir_directions, _z.supressed_edges, 1, _z.supressed_edges.size());
-
-    _z.values_for_subedges = valid_values_for_subedges;
 
     /* weights = min(max(zGradInDirection - params.gradZTh,0),params.gradZMax - params.gradZTh);
     if params.constantWeights
@@ -658,9 +787,10 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
     subPoints = [xim,yim,ones(size(yim))];
     vertices = subPoints*(pinv(params.Kdepth)').*zValuesForSubEdges/single(params.zMaxSubMM);
 
-    [uv,~,~] = OnlineCalibration.aux.projectVToRGB(vertices,params.rgbPmat,params.Krgb,params.rgbDistort);
+    [uv,~,~] =
+    OnlineCalibration.aux.projectVToRGB(vertices,params.rgbPmat,params.Krgb,params.rgbDistort);
     isInside = OnlineCalibration.aux.isInsideImage(uv,params.rgbRes);
-   
+
     xim = xim(isInside);
     yim = yim(isInside);
     zValuesForSubEdges = zValuesForSubEdges(isInside);
@@ -672,41 +802,116 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
     k_matrix k = depth_intrinsics;
     matrix_3x3 k_depth_pinv = { 0 };
     pinv_3x3( k.as_3x3().rot, k_depth_pinv.rot );
-    transform(_z.valid_edge_sub_pixel_x.begin(), _z.valid_edge_sub_pixel_x.end(), _z.valid_edge_sub_pixel_x.begin(), bind2nd(std::plus<double>(), -1.0));
-    transform(_z.valid_edge_sub_pixel_y.begin(), _z.valid_edge_sub_pixel_y.end(), _z.valid_edge_sub_pixel_y.begin(), bind2nd(std::plus<double>(), -1.0));
-    for (auto i = 0; i < _z.sub_points.size(); i += 3)
-    {
-        //%vertices = subPoints * pinv(params.Kdepth)' .* zValuesForSubEdges / params.zMaxSubMM;
-        double sub_points_mult[3];
-        double x = _z.sub_points[i];
-        double y = _z.sub_points[i + 1];
-        double z = _z.sub_points[i + 2];
-        for (auto jj = 0; jj < 3; jj++)
+    _z.k_depth_pinv = k_depth_pinv;
+
+    std::vector< byte > is_inside;
+    {
+        std::vector< double3 > vertices_all;
+        {
+            std::vector< double > sub_points;
+            sub_points.reserve( valid_edge_sub_pixel_x.size() * 3 );
+            {
+                std::vector< double > valid_edge_sub_pixel;
+                if( _debug_mode )
+                    valid_edge_sub_pixel.reserve( valid_edge_sub_pixel_x.size() );
+                for( auto i = 0; i < valid_edge_sub_pixel_x.size(); i++ )
+                {
+                    if( _debug_mode )
+                    {
+                        valid_edge_sub_pixel.push_back( *( valid_edge_sub_pixel_x.begin() + i ) );
+                        valid_edge_sub_pixel.push_back( *( valid_edge_sub_pixel_y.begin() + i ) );
+                    }
+                    // subPoints : subPoints = [xim,yim,ones(size(yim))];
+                    sub_points.push_back( *( valid_edge_sub_pixel_x.begin() + i ) - 1 );
+                    sub_points.push_back( *( valid_edge_sub_pixel_y.begin() + i ) - 1 );
+                    sub_points.push_back( 1 );
+                }
+                if( _debug_mode )
+                    _z.valid_edge_sub_pixel = std::move( valid_edge_sub_pixel );
+            }
+
+            vertices_all.reserve( valid_edge_sub_pixel_x.size() );
+            for( auto i = 0; i < sub_points.size(); i += 3 )
+            {
+                //% vertices = subPoints * pinv(params.Kdepth)' .* zValuesForSubEdges /
+                //params.zMaxSubMM;
+                double sub_points_mult[3];
+                double x = sub_points[i];
+                double y = sub_points[i + 1];
+                double z = sub_points[i + 2];
+                for( auto jj = 0; jj < 3; jj++ )
+                {
+                    sub_points_mult[jj] = x * k_depth_pinv.rot[3 * jj + 0]
+                                        + y * k_depth_pinv.rot[3 * jj + 1]
+                                        + z * k_depth_pinv.rot[3 * jj + 2];
+                }
+                auto z_value_for_subedge = values_for_subedges[i / 3];
+                auto val1 = sub_points_mult[0] * z_value_for_subedge / _params.max_sub_mm_z;
+                auto val2 = sub_points_mult[1] * z_value_for_subedge / _params.max_sub_mm_z;
+                auto val3 = sub_points_mult[2] * z_value_for_subedge / _params.max_sub_mm_z;
+                vertices_all.push_back( { val1, val2, val3 } );
+            }
+            if( _debug_mode )
+                _z.sub_points = std::move( sub_points );
+        }
+        std::vector< double2 > uvmap = get_texture_map( vertices_all,
+                                                        _original_calibration,
+                                                        _original_calibration.calc_p_mat() );
+        for( auto i = 0; i < uvmap.size(); i++ )
         {
-            sub_points_mult[jj] = x * k_depth_pinv.rot[3 * jj + 0]
-                                + y * k_depth_pinv.rot[3 * jj + 1]
-                                + z * k_depth_pinv.rot[3 * jj + 2];
+            //%isInside = xy(:,1) >= 0 & ...
+            //%           xy(:,1) <= res(2) - 1 & ...
+            //%           xy(:,2) >= 0 & ...
+            //%           xy(:,2) <= res(1) - 1;
+            bool cond_x = ( uvmap[i].x >= 0 ) && ( uvmap[i].x <= _yuy.width - 1 );
+            bool cond_y = ( uvmap[i].y >= 0 ) && ( uvmap[i].y <= _yuy.height - 1 );
+            is_inside.push_back( cond_x && cond_y );
         }
-        auto z_value_for_subedge = _z.values_for_subedges[i / 3];
-        auto val1 = sub_points_mult[0] * z_value_for_subedge / _params.max_sub_mm_z;
-        auto val2 = sub_points_mult[1] * z_value_for_subedge / _params.max_sub_mm_z;
-        auto val3 = sub_points_mult[2] * z_value_for_subedge / _params.max_sub_mm_z;
-        _z.vertices_all.push_back( { val1, val2, val3 } );
+        depth_filter( _z.vertices, vertices_all, is_inside, 1, is_inside.size() );
+        if( _debug_mode )
+            _z.uvmap = std::move( uvmap );
     }
-    _z.uvmap = get_texture_map( _z.vertices_all,
-                                _original_calibration,
-                                _original_calibration.calc_p_mat() );
 
+    if( _debug_mode )
+        depth_filter( _z.valid_direction_per_pixel,
+                      direction_per_pixel_x,
+                      _z.supressed_edges,
+                      1,
+                      _z.supressed_edges.size() );
 
-    for (auto i = 0; i < _z.uvmap.size(); i++)
     {
-        //%isInside = xy(:,1) >= 0 & ...
-        //%           xy(:,1) <= res(2) - 1 & ...
-        //%           xy(:,2) >= 0 & ...
-        //%           xy(:,2) <= res(1) - 1;
-        bool cond_x = (_z.uvmap[i].x >= 0) && (_z.uvmap[i].x <= _yuy.width-1);
-        bool cond_y = (_z.uvmap[i].y >= 0) && (_z.uvmap[i].y <= _yuy.height-1);
-        _z.is_inside.push_back( cond_x && cond_y );
+        std::vector< byte > z_valid_section_map;
+        depth_filter( z_valid_section_map,
+                      valid_section_map,
+                      _z.supressed_edges,
+                      1,
+                      _z.supressed_edges.size() );
+        depth_filter( _z.section_map, z_valid_section_map, is_inside, 1, is_inside.size() );
+        if( _debug_mode )
+            _z.valid_section_map = std::move( z_valid_section_map );
+    }
+
+    {
+        std::vector< double > valid_directions;
+        {
+            std::vector< double > edited_ir_directions;
+            edited_ir_directions.reserve( dirs.size() );
+            for( auto i = 0; i < dirs.size(); i++ )
+            {
+                auto val = double( *( dirs.begin() + i ) );
+                val = val + 1;  // +1 to align with matlab
+                val = val > 4 ? val - 4 : val;
+                edited_ir_directions.push_back( val );
+            }
+            depth_filter( valid_directions,
+                          edited_ir_directions,
+                          _z.supressed_edges,
+                          1,
+                          _z.supressed_edges.size() );
+        }
+        depth_filter( _z.directions, valid_directions, is_inside, 1, is_inside.size() );
+        if( _debug_mode )
+            _z.valid_directions = std::move( valid_directions );
     }
 
     /*xim = xim(isInside);
@@ -718,42 +923,75 @@ void optimizer::set_z_data( std::vector< z_t > && depth_data,
     vertices = vertices(isInside,:);
     sectionMapDepth = sectionMapDepth(isInside);*/
     //std::vector<double> weights;
-    for (auto i = 0; i < _z.is_inside.size(); i++) {
 
-        _z.valid_weights.push_back(_params.constant_weights);
+    {
+        std::vector< double > valid_weights;
+        valid_weights.reserve( is_inside.size() );
+        for( auto i = 0; i < is_inside.size(); i++ )
+            valid_weights.push_back( _params.constant_weights );
+        depth_filter( _z.weights, valid_weights, is_inside, 1, is_inside.size() );
     }
-    depth_filter(_z.subpixels_x, _z.valid_edge_sub_pixel_x, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.subpixels_y, _z.valid_edge_sub_pixel_y, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.closest, _z.values_for_subedges, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.grad_in_direction_inside, _z.grad_in_direction_valid, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.directions, _z.valid_directions, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.vertices, _z.vertices_all, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.section_map_depth_inside, _z.valid_section_map, _z.is_inside, 1, _z.is_inside.size());
-    depth_filter(_z.weights, _z.valid_weights, _z.is_inside, 1, _z.is_inside.size());
+
+    transform(valid_edge_sub_pixel_x.begin(), valid_edge_sub_pixel_x.end(), valid_edge_sub_pixel_x.begin(), bind2nd(std::plus<double>(), -1.0));
+    transform(valid_edge_sub_pixel_y.begin(), valid_edge_sub_pixel_y.end(), valid_edge_sub_pixel_y.begin(), bind2nd(std::plus<double>(), -1.0));
+    depth_filter(_z.subpixels_x, valid_edge_sub_pixel_x, is_inside, 1, is_inside.size());
+    depth_filter(_z.subpixels_y, valid_edge_sub_pixel_y, is_inside, 1, is_inside.size());
+
+    depth_filter(_z.closest, values_for_subedges, is_inside, 1, is_inside.size());
 
     _z.relevant_pixels_image.resize(_z.width * _z.height, 0);
-    std::vector<double> sub_pixel_x = _z.subpixels_x;
-    std::vector<double> sub_pixel_y= _z.subpixels_y;
+    std::vector< double > sub_pixel_x = _z.subpixels_x;
+    std::vector< double > sub_pixel_y = _z.subpixels_y;
 
     transform(_z.subpixels_x.begin(), _z.subpixels_x.end(), sub_pixel_x.begin(), [](double x) {return round(x + 1); });
     transform(_z.subpixels_y.begin(), _z.subpixels_y.end(), sub_pixel_y.begin(), [](double x) {return round(x + 1); });
 
-    _z.subpixels_y_round = sub_pixel_y;
-    _z.subpixels_x_round = sub_pixel_x;
-
     for (auto i = 0; i < sub_pixel_x.size(); i++)
     {
-        auto x = _z.subpixels_x_round[i];
-        auto y = _z.subpixels_y_round[i];
+        auto x = sub_pixel_x[i];
+        auto y = sub_pixel_y[i];
 
         _z.relevant_pixels_image[size_t( ( y - 1 ) * _z.width + x - 1 )] = 1;
     }
+
+    if( _debug_mode )
+    {
+        _z.gradient_x = std::move( z_gradient_x );
+        _z.gradient_y = std::move( z_gradient_y );
+        _ir.gradient_x = std::move( ir_gradient_x );
+        _ir.gradient_y = std::move( ir_gradient_y );
+        _ir.edges = std::move( ir_edges );
+        _ir.valid_edge_pixels_by_ir = std::move( valid_edge_pixels_by_ir );
+        _z.section_map_depth = std::move( section_map_depth );
+        _ir.valid_section_map = std::move( valid_section_map );
+        _ir.valid_gradient_x = std::move( valid_gradient_x );
+        _ir.valid_gradient_y = std::move( valid_gradient_y );
+        _ir.valid_location_rc_x = std::move( valid_location_rc_x );
+        _ir.valid_location_rc_y = std::move( valid_location_rc_y );
+        _ir.valid_location_rc = std::move( valid_location_rc );
+        _ir.directions = std::move( dirs );
+        _ir.direction_per_pixel = std::move( direction_per_pixel );
+        _z.grad_in_direction = std::move( grad_in_direction );
+        _z.values_for_subedges = std::move( values_for_subedges );
+
+        for (auto i = 0; i < 4; i++)
+        {
+            _ir.local_region[i] = std::move( local_region[i] );
+            _ir.local_region_x[i] = std::move( local_region_x[i] );
+            _ir.local_region_y[i] = std::move( local_region_y[i] );
+        }
+
+        _z.is_inside = std::move( is_inside );
+        _z.subpixels_x_round = std::move( sub_pixel_x );
+        _z.subpixels_y_round = std::move( sub_pixel_y );
+    }
 }
 
 
 void optimizer::set_yuy_data(
     std::vector< yuy_t > && yuy_data,
     std::vector< yuy_t > && prev_yuy_data,
+    std::vector< yuy_t > && last_successful_yuy_data,
     calib const & calibration
 )
 {
@@ -765,18 +1003,79 @@ void optimizer::set_yuy_data(
 
     _yuy.orig_frame = std::move( yuy_data );
     _yuy.prev_frame = std::move( prev_yuy_data );
+    _yuy.last_successful_frame = std::move( last_successful_yuy_data );
 
-    _yuy.lum_frame = get_luminance_from_yuy2( _yuy.orig_frame );
-    _yuy.prev_lum_frame = get_luminance_from_yuy2( _yuy.prev_frame );
+    std::vector< uint8_t > lum_frame;
+    std::vector< uint8_t > prev_lum_frame;
+    std::vector< uint8_t > last_successful_lum_frame;
 
-    _yuy.edges = calc_edges( _yuy.lum_frame, _yuy.width, _yuy.height );
-    _yuy.prev_edges = calc_edges(_yuy.prev_lum_frame, _yuy.width, _yuy.height);
+    lum_frame = get_luminance_from_yuy2( _yuy.orig_frame );
+    prev_lum_frame = get_luminance_from_yuy2( _yuy.prev_frame );
 
-    _yuy.edges_IDT = blur_edges( _yuy.edges, _yuy.width, _yuy.height );
+    auto edges = calc_edges( lum_frame, _yuy.width, _yuy.height );
 
-    _yuy.edges_IDTx = calc_vertical_gradient( _yuy.edges_IDT, _yuy.width, _yuy.height );
+    {
+        auto prev_edges = calc_edges( prev_lum_frame, _yuy.width, _yuy.height );
+
+        _yuy.movement_from_prev_frame
+            = is_movement_in_images( { prev_edges, prev_lum_frame },
+                                     { edges, lum_frame },
+                                     _debug_mode ? &_yuy.debug.movement_result : nullptr,
+                                     _params.move_thresh_pix_val,
+                                     _params.move_threshold_pix_num,
+                                     _yuy.width, _yuy.height );
+    }
+
+    AC_LOG( DEBUG,
+            "    previous calibration image "
+                << ( last_successful_yuy_data.empty() ? "was NOT supplied" : "supplied" ) );
+    if( ! _settings.is_manual_trigger && ! _yuy.last_successful_frame.empty() )
+    {
+        last_successful_lum_frame = get_luminance_from_yuy2( _yuy.last_successful_frame );
+        auto last_successful_edges = calc_edges( last_successful_lum_frame, _yuy.width, _yuy.height );
+
+        _yuy.movement_from_last_success = is_movement_in_images(
+            { last_successful_edges, last_successful_lum_frame },
+            { edges, lum_frame },
+            _debug_mode ? &_yuy.debug.movement_prev_valid_result : nullptr,
+            _params.move_last_success_thresh_pix_val,
+            _params.move_last_success_thresh_pix_num,
+            _yuy.width, _yuy.height );
+    }
+    else
+        _yuy.movement_from_last_success = true;
 
+    _yuy.edges_IDT = blur_edges( edges, _yuy.width, _yuy.height );
+    _yuy.edges_IDTx = calc_vertical_gradient( _yuy.edges_IDT, _yuy.width, _yuy.height );
     _yuy.edges_IDTy = calc_horizontal_gradient( _yuy.edges_IDT, _yuy.width, _yuy.height );
+
+    // Get a map for each pixel to its corresponding section
+    std::vector< byte > section_map_rgb( _yuy.width * _yuy.height );
+    section_per_pixel( _yuy,
+                       _params.num_of_sections_for_edge_distribution_x,  //% params.numSectionsH
+                       _params.num_of_sections_for_edge_distribution_y,  //% params.numSectionsV
+                       section_map_rgb.data() );
+
+    // remove pixels in section map where rgbEdge <= params.gradRgbTh (see preprocessRGB)
+    double const gradRgbTh = 15. * 1280 / _yuy.width;
+    int i = 0;
+    _yuy.section_map_edges.reserve( edges.size() );
+    for( auto it = edges.begin(); it != edges.end(); ++it, ++i )
+    {
+        if( *it > gradRgbTh )
+            _yuy.section_map_edges.push_back( section_map_rgb[i] );
+    }
+    _yuy.section_map_edges.shrink_to_fit();
+    AC_LOG( DEBUG, "    " << _yuy.section_map_edges.size() << " pixels with a relevant edge" );
+
+    if( _debug_mode )
+    {
+        _yuy.debug.lum_frame = std::move( lum_frame );
+        _yuy.debug.prev_lum_frame = std::move( prev_lum_frame );
+        _yuy.debug.last_successful_lum_frame = std::move( last_successful_lum_frame );
+
+        _yuy.debug.edges = std::move( edges );
+    }
 }
 
 void optimizer::set_ir_data(
@@ -789,7 +1088,6 @@ void optimizer::set_ir_data(
     _ir.height = height;
     
     _ir.ir_frame = std::move( ir_data );
-    _ir.edges = calc_edges( _ir.ir_frame, width, height );
 }
 
 calib optimizer::decompose_p_mat(p_matrix p)
@@ -809,20 +1107,6 @@ rs2_intrinsics_double optimizer::get_new_z_intrinsics_from_new_calib(const rs2_i
     return res;
 }
 
-void optimizer::zero_invalid_edges( z_frame_data & z_data, ir_frame_data const & ir_data )
-{
-    for( auto i = 0; i < ir_data.edges.size(); i++ )
-    {
-        if( ir_data.edges[i] <= _params.grad_ir_threshold || z_data.edges[i] <= _params.grad_z_threshold )
-        {
-            z_data.supressed_edges[i] = 0;
-            z_data.subpixels_x[i] = 0;
-            z_data.subpixels_y[i] = 0;
-            z_data.closest[i] = 0;
-        }
-    }
-}
-
 std::vector< direction > optimizer::get_direction( std::vector<double> gradient_x, std::vector<double> gradient_y )
 {
     std::vector<direction> res( gradient_x.size(), deg_none );
@@ -1000,11 +1284,11 @@ std::vector< byte > optimizer::get_luminance_from_yuy2( std::vector< yuy_t > con
     return res;
 }
 
-std::vector<uint8_t> optimizer::get_logic_edges( std::vector<double> edges )
+std::vector< uint8_t > optimizer::get_logic_edges( std::vector< double > const & edges )
 {
     std::vector<uint8_t> logic_edges( edges.size(), 0 );
     auto max = std::max_element( edges.begin(), edges.end() );
-    auto thresh = *max*_params.edge_thresh4_logic_lum;
+    auto thresh = *max * _params.edge_thresh4_logic_lum;
 
     for( auto i = 0; i < edges.size(); i++ )
     {
@@ -1025,6 +1309,10 @@ void optimizer::sum_per_section(
 for ix = 1:params.numSectionsV*params.numSectionsH
     sumWeightsPerSection(ix) = sum(weights(sectionMap == ix-1));
 end*/
+    if( section_map.size() != weights.size() )
+        throw std::runtime_error( to_string()
+                                  << "unexpected size for section_map (" << section_map.size()
+                                  << ") vs weights (" << weights.size() << ")" );
     sum_weights_per_section.resize( num_of_sections );
     auto p_sum = sum_weights_per_section.data();
     for( byte i = 0; i < num_of_sections; ++i, ++p_sum )
@@ -1265,21 +1553,68 @@ svm_model_linear::svm_model_linear()
 svm_model_gaussian::svm_model_gaussian()
 {
 }
-void params::set_depth_resolution( size_t width, size_t height )
+void params::set_depth_resolution( size_t width, size_t height, rs2_ambient_light ambient)
 {
-    AC_LOG( DEBUG, "... depth resolution= " << width << "x" << height );
+    AC_LOG( DEBUG, "    depth resolution= " << width << "x" << height );
     // Some parameters are resolution-dependent
     bool const XGA = (width == 1024 && height == 768);
+    bool const VGA = (width == 640 && height == 480);
     if( XGA )
     {
-        AC_LOG( DEBUG, "... changing IR threshold: " << grad_ir_threshold << " -> " << 2.5 << "  (because of resolution)" );
+        AC_LOG( DEBUG, "    changing IR threshold: " << grad_ir_threshold << " -> " << 2.5 << "  (because of resolution)" );
         grad_ir_threshold = 2.5;
     }
+    if (use_enhanced_preprocessing)
+    {
+        if (ambient == RS2_AMBIENT_LIGHT_NO_AMBIENT)
+        {
+            if (VGA)
+            {
+                grad_ir_low_th = 1.5;
+                grad_ir_high_th = 3.5;
+                grad_z_low_th = 0;
+                grad_z_high_th = 100;
+            }
+            else if (XGA)
+            {
+                grad_ir_low_th = 1;
+                grad_ir_high_th = 2.5;
+                grad_z_low_th = 0;
+                grad_z_high_th = 80;
+            }
+        }
+        else
+        {
+            if (VGA)
+            {
+                grad_ir_low_th = std::numeric_limits<double>::max();
+                grad_ir_high_th = 3.5;
+                grad_z_low_th = 0;
+                grad_z_high_th = std::numeric_limits<double>::max();
+            }
+            else if (XGA)
+            {
+                grad_ir_low_th = std::numeric_limits<double>::max();
+                grad_ir_high_th = 2.5;
+                grad_z_low_th = 0;
+                grad_z_high_th = std::numeric_limits<double>::max();
+            }
+        }
+    }
+    min_weighted_edge_per_section_depth = 50. * ( 480 * 640 ) / ( width * height );
 }
 
 void params::set_rgb_resolution( size_t width, size_t height )
 {
-    AC_LOG( DEBUG, "... RGB resolution= " << width << "x" << height );
+    AC_LOG( DEBUG, "    RGB resolution= " << width << "x" << height );
+    auto area = width * height;
+    size_t const hd_area = 1920 * 1080;
+    move_threshold_pix_num = 3e-5 * area;
+    move_last_success_thresh_pix_num = 0.1 * area;
+    max_xy_movement_per_calibration[0] = 10. * area / hd_area;
+    max_xy_movement_per_calibration[1] = max_xy_movement_per_calibration[2] = 2. * area / hd_area;
+    max_xy_movement_from_origin = 20. * area / hd_area;
+    min_weighted_edge_per_section_rgb = 0.05 * hd_area / area;
 }
 
 calib const & optimizer::get_calibration() const
@@ -1343,7 +1678,7 @@ void write_matlab_camera_params_file(
     //depth intrinsics
     write_obj( f, (double)_intr_depth.width );
     write_obj( f, (double)_intr_depth.height );
-    write_obj( f, (double)_depth_units );
+    write_obj( f, (double)1/_depth_units );
 
     double k_depth[9] = { _intr_depth.fx, 0, _intr_depth.ppx,
                         0, _intr_depth.fy, _intr_depth.ppy,
@@ -1392,12 +1727,13 @@ void write_matlab_camera_params_file(
 void optimizer::write_data_to( std::string const & dir )
 {
     // NOTE: it is expected that dir ends with a path separator or this won't work!
-    AC_LOG( DEBUG, "... writing data to: " << dir );
+    AC_LOG( DEBUG, "    writing data to: " << dir );
     
     try
     {
         write_vector_to_file( _yuy.orig_frame, dir, "rgb.raw" );
         write_vector_to_file( _yuy.prev_frame, dir, "rgb_prev.raw" );
+        write_vector_to_file( _yuy.last_successful_frame, dir, "rgb_last_successful.raw");
         write_vector_to_file( _ir.ir_frame, dir, "ir.raw" );
         write_vector_to_file( _z.frame, dir, "depth.raw" );
 
@@ -1409,6 +1745,7 @@ void optimizer::write_data_to( std::string const & dir )
         write_to_file( &cal_regs, sizeof( cal_regs ), dir, "cal.registers" );
         write_to_file( &_z.orig_intrinsics, sizeof( _z.orig_intrinsics), dir, "depth.intrinsics" );
         write_to_file( &_z.depth_units, sizeof( _z.depth_units ), dir, "depth.units" );
+        write_to_file( &_settings, sizeof( _settings ), dir, "settings" );
 
         // This file is meant for matlab -- it packages all the information needed
         write_matlab_camera_params_file( _z.orig_intrinsics,
@@ -1472,7 +1809,7 @@ optimization_params optimizer::back_tracking_line_search( optimization_params co
            && abs( step_size ) > _params.min_step_size
            && iter_count++ < _params.max_back_track_iters )
     {
-        AC_LOG( DEBUG, "    back tracking line search cost= " << AC_D_PREC << new_params.cost );
+        //AC_LOG( DEBUG, "    back tracking line search cost= " << AC_D_PREC << new_params.cost );
         step_size = _params.tau * step_size;
 
         new_params.curr_p_mat = curr_params.curr_p_mat + unit_grad * step_size;
@@ -1522,6 +1859,46 @@ void optimizer::set_cycle_data(const std::vector<double3>& vertices,
     _dsm_params_cand_from_bin = dsm_params_cand;
 }
 
+void optimizer::adjust_params_to_apd_gain()
+{
+    if(_settings.ambient == RS2_AMBIENT_LIGHT_NO_AMBIENT) // long preset
+        _params.saturation_value = 230;
+    else if(_settings.ambient == RS2_AMBIENT_LIGHT_LOW_AMBIENT) // short preset
+        _params.saturation_value = 250;
+    else
+        throw std::runtime_error( to_string() <<_settings.ambient <<" invalid ambient value");
+}
+
+void optimizer::adjust_params_to_manual_mode()
+{
+    _params.max_global_los_scaling_step = 0.005;
+    _params.pix_per_section_depth_th = 0.01;
+    _params.pix_per_section_rgb_th = 0.01;
+    _params.min_section_with_enough_edges = 2;
+    _params.edges_per_direction_ratio_th = 0.004;
+    _params.minimal_full_directions = 2;
+
+    const static double newvals[N_BASIC_DIRECTIONS] = { 0.09,0.09,0.09,0.09 };
+    std::copy(std::begin(newvals), std::end(newvals), std::begin(_params.dir_std_th));
+    _params.saturation_ratio_th = 0.15;
+    adjust_params_to_apd_gain();
+}
+
+void optimizer::adjust_params_to_auto_mode()
+{
+    _params.max_global_los_scaling_step = 0.004;
+    _params.pix_per_section_depth_th = 0.01;
+    _params.pix_per_section_rgb_th = 0.02;
+    _params.min_section_with_enough_edges = 2;
+    _params.edges_per_direction_ratio_th = 0.004;
+    _params.minimal_full_directions = 2;
+
+    const static double newvals[N_BASIC_DIRECTIONS] = { 0.09,0.09,0.09,0.09 };
+    std::copy(std::begin(newvals), std::end(newvals), std::begin(_params.dir_std_th));
+    _params.saturation_ratio_th = 0.05;
+    adjust_params_to_apd_gain();
+}
+
 size_t optimizer::optimize_p
 (
     const optimization_params& params_curr,
@@ -1531,37 +1908,42 @@ size_t optimizer::optimize_p
     calib& new_rgb_calib_for_k_to_dsm,
     rs2_intrinsics_double& new_z_k,
     std::function<void(data_collect const&data)> cb,
-    data_collect* data 
-)
+    data_collect& data )
 {
-
+    // The params_curr that we get contains a cost and p_matrix that do not match:
+    // The cost is the optimal cost calculated in the previous cycle, but we don't use it here.
+    // The p_matrix is the optimal p_matrix that has been modified (see the end of this function).
+    // Between the previous cycle and now we have new vertices so we recalculate a new cost based
+    // on the modified p_matrix and the new vertices
     size_t n_iterations = 0;
     auto curr = params_curr;
     while (1)
     {
 
-        auto res = calc_cost_and_grad(_z, new_vertices, _yuy, new_rgb_calib_for_k_to_dsm, curr.curr_p_mat, data);
+        auto res = calc_cost_and_grad(_z, new_vertices, _yuy, new_rgb_calib_for_k_to_dsm, curr.curr_p_mat, &data);
         curr.cost = res.first;
         curr.calib_gradients = res.second;
         AC_LOG( DEBUG, std::setw( 3 ) << std::right << n_iterations << std::left
                            << " cost= " << AC_D_PREC << curr.cost );
 
-        if (data)
+        data.iteration_data_p.iteration = n_iterations;
+        if( _debug_mode )
         {
-            data->type = iteration_data;
-            data->iteration_data_p.iteration = n_iterations;
-            data->iteration_data_p.params = curr;
-            data->iteration_data_p.c = new_rgb_calib_for_k_to_dsm;
-            data->iteration_data_p.iteration = n_iterations;
+            
+            data.iteration_data_p.params = curr;
+            data.iteration_data_p.c = new_rgb_calib_for_k_to_dsm;
+            data.iteration_data_p.iteration = n_iterations;
         }
 
-        params_new = back_tracking_line_search(curr, new_vertices, data);
+        params_new = back_tracking_line_search( curr, new_vertices, &data );
         
-        if (data)
-            data->iteration_data_p.next_params = params_new;
+        if( _debug_mode )
+            data.iteration_data_p.next_params = params_new;
+
+        data.type = _debug_mode ? iteration_data : general_data;
+        if( cb )
+            cb(data);
 
-        if (cb)
-            cb(*data);
 
         auto norm = (params_new.curr_p_mat - curr.curr_p_mat).get_norma();
         if (norm < _params.min_rgb_mat_delta)
@@ -1571,7 +1953,7 @@ size_t optimizer::optimize_p
         }
 
         auto delta = params_new.cost - curr.cost;
-        AC_LOG( DEBUG, "    delta= " << AC_D_PREC << delta );
+        //AC_LOG( DEBUG, "    delta= " << AC_D_PREC << delta );
         delta = abs(delta);
         if (delta < _params.min_cost_delta)
         {
@@ -1590,18 +1972,16 @@ size_t optimizer::optimize_p
     }
 
     AC_LOG( DEBUG,
-            "    cycle " << data->cycle_data_p.cycle << " finished after " << n_iterations << " iterations; cost "
+            "    optimize_p finished after " << n_iterations << " iterations; cost "
                          << AC_D_PREC << params_curr.cost << "  -->  " << params_new.cost );
     new_rgb_calib_for_k_to_dsm = optimaized_calibration = decompose_p_mat(params_new.curr_p_mat);
 
-    auto orig_rgb_calib = decompose_p_mat(params_curr.curr_p_mat);
-    new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[1] = 0;
+    new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[1] = 0; //sheer
 
-    new_z_k = get_new_z_intrinsics_from_new_calib(_z.orig_intrinsics, new_rgb_calib_for_k_to_dsm, orig_rgb_calib);
+    new_z_k = get_new_z_intrinsics_from_new_calib(_z.orig_intrinsics, new_rgb_calib_for_k_to_dsm, _original_calibration);
     new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[0] = _original_calibration.k_mat.get_fx();
     new_rgb_calib_for_k_to_dsm.k_mat.k_mat.rot[4] = _original_calibration.k_mat.get_fy();
     params_new.curr_p_mat = new_rgb_calib_for_k_to_dsm.calc_p_mat();
-    new_rgb_calib_for_k_to_dsm = decompose_p_mat(params_new.curr_p_mat);
 
     return n_iterations;
 }
@@ -1610,7 +1990,6 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
 {
     optimization_params params_orig;
     params_orig.curr_p_mat = _original_calibration.calc_p_mat();
-    _original_calibration = decompose(params_orig.curr_p_mat, _original_calibration);
     _params_curr = params_orig;
 
     data_collect data;
@@ -1618,7 +1997,13 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
     auto cycle = 1;
     data.cycle_data_p.cycle = cycle;
 
-    auto res = calc_cost_and_grad(_z, _z.vertices, _yuy, decompose(_params_curr.curr_p_mat, _original_calibration), _params_curr.curr_p_mat, &data);
+    auto res = calc_cost_and_grad( _z,
+                                   _z.vertices,
+                                   _yuy,
+                                   decompose( _params_curr.curr_p_mat, _original_calibration ),
+                                   _params_curr.curr_p_mat,
+                                   _debug_mode? &data: nullptr );
+
     _params_curr.cost = res.first;
     _params_curr.calib_gradients = res.second;
     params_orig.cost = res.first;
@@ -1632,12 +2017,19 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
 
     double last_cost = _params_curr.cost;
     
-    auto n_iterations = optimize_p(_params_curr, new_vertices, new_params, _optimaized_calibration, new_calib, new_k_depth, cb, &data);
+    auto n_iterations = optimize_p( _params_curr,
+                                    new_vertices,
+                                    new_params,
+                                    _optimaized_calibration,
+                                    new_calib,
+                                    new_k_depth,
+                                    cb,
+                                    data );
 
     _z.orig_vertices = _z.vertices;
     rs2_dsm_params_double new_dsm_params = _z.orig_dsm_params;
 
-    while (cycle < _params.max_K2DSM_iters)
+    while (cycle-1 < _params.max_K2DSM_iters)
     {
         std::vector<double3> cand_vertices = _z.vertices;
         auto dsm_regs_cand = new_dsm_regs;
@@ -1648,20 +2040,29 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
         calib optimaized_calib_candidate = _optimaized_calibration;
         rs2_intrinsics_double k_depth_candidate = new_k_depth;
 
-        data.cycle_data_p.cycle = ++cycle;
-        data.cycle_data_p.new_calib = new_calib;
-        data.cycle_data_p.new_k_depth = new_k_depth;
-        data.cycle_data_p.new_params = new_params;
-        data.cycle_data_p.new_dsm_params = new_dsm_params;
-        data.cycle_data_p.new_dsm_regs = new_dsm_regs;
-        data.cycle_data_p.new_vertices = new_vertices;
-        data.cycle_data_p.optimaized_calib_candidate = optimaized_calib_candidate;
+        ++cycle;
+        data.cycle_data_p.cycle = cycle;
 
-        if (cb)
+        if (_debug_mode)
         {
-            data.type = cycle_data;
-            cb(data);
+            data.cycle_data_p.new_calib = new_calib;
+            data.cycle_data_p.new_k_depth = new_k_depth;
+            data.cycle_data_p.new_params = new_params;
+            data.cycle_data_p.new_dsm_params = new_dsm_params;
+            data.cycle_data_p.new_dsm_regs = new_dsm_regs;
+            data.cycle_data_p.new_vertices = new_vertices;
+            data.cycle_data_p.optimaized_calib_candidate = optimaized_calib_candidate;
+
         }
+       
+        if( cb )
+        {
+            data.type = _debug_mode ? cycle_data : general_data;
+            cb( data );
+        }
+
+        AC_LOG(INFO, "CYCLE " << data.cycle_data_p.cycle << " started with: cost = " << AC_D_PREC << new_params.cost);
+
 
         if (get_cycle_data_from_bin)
         {
@@ -1672,23 +2073,40 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
             new_dsm_params = _dsm_params_cand_from_bin;
         }
 
-        auto dsm_candidate = _k_to_DSM->convert_new_k_to_DSM(_z.orig_intrinsics, new_k_depth, _z, cand_vertices, new_dsm_params, dsm_regs_cand, &data);
-        data.type = cycle_data;
+        auto dsm_candidate = _k_to_DSM->convert_new_k_to_DSM( _z.orig_intrinsics,
+                                                              new_k_depth,
+                                                              _z,
+                                                              cand_vertices,
+                                                              new_dsm_params,
+                                                              dsm_regs_cand,
+                                                              _debug_mode ? &data : nullptr );
+        //data.type = cycle_data;
 
         //this calib is now candidate to be the optimaized we can confirm it only after running more optimize_p
         calib_k_to_dsm_candidate = calib_candidate;
 
-        data.k2dsm_data_p.dsm_params_cand = dsm_candidate;
-        data.k2dsm_data_p.vertices = cand_vertices;
-        data.k2dsm_data_p.dsm_pre_process_data = _k_to_DSM->get_pre_process_data();
-
-        if (cb)
+        if (_debug_mode)
         {
-            data.type = k_to_dsm_data;
-            cb(data);
+            data.k2dsm_data_p.dsm_params_cand = dsm_candidate;
+            data.k2dsm_data_p.vertices = cand_vertices;
+            data.k2dsm_data_p.dsm_pre_process_data = _k_to_DSM->get_pre_process_data();
+
+            if( cb )
+            {
+                 data.type = k_to_dsm_data;
+                 cb(data);
+            }
         }
+     
 
-        optimize_p(new_params, cand_vertices, params_candidate, optimaized_calib_candidate, calib_candidate, k_depth_candidate, cb, &data);
+        optimize_p( new_params,
+                    cand_vertices,
+                    params_candidate,
+                    optimaized_calib_candidate,
+                    calib_candidate,
+                    k_depth_candidate,
+                    cb,
+                    data );
 
         if( params_candidate.cost < last_cost )
         {
@@ -1714,7 +2132,6 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
         new_vertices = cand_vertices;
         _z.vertices = new_vertices;
         _optimaized_calibration = optimaized_calib_candidate;
-        AC_LOG(INFO, "CYCLE " << data.cycle_data_p.cycle << ": cost = " << AC_D_PREC << new_params.cost);
     }
    
     AC_LOG( INFO,
@@ -1724,6 +2141,8 @@ size_t optimizer::optimize( std::function< void( data_collect const & data ) > c
     _final_dsm_params = _z.orig_dsm_params;
     clip_ac_scaling( _z.orig_dsm_params, new_dsm_params );
     new_dsm_params.copy_to( _final_dsm_params );
+    _final_dsm_params.temp_x2 = byte( _settings.hum_temp * 2 );
+
     _final_calibration = new_k_to_dsm_calib;
 
     // The actual valid cycles - we starting from 1 and the last cycle is only for verification
diff --git a/src/algo/depth-to-rgb-calibration/optimizer.h b/src/algo/depth-to-rgb-calibration/optimizer.h
index 096e0bd..0390188 100644
--- a/src/algo/depth-to-rgb-calibration/optimizer.h
+++ b/src/algo/depth-to-rgb-calibration/optimizer.h
@@ -18,7 +18,6 @@ namespace librealsense {
 namespace algo {
 namespace depth_to_rgb_calibration {
 
-
     struct optimization_params
     {
         p_matrix curr_p_mat;
@@ -31,7 +30,7 @@ namespace depth_to_rgb_calibration {
     {
         params();
 
-        void set_depth_resolution(size_t width, size_t height);
+        void set_depth_resolution(size_t width, size_t height, rs2_ambient_light ambient);
         void set_rgb_resolution(size_t width, size_t height);
 
         double gamma = 0.9;
@@ -42,6 +41,12 @@ namespace depth_to_rgb_calibration {
         double grad_z_max = 1000;
         double edge_thresh4_logic_lum = 0.1;
 
+        // enhanced preprocessing params
+        double grad_ir_low_th = std::numeric_limits<double>::max();
+        double grad_ir_high_th = 2.5;
+        double grad_z_low_th = 0;
+        double grad_z_high_th = std::numeric_limits<double>::max();
+
         double max_step_size = 1;
         double min_step_size = 0.00001;
         double control_param = 0.5;
@@ -50,7 +55,8 @@ namespace depth_to_rgb_calibration {
         double min_rgb_mat_delta = 0.00001;
         double min_cost_delta = 1;
         double tau = 0.5;
-        double min_weighted_edge_per_section = 19.5313;
+        double min_weighted_edge_per_section_depth = 0;      // resolution-dependent
+        double min_weighted_edge_per_section_rgb = 0;        // resolution-dependent
         size_t num_of_sections_for_edge_distribution_x = 2;
         size_t num_of_sections_for_edge_distribution_y = 2;
         p_matrix normalize_mat;  //% rgbPmatNormalizationMat
@@ -58,24 +64,39 @@ namespace depth_to_rgb_calibration {
         double edge_distribution_min_max_ratio = 0.005;
         double grad_dir_ratio = 10;
         double grad_dir_ratio_prep = 1.5;
-        size_t dilation_size = 3;
+        size_t dilation_size = 1;
         double gauss_sigma = 1;
         size_t gause_kernel_size = 5;
-        double move_thresh_pix_val = 20;
-        double move_threshold_pix_num = 62.2080;
+        double const move_thresh_pix_val = 20;
+        double move_threshold_pix_num = 0;                   // resolution-dependent
+        double const move_last_success_thresh_pix_val = 25;
+        double move_last_success_thresh_pix_num = 0;         // resolution-dependent
 
         //smearing
         double max_sub_mm_z = 4;
         double constant_weights = 1000;
 
         // output validation
-        double const max_xy_movement_per_calibration[3] = { 10, 2, 2 };
-        double const max_xy_movement_from_origin = 20;
+        double max_xy_movement_per_calibration[3]; // resolution-dependent = { 10, 2, 2 } * res/hd
+        double max_xy_movement_from_origin;        // resolution-dependent = 20 * res/hd
         double const max_scaling_step = 0.020000000000000;
         double const max_K2DSM_iters = 10;
         // TODO: the following should be 0.2% but was increased to 0.5% to account for
         // manual trigger activation
-        double const max_global_los_scaling_step = 0.005;  // the difference (.5%) between starting and final scale
+        double max_global_los_scaling_step = 0.004;  // the difference (.5%) between starting and final scale
+
+        // input validation
+        double edges_per_direction_ratio_th = 0.004;
+        double dir_std_th[N_BASIC_DIRECTIONS] = { 0.09, 0.09, 0.09, 0.09 };
+        int minimal_full_directions = 2;
+        bool require_orthogonal_valid_dirs = false;
+        int saturation_value = 230;
+        double saturation_ratio_th = 0.05;
+        double pix_per_section_rgb_th = 0.01;
+        double pix_per_section_depth_th = 0.01;
+        int min_section_with_enough_edges = 2;
+
+        bool use_enhanced_preprocessing = true;
     };
     // svm
     struct decision_params
@@ -146,7 +167,8 @@ namespace depth_to_rgb_calibration {
     {
         k_to_dsm_data,
         cycle_data,
-        iteration_data
+        iteration_data,
+        general_data
     };
 
     struct k_to_dsm_inputs
@@ -186,6 +208,7 @@ namespace depth_to_rgb_calibration {
         std::vector <double> sg_mat_tag_x_err_l2;
         std::vector <double> quad_coef;
         double2 focal_scaling;
+        double2 opt_scaling_1;
         double2 opt_scaling;
         double2 new_los_scaling;
         rs2_dsm_params_double dsm_params_cand;
@@ -243,14 +266,37 @@ namespace depth_to_rgb_calibration {
 
     };
 
+    struct input_validity_data
+    {
+        bool edges_dir_spread;
+        bool not_saturated;
+        bool depth_spatial_spread;
+        bool rgb_spatial_spread;
+        bool is_movement_from_last_success;
+    };
 
     class optimizer
     {
     public:
-        optimizer();
+#pragma pack(push, 1)
+        struct settings
+        {
+            bool is_manual_trigger = false;
+            double hum_temp = 0.;
+            rs2_ambient_light ambient = RS2_AMBIENT_LIGHT_NO_AMBIENT;
+            int receiver_gain = 0;  // aka APD
+
+            std::string to_string() const;
+        };
+#pragma pack(pop)
+
+        optimizer( settings const &, bool debug_mode = false );
+
+        void set_yuy_data( std::vector< yuy_t > && yuy_data, 
+            std::vector< yuy_t > && prev_yuy_data,
+            std::vector< yuy_t > && last_successful_yuy_data,
+            calib const & calibration);
 
-        void set_yuy_data( std::vector< yuy_t > && yuy_data, std::vector< yuy_t > && prev_yuy_data,
-                           calib const & calibration );
         void set_ir_data( std::vector< ir_t > && ir_data, size_t width, size_t height );
         void set_z_data( std::vector< z_t > && z_data,
                          rs2_intrinsics_double const & depth_intrinsics,
@@ -262,7 +308,21 @@ namespace depth_to_rgb_calibration {
         void write_data_to( std::string const & directory );
 
         // (optional) Return whether the scene passed in is valid and can go thru optimization
-        bool is_scene_valid();
+        bool is_scene_valid(input_validity_data* data = nullptr);
+
+        // This function checks for specific cases in which we expect poor
+        // performance of the AC2 algorithm.
+        // Covered Cases(By priority) :
+        // 1. Enough Edges in RGB image(Lights off bug fix)
+        // 2. Enough Edges in enough locations(3 / 4 quarters)
+        // 3. Enough Edges in enough directions(2 / 4 directions)
+        // 4. Large enough STD of edges in the chosen direction(weights will be
+        //    normalized by direction)  (Normalize by weights is done in a seperate
+        //    function)
+        // 5. Verify there is movement in RGB between this scene and the previous
+        // 6. Check for saturation in the depth
+        //    one in which we converged
+        bool input_validity_checks(input_validity_data* data = nullptr);
 
         // Optimize the calibration, optionally calling the callback after each iteration
         size_t optimize( std::function< void( data_collect const & data ) >
@@ -301,6 +361,10 @@ namespace depth_to_rgb_calibration {
             const p_matrix& p_mat_opt = p_matrix());
     private:
 
+        void adjust_params_to_manual_mode();
+        void adjust_params_to_auto_mode();
+        void adjust_params_to_apd_gain();
+
         // 1 cycle of optimization
         size_t optimize_p(const optimization_params& params_curr,
             const std::vector<double3>& new_vertices,
@@ -309,18 +373,17 @@ namespace depth_to_rgb_calibration {
             calib& new_rgb_calib_for_k_to_dsm,
             rs2_intrinsics_double& new_z_k,
             std::function<void(data_collect const&data)> cb,
-            data_collect* data);
+            data_collect& data);
 
         calib decompose_p_mat(p_matrix p);
         rs2_intrinsics_double get_new_z_intrinsics_from_new_calib(const rs2_intrinsics_double& orig, const calib & new_c, const calib & orig_c);
-        void zero_invalid_edges( z_frame_data& z_data, ir_frame_data const & ir_data );
         std::vector<direction> get_direction( std::vector<double> gradient_x, std::vector<double> gradient_y );
         std::vector<direction> get_direction2(std::vector<double> gradient_x, std::vector<double> gradient_y);
         std::vector<uint16_t> get_closest_edges( const z_frame_data& z_data, ir_frame_data const & ir_data, size_t width, size_t height );
         std::vector<double> blur_edges( std::vector<double> const & edges, size_t image_width, size_t image_height );
         std::vector< byte > get_luminance_from_yuy2( std::vector< yuy_t > const & yuy2_imagh );
 
-        std::vector<uint8_t> get_logic_edges( std::vector<double> edges );
+        std::vector<uint8_t> get_logic_edges( std::vector<double> const & edges );
         std::vector <double3> subedges2vertices(z_frame_data& z_data, const rs2_intrinsics_double& intrin, double depth_units);
         
         optimization_params back_tracking_line_search( optimization_params const & opt_params,
@@ -328,13 +391,22 @@ namespace depth_to_rgb_calibration {
                                                        data_collect * data = nullptr ) const;
        
         // input validation
-        bool is_movement_in_images(yuy2_frame_data& yuy);
+        bool is_movement_in_images( movement_inputs_for_frame const & prev,
+                                    movement_inputs_for_frame const & curr,
+                                    movement_result_data * result_data,
+                                    double const move_thresh_pix_val,
+                                    double const move_threshold_pix_num,
+                                    size_t width, size_t height );
+
         bool is_edge_distributed( z_frame_data & z_data, yuy2_frame_data & yuy_data );
         void section_per_pixel( frame_data const &, size_t section_w, size_t section_h, byte * section_map );
-        void check_edge_distribution(std::vector<double>& sum_weights_per_section, double& min_max_ratio, bool& is_edge_distributed);
         void sum_per_section(std::vector< double >& sum_weights_per_section, std::vector< byte > const& section_map, std::vector< double > const& weights, size_t num_of_sections);
-        void images_dilation(yuy2_frame_data& yuy);
-        void gaussian_filter(yuy2_frame_data& yuy);
+        std::vector<uint8_t> images_dilation(std::vector<uint8_t> const &logic_edges, size_t width, size_t height);
+        void gaussian_filter(std::vector<uint8_t> const& lum_frame,
+            std::vector<uint8_t> const& prev_lum_frame,
+            std::vector<double>& yuy_diff,
+            std::vector<double>& gaussian_filtered_image,
+            size_t width, size_t height);
 
         // svm
         bool valid_by_svm(svm_model model);
@@ -347,6 +419,7 @@ namespace depth_to_rgb_calibration {
                               rs2_dsm_params_double & ac_data_new ) const;
 
     private:
+        settings const _settings;
         params _params;
         decision_params _decision_params;
         svm_features _svm_features;
@@ -375,6 +448,7 @@ namespace depth_to_rgb_calibration {
         rs2_dsm_params_double _dsm_params_cand_from_bin;
 
         std::shared_ptr<k_to_DSM> _k_to_DSM;
+        bool _debug_mode;
     };
 
 }  // librealsense::algo::depth_to_rgb_calibration
diff --git a/src/algo/depth-to-rgb-calibration/utils.h b/src/algo/depth-to-rgb-calibration/utils.h
index fef3bea..438515f 100644
--- a/src/algo/depth-to-rgb-calibration/utils.h
+++ b/src/algo/depth-to-rgb-calibration/utils.h
@@ -28,6 +28,10 @@ namespace depth_to_rgb_calibration {
 
     double3x3 cholesky3x3( double3x3 const & mat );
 
+    // Check that the DSM parameters given do not exceed certain boundaries, and
+    // throw invalid_value_exception if they do.
+    void validate_dsm_params( struct rs2_dsm_params const & dsm_params );
+
 }
 }
 }
diff --git a/src/algo/depth-to-rgb-calibration/valid-results.cpp b/src/algo/depth-to-rgb-calibration/valid-results.cpp
index 8281817..42b1b9c 100644
--- a/src/algo/depth-to-rgb-calibration/valid-results.cpp
+++ b/src/algo/depth-to-rgb-calibration/valid-results.cpp
@@ -3,6 +3,7 @@
 
 #include "optimizer.h"
 #include "cost.h"
+#include "utils.h"
 #include "debug.h"
 
 using namespace librealsense::algo::depth_to_rgb_calibration;
@@ -146,10 +147,11 @@ void optimizer::clip_ac_scaling( rs2_dsm_params_double const & ac_data_in,
                                        / abs( ac_data_new.h_scale - ac_data_in.h_scale )
                                        * _params.max_global_los_scaling_step;
         AC_LOG( DEBUG,
-                "    H scale delta ("
-                    << AC_D_PREC << abs( ac_data_in.h_scale - ac_data_new.h_scale )
-                    << " > max global LoS scaling per step (" << _params.max_global_los_scaling_step
-                    << "); clipping to " << new_h_scale );
+                "    " << AC_D_PREC << "H scale {new}" << ac_data_new.h_scale
+                       << " is not within {step}"
+                       << std::string( to_string() << _params.max_global_los_scaling_step )
+                       << " of {old}" << ac_data_in.h_scale << "; clipping to {final}"
+                       << new_h_scale << " [CLIP-H]" );
         ac_data_new.h_scale = new_h_scale;
     }
     if( abs( ac_data_in.v_scale - ac_data_new.v_scale ) > _params.max_global_los_scaling_step )
@@ -159,10 +161,11 @@ void optimizer::clip_ac_scaling( rs2_dsm_params_double const & ac_data_in,
                                        / abs( ac_data_new.v_scale - ac_data_in.v_scale )
                                        * _params.max_global_los_scaling_step;
         AC_LOG( DEBUG,
-                "    V scale delta ("
-                    << AC_D_PREC << abs( ac_data_in.v_scale - ac_data_new.v_scale )
-                    << " > max global LoS scaling per step (" << _params.max_global_los_scaling_step
-                    << "); clipping to " << new_v_scale );
+                "    " << AC_D_PREC << "V scale {new}" << ac_data_new.v_scale
+                       << " is not within {step}"
+                       << std::string( to_string() << _params.max_global_los_scaling_step )
+                       << " of {old}" << ac_data_in.v_scale << "; clipping to {final}"
+                       << new_v_scale << " [CLIP-V]" );
         ac_data_new.v_scale = new_v_scale;
     }
 }
@@ -324,6 +327,7 @@ bool optimizer::valid_by_svm(svm_model model)
     case gaussian:
         is_valid = svm_rbf_predictor(_extracted_features, _svm_model_gaussian);
         break;
+
     default:
         AC_LOG(DEBUG, "ERROR : Unknown SVM kernel " << model);
         break;
@@ -343,7 +347,6 @@ bool optimizer::is_valid_results()
     }
 
 
-    bool res = true;
     // Clip any (average) movement of pixels if it's too big
     clip_pixel_movement();
 
@@ -352,7 +355,7 @@ bool optimizer::is_valid_results()
     if( _factory_calibration.width  &&  _factory_calibration.height )
     {
         double xy_movement = calc_correction_in_pixels(_final_calibration);
-        AC_LOG( DEBUG, "... average pixel movement from factory calibration= " << xy_movement );
+        AC_LOG( DEBUG, "    average pixel movement from factory calibration= " << xy_movement );
         if( xy_movement > _params.max_xy_movement_from_origin )
         {
             AC_LOG( ERROR, "Calibration has moved too far from the original factory calibration (" << xy_movement << " pixels)" );
@@ -361,7 +364,7 @@ bool optimizer::is_valid_results()
     }
     else
     {
-        AC_LOG( DEBUG, "... no factory calibration available; skipping distance check" );
+        AC_LOG( DEBUG, "    no factory calibration available; skipping distance check" );
     }
 
     /* %% Check and see that the score didn't increased by a lot in one image section and decreased in the others
@@ -379,19 +382,60 @@ bool optimizer::is_valid_results()
         = *std::min_element( _z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end() );
     double max_cost_diff
         = *std::max_element( _z.cost_diff_per_section.begin(), _z.cost_diff_per_section.end() );
-    AC_LOG( DEBUG, "... min cost diff= " << min_cost_diff << "  max= " << max_cost_diff );
-    if( min_cost_diff < 0. )
+    AC_LOG( DEBUG, "    min cost diff= " << min_cost_diff << "  max= " << max_cost_diff );
+
+    bool res_svm = valid_by_svm( linear );  //(gaussian);
+    if( ! res_svm )
+        return false;
+
+#if 0
+    try
     {
-        AC_LOG( ERROR,
-                "Some image sections were hurt by the optimization; invalidating calibration!" );
-        for( size_t x = 0; x < _z.cost_diff_per_section.size(); ++x )
-            AC_LOG( DEBUG,
-                    "... cost diff in section " << x << "= " << _z.cost_diff_per_section[x] );
-        // return false;
-        res = false;
+        validate_dsm_params( get_dsm_params() );
     }
+    catch( invalid_value_exception const & e )
+    {
+        AC_LOG( ERROR, "Result DSM parameters are invalid: " << e.what() );
+        return false;
+    }
+#endif
 
-    bool res_svm = valid_by_svm( linear );  //(gaussian);
-    return ( res && res_svm );
+    return true;
+}
+
+
+void librealsense::algo::depth_to_rgb_calibration::validate_dsm_params(
+    rs2_dsm_params const & dsm_params )
+{
+    /*  Considerable values for DSM correction:
+        - h/vFactor: 0.98-1.02, representing up to 2% change in FOV.
+        - h/vOffset:
+            - Under AOT model: (-2)-2, representing up to 2deg FOV tilt
+            - Under TOA model: (-125)-125, representing up to approximately
+              2deg FOV tilt
+        These values are extreme. For more reasonable values take 0.99-1.01
+        for h/vFactor and divide the suggested h/vOffset range by 10.
+
+        Update ww30: +/-1.5% limiter both H/V [0.985..1.015] until AC3.
+        Update ww33: vFactor for all 60 cocktail 1500h units is in the range
+                     of 1.000-1.015; changing to [0.995-1.015]
+    */
+    std::string error;
+    
+    if( dsm_params.model != RS2_DSM_CORRECTION_AOT )
+        error += to_string() << " {mode}" << +dsm_params.model << " must be AOT";
+
+    if( dsm_params.h_scale < 0.985 || dsm_params.h_scale > 1.015 )
+        error += to_string() << " {H-scale}" << dsm_params.h_scale << " exceeds 1.5% change";
+    if( dsm_params.v_scale < 0.995 || dsm_params.v_scale > 1.015 )
+        error += to_string() << " {V-scale}" << dsm_params.v_scale << " exceeds [-0.5%-1.5%]";
+
+    if( dsm_params.h_offset < -2. || dsm_params.h_offset > 2. )
+        error += to_string() << " {H-offset}" << dsm_params.h_offset << " is limited to 2 degrees";
+    if( dsm_params.v_offset < -2. || dsm_params.v_offset > 2. )
+        error += to_string() << " {V-offset}" << dsm_params.v_offset << " is limited to 2 degrees";
+
+    if( ! error.empty() )
+        throw invalid_value_exception( "invalid DSM:" + error + " [LIMIT]" );
 }
 
diff --git a/src/algo/depth-to-rgb-calibration/valid-scene.cpp b/src/algo/depth-to-rgb-calibration/valid-scene.cpp
index 2ac5084..eec3cac 100644
--- a/src/algo/depth-to-rgb-calibration/valid-scene.cpp
+++ b/src/algo/depth-to-rgb-calibration/valid-scene.cpp
@@ -1,4 +1,4 @@
-//// License: Apache 2.0. See LICENSE file in root directory.
+﻿//// License: Apache 2.0. See LICENSE file in root directory.
 //// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
 
 #include "optimizer.h"
@@ -9,7 +9,7 @@
 #include "cost.h"
 #include "debug.h"
 #include <math.h>
-
+#include <numeric>
 
 #define GAUSS_CONV_ROWS 4
 #define GAUSS_CONV_COLUMNS 4
@@ -18,6 +18,7 @@
 using namespace librealsense::algo::depth_to_rgb_calibration;
 using librealsense::to_string;
 
+
 template<class T>
 std::vector<double> gauss_convolution(std::vector<T> const& image,
     size_t image_width, size_t image_height,
@@ -27,7 +28,7 @@ std::vector<double> gauss_convolution(std::vector<T> const& image,
 {
     // boundaries handling 
     // Extend - The nearest border pixels are conceptually extended as far as necessary to provide values for the convolution.
-    // Corner pixels are extended in 90 wedges.Other edge pixels are extended in lines.
+    // Corner pixels are extended in 90° wedges.Other edge pixels are extended in lines.
     // https://en.wikipedia.org/wiki/Kernel_(image_processing)
     // handling order:
     // 1. rows: 0,1 and image_height-1, image_height-2
@@ -186,6 +187,8 @@ std::vector<double> gauss_convolution(std::vector<T> const& image,
     }
     return res;
 }
+
+
 template<class T>
 std::vector<uint8_t> dilation_convolution(std::vector<T> const& image,
     size_t image_width, size_t image_height,
@@ -278,11 +281,12 @@ std::vector<uint8_t> dilation_convolution(std::vector<T> const& image,
     }
     return res;
 }
-void optimizer::check_edge_distribution(
-    std::vector<double>& sum_weights_per_section,
-    double& min_max_ratio,
-    bool& is_edge_distributed
-    )
+
+
+static bool check_edge_distribution( std::vector< double > & sum_weights_per_section,
+                                     double const min_min_max_ratio,
+                                     double const min_weighted_edge_per_section,
+                                     double & min_max_ratio )
 {
     /*minMaxRatio = min(sumWeightsPerSection)/max(sumWeightsPerSection);
       if minMaxRatio < params.edgeDistributMinMaxRatio
@@ -290,17 +294,19 @@ void optimizer::check_edge_distribution(
           fprintf('isEdgeDistributed: Ratio between min and max is too small: %0.5f, threshold is %0.5f\n',minMaxRatio, params.edgeDistributMinMaxRatio);
           return;
       end*/
-    is_edge_distributed = true;
 
     double z_max = *std::max_element(sum_weights_per_section.begin(), sum_weights_per_section.end());
     double z_min = *std::min_element(sum_weights_per_section.begin(), sum_weights_per_section.end());
     min_max_ratio = z_min / z_max;
-    if (min_max_ratio < _params.edge_distribution_min_max_ratio)
+    if( min_max_ratio < min_min_max_ratio )
     {
-        is_edge_distributed = false;
-        AC_LOG(ERROR, "Edge distribution ratio ({min}" << z_min << "/" << z_max << "{max} = " << min_max_ratio << ") is too small; threshold= " << _params.edge_distribution_min_max_ratio);
-        return;
+        AC_LOG( DEBUG,
+                "Edge distribution ratio ({min}"
+                    << z_min << "/" << z_max << "{max} = " << min_max_ratio
+                    << ") is too small; minimum= " << min_min_max_ratio );
+        return false;
     }
+
     /*if any(sumWeightsPerSection< params.minWeightedEdgePerSection)
     isDistributed = false;
     printVals = num2str(sumWeightsPerSection(1));
@@ -310,31 +316,32 @@ void optimizer::check_edge_distribution(
     disp(['isEdgeDistributed: weighted edge per section is too low: ' printVals ', threshold is ' num2str(params.minWeightedEdgePerSection)]);
     return;
 end*/
-    for (auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it)
+    bool is_edge_distributed = true;
+    for( auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it )
     {
-        if (*it < _params.min_weighted_edge_per_section)
+        if( *it < min_weighted_edge_per_section )
         {
             is_edge_distributed = false;
             break;
         }
     }
-    if (!is_edge_distributed) {
-        AC_LOG(DEBUG, "check_edge_distribution: weighted edge per section is too low:  ");
-        for (auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it)
-        {
-            AC_LOG(DEBUG, "    " << *it);
-        }
-        AC_LOG(DEBUG, "threshold is: " << _params.min_weighted_edge_per_section);
-        return;
+    if( ! is_edge_distributed )
+    {
+        AC_LOG( DEBUG, "check_edge_distribution: weighted edge per section is too low:  " );
+        for( auto it = sum_weights_per_section.begin(); it != sum_weights_per_section.end(); ++it )
+            AC_LOG( DEBUG, "    " << *it );
+        AC_LOG( DEBUG, "threshold is: " << min_weighted_edge_per_section );
     }
-    
+    return is_edge_distributed;
 }
-bool optimizer::is_edge_distributed(z_frame_data& z, yuy2_frame_data& yuy)
+
+
+bool optimizer::is_edge_distributed( z_frame_data & z, yuy2_frame_data & yuy )
 {
     size_t num_of_sections = _params.num_of_sections_for_edge_distribution_x * _params.num_of_sections_for_edge_distribution_y;
 
     // depth frame
-    AC_LOG(DEBUG, "... checking Z edge distribution");
+    AC_LOG(DEBUG, "    checking Z edge distribution");
     sum_per_section(z.sum_weights_per_section, z.section_map, z.weights, num_of_sections);
     //for debug 
     auto it = z.sum_weights_per_section.begin();
@@ -342,17 +349,32 @@ bool optimizer::is_edge_distributed(z_frame_data& z, yuy2_frame_data& yuy)
     AC_LOG(DEBUG, "    sum_per_section(z), section #1  " << *(it + 2));
     AC_LOG(DEBUG, "    sum_per_section(z), section #2  " << *(it + 1));
     AC_LOG(DEBUG, "    sum_per_section(z), section #3  " << *(it + 3));
-    check_edge_distribution(z.sum_weights_per_section, z.min_max_ratio, z.is_edge_distributed);
+    z.is_edge_distributed = check_edge_distribution( z.sum_weights_per_section,
+                                                     _params.edge_distribution_min_max_ratio,
+                                                     _params.min_weighted_edge_per_section_depth,
+                                                     z.min_max_ratio );
+
     // yuy frame
-    AC_LOG(DEBUG, "... checking YUY edge distribution");
-    sum_per_section(yuy.sum_weights_per_section, yuy.section_map, yuy.edges_IDT, num_of_sections);
+    AC_LOG(DEBUG, "    checking YUY edge distribution");
+
+    // Get a map for each pixel to its corresponding section
+    std::vector< byte > section_map_rgb( _yuy.width * _yuy.height );
+    section_per_pixel( _yuy,
+                       _params.num_of_sections_for_edge_distribution_x,  //% params.numSectionsH
+                       _params.num_of_sections_for_edge_distribution_y,  //% params.numSectionsV
+                       section_map_rgb.data() );
+
+    sum_per_section( yuy.sum_weights_per_section, section_map_rgb, yuy.edges_IDT, num_of_sections );
     //for debug 
     it = yuy.sum_weights_per_section.begin();
     AC_LOG(DEBUG, "    sum_per_section(yuy), section #0  " << *(it));
     AC_LOG(DEBUG, "    sum_per_section(yuy), section #1  " << *(it + 2));
     AC_LOG(DEBUG, "    sum_per_section(yuy), section #2  " << *(it + 1));
     AC_LOG(DEBUG, "    sum_per_section(yuy), section #3  " << *(it + 3));
-    check_edge_distribution(yuy.sum_weights_per_section, yuy.min_max_ratio, yuy.is_edge_distributed);
+    yuy.is_edge_distributed = check_edge_distribution( yuy.sum_weights_per_section,
+                                                       _params.edge_distribution_min_max_ratio,
+                                                       _params.min_weighted_edge_per_section_rgb,
+                                                       yuy.min_max_ratio );
 
     return  (z.is_edge_distributed && yuy.is_edge_distributed);
 }
@@ -432,14 +454,14 @@ static bool is_grad_dir_balanced( std::vector< double > const & weights,
         if( perp_ratio > _params.grad_dir_ratio_prep )
         {
             AC_LOG( DEBUG,
-                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                    "    gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
                                                                 << _params.grad_dir_ratio );
             return false;
         }
         if( min_val_perp < 1e-3 )  // % Don't devide by zero...
         {
             AC_LOG( DEBUG,
-                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                    "    gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
                                                                 << _params.grad_dir_ratio );
             return false;
         }
@@ -450,7 +472,7 @@ static bool is_grad_dir_balanced( std::vector< double > const & weights,
         if( dir_ratio2 > _params.grad_dir_ratio )
         {
             AC_LOG( DEBUG,
-                    "... gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
+                    "    gradient direction is not balanced : " << dir_ratio1 << "; threshold is: "
                                                                 << _params.grad_dir_ratio );
             return false;
         }
@@ -458,12 +480,11 @@ static bool is_grad_dir_balanced( std::vector< double > const & weights,
     return true;
 }
 
-void optimizer::section_per_pixel(
-    frame_data const& f,
-    size_t const section_w,
-    size_t const section_h,
-    byte* const section_map
-    )
+
+void optimizer::section_per_pixel( frame_data const & f,
+                                   size_t const section_w,
+                                   size_t const section_h,
+                                   byte * const section_map )
 {
     //% [gridX,gridY] = meshgrid(0:res(2)-1,0:res(1)-1);
     //% gridX = floor(gridX/res(2)*params.numSectionsH);
@@ -493,6 +514,7 @@ void optimizer::section_per_pixel(
     }
 }
 
+
 template<class T>
 uint8_t dilation_calc(std::vector<T> const& sub_image, std::vector<uint8_t> const& mask)
 {
@@ -505,17 +527,27 @@ uint8_t dilation_calc(std::vector<T> const& sub_image, std::vector<uint8_t> cons
 
     return res;
 }
-void optimizer::images_dilation(yuy2_frame_data& yuy)
-{
-    auto area = yuy.height * yuy.width;
-    std::vector<uint8_t> dilation_mask = { 1, 1, 1,
-                                              1,  1,  1,
-                                              1,  1,  1 };
 
-    yuy.dilated_image = dilation_convolution<uint8_t>(yuy.prev_logic_edges, yuy.width, yuy.height, _params.dilation_size, _params.dilation_size, [&](std::vector<uint8_t> const& sub_image)
-        {return dilation_calc(sub_image, dilation_mask); });
 
+std::vector< uint8_t > optimizer::images_dilation( std::vector< uint8_t > const & logic_edges,
+                                                   size_t width,
+                                                   size_t height )
+{
+    if( _params.dilation_size == 1 )
+       return logic_edges;
+
+    std::vector< uint8_t > dilation_mask = { 1, 1, 1, 1, 1, 1, 1, 1, 1 };
+    return dilation_convolution< uint8_t >( logic_edges,
+                                            width,
+                                            height,
+                                            _params.dilation_size,
+                                            _params.dilation_size,
+                                            [&]( std::vector< uint8_t > const & sub_image ) {
+                                                return dilation_calc( sub_image, dilation_mask );
+                                            } );
 }
+
+
 template<class T>
 double gaussian_calc(std::vector<T> const& sub_image, std::vector<double> const& mask)
 {
@@ -529,69 +561,101 @@ double gaussian_calc(std::vector<T> const& sub_image, std::vector<double> const&
     return res;
 }
 
-void optimizer::gaussian_filter(yuy2_frame_data& yuy)
+
+void optimizer::gaussian_filter( std::vector< uint8_t > const & lum_frame,
+                                 std::vector< uint8_t > const & prev_lum_frame,
+                                 std::vector< double > & yuy_diff,
+                                 std::vector< double > & gaussian_filtered_image,
+                                 size_t width,
+                                 size_t height )
 {
-    auto area = yuy.height * yuy.width;
+
+    auto area = height *width;
 
     /* diffIm = abs(im1-im2);
 diffIm = imgaussfilt(im1-im2,params.moveGaussSigma);*/
     // use this matlab function to get gauss kernel with sigma=1: disp17(fspecial('gaussian',5,1))
-    std::vector<double>  gaussian_kernel = { 0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651, 0.0029690167439504968,
-        0.013306209891013651, 0.059634295436180138, 0.098320331348845769, 0.059634295436180138, 0.013306209891013651,
-        0.021938231279714643, 0.098320331348845769, 0.16210282163712664, 0.098320331348845769, 0.021938231279714643,
-        0.013306209891013651, 0.059634295436180138, 0.098320331348845769, 0.059634295436180138, 0.013306209891013651,
-        0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651, 0.0029690167439504968
-    };
-
-    std::vector<uint8_t>::iterator yuy_iter = yuy.lum_frame.begin();
-    std::vector<uint8_t>::iterator yuy_prev_iter = yuy.prev_lum_frame.begin();
+    std::vector< double > gaussian_kernel
+        = { 0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651,
+            0.0029690167439504968, 0.013306209891013651, 0.059634295436180138, 0.098320331348845769,
+            0.059634295436180138,  0.013306209891013651, 0.021938231279714643, 0.098320331348845769,
+            0.16210282163712664,   0.098320331348845769, 0.021938231279714643, 0.013306209891013651,
+            0.059634295436180138,  0.098320331348845769, 0.059634295436180138, 0.013306209891013651,
+            0.0029690167439504968, 0.013306209891013651, 0.021938231279714643, 0.013306209891013651,
+            0.0029690167439504968 };
+
+    auto yuy_iter = lum_frame.begin();
+    auto yuy_prev_iter = prev_lum_frame.begin();
     for (auto i = 0; i < area; i++, yuy_iter++, yuy_prev_iter++)
     {
-        yuy.yuy_diff.push_back((double)(*yuy_prev_iter) - (double)(*yuy_iter)); // used for testing only
+        yuy_diff.push_back((double)(*yuy_prev_iter) - (double)(*yuy_iter)); // used for testing only
     }
-    yuy.gaussian_filtered_image = gauss_convolution<double>(yuy.yuy_diff, yuy.width, yuy.height, _params.gause_kernel_size, _params.gause_kernel_size, [&](std::vector<double> const& sub_image)
-        {return gaussian_calc(sub_image, gaussian_kernel); });
-    return;
+    gaussian_filtered_image
+        = gauss_convolution< double >( yuy_diff,
+                                       width,
+                                       height,
+                                       _params.gause_kernel_size,
+                                       _params.gause_kernel_size,
+                                       [&]( std::vector< double > const & sub_image ) {
+                                           return gaussian_calc( sub_image, gaussian_kernel );
+                                       } );
 }
-void abs_values(std::vector< double >& vec_in)
+
+
+static void abs_values( std::vector< double > & vec_in )
 {
-    //std::vector< double > abs_vec_in = vec_in;
-    for (double& val : vec_in)
+    for( double & val : vec_in )
     {
         if (val < 0)
-        {
             val *= -1;
-        }
     }
 }
-void gaussian_dilation_mask(std::vector< double >& gauss_diff, std::vector< uint8_t >& dilation_mask)
+
+
+static void gaussian_dilation_mask( std::vector< double > & gauss_diff,
+                                    std::vector< uint8_t > const & dilation_mask )
 {
     auto gauss_it = gauss_diff.begin();
     auto dilation_it = dilation_mask.begin();
-    for (auto i = 0; i < gauss_diff.size(); i++, gauss_it++, dilation_it++)
+    for( auto i = 0; i < gauss_diff.size(); i++, gauss_it++, dilation_it++ )
     {
-        if (*dilation_it)
-        {
+        if( *dilation_it )
             *gauss_it = 0;
-        }
     }
 }
-void move_suspected_mask(std::vector< uint8_t >& move_suspect, std::vector< double >& gauss_diff_masked, double movement_threshold)
+
+
+static size_t move_suspected_mask( std::vector< uint8_t > & move_suspect,
+                                   std::vector< double > const & gauss_diff_masked,
+                                   double const movement_threshold )
 {
-    for (auto it = gauss_diff_masked.begin(); it != gauss_diff_masked.end(); ++it)
+    move_suspect.reserve( gauss_diff_masked.size() );
+    size_t n_movements = 0;
+    for( auto it = gauss_diff_masked.begin(); it != gauss_diff_masked.end(); ++it )
     {
-        if (*it > movement_threshold)
+        if( *it > movement_threshold )
         {
             move_suspect.push_back(1);
+            ++n_movements;
         }
         else
         {
             move_suspect.push_back(0);
         }
     }
+    return n_movements;
 }
-bool optimizer::is_movement_in_images(yuy2_frame_data& yuy)
+
+
+bool optimizer::is_movement_in_images( movement_inputs_for_frame const & prev,
+                                       movement_inputs_for_frame const & curr,
+                                       movement_result_data * const result_data,
+                                       double const move_thresh_pix_val,
+                                       double const move_threshold_pix_num,
+                                       size_t const width,
+                                       size_t const height )
 {
+
     /*function [isMovement,movingPixels] = isMovementInImages(im1,im2, params)
 isMovement = false;
 
@@ -601,83 +665,299 @@ SE = strel('square', params.seSize);
 dilatedIm = imdilate(logicEdges,SE);
 diffIm = imgaussfilt(double(im1)-double(im2),params.moveGaussSigma);
 */
-    yuy.prev_logic_edges = get_logic_edges(yuy.prev_edges);
-    images_dilation(yuy);
-    gaussian_filter(yuy);
-    /*
-%
-IDiffMasked = abs(diffIm);
-IDiffMasked(dilatedIm) = 0;
-% figure; imagesc(IDiffMasked); title('IDiffMasked');impixelinfo; colorbar;
-ixMoveSuspect = IDiffMasked > params.moveThreshPixVal;
-if sum(ixMoveSuspect(:)) > params.moveThreshPixNum
-    isMovement = true;
-end
-movingPixels = sum(ixMoveSuspect(:));
-disp(['isMovementInImages: # of pixels above threshold ' num2str(sum(ixMoveSuspect(:))) ', allowed #: ' num2str(params.moveThreshPixNum)]);
-end*/
-    yuy.gaussian_diff_masked = yuy.gaussian_filtered_image;
-    abs_values(yuy.gaussian_diff_masked);
-    gaussian_dilation_mask(yuy.gaussian_diff_masked, yuy.dilated_image);
-    move_suspected_mask(yuy.move_suspect, yuy.gaussian_diff_masked, _params.move_thresh_pix_val);
-    auto sum_move_suspect = 0;
-    for (auto it = yuy.move_suspect.begin(); it != yuy.move_suspect.end(); ++it)
+    std::vector< double > gaussian_diff_masked;
+    {
+        std::vector< uint8_t > dilated_image;
+        {
+            std::vector< double > gaussian_filtered_image;
+            {
+                auto logic_edges = get_logic_edges( prev.edges );
+                dilated_image = images_dilation( logic_edges, width, height );
+                std::vector< double > yuy_diff;
+                gaussian_filter( prev.lum_frame,
+                                 curr.lum_frame,
+                                 yuy_diff,
+                                 gaussian_filtered_image,
+                                 width,
+                                 height );
+                if( result_data )
+                {
+                    result_data->logic_edges = std::move( logic_edges );
+                    result_data->yuy_diff = std::move( yuy_diff );
+                }
+            }
+            /*
+            %
+            IDiffMasked = abs(diffIm);
+            IDiffMasked(dilatedIm) = 0;
+            % figure; imagesc(IDiffMasked); title('IDiffMasked');impixelinfo; colorbar;
+            ixMoveSuspect = IDiffMasked > params.moveThreshPixVal;
+            if sum(ixMoveSuspect(:)) > params.moveThreshPixNum
+                isMovement = true;
+            end
+            movingPixels = sum(ixMoveSuspect(:));
+            disp(['isMovementInImages: # of pixels above threshold ' num2str(sum(ixMoveSuspect(:))) ',
+            allowed #: ' num2str(params.moveThreshPixNum)]); end*/
+            gaussian_diff_masked = gaussian_filtered_image;
+            if( result_data )
+                result_data->gaussian_filtered_image = std::move( gaussian_filtered_image );
+        }
+        abs_values( gaussian_diff_masked );
+        gaussian_dilation_mask( gaussian_diff_masked, dilated_image );
+        if( result_data )
+            result_data->dilated_image = std::move( dilated_image );
+    }
+
+    std::vector< uint8_t > move_suspect;
+    auto sum_move_suspect
+        = move_suspected_mask( move_suspect, gaussian_diff_masked, move_thresh_pix_val );
+    if( result_data )
     {
-        sum_move_suspect += *it;
+        result_data->gaussian_diff_masked = std::move( gaussian_diff_masked );
+        result_data->move_suspect = std::move( move_suspect );
     }
-    if (sum_move_suspect > _params.move_threshold_pix_num)
+
+    if( sum_move_suspect > move_threshold_pix_num )
     {
-        AC_LOG(DEBUG, "is_movement_in_images:  # of pixels above threshold " << sum_move_suspect << " allowed #:" << _params.move_threshold_pix_num);
+        AC_LOG( DEBUG,
+                "    found movement: " << sum_move_suspect << " pixels above threshold; allowed: "
+                                       << _params.move_threshold_pix_num );
         return true;
     }
 
     return false;
 }
-bool optimizer::is_scene_valid()
+
+
+bool optimizer::is_scene_valid( input_validity_data * data )
 {
-    std::vector< byte > section_map_depth(_z.width * _z.height);
-    std::vector< byte > section_map_rgb(_yuy.width * _yuy.height);
+    std::vector< byte > section_map_depth( _z.width * _z.height );
 
     size_t const section_w = _params.num_of_sections_for_edge_distribution_x;  //% params.numSectionsH
     size_t const section_h = _params.num_of_sections_for_edge_distribution_y;  //% params.numSectionsH
 
     // Get a map for each pixel to its corresponding section
-    section_per_pixel(_z, section_w, section_h, section_map_depth.data());
-    section_per_pixel(_yuy, section_w, section_h, section_map_rgb.data());
+    section_per_pixel( _z, section_w, section_h, section_map_depth.data() );
 
     // remove pixels in section map that were removed in weights
-    AC_LOG(DEBUG, "... " << _z.supressed_edges.size() << " total edges");
-    for (auto i = 0; i < _z.supressed_edges.size(); i++)
+    AC_LOG( DEBUG, "    " << _z.supressed_edges.size() << " total edges" );
+    AC_LOG( DEBUG, "    " << _z.section_map.size() << " not suppressed" );
+
+    // The previous and current frames must have "NO" movement between them
+    if( _yuy.movement_from_prev_frame )
+        AC_LOG( ERROR, "Scene is not valid: movement detected between current & previous frames [MOVE]" );
+
+    // These two are used in the results validity, in the decision params
+    bool res_edges = is_edge_distributed( _z, _yuy );
+    bool res_gradient = is_grad_dir_balanced( _z.weights,
+                                              _z.directions,
+                                              _params,
+                                              &_z.sum_weights_per_direction,
+                                              &_z.dir_ratio1 );
+
+    auto valid = ! _yuy.movement_from_prev_frame;
+    valid = input_validity_checks(data)  &&  valid;
+        
+    return(valid);
+}
+
+bool check_edges_dir_spread(const std::vector<double>& directions,
+    const std::vector<double>& subpixels_x,
+    const std::vector<double>& subpixels_y,
+    size_t width,
+    size_t height,
+    const params& p)
+{
+    // check if there are enough edges per direction
+    int edges_amount_per_dir[N_BASIC_DIRECTIONS] = { 0 };
+
+    for (auto && i : directions)
     {
-        if (_z.supressed_edges[i])
-        {
-            _z.section_map.push_back(section_map_depth[i]);
-        }
+        edges_amount_per_dir[(int)i - 1]++;
+    }
+
+    bool dirs_with_enough_edges[N_BASIC_DIRECTIONS] = { false };
+
+    for (auto i = 0; i < N_BASIC_DIRECTIONS; i++)
+    {
+        auto edges_amount_per_dir_normalized =  (double)edges_amount_per_dir[i] / (width * height);
+        dirs_with_enough_edges[i] = (edges_amount_per_dir_normalized > p.edges_per_direction_ratio_th);
+    }
+
+    // std Check for valid directions
+    double2 dir_vecs[N_BASIC_DIRECTIONS] =
+    {
+        { 1,             0},
+        { 1 / sqrt(2),   1 / sqrt(2) },
+        { 0,             1 },
+        { -1 / sqrt(2),  1 / sqrt(2) }
+    };
+
+
+    auto diag_length = sqrt((double)width*(double)width + (double)height*(double)height);
+
+    std::vector<double> val_per_dir[N_BASIC_DIRECTIONS];
+
+    for (auto i = 0; i < subpixels_x.size(); i++)
+    {
+        auto dir = (int)directions[i] - 1;
+        auto val = subpixels_x[i] * dir_vecs[dir].x + subpixels_y[i] * dir_vecs[dir].y;
+        val_per_dir[dir].push_back(val);
     }
-    _z.section_map = _z.section_map_depth_inside; // NOHA :: taken from preprocessDepth
-    AC_LOG(DEBUG, "... " << _z.section_map.size() << " not suppressed");
 
-    // remove pixels in section map where edges_IDT > 0
-    int i = 0;
-    AC_LOG(DEBUG, "... " << _z.supressed_edges.size() << " total edges IDT");
+    double std_per_dir[N_BASIC_DIRECTIONS] = { 0 };
+    bool std_bigger_than_th[N_BASIC_DIRECTIONS] = { false };
 
-    for (auto it = _yuy.edges_IDT.begin(); it != _yuy.edges_IDT.end(); ++it, ++i)
+    for (auto i = 0; i < N_BASIC_DIRECTIONS; i++)
     {
-        if (*it > 0)
+        auto curr_dir = val_per_dir[i];
+        double sum = std::accumulate(curr_dir.begin(), curr_dir.end(), 0.0);
+        double mean = sum / curr_dir.size();
+
+        double dists_sum = 0;
+        std::for_each(curr_dir.begin(), curr_dir.end(), [&](double val) {dists_sum += (val - mean)*(val - mean); });
+
+        // The denominator in the 'Sample standard deviation' formula is N − 1 vs 'Population standard deviation' that is N
+        // https://en.wikipedia.org/wiki/Standard_deviation
+        // we use 'Sample standard deviation' as Matlab
+        auto stdev = sqrt(dists_sum / (curr_dir.size() - 1));
+        std_per_dir[i] = stdev / diag_length;
+        std_bigger_than_th[i] = std_per_dir[i] > p.dir_std_th[i];
+    }
+
+    bool valid_directions[N_BASIC_DIRECTIONS] = { false };
+
+    for (auto i = 0; i < N_BASIC_DIRECTIONS; i++)
+    {
+        valid_directions[i] = dirs_with_enough_edges[i] && std_bigger_than_th[i];
+    }
+    auto valid_directions_sum = std::accumulate(&valid_directions[0], &valid_directions[N_BASIC_DIRECTIONS], 0);
+
+    auto edges_dir_spread = valid_directions_sum >= p.minimal_full_directions;
+
+    if (!edges_dir_spread)
+    {
+        AC_LOG( ERROR,
+                "Scene is not valid: not enough edge direction spread (have "
+                    << valid_directions_sum << "; need " << p.minimal_full_directions << ") [EDGE-DIR]" );
+        return edges_dir_spread;
+    }
+
+    if (p.require_orthogonal_valid_dirs)
+    {
+        auto valid_even = true;
+        for (auto i = 0; i < N_BASIC_DIRECTIONS; i += 2)
         {
-            _yuy.section_map.push_back(section_map_rgb[i]);
+            valid_even &= valid_directions[i];
         }
+
+        auto valid_odd = true;
+        for (auto i = 1; i < N_BASIC_DIRECTIONS; i += 2)
+        {
+            valid_odd &= valid_directions[i];
+        }
+        auto orthogonal_valid_dirs = valid_even || valid_odd;
+
+        if( ! orthogonal_valid_dirs )
+            AC_LOG( ERROR,
+                    "Scene is not valid: need at least two orthogonal directions that have enough "
+                    "spread edges [EDGE-DIR]" );
+
+        return edges_dir_spread && orthogonal_valid_dirs;
     }
-    AC_LOG(DEBUG, "... " << _yuy.section_map.size() << " not suppressed");
 
-    bool res_movement = is_movement_in_images(_yuy);
-    bool res_edges = is_edge_distributed(_z, _yuy);
-    bool res_gradient = is_grad_dir_balanced( _z.weights,
-                                              _z.directions,
-                                              _params,
-                                              &_z.sum_weights_per_direction,
-                                              &_z.dir_ratio1 );
+    return edges_dir_spread;
+}
+
+bool check_saturation(const std::vector< ir_t >& ir_frame,
+    size_t width,
+    size_t height,
+    const params& p)
+{
+    size_t saturated_pixels = 0;
+
+    for (auto&& i : ir_frame)
+    {
+        if( i >= p.saturation_value )
+            saturated_pixels++;
+    }
+
+    auto saturated_pixels_ratio = (double)saturated_pixels / (double)(width*height);
+
+    if( saturated_pixels_ratio >= p.saturation_ratio_th )
+        AC_LOG( ERROR,
+                "Scene is not valid: saturation ratio ("
+                    << saturated_pixels_ratio << ") is above threshold (" << p.saturation_ratio_th
+                    << ") [SAT]" );
+
+    return saturated_pixels_ratio < p.saturation_ratio_th;
+}
+
+bool check_edges_spatial_spread(const std::vector<byte>& section_map,
+    size_t width,
+    size_t height, 
+    double th,
+    size_t n_sections,
+    size_t min_section_with_enough_edges)
+{
+    std::vector<int> num_pix_per_sec(n_sections, 0);
+
+    for (auto&&i : section_map)
+    {
+        num_pix_per_sec[i]++;
+    }
+    std::vector<double> num_pix_per_sec_over_area(n_sections, 0);
+    std::vector<bool> num_sections_with_enough_edges(n_sections, false);
+
+    for (auto i = 0; i < n_sections; i++)
+    {
+        num_pix_per_sec_over_area[i] = (double)num_pix_per_sec[i] / (width*height)*n_sections;
+        num_sections_with_enough_edges[i] = num_pix_per_sec_over_area[i] > th;
+    }
+
+    double sum = std::accumulate(num_sections_with_enough_edges.begin(), num_sections_with_enough_edges.end(), 0.0);
 
-    //return((!res_movement) && res_edges && res_gradient);
-    return(!res_movement);
+    return sum >= min_section_with_enough_edges;
 }
+
+bool optimizer::input_validity_checks(input_validity_data* data )
+{
+    auto dir_spread = check_edges_dir_spread(_z.directions, _z.subpixels_x, _z.subpixels_y, _z.width, _z.height, _params);
+    auto not_saturated = check_saturation(_ir.ir_frame, _ir.width, _ir.height, _params);
+
+    auto depth_spatial_spread = check_edges_spatial_spread(
+        _z.section_map, _z.width, _z.height, 
+        _params.pix_per_section_depth_th, 
+        _params.num_of_sections_for_edge_distribution_x*_params.num_of_sections_for_edge_distribution_y,
+        _params.min_section_with_enough_edges);
+
+    auto rgb_spatial_spread = check_edges_spatial_spread(
+        _yuy.section_map_edges,
+        _yuy.width, _yuy.height, 
+        _params.pix_per_section_rgb_th,
+        _params.num_of_sections_for_edge_distribution_x*_params.num_of_sections_for_edge_distribution_y,
+        _params.min_section_with_enough_edges);
+
+    if( ! depth_spatial_spread )
+        AC_LOG( ERROR, "Scene is not valid: not enough depth edge spread [EDGE-D]" );
+
+    if( ! rgb_spatial_spread )
+        AC_LOG( ERROR, "Scene is not valid: not enough RGB edge spread [EDGE-C]" );
+
+    if( ! _yuy.movement_from_last_success )
+        AC_LOG( ERROR, "Scene is not valid: not enough movement from last-calibrated scene [SALC]" );
+
+    if( data )
+    {
+        data->edges_dir_spread = dir_spread;
+        data->not_saturated = not_saturated;
+        data->depth_spatial_spread = depth_spatial_spread;
+        data->rgb_spatial_spread = rgb_spatial_spread;
+        data->is_movement_from_last_success = _yuy.movement_from_last_success;
+    }
+
+    return dir_spread && not_saturated && depth_spatial_spread && rgb_spatial_spread
+        && _yuy.movement_from_last_success;
+}
+
+
diff --git a/src/android/jni/device.cpp b/src/android/jni/device.cpp
index 938e7f0..7e95558 100644
--- a/src/android/jni/device.cpp
+++ b/src/android/jni/device.cpp
@@ -57,7 +57,12 @@ Java_com_intel_realsense_librealsense_Device_nQuerySensors(JNIEnv *env, jclass t
         sensors.push_back(s);
     }
     jlongArray rv = env->NewLongArray(sensors.size());
-    env->SetLongArrayRegion(rv, 0, sensors.size(), reinterpret_cast<const jlong *>(sensors.data()));
+
+    for (auto i = 0; i < sensors.size(); i++)
+    {
+        env->SetLongArrayRegion(rv, i, 1, reinterpret_cast<const jlong *>(&sensors[i]));
+    }
+
     return rv;
 }
 
diff --git a/src/android/jni/sensor.cpp b/src/android/jni/sensor.cpp
index c332aa2..e370e96 100644
--- a/src/android/jni/sensor.cpp
+++ b/src/android/jni/sensor.cpp
@@ -36,8 +36,12 @@ Java_com_intel_realsense_librealsense_Sensor_nGetStreamProfiles(JNIEnv *env, jcl
         profiles.push_back(sp);
     }
 
+    // jlong is 64-bit, but pointer in profiles could be 32-bit, copy element by element
     jlongArray rv = env->NewLongArray(profiles.size());
-    env->SetLongArrayRegion(rv, 0, profiles.size(), reinterpret_cast<const jlong *>(profiles.data()));
+    for (auto i = 0; i < size; i++)
+    {
+        env->SetLongArrayRegion(rv, i, 1, reinterpret_cast<const jlong *>(&profiles[i]));
+    }
     return rv;
 }
 
@@ -97,4 +101,4 @@ Java_com_intel_realsense_librealsense_DepthSensor_nGetDepthScale(JNIEnv *env, jc
     float depthScale = rs2_get_depth_scale(reinterpret_cast<rs2_sensor *>(handle), &e);
     handle_error(env, e);
     return depthScale;
-}
\ No newline at end of file
+}
diff --git a/src/concurrency.h b/src/concurrency.h
index e1bab21..fa9403d 100644
--- a/src/concurrency.h
+++ b/src/concurrency.h
@@ -266,14 +266,16 @@ public:
         auto func = std::move(item);
         invoke([&, func](dispatcher::cancellable_timer c)
         {
+            std::lock_guard<std::mutex> lk(_blocking_invoke_mutex);
             func(c);
+
             done = true;
             _blocking_invoke_cv.notify_one();
         }, is_blocking);
 
         //wait
         std::unique_lock<std::mutex> lk(_blocking_invoke_mutex);
-        while(_blocking_invoke_cv.wait_for(lk, std::chrono::milliseconds(10), [&](){ return !done && !exit_condition(); }));
+        _blocking_invoke_cv.wait(lk, [&](){ return done || exit_condition(); });
     }
 
     void start()
@@ -288,6 +290,9 @@ public:
     {
         {
             std::unique_lock<std::mutex> lock(_was_stopped_mutex);
+
+            if (_was_stopped.load()) return;
+
             _was_stopped = true;
             _was_stopped_cv.notify_all();
         }
@@ -310,6 +315,8 @@ public:
         stop();
         _queue.clear();
         _is_alive = false;
+
+        if (_thread.joinable())
         _thread.join();
     }
 
@@ -379,8 +386,10 @@ public:
 
     void stop()
     {
-        _stopped = true;
-        _dispatcher.stop();
+        if (!_stopped.load()) {
+            _stopped = true;
+            _dispatcher.stop();
+        }
     }
 
     ~active_object()
diff --git a/src/depth-to-rgb-calibration.cpp b/src/depth-to-rgb-calibration.cpp
index 7a5c43c..ecd6123 100644
--- a/src/depth-to-rgb-calibration.cpp
+++ b/src/depth-to-rgb-calibration.cpp
@@ -9,46 +9,62 @@
 #include "api.h"  // VALIDATE_INTERFACE_NO_THROW
 #include "algo/depth-to-rgb-calibration/debug.h"
 
-#ifndef _WIN32
-#include <sys/stat.h>  // mkdir
-#endif
-
 
 using namespace librealsense;
 namespace impl = librealsense::algo::depth_to_rgb_calibration;
 
+#define CHECK_IF_NEEDS_TO_STOP() if (_should_continue) _should_continue()
+
 depth_to_rgb_calibration::depth_to_rgb_calibration(
+    impl::optimizer::settings const & settings,
     rs2::frame depth,
     rs2::frame ir,
     rs2::frame yuy,
     rs2::frame prev_yuy,
-    algo::depth_to_rgb_calibration::algo_calibration_info const & cal_info,
-    algo::depth_to_rgb_calibration::algo_calibration_registers const & cal_regs
+    std::vector< impl::yuy_t > const & last_yuy_data,
+    impl::algo_calibration_info const & cal_info,
+    impl::algo_calibration_registers const & cal_regs,
+    std::function<void()> should_continue
 )
-    : _intr( yuy.get_profile().as< rs2::video_stream_profile >().get_intrinsics() )
+    : _algo( settings )
+    , _intr( yuy.get_profile().as< rs2::video_stream_profile >().get_intrinsics() )
     , _extr(to_raw_extrinsics( depth.get_profile().get_extrinsics_to( yuy.get_profile() )))
     , _from( depth.get_profile().get()->profile )
     , _to( yuy.get_profile().get()->profile )
+    , _should_continue( should_continue )
 {
-    AC_LOG( DEBUG, "... setting yuy data" );
+    AC_LOG( DEBUG, "Setting YUY data" );
     auto color_profile = yuy.get_profile().as< rs2::video_stream_profile >();
     auto yuy_data = (impl::yuy_t const *) yuy.get_data();
     auto prev_yuy_data = (impl::yuy_t const *) prev_yuy.get_data();
+    if( last_yuy_data.size() == yuy.get_data_size() / sizeof( impl::yuy_t ) )
+        _last_successful_frame_data = last_yuy_data;  // copy -- will be moved to algo
+    else if( ! last_yuy_data.empty() )
+        AC_LOG( DEBUG, "Not using last successfully-calibrated scene: it's of a different resolution" );
     impl::calib calibration( _intr, _extr );
+
+    CHECK_IF_NEEDS_TO_STOP();
+
     _algo.set_yuy_data(
         std::vector< impl::yuy_t >( yuy_data, yuy_data + yuy.get_data_size() / sizeof( impl::yuy_t )),
         std::vector< impl::yuy_t >( prev_yuy_data, prev_yuy_data + yuy.get_data_size() / sizeof( impl::yuy_t ) ),
+        std::move( _last_successful_frame_data ),
         calibration
     );
 
-    AC_LOG( DEBUG, "... setting ir data" );
+    AC_LOG( DEBUG, "Setting IR data" );
     auto ir_profile = ir.get_profile().as< rs2::video_stream_profile >();
     auto ir_data = (impl::ir_t const *) ir.get_data();
+
+    CHECK_IF_NEEDS_TO_STOP();
+
     _algo.set_ir_data(
         std::vector< impl::ir_t >( ir_data, ir_data + ir.get_data_size() / sizeof( impl::ir_t )),
         ir_profile.width(), ir_profile.height()
     );
 
+    CHECK_IF_NEEDS_TO_STOP();
+
     auto si = ((frame_interface *) depth.get() )->get_sensor();
     auto cs = VALIDATE_INTERFACE_NO_THROW( si, librealsense::calibrated_sensor );
     if( !cs )
@@ -58,9 +74,12 @@ depth_to_rgb_calibration::depth_to_rgb_calibration(
     }
     _dsm_params = cs->get_dsm_params();
 
-    AC_LOG( DEBUG, "... setting z data" );
+    AC_LOG( DEBUG, "Setting Z data" );
     auto z_profile = depth.get_profile().as< rs2::video_stream_profile >();
     auto z_data = (impl::z_t const *) depth.get_data();
+
+    CHECK_IF_NEEDS_TO_STOP();
+
     _algo.set_z_data(
         std::vector< impl::z_t >( z_data, z_data + depth.get_data_size() / sizeof( impl::z_t ) ),
         z_profile.get_intrinsics(), _dsm_params, cal_info, cal_regs,
@@ -68,27 +87,12 @@ depth_to_rgb_calibration::depth_to_rgb_calibration(
     );
 
     debug_calibration( "old" );
+}
 
-    // If the user has this env var defined, then we write out logs and frames to it
-    // NOTE: The var should end with a directory separator \ or /
-    auto dir_ = getenv( "RS2_DEBUG_DIR" );
-    if( dir_ )
-    {
-        std::string dir( dir_ );
-        dir += std::to_string( depth.get_frame_number() );
-        
-#ifdef _WIN32
-        dir += "\\";
-        auto status = _mkdir( dir.c_str() );
-#else
-        dir += "/";
-        auto status = mkdir( dir.c_str(), 0700 );
-#endif
-        if( status == 0 )
-            _algo.write_data_to( dir );
-        else
-            AC_LOG( WARNING, "Failed (" << status << ") to write AC frame data to: " << dir );
-    }
+
+void depth_to_rgb_calibration::write_data_to( std::string const & dir )
+{
+    _algo.write_data_to( dir );
 }
 
 
@@ -100,10 +104,10 @@ rs2_calibration_status depth_to_rgb_calibration::optimize(
 
     try
     {
-        AC_LOG( DEBUG, "... checking scene validity" );
+        AC_LOG( DEBUG, "Checking scene validity" );
         if( !_algo.is_scene_valid() )
         {
-            AC_LOG( ERROR, "Calibration scene was found invalid!" );
+            //AC_LOG( ERROR, "Calibration scene was found invalid!" );
             call_back( RS2_CALIBRATION_SCENE_INVALID );
             if( !getenv( DISABLE_RS2_CALIBRATION_CHECKS ) )
             {
@@ -120,10 +124,16 @@ rs2_calibration_status depth_to_rgb_calibration::optimize(
             AC_LOG( DEBUG, DISABLE_RS2_CALIBRATION_CHECKS << " is on; continuing" );
         }
 
-        AC_LOG( DEBUG, "... optimizing" );
-        _algo.optimize();
+        CHECK_IF_NEEDS_TO_STOP();
+
+
+        AC_LOG( DEBUG, "Optimizing" );
+
+        _algo.optimize(
+            [&]( impl::data_collect const & data ) { CHECK_IF_NEEDS_TO_STOP(); }
+        );
 
-        AC_LOG( DEBUG, "... checking result validity" );
+        AC_LOG( DEBUG, "Checking result validity" );
         if( !_algo.is_valid_results() )
         {
             // Error would have printed inside
@@ -148,11 +158,12 @@ rs2_calibration_status depth_to_rgb_calibration::optimize(
         // AC_LOG( INFO, "Calibration finished; original cost= " << original_cost << "  optimized
         // cost= " << params_curr.cost );
 
-        AC_LOG( DEBUG, "... optimization successful!" );
+        AC_LOG( DEBUG, "Optimization successful!" );
         _intr = _algo.get_calibration().get_intrinsics();
         _intr.model = RS2_DISTORTION_INVERSE_BROWN_CONRADY; //restore LRS model 
         _extr = from_raw_extrinsics( _algo.get_calibration().get_extrinsics() );
         _dsm_params = _algo.get_dsm_params();
+        _last_successful_frame_data = _algo.get_yuy_data().orig_frame;  // copy -- will be moved to ac_trigger
         debug_calibration( "new" );
         return RS2_CALIBRATION_SUCCESSFUL;
     }
@@ -166,8 +177,8 @@ rs2_calibration_status depth_to_rgb_calibration::optimize(
 
 void depth_to_rgb_calibration::debug_calibration( char const * prefix )
 {
-    AC_LOG( DEBUG, AC_F_PREC << prefix << _intr );
-    AC_LOG( DEBUG, AC_F_PREC << prefix << " extr" << _extr );
-    AC_LOG( DEBUG, AC_F_PREC << prefix << " dsm" << _dsm_params );
+    AC_LOG( DEBUG, AC_F_PREC << "    " << prefix << " intr" << _intr );
+    AC_LOG( DEBUG, AC_F_PREC << "    " << prefix << " extr" << _extr );
+    AC_LOG( DEBUG, AC_F_PREC << "    " << prefix << "  dsm" << _dsm_params );
 }
 
diff --git a/src/depth-to-rgb-calibration.h b/src/depth-to-rgb-calibration.h
index a0901a4..843143f 100644
--- a/src/depth-to-rgb-calibration.h
+++ b/src/depth-to-rgb-calibration.h
@@ -5,6 +5,7 @@
 
 #include "algo/depth-to-rgb-calibration/optimizer.h"
 #include "types.h"
+#include <vector>
 
 
 namespace librealsense
@@ -24,17 +25,22 @@ namespace librealsense
         rs2_extrinsics _extr;
         rs2_intrinsics _intr;
         rs2_dsm_params _dsm_params;
+        std::vector< algo::depth_to_rgb_calibration::yuy_t > _last_successful_frame_data;
 
         algo::depth_to_rgb_calibration::optimizer _algo;
+        std::function<void()> _should_continue;
 
     public:
         depth_to_rgb_calibration(
+            algo::depth_to_rgb_calibration::optimizer::settings const & settings,
             rs2::frame depth,
             rs2::frame ir,
             rs2::frame yuy,
             rs2::frame prev_yuy,
+            std::vector< algo::depth_to_rgb_calibration::yuy_t > const & last_yuy_data,
             algo::depth_to_rgb_calibration::algo_calibration_info const & cal_info,
-            algo::depth_to_rgb_calibration::algo_calibration_registers const & cal_regs
+            algo::depth_to_rgb_calibration::algo_calibration_registers const & cal_regs,
+            std::function<void()> should_continue = nullptr
         );
 
         rs2_extrinsics const & get_extrinsics() const { return _extr; }
@@ -42,8 +48,14 @@ namespace librealsense
         stream_profile_interface * get_from_profile() const { return _from; }
         stream_profile_interface * get_to_profile() const { return _to; }
         rs2_dsm_params const & get_dsm_params() const { return _dsm_params; }
+        std::vector< algo::depth_to_rgb_calibration::yuy_t > & get_last_successful_frame_data()
+        {
+            return _last_successful_frame_data;
+        }
 
-        rs2_calibration_status optimize( std::function<void( rs2_calibration_status )> call_back = nullptr );
+        void write_data_to( std::string const & dir );
+
+        rs2_calibration_status optimize( std::function<void( rs2_calibration_status )> call_back = nullptr);
 
     private:
         void debug_calibration( char const * prefix );
diff --git a/src/ds5/ds5-active.cpp b/src/ds5/ds5-active.cpp
index e1b7b10..c8a02e9 100644
--- a/src/ds5/ds5-active.cpp
+++ b/src/ds5/ds5-active.cpp
@@ -25,8 +25,9 @@ namespace librealsense
     {
         using namespace ds;
 
+        //Projector's capacity is established based on actual HW capabilities
         auto pid = group.uvc_devices.front().pid;
-        if (pid != RS_USB2_PID)
+        if ((pid != RS_USB2_PID) && ((_device_capabilities & d400_caps::CAP_ACTIVE_PROJECTOR) == d400_caps::CAP_ACTIVE_PROJECTOR))
         {
             auto&& depth_ep = get_depth_sensor();
             auto&& raw_depth_ep = get_raw_depth_sensor();
@@ -38,6 +39,7 @@ namespace librealsense
                                                                          depth_xu,
                                                                          DS5_LASER_POWER,
                                                                          "Manual laser power in mw. applicable only when laser power mode is set to Manual");
+
             depth_ep.register_option(RS2_OPTION_LASER_POWER,
                                      std::make_shared<auto_disabling_control>(
                                      laser_power,
@@ -45,8 +47,13 @@ namespace librealsense
                                      std::vector<float>{0.f, 2.f}, 1.f));
 
             depth_ep.register_option(RS2_OPTION_PROJECTOR_TEMPERATURE,
-                    std::make_shared<asic_and_projector_temperature_options>(raw_depth_ep,
+                std::make_shared<asic_and_projector_temperature_options>(raw_depth_ep,
                     RS2_OPTION_PROJECTOR_TEMPERATURE));
         }
+        else
+        {
+            LOG_WARNING("Projector capacity is overrided and disabled by FW\nDevice PID = 0x" << std::hex << pid
+                << std::dec << ", Capabilities Vector = [" << _device_capabilities << "]");
+        }
     }
 }
diff --git a/src/ds5/ds5-device.cpp b/src/ds5/ds5-device.cpp
index 49f589e..9aeca4f 100644
--- a/src/ds5/ds5-device.cpp
+++ b/src/ds5/ds5-device.cpp
@@ -666,20 +666,18 @@ namespace librealsense
             depth_sensor.register_processing_block(processing_block_factory::create_id_pbf(RS2_FORMAT_Z16H, RS2_STREAM_DEPTH));
         }
 
-        if (advanced_mode && (_usb_mode >= usb3_type))
-        {
-            depth_sensor.register_processing_block(
-                { {RS2_FORMAT_Y8I} },
-                { {RS2_FORMAT_Y8, RS2_STREAM_INFRARED, 1} , {RS2_FORMAT_Y8, RS2_STREAM_INFRARED, 2} },
-                []() { return std::make_shared<y8i_to_y8y8>(); }
-            ); // L+R
-
-            depth_sensor.register_processing_block(
-                {RS2_FORMAT_Y12I},
-                {{RS2_FORMAT_Y16, RS2_STREAM_INFRARED, 1}, {RS2_FORMAT_Y16, RS2_STREAM_INFRARED, 2}},
-                []() {return std::make_shared<y12i_to_y16y16>(); }
-            );
-        }
+
+        depth_sensor.register_processing_block(
+            { {RS2_FORMAT_Y8I} },
+            { {RS2_FORMAT_Y8, RS2_STREAM_INFRARED, 1} , {RS2_FORMAT_Y8, RS2_STREAM_INFRARED, 2} },
+            []() { return std::make_shared<y8i_to_y8y8>(); }
+        ); // L+R
+
+        depth_sensor.register_processing_block(
+            {RS2_FORMAT_Y12I},
+            {{RS2_FORMAT_Y16, RS2_STREAM_INFRARED, 1}, {RS2_FORMAT_Y16, RS2_STREAM_INFRARED, 2}},
+            []() {return std::make_shared<y12i_to_y16y16>(); }
+        );
 
         auto pid_hex_str = hexify(pid);
 
@@ -693,12 +691,12 @@ namespace librealsense
                     "Set the power level of the LED, with 0 meaning LED off"));
         }
 
-        if ((pid == RS405_PID || pid == RS455_PID) && _fw_version >= firmware_version("5.12.7.0"))
-        {
-            depth_sensor.register_option(RS2_OPTION_THERMAL_COMPENSATION,
-                std::make_shared<uvc_xu_option<uint8_t>>(raw_depth_sensor, depth_xu, DS5_THERMAL_COMPENSATION,
-                    "Toggle Depth Sensor Thermal Compensation"));
-        }
+        //if ((pid == RS405_PID || pid == RS455_PID) && _fw_version >= firmware_version("5.12.4.0"))
+        //{
+        //    depth_sensor.register_option(RS2_OPTION_THERMAL_COMPENSATION,
+        //        std::make_shared<uvc_xu_option<uint8_t>>(raw_depth_sensor, depth_xu, DS5_THERMAL_COMPENSATION,
+        //            "Toggle Depth Sensor Thermal Compensation"));
+        //}
 
         if (_fw_version >= firmware_version("5.6.3.0"))
         {
diff --git a/src/ds5/ds5-private.h b/src/ds5/ds5-private.h
index 9f51c29..7f05b6a 100644
--- a/src/ds5/ds5-private.h
+++ b/src/ds5/ds5-private.h
@@ -317,7 +317,7 @@ namespace librealsense
                             d400_caps::CAP_BMI_055,         d400_caps::CAP_BMI_085 })
             {
                 if (i==(i&cap))
-                    stream << d400_capabilities_names.at(i) << " ";
+                    stream << d400_capabilities_names.at(i) << "/";
             }
             return stream;
         }
diff --git a/src/firmware_logger_device.cpp b/src/firmware_logger_device.cpp
index 63564c5..c829c45 100644
--- a/src/firmware_logger_device.cpp
+++ b/src/firmware_logger_device.cpp
@@ -51,8 +51,6 @@ namespace librealsense
         // convert bytes to fw_logs_binary_data
         for (int i = 0; i < res.size() / fw_logs::BINARY_DATA_SIZE; ++i)
         {
-            if (*beginOfLogIterator == 0)
-                break;
             auto endOfLogIterator = beginOfLogIterator + fw_logs::BINARY_DATA_SIZE;
             std::vector<uint8_t> resultsForOneLog;
             resultsForOneLog.insert(resultsForOneLog.begin(), beginOfLogIterator, endOfLogIterator);
diff --git a/src/frame-archive.h b/src/frame-archive.h
index 89276e8..4f6b753 100644
--- a/src/frame-archive.h
+++ b/src/frame-archive.h
@@ -221,7 +221,7 @@ namespace librealsense
         {
             if (pending_frames > 0)
             {
-                LOG_INFO("All frames from stream 0x"
+                LOG_DEBUG("All frames from stream 0x"
                     << std::hex << this << " are now released by the user" << std::dec);
             }
         }
diff --git a/src/global_timestamp_reader.cpp b/src/global_timestamp_reader.cpp
index faf1e46..1ec7fc0 100644
--- a/src/global_timestamp_reader.cpp
+++ b/src/global_timestamp_reader.cpp
@@ -3,6 +3,8 @@
 #include "global_timestamp_reader.h"
 #include <chrono>
 
+using namespace std::chrono;
+
 namespace librealsense
 {
     CSample& CSample::operator-=(const CSample& other)
@@ -38,7 +40,6 @@ namespace librealsense
 
     void CLinearCoefficients::add_value(CSample val)
     {
-        std::lock_guard<std::recursive_mutex> lock(_add_mtx);   // Redandent as only being read from update_diff_time() and there is a lock there.
         while (_last_values.size() > _buffer_size)
         {
             _last_values.pop_back();
@@ -62,7 +63,6 @@ namespace librealsense
         double n(static_cast<double>(_last_values.size()));
         double a(1);
         double b(0);
-        double crnt_time(_last_values.front()._x);
         double dt(1);
         if (n == 1)
         {
@@ -71,6 +71,7 @@ namespace librealsense
             _dest_b = 0;
             _prev_a = 0;
             _prev_b = 0;
+            _last_request_time = _last_values.front()._x;
         }
         else
         {
@@ -90,38 +91,72 @@ namespace librealsense
             b = (sum_y*sum_x2 - sum_x * sum_xy) / (n*sum_x2 - sum_x * sum_x);
             a = (n*sum_xy - sum_x * sum_y) / (n*sum_x2 - sum_x * sum_x);
 
-            if (crnt_time - _prev_time < _time_span_ms)
+            if (_last_request_time - _prev_time < _time_span_ms)
             {
-                dt = (crnt_time - _prev_time) / _time_span_ms;
+                dt = (_last_request_time - _prev_time) / _time_span_ms;
             }
         }
-        std::lock_guard<std::recursive_mutex> lock(_stat_mtx);
         _prev_a = _dest_a * dt + _prev_a * (1 - dt);
         _prev_b = _dest_b * dt + _prev_b * (1 - dt);
         _dest_a = a;
         _dest_b = b;
-        _prev_time = crnt_time;
+        _prev_time = _last_request_time;
     }
 
-    double CLinearCoefficients::calc_value(double x) const
+    void CLinearCoefficients::get_a_b(double x, double& a, double& b) const
     {
-        std::lock_guard<std::recursive_mutex> lock(_stat_mtx);
-        double a(_dest_a), b(_dest_b);
+        a = _dest_a;
+        b = _dest_b;
         if (x - _prev_time < _time_span_ms)
         {
-            double dt( (x - _prev_time) / _time_span_ms );
+            double dt((x - _prev_time) / _time_span_ms);
             a = _dest_a * dt + _prev_a * (1 - dt);
             b = _dest_b * dt + _prev_b * (1 - dt);
         }
+    }
+
+    double CLinearCoefficients::calc_value(double x) const
+    {
+        double a, b;
+        get_a_b(x, a, b);
         double y(a * (x - _base_sample._x) + b + _base_sample._y);
-        LOG_DEBUG("CLinearCoefficients::calc_value: " << x << " -> " << y << " with coefs:" << a << ", " << b << ", " << _base_sample._x << ", " << _base_sample._y);
+        LOG_DEBUG(__FUNCTION__ << ": " << x << " -> " << y << " with coefs:" << a << ", " << b << ", " << _base_sample._x << ", " << _base_sample._y);
         return y;
     }
 
+    bool CLinearCoefficients::update_samples_base(double x)
+    {
+        static const double max_device_time(pow(2, 32) * TIMESTAMP_USEC_TO_MSEC);
+        double base_x;
+        if (_last_values.empty())
+            return false;
+        if ((_last_values.front()._x - x) > max_device_time / 2)
+            base_x = max_device_time;
+        else if ((x - _last_values.front()._x) > max_device_time / 2)
+            base_x = -max_device_time;
+        else
+            return false;
+        LOG_DEBUG(__FUNCTION__ << "(" << base_x << ")");
+
+        double a, b;
+        get_a_b(x+base_x, a, b);
+        for (auto &&sample : _last_values)
+        {
+            sample._x -= base_x;
+        }
+        _prev_time -= base_x;
+        _base_sample._y += a * base_x;
+        return true;
+    }
+
+    void CLinearCoefficients::update_last_sample_time(double x)
+    {
+        _last_request_time = x;
+    }
+
     time_diff_keeper::time_diff_keeper(global_time_interface* dev, const unsigned int sampling_interval_ms) :
         _device(dev),
         _poll_intervals_ms(sampling_interval_ms),
-        _last_sample_hw_time(1e+200),
         _coefs(15),
         _users_count(0),
         _is_ready(false),
@@ -155,6 +190,7 @@ namespace librealsense
             LOG_DEBUG("time_diff_keeper::stop: stop object.");
             _active_object.stop();
             _coefs.reset();
+            _is_ready = false;
         }
     }
 
@@ -165,32 +201,27 @@ namespace librealsense
 
     bool time_diff_keeper::update_diff_time()
     {
-        using namespace std::chrono;
         try
         {
             if (!_users_count)
                 throw wrong_api_call_sequence_exception("time_diff_keeper::update_diff_time called before object started.");
-            std::lock_guard<std::recursive_mutex> lock(_mtx);
             double system_time_start = duration<double, std::milli>(system_clock::now().time_since_epoch()).count();
-
             double sample_hw_time = _device->get_device_time_ms();
             double system_time_finish = duration<double, std::milli>(system_clock::now().time_since_epoch()).count();
             double command_delay = (system_time_finish-system_time_start)/2;
 
+            std::lock_guard<std::recursive_mutex> lock(_read_mtx);
             if (command_delay < _min_command_delay)
             {
                 _coefs.add_const_y_coefs(command_delay - _min_command_delay);
                 _min_command_delay = command_delay;
             }
             double system_time(system_time_finish - _min_command_delay);
-            if (sample_hw_time < _last_sample_hw_time)
+            if (_is_ready)
             {
-                // A time loop happend:
-                //LOG_DEBUG("time_diff_keeper::call reset()");
-                _coefs.reset();
+                _coefs.update_samples_base(sample_hw_time);
             }
-            _last_sample_hw_time = sample_hw_time;
-            CSample crnt_sample(_last_sample_hw_time, system_time);
+            CSample crnt_sample(sample_hw_time, system_time);
             _coefs.add_value(crnt_sample);
             _is_ready = true;
             return true;
@@ -216,12 +247,9 @@ namespace librealsense
 
     void time_diff_keeper::polling(dispatcher::cancellable_timer cancellable_timer)
     {
+        update_diff_time();
         unsigned int time_to_sleep = _poll_intervals_ms + _coefs.is_full() * (9 * _poll_intervals_ms);
-        if (cancellable_timer.try_sleep(time_to_sleep))
-        {
-            update_diff_time();
-        }
-        else
+        if (!cancellable_timer.try_sleep(time_to_sleep))
         {
             LOG_DEBUG("Notification: time_diff_keeper polling loop is being shut-down");
         }
@@ -229,17 +257,14 @@ namespace librealsense
 
     double time_diff_keeper::get_system_hw_time(double crnt_hw_time, bool& is_ready)
     {
-        static const double possible_loop_time(3000);
-        {
-            std::lock_guard<std::recursive_mutex> lock(_read_mtx);
-            if ((_last_sample_hw_time - crnt_hw_time) > possible_loop_time)
-            {
-                update_diff_time();
-            }
-        }
+        std::lock_guard<std::recursive_mutex> lock(_read_mtx);
         is_ready = _is_ready;
         if (_is_ready)
+        {
+            _coefs.update_samples_base(crnt_hw_time);
+            _coefs.update_last_sample_time(crnt_hw_time);
             return _coefs.calc_value(crnt_hw_time);
+        }
         else        
             return crnt_hw_time;
     }
diff --git a/src/global_timestamp_reader.h b/src/global_timestamp_reader.h
index 424f2dd..7f2629e 100644
--- a/src/global_timestamp_reader.h
+++ b/src/global_timestamp_reader.h
@@ -37,12 +37,14 @@ namespace librealsense
         void reset();
         void add_value(CSample val);
         void add_const_y_coefs(double dy);
-        void update_linear_coefs(double x);
+        bool update_samples_base(double x);
+        void update_last_sample_time(double x);
         double calc_value(double x) const;
         bool is_full() const;
 
     private:
         void calc_linear_coefs();
+        void get_a_b(double x, double& a, double& b) const;
 
     private:
         unsigned int _buffer_size;
@@ -51,8 +53,7 @@ namespace librealsense
         double _prev_a, _prev_b;    //Linear regression coeffitions - previously used values.
         double _dest_a, _dest_b;    //Linear regression coeffitions - recently calculated.
         double _prev_time, _time_span_ms;
-        mutable std::recursive_mutex _add_mtx;
-        mutable std::recursive_mutex _stat_mtx;
+        double _last_request_time;
     };
 
     class global_time_interface;
@@ -72,11 +73,9 @@ namespace librealsense
 
     private:
         global_time_interface* _device;
-        double _last_sample_hw_time;
         unsigned int _poll_intervals_ms;
         int             _users_count;
         active_object<> _active_object;
-        mutable std::recursive_mutex _mtx;      // Watch the update process
         mutable std::recursive_mutex _read_mtx; // Watch only 1 reader at a time.
         mutable std::recursive_mutex _enable_mtx; // Watch only 1 start/stop operation at a time.
         CLinearCoefficients _coefs;
diff --git a/src/l500/ac-trigger.cpp b/src/l500/ac-trigger.cpp
index ddb9632..77a5789 100644
--- a/src/l500/ac-trigger.cpp
+++ b/src/l500/ac-trigger.cpp
@@ -9,6 +9,10 @@
 #include "algo/depth-to-rgb-calibration/debug.h"
 #include "log.h"
 
+#ifndef _WIN32
+#include <sys/stat.h>  // mkdir
+#endif
+
 
 template < class X > struct string_to {};
 
@@ -101,6 +105,20 @@ public:
 };
 
 
+// Returns the current date and time, with the chosen formatting
+// See format docs here: https://en.cppreference.com/w/cpp/chrono/c/strftime
+// %T = equivalent to "%H:%M:%S"
+static std::string now_string( char const * format_string = "%T" )
+{
+    std::time_t now = std::time( nullptr );
+    auto ptm = localtime( &now );
+    char buf[256];
+    strftime( buf, sizeof( buf ), format_string, ptm );
+    return buf;
+}
+
+
+
 static int get_retry_sf_seconds()
 {
     static int n_seconds
@@ -110,13 +128,13 @@ static int get_retry_sf_seconds()
 static double get_temp_diff_trigger()
 {
     static double d_temp
-        = env_var< int >( "RS2_AC_TEMP_DIFF", 0, []( int n ) { return n >= 0; } ).value();
+        = env_var< int >( "RS2_AC_TEMP_DIFF", 5, []( int n ) { return n >= 0; } ).value();
     return d_temp;
 }
 static std::chrono::seconds get_trigger_seconds()
 {
     auto n_seconds = env_var< int >( "RS2_AC_TRIGGER_SECONDS",
-        0,  // off by default (600 = 10 minutes since last is the normal default)
+        600,  // 10 minutes since last (0 to disable)
         []( int n ) { return n >= 0; } );
     // 0 means turn off auto-trigger
     return std::chrono::seconds( n_seconds );
@@ -146,7 +164,7 @@ namespace librealsense {
 namespace ivcam2 {
 
 
-    static bool is_auto_trigger_default()
+    static bool is_auto_trigger_possible()
     {
         if( get_trigger_seconds().count() )
             return true;
@@ -154,9 +172,24 @@ namespace ivcam2 {
             return true;
         return false;
     }
+    static bool is_auto_trigger_default()
+    {
+        return env_var< bool >( "RS2_AC_AUTO_TRIGGER",
+#ifdef __arm__
+                                false
+#else
+                                false
+#endif
+                                )
+            && is_auto_trigger_possible();
+    }
 
     ac_trigger::enabler_option::enabler_option( std::shared_ptr< ac_trigger > const & autocal )
-        : bool_option( is_auto_trigger_default() )
+        : super( option_range{ 0,
+                               RS2_CAH_TRIGGER_COUNT - 1,
+                               1,
+                               is_auto_trigger_default() ? float( RS2_CAH_TRIGGER_AUTO )
+                                                         : float( RS2_CAH_TRIGGER_MANUAL ) } )
         , _autocal( autocal )
     {
     }
@@ -169,51 +202,77 @@ namespace ivcam2 {
 
     void ac_trigger::enabler_option::set( float value )
     {
-        //bool_option::set( value );
-        if( is_auto_trigger_default() )
+        if( value == query() )
+        {
+            return;
+        }
+
+        auto ac = _autocal.lock();
+        if (!ac)
+            throw std::runtime_error( "device no longer exists" );
+
+        if( value != RS2_CAH_TRIGGER_NOW )
         {
             // When auto trigger is on in the environment, we control the timed activation
             // of AC, and do NOT trigger manual calibration
-            bool_option::set( value );
-            if( is_true() )
+            if( value == RS2_CAH_TRIGGER_AUTO )
             {
-                if( _autocal->_dev.get_depth_sensor().is_streaming() )
-                    _autocal->start();
+                if( ! is_auto_trigger_possible() )
+                    throw invalid_value_exception( "auto trigger is disabled in the environment" );
+                try
+                {
+                    if (ac->_dev.get_depth_sensor().is_streaming())
+                        ac->_start();
+
+                    super::set(value);
+                }
+                catch (std::exception const & e)
+                {
+                    AC_LOG(ERROR, "EXCEPTION caught during start: " << e.what());
+                    return;
+                }
                 // else start() will get called on stream start
             }
             else
             {
-                _autocal->stop();
+                super::set( value );
+                ac->stop();
             }
+            _record_action( *this );
         }
         else
         {
-            // Without the auto-trigger, turning us on never actually toggles us so we stay
-            // "off" and just trigger a new calibration
-            auto & depth_sensor = _autocal->_dev.get_depth_sensor();
-            if( depth_sensor.is_streaming() )
+            // User wants to trigger it RIGHT NOW
+            // We don't change the actual control value!
+            bool is_depth_streaming(false);
+
+            is_depth_streaming = ac->_dev.get_depth_sensor().is_streaming();
+
+            if( is_depth_streaming )
             {
                 AC_LOG( DEBUG, "Triggering manual calibration..." );
-                _autocal->trigger_calibration();
+                ac->trigger_calibration( calibration_type::MANUAL );
             }
             else
             {
-                AC_LOG( ERROR, "Cannot trigger calibration: depth sensor is not on!" );
+                throw wrong_api_call_sequence_exception( "Cannot trigger calibration: depth sensor is not on!" );
             }
         }
-        _record_action( *this );
     }
 
-    void ac_trigger::reset_option::set( float value )
+    void ac_trigger::reset_option::set(float value)
     {
         //bool_option::set( value );
+        auto ac = _autocal.lock();
+        if (!ac)
+            throw std::runtime_error( "device no longer exists" );
 
         // Reset the calibration so we can do it all over again
-        if (auto color_sensor = _autocal->_dev.get_color_sensor())
+        if (auto color_sensor = ac->_dev.get_color_sensor())
             color_sensor->reset_calibration();
-        _autocal->_dev.get_depth_sensor().reset_calibration();
-        _autocal->_dev.notify_of_calibration_change( RS2_CALIBRATION_SUCCESSFUL );
-        _record_action( *this );
+        ac->_dev.get_depth_sensor().reset_calibration();
+        ac->_dev.notify_of_calibration_change(RS2_CALIBRATION_SUCCESSFUL);
+        _record_action(*this);
     }
 
 
@@ -222,13 +281,13 @@ namespace ivcam2 {
     // retry period elapses then nothing will happen!
     class ac_trigger::retrier
     {
-        ac_trigger & _ac;
+        std::weak_ptr<ac_trigger> _ac;
         unsigned _id;
         char const * const _name;
 
     protected:
         retrier( ac_trigger & ac, char const * name )
-            : _ac( ac )
+            : _ac( ac.shared_from_this() )
             , _name( name ? name : "retrier" )
         {
             static unsigned id = 0;
@@ -236,19 +295,27 @@ namespace ivcam2 {
         }
 
         unsigned get_id() const { return _id; }
-        ac_trigger & get_ac() const { return _ac; }
+        std::shared_ptr <ac_trigger> get_ac() const { return _ac.lock(); }
         char const * get_name() const { return _name; }
 
-        virtual void retry()
+        static std::string _prefix( std::string const & name, unsigned id )
+        {
+            return to_string() << "... " << now_string() << " " << name << ' ' << id << ": ";
+        }
+        std::string prefix() const
         {
-            AC_LOG( DEBUG, "triggering " << _name << ' ' << get_id() );
-            _ac.trigger_calibration( true );
+            return _prefix( get_name(), get_id() );
+        }
+
+        virtual void retry(ac_trigger & trigger)
+        {
+            trigger.trigger_retry();
         }
 
     public:
         virtual ~retrier()
         {
-            AC_LOG( DEBUG, "~" << get_name() << " " << get_id() );
+            AC_LOG( DEBUG, _prefix( '~' + std::string(get_name()), get_id() ));
         }
 
         template < class T = retrier >
@@ -259,23 +326,60 @@ namespace ivcam2 {
             T * r = new T( trigger, name );
             auto id = r->get_id();
             name = r->get_name();
-            AC_LOG( DEBUG, name << ' ' << id << ": " << n_seconds.count() << " seconds starting" );
+            AC_LOG( DEBUG, r->prefix() << n_seconds.count() << " seconds starting" );
             auto pr = std::shared_ptr< T >( r );
             std::weak_ptr< T > weak{ pr };
-            std::thread([=]() {
-                std::this_thread::sleep_for(n_seconds);
+            std::thread( [=]() {
+                std::this_thread::sleep_for( n_seconds );
                 auto pr = weak.lock();
-                if (pr && pr->get_id() == id)
+                if( pr && pr->get_id() == id )
                 {
-                    ((retrier *)pr.get())->retry();
+                    try
+                    {
+                        AC_LOG( DEBUG, _prefix( name, id ) << "triggering" );
+                        auto ac = ( (retrier *)pr.get() )->get_ac();
+                        if( ac )
+                            ( (retrier *)pr.get() )->retry( *ac );
+                    }
+                    catch( std::exception const & e )
+                    {
+                        // Unexpected! If we don't handle, we'll crash!
+                        AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+                    }
                 }
                 else
                     AC_LOG( DEBUG,
-                            name << ' ' << id << ": " << n_seconds.count()
-                                 << " seconds are up; nothing needed" );
+                            _prefix( name, id )
+                                << n_seconds.count() << " seconds are up; nothing needed" );
             } ).detach();
             return pr;
-        };
+        }
+    };
+    class ac_trigger::next_trigger : public ac_trigger::retrier
+    {
+    public:
+        next_trigger( ac_trigger & ac, const char * name )
+            : retrier( ac, name ? name : "next trigger" )
+        {
+        }
+
+    private:
+        void retry( ac_trigger & trigger ) override
+        {
+            // We start another trigger regardless of what happens next; if a calibration actually
+            // proceeds, it will be cancelled...
+            trigger.schedule_next_calibration();
+            try
+            {
+                trigger.trigger_calibration( calibration_type::AUTO );
+            }
+            catch( invalid_value_exception const & )
+            {
+                // Invalid conditions for calibration
+                // Error should already have been printed
+                // We should already have the next triggers set -- do nothing else
+            }
+        }
     };
     class ac_trigger::temp_check : public ac_trigger::retrier
     {
@@ -286,40 +390,51 @@ namespace ivcam2 {
         }
 
     private:
-        void retry() override
+        void retry( ac_trigger & trigger ) override
         {
-            auto & trigger = get_ac();
             if( trigger.is_active() )
             {
-                AC_LOG( DEBUG, "temp check " << get_id() << ": AC already active" );
+                AC_LOG( DEBUG, "... already active; ignoring" );
                 return;
             }
+            // We start another trigger regardless of what happens next; if a calibration actually
+            // proceeds, it will be cancelled...
+            trigger.schedule_next_temp_trigger();
             auto current_temp = trigger.read_temperature();
-            auto d_temp = current_temp - trigger._last_temp;
-            if( d_temp >= get_temp_diff_trigger() )
+            if( current_temp )
             {
-                AC_LOG( DEBUG, "Delta since last calibration is " << d_temp << " degrees Celsius; triggering..." );
-                trigger.trigger_calibration();
-            }
-            else
-            {
-                // We do not update the trigger temperature: that is only updated after calibration
-                AC_LOG( DEBUG, "Delta since last calibration is " << d_temp << " degrees Celsius" );
-                trigger._temp_check = retrier::start< temp_check >( trigger, std::chrono::seconds( 60 ) );
+                auto d_temp = current_temp - trigger._last_temp;
+                if( d_temp >= get_temp_diff_trigger() )
+                {
+                    try
+                    {
+                        AC_LOG( DEBUG, "Delta since last successful calibration is " << d_temp << " degrees Celsius; triggering..." );
+                        trigger.trigger_calibration( calibration_type::AUTO );
+                    }
+                    catch( invalid_value_exception const & )
+                    {
+                        // Invalid conditions for calibration
+                        // Error should already have been printed
+                        // We should already have the next trigger set -- do nothing else
+                    }
+                }
+                // We do not update the trigger temperature: it is only updated after calibration
             }
         }
     };
 
 
     /*
-        Temporary (?) class used to direct AC logs to either console or a special log
+        Temporary (?) class used to direct CAH logs to either console or a special log
 
         If RS2_DEBUG_DIR is defined in the environment, we try to create a log file in there
         that has the name "<pid>.ac_log".
     */
-    class ac_logger : public rs2_log_callback
+    class ac_trigger::ac_logger : public rs2_log_callback
     {
-        std::ofstream _f;
+        std::ofstream _f_main;
+        std::ofstream _f_active;
+        std::string _active_dir;
         bool _to_stdout;
 
     public:
@@ -327,24 +442,114 @@ namespace ivcam2 {
             : _to_stdout( to_stdout )
         {
             using namespace std::chrono;
-            auto dir = getenv( "RS2_DEBUG_DIR" );
-            if( dir )
+
+#ifdef WIN32
+            // In the Viewer, a console does not exist (even when run from a console) because
+            // it's a WIN32 application (this can be removed in its CMakeLists.txt) -- so we
+            // need to create one.
+            if( _to_stdout )
             {
-                std::string filename = to_string()
-                    << dir
-                    << system_clock::now().time_since_epoch().count() * system_clock::period::num / system_clock::period::den
-                    << ".ac_log";
-
-                _f.open( filename );
-                if( _f  &&  _to_stdout )
-                    std::cout << "-D- AC log is being written to: " << filename << std::endl;
+                if( AttachConsole( ATTACH_PARENT_PROCESS ) || AllocConsole() )
+                    write_out( std::string{} );  // for a newline
+            }
+#endif
+
+            std::string filename = get_debug_path_base();
+            if( ! filename.empty() )
+            {
+                filename += ".ac_log";
+
+                _f_main.open( filename );
+                if( _f_main  &&  _to_stdout )
+                    write_out( to_string() << "-D- CAH main log is being written to: " << filename );
             }
 
             librealsense::log_to_callback( RS2_LOG_SEVERITY_ALL,
-                { this, []( rs2_log_callback * p ) {} } );
+                                            { this, []( rs2_log_callback * p ) {} } );
+
             AC_LOG( DEBUG, "LRS version: " << RS2_API_FULL_VERSION_STR );
         }
 
+        static void add_dir_sep( std::string & path )
+        {
+#ifdef _WIN32
+            char const dir_sep = '\\';
+#else
+            char const dir_sep = '/';
+#endif
+            if( ! path.empty() && path.back() != dir_sep )
+                path += dir_sep;
+        }
+
+        static std::string get_debug_path_base()
+        {
+            std::string path;
+
+            // If the user has this env var defined, then we write out logs and frames to it
+            // NOTE: The var should end with a directory separator \ or /
+            auto dir_ = getenv( "RS2_DEBUG_DIR" );
+            if( dir_ )
+            {
+                path = dir_;
+                add_dir_sep( path );
+                path += now_string( "%y%m%d.%H%M%S" );
+            }
+            
+            return path;
+        }
+
+        bool set_active_dir()
+        {
+            _active_dir = get_debug_path_base();
+            if( _active_dir.empty() )
+                return false;
+            add_dir_sep( _active_dir );
+
+#ifdef _WIN32
+            auto status = _mkdir( _active_dir.c_str() );
+#else
+            auto status = mkdir( _active_dir.c_str(), 0700 ); // 0700 = user r/w/x
+#endif
+
+            if( status != 0 )
+            {
+                AC_LOG( WARNING,
+                        "Failed (" << status << ") to create directory for AC frame data in: " << _active_dir );
+                _active_dir.clear();
+                return false;
+            }
+            return true;
+        }
+
+        std::string const & get_active_dir() const { return _active_dir; }
+
+        void open_active()
+        {
+            close_active();
+            if( ! set_active_dir() )
+                return;
+            std::string filename = get_active_dir() + "ac.log";
+            if( _f_main || _to_stdout )
+                AC_LOG( DEBUG, now_string() << "  Active calibration log is being written to: " << filename );
+            _f_active.open( filename );
+            if( ! _f_active )
+                AC_LOG( DEBUG, "             failed!" );
+            else if( _to_stdout )
+                write_out( to_string() << "-D- CAH active log is being written to: " << filename );
+        }
+
+        void close_active()
+        {
+            if( _f_active )
+            {
+                _f_active.close();
+                _f_active.setstate( std::ios_base::failbit );  // so we don't try to write to it
+                _active_dir.clear();
+                if( _f_main )
+                    AC_LOG( DEBUG, now_string() << "  ... done" );
+            }
+        }
+
         void on_log( rs2_log_severity severity, rs2_log_message const & msg ) noexcept override
         {
             log_message const & wrapper = (log_message const &)(msg);
@@ -356,22 +561,47 @@ namespace ivcam2 {
             ss << (raw + 5);
             std::string text = ss.str();
             if( _to_stdout )
-                std::cout << text << std::endl;
-            if( _f )
-                _f << text << std::endl;
+                write_out( text );
+            if( _f_active )
+                _f_active << text << std::endl;
+            else if( _f_main )
+                _f_main << text << std::endl;
         }
 
         void release() override { delete this; }
+
+    private:
+        static void write_out( std::string const & s )
+        {
+#ifdef WIN32
+            HANDLE stdOut = GetStdHandle( STD_OUTPUT_HANDLE );
+            if( stdOut != NULL && stdOut != INVALID_HANDLE_VALUE )
+            {
+                DWORD written = 0;
+                WriteConsoleA( stdOut, s.c_str(), (DWORD)s.length(), &written, NULL );
+                WriteConsoleA( stdOut, "\n\r", 2, &written, NULL );
+            }
+#else
+            std::cout << s << std::endl;
+#endif
+        }
     };
 
 
-    ac_trigger::ac_trigger( l500_device & dev, hw_monitor & hwm )
+    ac_trigger::ac_trigger( l500_device & dev, std::shared_ptr<hw_monitor> hwm )
         : _hwm( hwm )
         , _dev( dev )
+    {
+        get_ac_logger();
+    }
+
+
+    ac_trigger::ac_logger & ac_trigger::get_ac_logger()
     {
         static ac_logger one_logger(
             env_var< bool >( "RS2_AC_LOG_TO_STDOUT", false )  // log to stdout
             );
+        return one_logger;
     }
 
 
@@ -380,124 +610,174 @@ namespace ivcam2 {
         if( _worker.joinable() )
         {
             _is_processing = false;  // Signal the thread that we want to stop!
+            _is_on = false;          // Set auto calibration off so it won't retry.
             _worker.join();
         }
     }
 
 
-    void ac_trigger::trigger_calibration( bool is_retry )
+    void ac_trigger::call_back( rs2_calibration_status status )
+    {
+        _last_status_sent = status;
+        for( auto && cb : _callbacks )
+            cb( status );
+    }
+
+
+    void ac_trigger::trigger_retry()
     {
-        if (false == _dev.get_depth_sensor().is_streaming())
+        _retrier.reset();
+        if( ! is_active() )
         {
-            AC_LOG(ERROR, "Depth streaming not found, canceling calibration");
-            stop();
+            AC_LOG( ERROR, "Retry attempted but we're not active; ignoring" );
             return;
         }
-
-        _retrier.reset();
-        if(is_retry  &&  is_active() )
+        if( _need_to_wait_for_color_sensor_stability )
         {
-            if( _recycler )
-            {
-                // This is another cycle of AC, after we've woken up from some time after
-                // the previous invalid-scene or bad-result...
-                _n_retries = 0;
-                _recycler.reset();
-            }
-            else if( ++_n_retries > 4 )
-            {
-                AC_LOG( ERROR, "too many retries; aborting" );
-                stop_color_sensor_if_started();
-                call_back( RS2_CALIBRATION_FAILED );
-                calibration_is_done();
-                return;
-            }
+            AC_LOG( ERROR, "Failed to receive stable RGB frame; cancelling calibration" );
+            cancel_current_calibration();
+            return;
+        }
 
-            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle " << _n_cycles << " retry " << _n_retries << ")" );
-            call_back( RS2_CALIBRATION_RETRY );
+        try
+        {
+            check_conditions();
         }
-        else
+        catch( invalid_value_exception const & )
         {
-            if( is_active() )
-            {
-                AC_LOG( ERROR, "Failed to trigger calibration: AC is already active" );
-                return;
-            }
+            //AC_LOG( ERROR, "Cancelling calibration" );
+            cancel_current_calibration();
+            return;
+        }
+
+        if( _recycler )
+        {
+            // This is another cycle of AC, after we've woken up from some time after
+            // the previous invalid-scene or bad-result...
             _n_retries = 0;
-            _n_cycles = 1;          // now active
-            AC_LOG( INFO, "Camera Accuracy Health check has started in the background" );
-            _next_trigger.reset();  // don't need a trigger any more
-            _temp_check.reset();    // nor a temperature check
-            _recycler.reset();      // just in case
-            start_color_sensor_if_needed();
-            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle 1); now active..." );
+            _recycler.reset();
         }
-        command cmd{ GET_SPECIAL_FRAME, 0x5F, 1 };  // 5F = SF = Special Frame, for easy recognition
-        try
+        else if( ++_n_retries > 4 )
         {
-            _hwm.send( cmd );
+            AC_LOG( ERROR, "Too many retries; aborting" );
+            cancel_current_calibration();
+            return;
         }
-        catch( std::exception const & e )
+
+        call_back( RS2_CALIBRATION_RETRY );
+
+        start_color_sensor_if_needed();
+        if( _need_to_wait_for_color_sensor_stability )
         {
-            AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+            AC_LOG( DEBUG, "Waiting for RGB stability before asking for special frame" );
+            _retrier = retrier::start( *this, std::chrono::seconds( get_retry_sf_seconds() + 1 ) );
         }
-        // Start a timer: enable retries if something's wrong with the special frame
-        if (is_active())
+        else
         {
-            _retrier = retrier::start(*this, std::chrono::seconds(get_retry_sf_seconds()));
+            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle " << _n_cycles << " retry " << _n_retries << ")" );
+            trigger_special_frame();
         }
     }
 
 
-    template<class T>
-    frame_callback_ptr make_frame_callback( T callback )
+    void ac_trigger::trigger_special_frame()
     {
-        return {
-            new internal_frame_callback<T>( callback ),
-            []( rs2_frame_callback* p ) { p->release(); }
-        };
+        command cmd{ GET_SPECIAL_FRAME, 0x5F, 1 };  // 5F = SF = Special Frame, for easy recognition
+        try
+        {
+            auto hwm = _hwm.lock();
+            if( ! hwm )
+            {
+                AC_LOG( ERROR, "Hardware monitor is inaccessible - calibration not triggered" );
+                return;
+            }
+            hwm->send( cmd );
+        }
+        catch( std::exception const & e )
+        {
+            AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+        }
+        // Start a timer: enable retries if something's wrong with the special frame
+        if( is_active() )
+            _retrier = retrier::start( *this, std::chrono::seconds( get_retry_sf_seconds() ) );
     }
 
 
-    void ac_trigger::start_color_sensor_if_needed()
+    void ac_trigger::trigger_calibration( calibration_type type )
     {
-        // With AC, we need a color sensor even when the user has not asked for one --
-        // otherwise we risk misalignment over time. We turn it on automatically!
+        if( is_active() )
+        {
+            AC_LOG( ERROR, "Failed to trigger calibration: CAH is already active" );
+            throw wrong_api_call_sequence_exception( "CAH is already active" );
+        }
+        if( _retrier.get() || _recycler.get() )
+        {
+            AC_LOG( ERROR, "Bad inactive state: one of retrier or recycler is set!" );
+            throw std::runtime_error( "bad inactive state" );
+        }
 
-        auto color_sensor = _dev.get_color_sensor();
-        if( !color_sensor )
+        _calibration_type = type;
+        AC_LOG( DEBUG, "Calibration type is " << (type == calibration_type::MANUAL ? "MANUAL" : "AUTO") );
+        
+        try
         {
-            AC_LOG( ERROR, "No color sensor in device; cannot run AC?!" );
-            return;
+            check_conditions();
+        }
+        catch( invalid_value_exception const & )
+        {
+            call_back( RS2_CALIBRATION_BAD_CONDITIONS );
+            // Above throws invalid_value_exception, which we want: if calibration is triggered
+            // under bad conditions, we want the user to get this!
+            throw;
         }
 
-        if( color_sensor->is_streaming() )
+        _n_retries = 0;
+        _n_cycles = 1;          // now active
+        get_ac_logger().open_active();
+        AC_LOG( INFO, "Camera Accuracy Health check is now active (HUM temp is " << _temp << " dec C)" );
+        call_back( RS2_CALIBRATION_TRIGGERED );
+        _next_trigger.reset();  // don't need a trigger any more
+        _temp_check.reset();    // nor a temperature check
+        start_color_sensor_if_needed();
+        if( _need_to_wait_for_color_sensor_stability )
         {
-            AC_LOG( DEBUG, "Color sensor is already streaming" );
-            return;
+            AC_LOG( DEBUG, "Waiting for RGB stability before asking for special frame" );
+            _retrier = retrier::start( *this, std::chrono::seconds( get_retry_sf_seconds() + 1 ) );
         }
+        else
+        {
+            AC_LOG( DEBUG, "Sending GET_SPECIAL_FRAME (cycle 1)" );
+            trigger_special_frame();
+        }
+    }
 
-        AC_LOG( INFO, "Color sensor was NOT streaming; turning on..." );
 
+    void ac_trigger::start_color_sensor_if_needed()
+    {
+        // With AC, we need a color sensor even when the user has not asked for one --
+        // otherwise we risk misalignment over time. We turn it on automatically!
         try
         {
+            auto color_sensor = _dev.get_color_sensor();
+            if( ! color_sensor )
+            {
+                AC_LOG( ERROR, "No color sensor in device; cannot run AC?!" );
+                return;
+            }
+
             auto & depth_sensor = _dev.get_depth_sensor();
             auto rgb_profile = depth_sensor.is_color_sensor_needed();
-            if( !rgb_profile )
+            if( ! rgb_profile )
                 return;  // error should have already been printed
             //AC_LOG( DEBUG, "Picked profile: " << *rgb_profile );
 
-            AC_LOG( DEBUG, "Open..." );
-            color_sensor->open( { rgb_profile } );
-            AC_LOG( DEBUG, "Start..." );
-
-            color_sensor->start(make_frame_callback([&](frame_holder fref) {}));
-
-            AC_LOG( DEBUG, "Started!" );
-            // Note that we don't do anything with the frames -- they shouldn't end up
-            // at the user. But AC will still get them.
-
-            _own_color_stream = true;
+            // If we just started the sensor, especially for AC, then we cannot simply take
+            // the first RGB frame we get: for various reasons, including auto exposure, the
+            // first frames we receive cannot be used (there's a "fade-in" effect). So we
+            // only enable frame capture after some time has passed (see set_color_frame):
+            _rgb_sensor_start = std::chrono::high_resolution_clock::now();
+            _need_to_wait_for_color_sensor_stability
+                = color_sensor->start_stream_for_calibration( { rgb_profile } );
         }
         catch( std::exception const & e )
         {
@@ -508,27 +788,37 @@ namespace ivcam2 {
 
     void ac_trigger::stop_color_sensor_if_started()
     {
-        if( !_own_color_stream.exchange( false ) )
-            return;
+        _need_to_wait_for_color_sensor_stability = false;  // jic
 
-        AC_LOG( INFO, "STOPPING color sensor..." );
-        auto & color_sensor = *_dev.get_color_sensor();
-        color_sensor.stop();
-        AC_LOG( INFO, "CLOSING color sensor..." );
-        color_sensor.close();
-        AC_LOG( INFO, "Closed!" );
+        // By using a thread we protect a case that tries to close a sensor from it's processing block callback and creates a deadlock.
+        std::thread([&]()
+        {
+            try
+            {
+                auto & color_sensor = *_dev.get_color_sensor();
+                color_sensor.stop_stream_for_calibration();
+            }
+            catch (std::exception& ex)
+            {
+                AC_LOG(ERROR, "caught exception in closing color sensor: " << ex.what());
+            }
+            catch (...)
+            {
+                AC_LOG(ERROR, "unknown exception in closing color sensor");
+            }
+        }).detach();
+        
     }
 
 
     void ac_trigger::set_special_frame( rs2::frameset const & fs )
     {
-        if( !is_active() )
+        if( ! is_active() )
         {
             AC_LOG( ERROR, "Special frame received while is_active() is false" );
             return;
         }
 
-        AC_LOG( DEBUG, "special frame received :)" );
         // Notify of the special frame -- mostly for validation team so they know to expect a frame
         // drop...
         call_back( RS2_CALIBRATION_SPECIAL_FRAME );
@@ -539,14 +829,14 @@ namespace ivcam2 {
             return;
         }
         auto irf = fs.get_infrared_frame();
-        if( !irf )
+        if( ! irf )
         {
             AC_LOG( ERROR, "no IR frame found; ignoring special frame!" );
             //call_back( RS2_CALIBRATION_FAILED );
             return;
         }
         auto df = fs.get_depth_frame();
-        if( !df )
+        if( ! df )
         {
             AC_LOG( ERROR, "no depth frame found; ignoring special frame!" );
             //call_back( RS2_CALIBRATION_FAILED );
@@ -555,18 +845,6 @@ namespace ivcam2 {
 
         _retrier.reset();  // No need to activate a retry if the following takes a bit of time!
 
-        // We have to read the FW registers at the time of the special frame.
-        // NOTE: the following is I/O to FW, meaning it takes time! In this time, another
-        // thread can receive a set_color_frame() and, since we've already received the SF,
-        // start working even before we finish! NOT GOOD!
-        ivcam2::read_fw_register( _hwm, &_dsm_x_scale, 0xfffe3844 );
-        ivcam2::read_fw_register( _hwm, &_dsm_y_scale, 0xfffe3830 );
-        ivcam2::read_fw_register( _hwm, &_dsm_x_offset, 0xfffe3840 );
-        ivcam2::read_fw_register( _hwm, &_dsm_y_offset, 0xfffe382c );
-        AC_LOG( DEBUG, "dsm registers=  x[" << AC_F_PREC << _dsm_x_scale << ' ' << _dsm_y_scale
-            << "]  +[" << _dsm_x_offset << ' ' << _dsm_y_offset
-            << "]" );
-
         _sf = fs;  // Assign right before the sync otherwise we may start() prematurely
         _sf.keep();
         std::lock_guard< std::mutex > lock( _mutex );
@@ -582,6 +860,33 @@ namespace ivcam2 {
         if( ! is_active()  ||  _is_processing )
             // No error message -- we expect to get new color frames while processing...
             return;
+        if( _need_to_wait_for_color_sensor_stability )
+        {
+            // Wait at least a second before we deem the sensor stable enough
+            auto time = std::chrono::high_resolution_clock::now() - _rgb_sensor_start;
+            if( time < std::chrono::milliseconds( 1000 ) )
+                return;
+
+            auto number = f.get_frame_number();
+            AC_LOG( DEBUG, "RGB frame #" << number << " is our first stable frame" );
+            if( f.supports_frame_metadata( RS2_FRAME_METADATA_ACTUAL_EXPOSURE ) )
+            {
+                AC_LOG( DEBUG,
+                        "    actual exposure= "
+                            << f.get_frame_metadata( RS2_FRAME_METADATA_ACTUAL_EXPOSURE ) );
+                AC_LOG( DEBUG,
+                        "    backlight compensation= "
+                            << f.get_frame_metadata( RS2_FRAME_METADATA_BACKLIGHT_COMPENSATION ) );
+                AC_LOG( DEBUG,
+                        "    brightness= "
+                            << f.get_frame_metadata( RS2_FRAME_METADATA_BRIGHTNESS ) );
+                AC_LOG( DEBUG,
+                        "    contrast= "
+                            << f.get_frame_metadata( RS2_FRAME_METADATA_CONTRAST ) );
+            }
+            _need_to_wait_for_color_sensor_stability = false;
+            trigger_special_frame();
+        }
 
         _pcf = _cf;
         _cf = f;
@@ -624,9 +929,9 @@ namespace ivcam2 {
                 "Starting processing:"
                     << "  color #" << _cf.get_frame_number() << " " << _cf.get_profile()
                     << "  depth #" << _sf.get_frame_number() << ' ' << _sf.get_profile() );
+        stop_color_sensor_if_started();
         _is_processing = true;
         _retrier.reset();
-        stop_color_sensor_if_started();
         if( _worker.joinable() )
         {
             AC_LOG( DEBUG, "Waiting for worker to join ..." );
@@ -639,31 +944,76 @@ namespace ivcam2 {
                     AC_LOG( DEBUG, "Calibration algo has started ..." );
                     call_back( RS2_CALIBRATION_STARTED );
 
-                    static algo::depth_to_rgb_calibration::algo_calibration_info cal_info;
-                    static bool cal_info_initialized = false;
-                    if( !cal_info_initialized )
+                    // We have to read the FW registers at the time of the special frame, but we
+                    // cannot do it from set_special_frame() because it takes time and we should not
+                    // hold up the thread that the frame callbacks are on!
+                    float dsm_x_scale, dsm_y_scale, dsm_x_offset, dsm_y_offset;
+                    algo::depth_to_rgb_calibration::algo_calibration_info cal_info;
                     {
-                        cal_info_initialized = true;
-                        ivcam2::read_fw_table( _hwm, cal_info.table_id, &cal_info );  // throws!
+                        auto hwm = _hwm.lock();
+                        if( ! hwm )
+                            throw std::runtime_error( "HW monitor is inaccessible - stopping algo" );
+
+                        ivcam2::read_fw_register( *hwm, &dsm_x_scale, 0xfffe3844 );
+                        ivcam2::read_fw_register( *hwm, &dsm_y_scale, 0xfffe3830 );
+                        ivcam2::read_fw_register( *hwm, &dsm_x_offset, 0xfffe3840 );
+                        ivcam2::read_fw_register( *hwm, &dsm_y_offset, 0xfffe382c );
+
+                        ivcam2::read_fw_table( *hwm, cal_info.table_id, &cal_info );
+
+                        // If the above throw (and they can!) then we catch below and stop...
                     }
+
+                    AC_LOG( DEBUG,
+                            "dsm registers=  x[" << AC_F_PREC << dsm_x_scale << ' ' << dsm_y_scale
+                                                 << "]  +[" << dsm_x_offset << ' ' << dsm_y_offset
+                                                 << "]" );
                     algo::depth_to_rgb_calibration::algo_calibration_registers cal_regs;
-                    cal_regs.EXTLdsmXscale = _dsm_x_scale;
-                    cal_regs.EXTLdsmYscale = _dsm_y_scale;
-                    cal_regs.EXTLdsmXoffset = _dsm_x_offset;
-                    cal_regs.EXTLdsmYoffset = _dsm_y_offset;
+                    cal_regs.EXTLdsmXscale  = dsm_x_scale;
+                    cal_regs.EXTLdsmYscale  = dsm_y_scale;
+                    cal_regs.EXTLdsmXoffset = dsm_x_offset;
+                    cal_regs.EXTLdsmYoffset = dsm_y_offset;
 
                     auto df = _sf.get_depth_frame();
                     auto irf = _sf.get_infrared_frame();
-                    depth_to_rgb_calibration algo( df, irf, _cf, _pcf, cal_info, cal_regs );
+
+                    auto should_continue = [&]()
+                    {
+                        if( ! is_processing() )
+                        {
+                            AC_LOG( DEBUG, "Stopping algo: not processing any more" );
+                            throw std::runtime_error( "stopping algo: not processing any more" );
+                        }
+                    };
+                    algo::depth_to_rgb_calibration::optimizer::settings settings;
+                    settings.is_manual_trigger = _calibration_type == calibration_type::MANUAL;
+                    settings.hum_temp = _temp;
+                    settings.ambient = _ambient;
+                    settings.receiver_gain = _receiver_gain;
+                    depth_to_rgb_calibration algo( settings,
+                                                   df, irf,
+                                                   _cf, _pcf, _last_yuy_data,
+                                                   cal_info, cal_regs,
+                                                   should_continue );
+
+                    std::string debug_dir = get_ac_logger().get_active_dir();
+                    if( ! debug_dir.empty() )
+                        algo.write_data_to( debug_dir );
+
                     _from_profile = algo.get_from_profile();
                     _to_profile = algo.get_to_profile();
 
-                    auto status = algo.optimize(
-                        [this]( rs2_calibration_status status ) { call_back( status ); } );
+                    rs2_calibration_status status = RS2_CALIBRATION_FAILED;  // assume fail until we get a success
+
+                    if( is_processing() )  // check if the device still exists
+                    {
+                        status = algo.optimize(
+                            [this]( rs2_calibration_status status ) { call_back( status ); });
+                    }
 
                     // It's possible that, while algo was working, stop() was called. In this case,
                     // we have to make sure that we notify of failure:
-                    if( !is_active() )
+                    if( ! is_processing() )
                     {
                         AC_LOG( DEBUG, "Algo finished (with " << status << "), but stop() was detected; notifying of failure..." );
                         status = RS2_CALIBRATION_FAILED;
@@ -675,7 +1025,10 @@ namespace ivcam2 {
                         _extr = algo.get_extrinsics();
                         _intr = algo.get_intrinsics();
                         _dsm_params = algo.get_dsm_params();
-                        // Fall-thru!
+                        call_back( status );  // if this throws, we don't want to do the below:
+                        _last_temp = _temp;
+                        _last_yuy_data = std::move( algo.get_last_successful_frame_data() );
+                        break;
                     case RS2_CALIBRATION_NOT_NEEDED:
                         // This is the same as SUCCESSFUL, except there was no change because the
                         // existing calibration is good enough. We notify and exit.
@@ -686,15 +1039,18 @@ namespace ivcam2 {
                         if( ++_n_cycles > 5 )
                         {
                             // ... but we've tried too many times
-                            AC_LOG( ERROR, "Too many cycles of calibration; quitting" );
+                            AC_LOG( ERROR, "Too many retry cycles; quitting" );
                             call_back( RS2_CALIBRATION_FAILED );
                         }
                         else
                         {
-                            AC_LOG( DEBUG, "Triggering another cycle for calibration..." );
-                            int n_seconds = env_var< int >( "RS2_AC_INVALID_RETRY_SECONDS",
-                                2,  // TODO: should be 60, but changed for manual trigger
-                                []( int n ) { return n > 0; } );
+                            AC_LOG( DEBUG, "Waiting for retry cycle " << _n_cycles << " ..." );
+                            bool const is_manual = _calibration_type == calibration_type::MANUAL;
+                            int n_seconds
+                                = env_var< int >( is_manual ? "RS2_AC_INVALID_RETRY_SECONDS_MANUAL"
+                                                            : "RS2_AC_INVALID_RETRY_SECONDS_AUTO",
+                                                  is_manual ? 2 : 60,
+                                                  []( int n ) { return n > 0; } );
                             _recycler = retrier::start( *this, std::chrono::seconds( n_seconds ) );
                         }
                         break;
@@ -706,21 +1062,44 @@ namespace ivcam2 {
                         // All the rest of the codes are not end-states of the algo, so we don't expect
                         // to get here!
                         AC_LOG( ERROR,
-                            "Unexpected status '" << status << "' received from AC algo; stopping!" );
+                            "Unexpected status '" << status << "' received from CAH algo; stopping!" );
                         call_back( RS2_CALIBRATION_FAILED );
                         break;
                     }
                 }
-                catch( std::exception& ex )
+                catch( std::exception & e )
                 {
-                    AC_LOG( ERROR, "caught exception in calibration algo: " << ex.what() );
-                    call_back( RS2_CALIBRATION_FAILED );
+                    AC_LOG( ERROR, "EXCEPTION in calibration algo: " << e.what() );
+                    try
+                    {
+                        call_back( RS2_CALIBRATION_FAILED );
+                    }
+                    catch( std::exception & e )
+                    {
+                        AC_LOG( ERROR, "EXCEPTION in FAILED callback: " << e.what() );
+                    }
+                    catch( ... )
+                    {
+                        AC_LOG( ERROR, "EXCEPTION in FAILED callback!" );
+                    }
                 }
                 catch( ... )
                 {
-                    AC_LOG( ERROR, "unknown exception in calibration algo!!!" );
-                    call_back( RS2_CALIBRATION_FAILED );
+                    AC_LOG( ERROR, "Unknown EXCEPTION in calibration algo!!!" );
+                    try
+                    {
+                        call_back( RS2_CALIBRATION_FAILED );
+                    }
+                    catch( std::exception & e )
+                    {
+                        AC_LOG( ERROR, "EXCEPTION in FAILED callback: " << e.what() );
+                    }
+                    catch( ... )
+                    {
+                        AC_LOG( ERROR, "EXCEPTION in FAILED callback!" );
+                    }
                 }
+                _is_processing = false;  // to avoid debug msg in reset()
                 reset();
                 switch( _last_status_sent )
                 {
@@ -734,34 +1113,87 @@ namespace ivcam2 {
     }
 
 
-    void ac_trigger::calibration_is_done()
+    void ac_trigger::cancel_current_calibration()
     {
-        // We get here when we've reached some final state (failed/successful)
-        _n_cycles = 0;  // now inactive
-        if( _last_status_sent != RS2_CALIBRATION_SUCCESSFUL )
-            AC_LOG( WARNING, "Camera Accuracy Health has finished unsuccessfully" );
+        if( ! is_active() )
+            return;
+        if( is_processing() )
+        {
+            reset();
+            // Wait until we're out of run_algo() -- until then, we're active!
+        }
         else
-            AC_LOG( INFO, "Camera Accuracy Health has finished" );
+        {
+            stop_color_sensor_if_started();
+            call_back( RS2_CALIBRATION_FAILED );
+            reset();
+            _retrier.reset();
+            _recycler.reset();
+            calibration_is_done();
+        }
+    }
+
 
-        // Trigger the next AC -- but only if we're "on", meaning this wasn't a manual calibration
-        if( !auto_calibration_is_on() )
+    void ac_trigger::calibration_is_done()
+    {
+        if( is_active() )
+        {
+            // We get here when we've reached some final state (failed/successful)
+            if( _last_status_sent != RS2_CALIBRATION_SUCCESSFUL )
+                AC_LOG( WARNING, "Camera Accuracy Health has finished unsuccessfully" );
+            else
+                AC_LOG( INFO, "Camera Accuracy Health has finished" );
+            set_not_active();
+        }
+
+        schedule_next_calibration();
+    }
+
+
+    void ac_trigger::set_not_active()
+    {
+        _n_cycles = 0;
+        get_ac_logger().close_active();
+    }
+
+
+    void ac_trigger::schedule_next_calibration()
+    {
+        // Trigger the next CAH -- but only if we're "on", meaning this wasn't a manual calibration
+        if( ! auto_calibration_is_on() )
         {
             AC_LOG( DEBUG, "Calibration mechanism is not on; not scheduling next calibration" );
             return;
         }
 
-        // Trigger after a set amount of time
-        auto n_seconds = get_trigger_seconds();
-        if( n_seconds.count() )
-            start( n_seconds );
-        else
-            AC_LOG( DEBUG, "RS2_AC_TRIGGER_SECONDS is 0; no time trigger" );
-        
-        // Or after a certain temperature change
-        if( get_temp_diff_trigger() )
+        schedule_next_time_trigger();
+        schedule_next_temp_trigger();
+    }
+
+    void ac_trigger::schedule_next_time_trigger( std::chrono::seconds n_seconds )
+    {
+        if( ! n_seconds.count() )
+        {
+            n_seconds = get_trigger_seconds();
+            if (!n_seconds.count())
+            {
+                AC_LOG(DEBUG, "RS2_AC_TRIGGER_SECONDS is 0; no time trigger");
+                return;
+            }
+        }
+
+        // If there's already a trigger, this will simply override it
+        _next_trigger = retrier::start< next_trigger >( *this, n_seconds );
+    }
+
+    void ac_trigger::schedule_next_temp_trigger()
+    {
+        // If no _last_temp --> first calibration! We want to keep checking every minute
+        // until temperature is within proper conditions...
+        if( get_temp_diff_trigger()  ||  ! _last_temp )
         {
-            if( _last_temp = read_temperature() )
-                _temp_check = retrier::start< temp_check >( *this, std::chrono::seconds( 60 ) );
+            //AC_LOG( DEBUG, "Last HUM temperature= " << _last_temp );
+            _temp_check = retrier::start< temp_check >( *this, std::chrono::seconds( 60 ) );
         }
         else
         {
@@ -772,77 +1204,192 @@ namespace ivcam2 {
 
     double ac_trigger::read_temperature()
     {
+        auto hwm = _hwm.lock();
+        if( ! hwm )
+        {
+            AC_LOG( ERROR, "Hardware monitor is inaccessible; cannot read temperature" );
+            return 0.;
+        }
         // The temperature may depend on streaming?
-        auto res = _hwm.send( command{ TEMPERATURES_GET } );
+        std::vector<byte> res;
+
+        try
+        {
+            res = hwm->send(command{ TEMPERATURES_GET });
+        }
+        catch (std::exception const & e)
+        {
+            AC_LOG(ERROR,
+                "Failed to get temperatures; hardware monitor in inaccessible: " << e.what());
+            return 0.;
+        }
+
         if( res.size() < sizeof( temperatures ) )  // New temperatures may get added by FW...
         {
             AC_LOG( ERROR,
                     "Failed to get temperatures; result size= "
                         << res.size() << "; expecting at least " << sizeof( temperatures ) );
-            return 0;
+            return 0.;
         }
         auto const & ts = *( reinterpret_cast< temperatures * >( res.data() ) );
         AC_LOG( DEBUG, "HUM temperture is currently " << ts.HUM_temperature << " degrees Celsius" );
         return ts.HUM_temperature;
     }
 
-    void ac_trigger::start( std::chrono::seconds n_seconds )
+
+    void ac_trigger::check_conditions()
     {
-        if( is_active() )
-            throw wrong_api_call_sequence_exception( "AC is already active" );
+        // Make sure we're still streaming
+        bool is_streaming = false;
+        try
+        {
+            is_streaming = _dev.get_depth_sensor().is_streaming();
+        }
+        catch( std::exception const & e )
+        {
+            AC_LOG( ERROR, "EXCEPTION caught: " << e.what() );
+        }
+        if( ! is_streaming )
+        {
+            AC_LOG( ERROR, "Not streaming; stopping" );
+            stop();
+            throw wrong_api_call_sequence_exception( "not streaming" );
+        }
 
-        if( !n_seconds.count() )
+        std::string invalid_reason;
+
+        // Temperature must be within range or algo may not work right
+        _temp = read_temperature();
+        if( _temp < 32. )
+        {
+            if( ! invalid_reason.empty() )
+                invalid_reason += ", ";
+            invalid_reason += to_string() << "temperature (" << _temp << ") too low (<32)";
+        }
+        else if( _temp > 46. )
+        {
+            if( ! invalid_reason.empty() )
+                invalid_reason += ", ";
+            invalid_reason += to_string() << "temperature (" << _temp << ") too high (>46)";
+        }
+
+        // Algo was written with specific receiver gain (APD) in mind, depending on
+        // the FW preset (ambient light)
+        auto & depth_sensor = _dev.get_depth_sensor();
+        auto & ambient_light = depth_sensor.get_option( RS2_OPTION_AMBIENT_LIGHT );
+        float raw_ambient = ambient_light.query();
+        auto & apd = depth_sensor.get_option( RS2_OPTION_AVALANCHE_PHOTO_DIODE );
+        float raw_apd = apd.query();
+        _receiver_gain = int( raw_apd );
+        _ambient = ( rs2_ambient_light ) int( raw_ambient );
+        switch( _ambient )
         {
-#if 0 // TODO on auto trigger, we want this back
-            option & o = _dev.get_depth_sensor().get_option( RS2_OPTION_CAMERA_ACCURACY_HEALTH_ENABLED );
-            if( !o.query() )
+        case RS2_AMBIENT_LIGHT_LOW_AMBIENT:  // SHORT
+            if( _receiver_gain != 18 )
             {
-                // auto trigger is turned off
-                AC_LOG( DEBUG, "Camera Accuracy Health is turned off -- no trigger set" );
-                return;
+                if( ! invalid_reason.empty() )
+                    invalid_reason += ", ";
+                invalid_reason += to_string()
+                               << "low-ambient (SHORT) receiver gain (" << raw_apd << ") != 18";
             }
-#endif
+            break;
 
-            // Check if we want auto trigger
-            // Note: we arbitrarly choose the time before AC starts at 10 second -- enough time to
-            // make sure the user isn't going to fiddle with color sensor activity too much, because
-            // if color is off then AC will automatically turn it on!
-            if( get_trigger_seconds().count() )
-                n_seconds = std::chrono::seconds( 10 );
-            else if( get_temp_diff_trigger() && (_last_temp = read_temperature()) )
-                _temp_check = retrier::start< temp_check >( *this, std::chrono::seconds( 60 ) );
-            else
+        case RS2_AMBIENT_LIGHT_NO_AMBIENT:  // LONG
+            if( _receiver_gain != 9 )
             {
-                AC_LOG( DEBUG, "Camera Accuracy Health auto trigger is disabled in environment" );
-                return;  // no auto trigger
+                if( ! invalid_reason.empty() )
+                    invalid_reason += ", ";
+                invalid_reason += to_string()
+                               << "no-ambient (LONG) receiver gain (" << raw_apd << ") != 9";
             }
+            break;
+
+        default:
+            if( ! invalid_reason.empty() )
+                invalid_reason += ", ";
+            invalid_reason += to_string() << "invalid (" << raw_ambient << ") ambient preset";
+            break;
         }
+
+        if( ! invalid_reason.empty() )
+        {
+            // This can and will happen every minute (from the temp check), therefore not an error...
+            AC_LOG( DEBUG, "Invalid conditions for CAH: " << invalid_reason );
+            if( ! env_var< bool >( "RS2_AC_DISABLE_CONDITIONS", false ) )
+                throw invalid_value_exception( invalid_reason );
+            AC_LOG( DEBUG, "RS2_AC_DISABLE_CONDITIONS is on; continuing anyway" );
+        }
+    }
+
+    void ac_trigger::start()
+    {
+        try
+        {
+            option & o
+                = _dev.get_depth_sensor().get_option( RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH );
+            if( o.query() != float( RS2_CAH_TRIGGER_AUTO ) )
+            {
+                // auto trigger is turned off
+                AC_LOG( DEBUG, "Turned off -- no trigger set" );
+                return;
+            }
+        }
+        catch( std::exception const & e )
+        {
+            AC_LOG( ERROR, "EXCEPTION caught in access to device: " << e.what() );
+            return;
+        }
+
+        _start();
+    }
+
+    void ac_trigger::_start()
+    {
+        if( auto_calibration_is_on() )
+            throw wrong_api_call_sequence_exception( "CAH is already active" );
+
+        if( ! is_auto_trigger_possible() )
+        {
+            AC_LOG( DEBUG, "Auto trigger is disabled in environment" );
+            return;  // no auto trigger
+        }
+
         _is_on = true;
-        if( n_seconds.count() )
+
+        // If we are already active then we don't need to do anything: another calibration will be
+        // triggered automatically at the end of the current one 
+        if( is_active() )
         {
-            AC_LOG( DEBUG, "Calibration will be triggered in " << n_seconds.count() << " seconds..." );
-            // If there's already a trigger, this will simply override it
-            _next_trigger = retrier::start( *this, n_seconds, "next calibration" );
+            return;
         }
+
+        // Note: we arbitrarily choose the time before CAH starts at 10 second -- enough time to
+        // make sure the user isn't going to fiddle with color sensor activity too much, because
+        // if color is off then CAH will automatically turn it on!
+        schedule_next_time_trigger( std::chrono::seconds( 10 ) );
     }
 
     void ac_trigger::stop()
     {
         _is_on = false;
-        if( _next_trigger )
+        if (is_active())
         {
-            AC_LOG( DEBUG, "Cancelling next calibration" );
-            _next_trigger.reset();
+            cancel_current_calibration();
         }
-        if( is_active() )
+        else
         {
-            AC_LOG( DEBUG, "Cancelling current calibration" );
-            _n_cycles = 0;  // now inactive!
+            if (_next_trigger)
+            {
+                AC_LOG(DEBUG, "Cancelling next time trigger");
+                _next_trigger.reset();
+            }
+
+            if (_temp_check)
+            {
+                AC_LOG(DEBUG, "Cancelling next temp trigger");
+                _temp_check.reset();
+            }
         }
-        stop_color_sensor_if_started();
-        _temp_check.reset();
-        _retrier.reset();
-        _recycler.reset();
     }
 
     void ac_trigger::reset()
@@ -851,8 +1398,12 @@ namespace ivcam2 {
         _cf = rs2::frame{};;
         _pcf = rs2::frame{};
 
-        _is_processing = false;
-        AC_LOG( DEBUG, "reset()" );
+        _need_to_wait_for_color_sensor_stability = false;
+        if( _is_processing )
+        {
+            _is_processing = false;
+            AC_LOG( DEBUG, "Algo is processing; signalling stop" );
+        }
     }
 
 
@@ -893,22 +1444,22 @@ namespace ivcam2 {
     rs2::frame ac_trigger::depth_processing_block::process_frame( const rs2::frame_source & source,
                                                                   const rs2::frame & f )
     {
-        // AC can be triggered manually, too, so we do NOT check whether the option is on!
-
+        // CAH can be triggered manually, too, so we do NOT check whether the option is on!
         auto fs = f.as< rs2::frameset >();
+        auto autocal = _autocal.lock();
         if( fs )
         {
             auto df = fs.get_depth_frame();
-            if( _autocal->is_expecting_special_frame() && is_special_frame( df ) )
+            if( autocal && autocal->is_expecting_special_frame() && is_special_frame( df ) )
             {
-                AC_LOG( DEBUG, "frame " << f.get_frame_number() << " is our special frame" );
-                _autocal->set_special_frame( f );
+                AC_LOG( DEBUG, "Depth frame #" << f.get_frame_number() << " is our special frame" );
+                autocal->set_special_frame( f );
             }
             // Disregard framesets: we'll get those broken down into individual frames by generic_processing_block's on_frame
             return rs2::frame{};
         }
 
-        if( _autocal->is_expecting_special_frame() && is_special_frame( f.as< rs2::depth_frame >() ) )
+        if( autocal && autocal->is_expecting_special_frame() && is_special_frame( f.as< rs2::depth_frame >() ) )
             // We don't want the user getting this frame!
             return rs2::frame{};
 
@@ -944,14 +1495,16 @@ namespace ivcam2 {
 
     rs2::frame ac_trigger::color_processing_block::process_frame( const rs2::frame_source& source, const rs2::frame& f )
     {
-        // AC can be triggered manually, too, so we do NOT check whether the option is on!
+        // CAH can be triggered manually, too, so we do NOT check whether the option is on!
 
         // Disregard framesets: we'll get those broken down into individual frames by generic_processing_block's on_frame
         if( f.is< rs2::frameset >() )
             return rs2::frame{};
 
-        // We record each and every color frame
-        _autocal->set_color_frame( f );
+        auto autocal = _autocal.lock();
+        if( autocal )
+            // We record each and every color frame
+            autocal->set_color_frame( f );
 
         // Return the frame as is!
         return f;
diff --git a/src/l500/ac-trigger.h b/src/l500/ac-trigger.h
index 46d2ae7..4cf7805 100644
--- a/src/l500/ac-trigger.h
+++ b/src/l500/ac-trigger.h
@@ -24,17 +24,16 @@ namespace ivcam2 {
         rs2::frameset _sf;
         rs2::frame _cf, _pcf;  // Keep the last and previous frame!
 
-        float _dsm_x_scale;  // registers read when we get a special frame
-        float _dsm_y_scale;
-        float _dsm_x_offset;
-        float _dsm_y_offset;
+        rs2_ambient_light _ambient;
+        int _receiver_gain;
+        double _temp;
 
-        hw_monitor & _hwm;
+        std::weak_ptr< hw_monitor > _hwm;
         l500_device & _dev;
 
         bool _is_on = false;
         std::mutex _mutex;
-        bool _is_processing = false;  // Whether algo is currently running
+        std::atomic_bool _is_processing {false};  // Whether algo is currently running
         std::thread _worker;
         unsigned _n_retries;     // how many special frame requests we've made
         unsigned _n_cycles = 0;  // how many times we've run algo
@@ -44,24 +43,29 @@ namespace ivcam2 {
         rs2_dsm_params _dsm_params;
         stream_profile_interface* _from_profile = nullptr;
         stream_profile_interface* _to_profile = nullptr;
+        std::vector< uint16_t > _last_yuy_data;
 
         class retrier;
         std::shared_ptr< retrier > _retrier;
         std::shared_ptr< retrier > _recycler;
-        std::shared_ptr< retrier > _next_trigger;
         rs2_calibration_status _last_status_sent;
-        std::atomic_bool _own_color_stream{ false };
+
+        class next_trigger;
+        std::shared_ptr< next_trigger > _next_trigger;
 
         class temp_check;
         double _last_temp = 0;
         std::shared_ptr< temp_check > _temp_check;
 
+        bool _need_to_wait_for_color_sensor_stability = false;
+        std::chrono::high_resolution_clock::time_point _rgb_sensor_start;
+
     public:
         /* Depth frame processing: detect special frames
         */
         class depth_processing_block : public generic_processing_block
         {
-            std::shared_ptr< ac_trigger > _autocal;
+            std::weak_ptr< ac_trigger > _autocal;
 
         public:
             depth_processing_block( std::shared_ptr< ac_trigger > autocal );
@@ -77,7 +81,7 @@ namespace ivcam2 {
         */
         class color_processing_block : public generic_processing_block
         {
-            std::shared_ptr< ac_trigger > _autocal;
+            std::weak_ptr< ac_trigger > _autocal;
 
         public:
             color_processing_block( std::shared_ptr< ac_trigger > autocal );
@@ -89,17 +93,22 @@ namespace ivcam2 {
         };
 
         /* For RS2_OPTION_TRIGGER_CAMERA_ACCURACY_HEALTH */
-        class enabler_option : public bool_option
+        class enabler_option : public float_option
         {
-            std::shared_ptr< ac_trigger > _autocal;
+            typedef float_option super;
+
+            std::weak_ptr< ac_trigger > _autocal;
 
         public:
             enabler_option( std::shared_ptr< ac_trigger > const & autocal );
 
+            bool is_auto() const { return (_value == _opt_range.max); }
+            bool is_manual() const { return ! is_auto(); }
+
             virtual void set( float value ) override;
             virtual const char* get_description() const override
             {
-                return "Trigger Camera Accuracy Health";
+                return "Trigger Camera Accuracy Health (off, run now, auto)";
             }
             virtual void enable_recording( std::function<void( const option& )> record_action ) override { _record_action = record_action; }
 
@@ -110,7 +119,7 @@ namespace ivcam2 {
         /* For RS2_OPTION_RESET_CAMERA_ACCURACY_HEALTH */
         class reset_option : public bool_option
         {
-            std::shared_ptr< ac_trigger > _autocal;
+            std::weak_ptr< ac_trigger > _autocal;
 
         public:
             reset_option( std::shared_ptr< ac_trigger > const & autocal );
@@ -126,13 +135,22 @@ namespace ivcam2 {
             std::function<void( const option& )> _record_action = []( const option& ) {};
         };
 
+        enum class calibration_type
+        {
+            MANUAL,
+            AUTO
+        };
+
+    private:
+        calibration_type _calibration_type;
+
     public:
-        ac_trigger( l500_device & dev, hw_monitor & hwm );
+        ac_trigger( l500_device & dev, std::shared_ptr<hw_monitor> hwm );
         ~ac_trigger();
 
-        // Wait a certain amount of time before the next calibration happens. Can only happen if not
-        // already active!
-        void start( std::chrono::seconds n_seconds = std::chrono::seconds(0) );
+        // Called when depth sensor start. Triggers a calibration in a few seconds if auto
+        // calibration is turned on.
+        void start();
 
         // Once triggered, we may want to cancel it... like when stopping the stream
         void stop();
@@ -151,7 +169,7 @@ namespace ivcam2 {
         bool auto_calibration_is_on() const { return _is_on; }
 
         // Start calibration -- after this, is_active() returns true. See the note for is_on().
-        void trigger_calibration( bool is_retry = false );
+        void trigger_calibration( calibration_type type );
 
         rs2_extrinsics const & get_extrinsics() const { return _extr; }
         rs2_intrinsics const & get_intrinsics() const { return _intr; }
@@ -174,21 +192,31 @@ namespace ivcam2 {
 
         bool is_processing() const { return _is_processing; }
         bool is_expecting_special_frame() const { return !!_retrier; }
+
         double read_temperature();
         void calibration_is_done();
+        void schedule_next_calibration();
+        void schedule_next_time_trigger( std::chrono::seconds n_seconds = std::chrono::seconds( 0 ) );
+        void schedule_next_temp_trigger();
+        void cancel_current_calibration();
+        void set_not_active();
+        void trigger_retry();
+        void trigger_special_frame();
+        void check_conditions();
+        void _start();
+
 
         std::vector< callback > _callbacks;
 
-        void call_back( rs2_calibration_status status )
-        {
-            _last_status_sent = status;
-            for( auto && cb : _callbacks )
-                cb( status );
-        }
+        void call_back( rs2_calibration_status status );
 
         bool check_color_depth_sync();
         void run_algo();
         void reset();
+
+        class ac_logger;
+        ac_logger & get_ac_logger();
+
     };
 
 
diff --git a/src/l500/l500-color.cpp b/src/l500/l500-color.cpp
index ac0202c..e4042d2 100644
--- a/src/l500/l500-color.cpp
+++ b/src/l500/l500-color.cpp
@@ -4,6 +4,9 @@
 #include "l500-color.h"
 
 #include <cstddef>
+#include <mutex>
+
+
 
 #include "l500-private.h"
 #include "proc/color-formats-converter.h"
@@ -164,7 +167,7 @@ namespace librealsense
                 return get_color_stream_extrinsic(*_color_extrinsics_table_raw);
             } );
         environment::get_instance().get_extrinsics_graph().register_extrinsics(*_depth_stream, *_color_stream, _color_extrinsic);
-        register_stream_to_extrinsic_group(*_depth_stream, 0);
+        register_stream_to_extrinsic_group(*_color_stream, 0);
 
 
         _color_device_idx = add_sensor(create_color_device(ctx, color_devs_info));
@@ -341,6 +344,145 @@ namespace librealsense
         AC_LOG( INFO, "Color sensor calibration has been reset" );
     }
 
+    void l500_color_sensor::start(frame_callback_ptr callback)
+    {
+        std::lock_guard<std::mutex> lock(_state_mutex);
+
+        if (_state != sensor_state::OWNED_BY_USER)
+            throw wrong_api_call_sequence_exception("tried to start an unopened sensor");
+
+        delayed_start(callback);
+    }
+
+    
+    void l500_color_sensor::stop()
+    {
+        std::lock_guard<std::mutex> lock(_state_mutex);
+        
+        // Protect not stopping the calibration color stream due to wrong API sequence
+        if (_state != sensor_state::OWNED_BY_USER)
+            throw wrong_api_call_sequence_exception("tried to stop sensor without starting it");
+
+        delayed_stop();
+    }
+
+
+    void l500_color_sensor::open( const stream_profiles & requests )
+    {
+        std::lock_guard< std::mutex > lock( _state_mutex );
+
+        if( sensor_state::OWNED_BY_AUTO_CAL == _state )
+        {
+            if( is_streaming() )
+            {
+                delayed_stop();
+            }
+            if( is_opened() )
+            {
+                LOG_DEBUG( "Closing color sensor..." );
+                synthetic_sensor::close();
+            }
+            set_sensor_state( sensor_state::CLOSED );
+            LOG_DEBUG( "Calibration color stream was on, turned it off" );
+        }
+
+        LOG_DEBUG( "Opening color sensor..." );
+        synthetic_sensor::open( requests );
+        set_sensor_state( sensor_state::OWNED_BY_USER );
+    }
+
+    
+    void l500_color_sensor::close()
+    {
+        std::lock_guard< std::mutex > lock( _state_mutex );
+
+        if( _state != sensor_state::OWNED_BY_USER )
+            throw wrong_api_call_sequence_exception( "tried to close sensor without opening it" );
+
+        LOG_DEBUG("Closing color sensor...");
+        synthetic_sensor::close();
+        set_sensor_state(sensor_state::CLOSED);
+    }
+
+    // Helper function for start stream callback
+    template<class T>
+    frame_callback_ptr make_frame_callback(T callback)
+    {
+        return {
+            new internal_frame_callback<T>(callback),
+            [](rs2_frame_callback* p) { p->release(); }
+        };
+    }
+
+    bool l500_color_sensor::start_stream_for_calibration(const stream_profiles& requests)
+    {
+        std::lock_guard< std::mutex > lock( _state_mutex );
+
+        // Allow calibration process to open the color stream only if it is not started by the user.
+        if( _state == sensor_state::CLOSED )
+        {
+            synthetic_sensor::open(requests);
+            set_sensor_state(sensor_state::OWNED_BY_AUTO_CAL);
+            AC_LOG( INFO, "Starting color sensor stream -- for calibration" );
+            delayed_start( make_frame_callback( [&]( frame_holder fref ) {} ) );
+            return true;
+        }
+        if( ! is_streaming() )
+        {
+            // This is a corner case that is not covered at the moment: The user opened the sensor
+            // but did not start it.
+            AC_LOG( WARNING,
+                    "The color sensor was opened but never started by the user; streaming may not work" );
+        }
+        else
+            AC_LOG( DEBUG, "Color sensor is already streaming (" << state_to_string(_state) << ")" );
+        return false;
+    }
+
+    void l500_color_sensor::stop_stream_for_calibration()
+    {
+        std::lock_guard< std::mutex > lock( _state_mutex );
+        
+        if( _state == sensor_state::OWNED_BY_AUTO_CAL )
+        {
+            if( is_streaming() )
+            {
+                AC_LOG( INFO, "Stopping color sensor stream from calibration" );
+                delayed_stop();
+                AC_LOG( INFO, "Color sensor stream stopped" );
+
+            }
+            if (is_opened())
+            {
+                LOG_DEBUG( "Closing color sensor..." );
+                synthetic_sensor::close();
+                LOG_DEBUG( "Color sensor closed" );
+            }
+
+            // If we got here with no exception it means the start has succeeded.
+            set_sensor_state( sensor_state::CLOSED );
+        }
+        else
+        {
+            AC_LOG( DEBUG, "Color sensor was not opened by us; no need to close" );
+        }
+    }
+
+    std::string l500_color_sensor::state_to_string(sensor_state state)
+    {
+        switch (state)
+        {
+        case sensor_state::CLOSED:
+            return "CLOSED";
+        case sensor_state::OWNED_BY_AUTO_CAL:
+            return "OWNED_BY_AUTO_CAL";
+        case sensor_state::OWNED_BY_USER:
+            return "OWNED_BY_USER";
+        default:
+            LOG_DEBUG("Invalid color sensor state: " << static_cast<int>(state));
+            return "Unknown state";
+        }
+    }
 
 
     std::vector<tagged_profile> l500_color::get_profiles_tags() const
diff --git a/src/l500/l500-color.h b/src/l500/l500-color.h
index 52b28d6..d99efa7 100644
--- a/src/l500/l500-color.h
+++ b/src/l500/l500-color.h
@@ -57,7 +57,8 @@ namespace librealsense
             std::map<uint32_t, rs2_format> l500_color_fourcc_to_rs2_format,
             std::map<uint32_t, rs2_stream> l500_color_fourcc_to_rs2_stream)
             : synthetic_sensor("RGB Camera", uvc_sensor, owner, l500_color_fourcc_to_rs2_format, l500_color_fourcc_to_rs2_stream),
-            _owner(owner)
+            _owner(owner),
+            _state(sensor_state::CLOSED)
         {}
 
         rs2_intrinsics get_intrinsics( const stream_profile& profile ) const override;
@@ -106,24 +107,68 @@ namespace librealsense
             return get_color_recommended_proccesing_blocks();
         }
 
-        void start(frame_callback_ptr callback) override
+
+        // Opens the color sensor profile, if the sensor is opened by calibration process,
+        // It will close it and reopen with the requested profile.
+        void open(const stream_profiles& requests) override;
+
+        // Close the color sensor
+        void close() override;
+    
+        // Start the color sensor streaming
+        void start(frame_callback_ptr callback) override;
+        
+        // Stops the color sensor streaming
+        void stop() override;
+
+        // This function serves the auto calibration process,
+        // It is used to open and start the color sensor with a single call if it is closed.
+        // Note: if the sensor is opened by the user, the function assumes that the user will start the stream.
+        // Returns whether the stream was started.
+        bool start_stream_for_calibration( const stream_profiles & requests );
+       
+        // Stops the color sensor if was opened by the calibration process, otherwise does nothing
+        void stop_stream_for_calibration();
+        
+    private:
+        l500_color* const _owner;
+        action_delayer _action_delayer;
+        std::mutex _state_mutex;
+
+        enum class sensor_state 
+        {
+            CLOSED,
+            OWNED_BY_USER,
+            OWNED_BY_AUTO_CAL
+        };
+
+        std::atomic< sensor_state > _state;
+
+        void delayed_start(frame_callback_ptr callback)
         {
-            _action_delayer.do_after_delay([&]() {
-                    synthetic_sensor::start(callback);
-                    //_owner->trigger_device_calibration( RS2_CALIBRATION_DEPTH_TO_RGB );
-            });
+            LOG_DEBUG("Starting color sensor...");
+            // The delay is here as a work around to a firmware bug [RS5-5453]
+            _action_delayer.do_after_delay([&]() { synthetic_sensor::start(callback); });
+            LOG_DEBUG("Color sensor started");
         }
 
-        void stop() override
+        void delayed_stop()
         {
-            _action_delayer.do_after_delay([&]() {
-                synthetic_sensor::stop();
-            });
+            LOG_DEBUG("Stopping color sensor...");
+            // The delay is here as a work around to a firmware bug [RS5-5453]
+            _action_delayer.do_after_delay([&]() { synthetic_sensor::stop(); });
+            LOG_DEBUG("Color sensor stopped");
         }
 
-    private:
-        l500_color* const _owner;
-        action_delayer _action_delayer;
+        std::string state_to_string(sensor_state state);
+
+        
+        void set_sensor_state(sensor_state state)
+        {
+                LOG_DEBUG("Sensor state changed from: " << state_to_string(_state) <<
+                    " to: " << state_to_string(state));
+                _state = state;
+        }
     };
 
 }
diff --git a/src/l500/l500-depth.cpp b/src/l500/l500-depth.cpp
index 38cf034..6016e14 100644
--- a/src/l500/l500-depth.cpp
+++ b/src/l500/l500-depth.cpp
@@ -19,6 +19,7 @@
 #include "l500-options.h"
 #include "ac-trigger.h"
 #include "algo/depth-to-rgb-calibration/debug.h"
+#include "algo/depth-to-rgb-calibration/utils.h"  // validate_dsm_params
 
 
 #define MM_TO_METER 1/1000
@@ -83,6 +84,7 @@ namespace librealsense
 
         register_stream_to_extrinsic_group(*_depth_stream, 0);
         register_stream_to_extrinsic_group(*_ir_stream, 0);
+        register_stream_to_extrinsic_group(*_confidence_stream, 0);
 
         auto error_control = std::unique_ptr<uvc_xu_option<int>>(new uvc_xu_option<int>(raw_depth_sensor, ivcam2::depth_xu, L500_ERROR_REPORTING, "Error reporting"));
 
@@ -234,17 +236,16 @@ namespace librealsense
 
     void l500_depth_sensor::override_dsm_params( rs2_dsm_params const & dsm_params )
     {
-        /*  Considerable values for DSM correction:
-            - h/vFactor: 0.98-1.02, representing up to 2% change in FOV.
-            - h/vOffset:
-                - Under AOT model: (-2)-2, representing up to 2deg FOV tilt
-                - Under TOA model: (-125)-125, representing up to approximately
-                  2deg FOV tilt
-            These values are extreme. For more reasonable values take 0.99-1.01
-            for h/vFactor and divide the suggested h/vOffset range by 10.
-        */
-        if( dsm_params.model != RS2_DSM_CORRECTION_AOT )
-            throw invalid_value_exception( "DSM non-AoT (1) mode is currently unsupported" );
+        try
+        {
+            algo::depth_to_rgb_calibration::validate_dsm_params( dsm_params );  // throws!
+        }
+        catch( invalid_value_exception const & e )
+        {
+            if( ! getenv( "RS2_AC_IGNORE_LIMITERS" ))
+                throw;
+            AC_LOG( ERROR, "Ignoring (RS2_AC_IGNORE_LIMITERS) " << e.what() );
+        }
 
         ac_depth_results table( dsm_params );
         // table.params.timestamp = std::chrono::system_clock::now().time_since_epoch().count();
@@ -253,18 +254,6 @@ namespace librealsense
         table.params.timestamp = mktime( gmtime( &t ) );  // UTC time
         table.params.version = ac_depth_results::this_version;
 
-        // The temperature may depend on streaming?
-        auto res = _owner->_hw_monitor->send( command{TEMPERATURES_GET} );
-        if( res.size() < sizeof( temperatures ) )  // New temperatures may get added by FW...
-        {
-            AC_LOG( ERROR, "Failed to get temperatures; result size= " << res.size() << "; expecting at least " << sizeof( temperatures ) );
-        }
-        else
-        {
-            auto const & ts = *( reinterpret_cast<temperatures *>( res.data() ) );
-            table.params.temp_x2 = byte( ts.LDD_temperature * 2 );
-        }
-
         AC_LOG( INFO, "Overriding DSM : " << table.params );
         ivcam2::write_fw_table( *_owner->_hw_monitor, ac_depth_results::table_id, table );
     }
@@ -370,6 +359,7 @@ namespace librealsense
 
     void l500_depth_sensor::start(frame_callback_ptr callback)
     {
+        // The delay is here as a work around to a firmware bug [RS5-5453]
         _action_delayer.do_after_delay( [&]() {
             if( _depth_invalidation_enabled )
                 synthetic_sensor::start(
@@ -386,6 +376,7 @@ namespace librealsense
 
     void l500_depth_sensor::stop()
     {
+    // The delay is here as a work around to a firmware bug [RS5-5453]
         _action_delayer.do_after_delay([&]() {
             synthetic_sensor::stop();
             _depth_invalidation_option->set_streaming(false);
@@ -483,48 +474,42 @@ namespace librealsense
             _user_requests = requests;
             _depth_invalidation_option->set_streaming(true);
 
-            if (_depth_invalidation_enabled)
-            {
-                auto is_ir_requested
-                    = std::find_if( requests.begin(),
-                                    requests.end(),
-                                    []( std::shared_ptr< stream_profile_interface > const & sp ) {
-                                        return sp->get_stream_type() == RS2_STREAM_INFRARED;
-                                    } )
-                   != requests.end();
+            auto is_ir_requested
+                = std::find_if( requests.begin(),
+                                requests.end(),
+                                []( std::shared_ptr< stream_profile_interface > const & sp ) {
+                                    return sp->get_stream_type() == RS2_STREAM_INFRARED;
+                                } )
+               != requests.end();
 
-                _validator_requests = requests;
+            _validator_requests = requests;
 
-                //enable ir if user didn't asked ir in order to validate the ir frame
-                if (!is_ir_requested)
-                {
-                    auto user_request = std::find_if(requests.begin(), requests.end(), [](std::shared_ptr<stream_profile_interface> sp)
-                    {return sp->get_stream_type() != RS2_STREAM_INFRARED;});
+            //enable ir if user didn't asked ir in order to validate the ir frame
+            if (!is_ir_requested)
+            {
+                auto user_request = std::find_if(requests.begin(), requests.end(), [](std::shared_ptr<stream_profile_interface> sp)
+                {return sp->get_stream_type() != RS2_STREAM_INFRARED;});
 
-                    if (user_request == requests.end())
-                        throw std::runtime_error(to_string() << "input stream_profiles is invalid");
+                if (user_request == requests.end())
+                    throw std::runtime_error(to_string() << "input stream_profiles is invalid");
 
-                    auto user_request_profile = dynamic_cast<video_stream_profile*>(user_request->get());
+                auto user_request_profile = dynamic_cast<video_stream_profile*>(user_request->get());
 
-                    auto sp = synthetic_sensor::get_stream_profiles();
+                auto sp = synthetic_sensor::get_stream_profiles();
 
-                    auto corresponding_ir = std::find_if(sp.begin(), sp.end(), [&](std::shared_ptr<stream_profile_interface> sp)
-                    {
-                        auto vs = dynamic_cast<video_stream_profile*>(sp.get());
-                        return sp->get_stream_type() == RS2_STREAM_INFRARED && stream_profiles_correspond(sp.get(), user_request_profile);
-                    });
+                auto corresponding_ir = std::find_if(sp.begin(), sp.end(), [&](std::shared_ptr<stream_profile_interface> sp)
+                {
+                    auto vs = dynamic_cast<video_stream_profile*>(sp.get());
+                    return sp->get_stream_type() == RS2_STREAM_INFRARED && stream_profiles_correspond(sp.get(), user_request_profile);
+                });
 
-                    if (corresponding_ir == sp.end())
-                        throw std::runtime_error(to_string() << "can't find ir stream corresponding to user request");
+                if (corresponding_ir == sp.end())
+                    throw std::runtime_error(to_string() << "can't find ir stream corresponding to user request");
 
-                    _validator_requests.push_back(*corresponding_ir);
-                }
-            }
-            else
-            {
-                _validator_requests = requests;
+                _validator_requests.push_back(*corresponding_ir);
             }
 
+
             auto dp = std::find_if( requests.begin(),
                                     requests.end(),
                                     []( std::shared_ptr< stream_profile_interface > sp ) {
diff --git a/src/l500/l500-device.cpp b/src/l500/l500-device.cpp
index b5b6df1..2ad210c 100644
--- a/src/l500/l500-device.cpp
+++ b/src/l500/l500-device.cpp
@@ -210,10 +210,10 @@ namespace librealsense
         is_zo_enabled_opt->set(false);
         depth_sensor.register_option(RS2_OPTION_ZERO_ORDER_ENABLED, is_zo_enabled_opt);
 
-        if( _fw_version >= firmware_version( "1.3.12.0" ) )
+        if( _fw_version >= firmware_version( "1.5.0.0" ) )
         {
             // TODO may not need auto-cal if there's no color sensor, like on the rs500...
-            _autocal = std::make_shared< ac_trigger >( *this, *_hw_monitor );
+            _autocal = std::make_shared< ac_trigger >( *this, _hw_monitor );
 
             // Have the auto-calibration mechanism notify us when calibration has finished
             _autocal->register_callback(
@@ -221,11 +221,13 @@ namespace librealsense
                 {
                     if( status == RS2_CALIBRATION_SUCCESSFUL )
                     {
+                        // We override the DSM params first, because it can throw if the parameters
+                        // are exceeding spec! This may throw!!
+                        get_depth_sensor().override_dsm_params( _autocal->get_dsm_params() );
+                     
                         auto & color_sensor = *get_color_sensor();
                         color_sensor.override_intrinsics( _autocal->get_intrinsics() );
                         color_sensor.override_extrinsics( _autocal->get_extrinsics() );
-
-                        get_depth_sensor().override_dsm_params( _autocal->get_dsm_params() );
                     }
                     notify_of_calibration_change( status );
                 } );
@@ -375,9 +377,19 @@ namespace librealsense
 
     void l500_device::trigger_device_calibration( rs2_calibration_type type )
     {
-        if( type != RS2_CALIBRATION_DEPTH_TO_RGB )
+        ac_trigger::calibration_type calibration_type;
+        switch( type )
+        {
+        case RS2_CALIBRATION_AUTO_DEPTH_TO_RGB:
+            calibration_type = ac_trigger::calibration_type::AUTO;
+            break;
+        case RS2_CALIBRATION_MANUAL_DEPTH_TO_RGB:
+            calibration_type = ac_trigger::calibration_type::MANUAL;
+            break;
+        default:
             throw not_implemented_exception(
                 to_string() << "unsupported calibration type (" << type << ")" );
+        }
 
         if( !_autocal )
             throw not_implemented_exception(
@@ -388,7 +400,7 @@ namespace librealsense
             throw wrong_api_call_sequence_exception( "Camera Accuracy Health is already active" );
 
         AC_LOG( INFO, "Camera Accuracy Health has been manually triggered" );
-        _autocal->trigger_calibration();
+        _autocal->trigger_calibration( calibration_type );
     }
 
     void l500_device::force_hardware_reset() const
@@ -609,6 +621,54 @@ namespace librealsense
         return command{ ivcam2::FRB, 0x0011E000, 0x3f8 };
     }
 
+    static void log_FW_response_first_byte(hw_monitor& hwm, const std::string& command_name, const command &cmd, size_t expected_size)
+    {
+        auto res = hwm.send(cmd);
+        if (res.size() < expected_size)
+        {
+            throw invalid_value_exception(to_string()
+                << command_name + " FW command failed: size expected: "
+                << expected_size << " , size received: " << res.size());
+        }
+
+        LOG_INFO(command_name << ": " << static_cast<int>(res[0]));
+    }
+
+    std::vector< uint8_t > l500_device::send_receive_raw_data(const std::vector< uint8_t > & input)
+    {
+        std::string command_str(input.begin(), input.end());
+
+        if (command_str == "GET-NEST")
+        {
+            // Handle extended temperature command
+            auto nest_response = _hw_monitor->send(command{ ivcam2::TEMPERATURES_GET });
+            if (nest_response.size() < sizeof(extended_temperatures))
+            {
+                throw invalid_value_exception(to_string() <<
+                    "Extended temperatures get FW command failed, size expected: " << sizeof(extended_temperatures )
+                    << " , size received: " << nest_response.size() );
+            }
+
+            auto const & ext_temp
+                = *(reinterpret_cast<extended_temperatures *>(nest_response.data()));
+            LOG_INFO("Nest AVG: " << ext_temp.nest_avg);
+
+            // Handle other commands (all results log the first byte)
+            log_FW_response_first_byte(*_hw_monitor, "Gain trim",
+                command(ivcam2::IRB, 0x6C, 0x2, 0x1),
+                sizeof(uint8_t));
+            log_FW_response_first_byte(*_hw_monitor, "IPF gain",
+                command(ivcam2::MRD, 0xA003007C, 0xA0030080),
+                sizeof(uint32_t));
+            log_FW_response_first_byte(*_hw_monitor, "APB VBR",
+                command(ivcam2::AMCGET, 0x4, 0x0, 0x0),
+                sizeof(uint32_t));
+            return std::vector< uint8_t >();
+        }
+
+        return _hw_monitor->send(input);
+    }
+
     notification l500_notification_decoder::decode(int value)
     {
         if (l500_fw_error_report.find(static_cast<uint8_t>(value)) != l500_fw_error_report.end())
diff --git a/src/l500/l500-device.h b/src/l500/l500-device.h
index 431c477..b08a26e 100644
--- a/src/l500/l500-device.h
+++ b/src/l500/l500-device.h
@@ -58,10 +58,7 @@ namespace librealsense
 
         void notify_of_calibration_change( rs2_calibration_status status );
 
-        std::vector<uint8_t> send_receive_raw_data(const std::vector<uint8_t>& input) override
-        {
-            return _hw_monitor->send(input);
-        }
+        std::vector< uint8_t > send_receive_raw_data(const std::vector< uint8_t > & input) override;
 
         void hardware_reset() override
         {
diff --git a/src/l500/l500-private.h b/src/l500/l500-private.h
index 3bd338d..7c7c393 100644
--- a/src/l500/l500-private.h
+++ b/src/l500/l500-private.h
@@ -46,6 +46,7 @@ namespace librealsense
 
         enum fw_cmd : uint8_t
         {
+            IRB                         = 0x03, //"Read from i2c ( 8x8 )"
             MRD                         = 0x01, //"Read Tensilica memory ( 32bit ). Output : 32bit dump"
             FRB                         = 0x09, //"Read from flash"
             FWB                         = 0x0A, //"Write to flash"
@@ -87,7 +88,7 @@ namespace librealsense
         // Read a table from firmware and, if FW says the table is empty, optionally initialize it
         // using your own code...
         template< typename T >
-        void read_fw_table( hw_monitor & hwm,
+        void read_fw_table( hw_monitor& hwm,
                             int table_id, T * ptable,
                             table_header * pheader = nullptr,
                             std::function< void() > init = nullptr )
@@ -127,7 +128,7 @@ namespace librealsense
 
         // Write a table to firmware
         template< typename T >
-        void write_fw_table( hw_monitor & hwm, uint16_t const table_id, T const & table )
+        void write_fw_table( hw_monitor& hwm, uint16_t const table_id, T const & table )
         {
             command cmd( fw_cmd::WRITE_TABLE, 0 );
             cmd.data.resize( sizeof( table_header ) + sizeof( table ) );
@@ -156,7 +157,7 @@ namespace librealsense
         }
 
         template< typename T >
-        void read_fw_register( hw_monitor & hwm, T * preg, int const baseline_address )
+        void read_fw_register(hw_monitor& hwm, T * preg, int const baseline_address )
         {
             command cmd( ivcam2::fw_cmd::MRD, baseline_address, baseline_address + sizeof( T ) );
             auto res = hwm.send( cmd );
@@ -363,6 +364,12 @@ namespace librealsense
             double HUM_temperature;
             double AlgoTermalLddAvg_temperature;
         };
+
+        //FW versions >= 1.5.0.0 added to the response vector the nest AVG value
+        struct extended_temperatures {
+            temperatures base_temperatures;
+            double nest_avg;
+        };
 #pragma pack( pop )
 
         rs2_extrinsics get_color_stream_extrinsic(const std::vector<uint8_t>& raw_data);
@@ -485,7 +492,7 @@ namespace librealsense
         class freefall_option : public bool_option
         {
         public:
-            freefall_option( hw_monitor & hwm, bool enabled = true );
+            freefall_option( hw_monitor& hwm, bool enabled = true );
 
             bool is_enabled() const override { return _enabled; }
             virtual void enable( bool = true );
diff --git a/src/linux/backend-v4l2.cpp b/src/linux/backend-v4l2.cpp
index 5ed8d70..64a1ff2 100644
--- a/src/linux/backend-v4l2.cpp
+++ b/src/linux/backend-v4l2.cpp
@@ -38,7 +38,6 @@
 #include <linux/usb/video.h>
 #include <linux/uvcvideo.h>
 #include <linux/videodev2.h>
-#include <fts.h>
 #include <regex>
 #include <list>
 
diff --git a/src/linux/backend-v4l2.h b/src/linux/backend-v4l2.h
index 2ffee50..6dc1717 100644
--- a/src/linux/backend-v4l2.h
+++ b/src/linux/backend-v4l2.h
@@ -36,7 +36,6 @@
 #include <linux/usb/video.h>
 #include <linux/uvcvideo.h>
 #include <linux/videodev2.h>
-#include <fts.h>
 #include <regex>
 #include <list>
 
diff --git a/src/mf/mf-backend.cpp b/src/mf/mf-backend.cpp
index 5ce6af5..fbb4f3e 100644
--- a/src/mf/mf-backend.cpp
+++ b/src/mf/mf-backend.cpp
@@ -87,7 +87,10 @@ namespace librealsense
             return device_infos;
         }
 
-        wmf_hid_device::wmf_hid_device(const hid_device_info& info)
+        wmf_hid_device::wmf_hid_device(const hid_device_info& info,
+                                       std::shared_ptr<const wmf_backend> backend)
+            : _backend(std::move(backend)),
+              _cb(nullptr)
         {
             bool found = false;
 
@@ -107,7 +110,7 @@ namespace librealsense
 
         std::shared_ptr<hid_device> wmf_backend::create_hid_device(hid_device_info info) const
         {
-            return std::make_shared<wmf_hid_device>(info);
+            return std::make_shared<wmf_hid_device>(info, shared_from_this());
         }
 
         std::vector<hid_device_info> wmf_backend::query_hid_devices() const
diff --git a/src/mf/mf-hid.h b/src/mf/mf-hid.h
index ae01e11..1073dda 100644
--- a/src/mf/mf-hid.h
+++ b/src/mf/mf-hid.h
@@ -50,11 +50,13 @@ namespace librealsense
             std::string _name;
         };
 
+        class wmf_backend;
+
         class wmf_hid_device : public hid_device
         {
         public:
             static void foreach_hid_device(std::function<void(hid_device_info, CComPtr<ISensor>)> action);
-            wmf_hid_device(const hid_device_info& info);
+            wmf_hid_device(const hid_device_info& info, std::shared_ptr<const wmf_backend> backend);
 
             void register_profiles(const std::vector<hid_profile>& hid_profiles) override { _hid_profiles = hid_profiles;}
             void open(const std::vector<hid_profile>&iio_profiles) override;
@@ -65,12 +67,14 @@ namespace librealsense
             std::vector<uint8_t> get_custom_report_data(const std::string& custom_sensor_name, const std::string& report_name, custom_sensor_report_field report_field) override;
 
         private:
+            // Don't move the position of wmf_backend member. This object must be destroyed only after COM objects.
+            std::shared_ptr<const wmf_backend>           _backend;
 
             std::vector<std::shared_ptr<wmf_hid_sensor>> _connected_sensors; // Vector of all connected sensors of this device
             std::vector<std::shared_ptr<wmf_hid_sensor>> _opened_sensors;    // Vector of all opened sensors of this device (subclass of _connected_sensors)
             std::vector<std::shared_ptr<wmf_hid_sensor>> _streaming_sensors; // Vector of all streaming sensors of this device (subclass of _connected_sensors)
 
-            CComPtr<ISensorEvents> _cb = nullptr;
+            CComPtr<ISensorEvents> _cb;
             std::vector<hid_profile> _hid_profiles;
         };
     }
diff --git a/src/mf/mf-uvc.h b/src/mf/mf-uvc.h
index e04d8a0..3c9e2ba 100644
--- a/src/mf/mf-uvc.h
+++ b/src/mf/mf-uvc.h
@@ -119,6 +119,9 @@ namespace librealsense
             void set_d0();
             void set_d3();
 
+            // Don't move the position of wmf_backend member. This object must be destroyed only after COM objects.
+            std::shared_ptr<const wmf_backend>      _backend;
+
             const uvc_device_info                   _info;
             power_state                             _power_state = D3;
 
@@ -139,8 +142,6 @@ namespace librealsense
             std::vector<profile_and_callback>       _streams;
             std::mutex                              _streams_mutex;
 
-            std::shared_ptr<const wmf_backend>      _backend;
-
             named_mutex                             _systemwide_lock;
             std::string                             _location;
             usb_spec                                _device_usb_spec;
diff --git a/src/pipeline/pipeline.cpp b/src/pipeline/pipeline.cpp
index 2165535..d81ce77 100644
--- a/src/pipeline/pipeline.cpp
+++ b/src/pipeline/pipeline.cpp
@@ -20,11 +20,12 @@ namespace librealsense
 
         pipeline::~pipeline()
         {
-            try
-            {
-                unsafe_stop();
+            if (_active_profile) {
+                try {
+                    unsafe_stop();
+                }
+                catch (...) {}
             }
-            catch (...) {}
         }
 
         std::shared_ptr<profile> pipeline::start(std::shared_ptr<config> conf, frame_callback_ptr callback)
@@ -144,10 +145,13 @@ namespace librealsense
                 catch (...)
                 {
                 } // Stop will throw if device was disconnected. TODO - refactoring anticipated
+
+                // shared pointers initialized when pipeline running with _active_profile
+                // should be reset with _active_profile too
+                _active_profile.reset();
+                _prev_conf.reset();
+                _streams_callback.reset();
             }
-            _active_profile.reset();
-            _prev_conf.reset();
-            _streams_callback.reset();
         }
 
         std::shared_ptr<device_interface> pipeline::wait_for_device(const std::chrono::milliseconds& timeout, const std::string& serial)
diff --git a/src/proc/occlusion-filter.cpp b/src/proc/occlusion-filter.cpp
index 265f84b..1d276be 100644
--- a/src/proc/occlusion-filter.cpp
+++ b/src/proc/occlusion-filter.cpp
@@ -36,6 +36,33 @@ namespace librealsense
             break;
         }
     }
+   int gcd(int a, int b) {
+       if (b == 0)
+           return a;
+       return gcd(b, a % b);
+   }
+   // Return the greatest common divisor of a 
+   // and b which lie in the given range. 
+   int maxDivisorRange(int a, int b, int lo, int hi)
+   {
+       if (lo > hi)
+       {
+           std::swap(hi, lo);
+       }
+       int g = gcd(a, b);
+       int res = g;
+
+       // Loop from 1 to sqrt(GCD(a, b). 
+       for (int i = lo; i * i <= g && i <= hi; i++)
+
+           if ((g % i == 0) && (g / i) <= hi)
+           {
+               res = g / i; 
+               break;
+           }
+
+       return res;
+   }
    template<size_t SIZE>
    void rotate_image_optimized(byte* dest[], const byte* source, int width, int height)
    {
@@ -44,24 +71,40 @@ namespace librealsense
        auto height_out = width;
 
        auto out = dest[0];
-       byte buffer[ROTATION_BUFFER_SIZE][ROTATION_BUFFER_SIZE * SIZE];
-       for (int i = 0; i < height; i = i + ROTATION_BUFFER_SIZE)
+       auto buffer_size = maxDivisorRange(height, width, 1, ROTATION_BUFFER_SIZE); 
+
+       byte** buffer = new byte * [buffer_size];
+       for (int i = 0; i < buffer_size; ++i)
+           buffer[i] = new byte[buffer_size * SIZE];
+
+
+       for (int i = 0; i <= height - buffer_size; i = i + buffer_size)
        {
-           for (int j = 0; j < width; j = j + ROTATION_BUFFER_SIZE)
+           for (int j = 0; j <= width - buffer_size; j = j + buffer_size)
            {
-               for (int ii = 0; ii < ROTATION_BUFFER_SIZE; ii++) {
-                   for (int jj = 0; jj < ROTATION_BUFFER_SIZE; jj++) {
-                       auto source_index = (j + jj + (width * (i + ii))) * SIZE; // capture a buffer from source
-                       memcpy((void*)&(buffer[ROTATION_BUFFER_SIZE - jj - 1][(ROTATION_BUFFER_SIZE - ii - 1) * SIZE]), &source[source_index], SIZE);
+               for (int ii = 0; ii < buffer_size; ++ii)
+               {
+                   for (int jj = 0; jj < buffer_size; ++jj)
+                   {
+                       auto source_index = ((j + jj) + (width * (i + ii))) * SIZE;
+                       memcpy((void*)&(buffer[(buffer_size-1 - jj)][(buffer_size-1 - ii) * SIZE]), &source[source_index], SIZE);
                    }
                }
-               for (int ii = 0; ii < ROTATION_BUFFER_SIZE; ii++) { // copy buffer to out
-                   auto out_index = ((height - (i + ROTATION_BUFFER_SIZE - 1) - 1) + (width - (j + ROTATION_BUFFER_SIZE - 1) - 1 + ii) * height) * SIZE;
-                   memcpy(&out[out_index], (buffer + ii), SIZE * ROTATION_BUFFER_SIZE);
-               }
 
+               for (int ii = 0; ii < buffer_size; ++ii)
+               {
+                   auto out_index = (((height_out - buffer_size - j + 1) * width_out) - i - buffer_size + (ii)*width_out);
+                   memcpy(&out[(out_index)*SIZE], (buffer[ii]), buffer_size * SIZE);
+               }
            }
        }
+
+       for (int i = 0; i < buffer_size; ++i)
+       {
+           delete[] buffer[i];
+       }
+       delete[] buffer;
+ 
    }
     // IMPORTANT! This implementation is based on the assumption that the RGB sensor is positioned strictly to the left of the depth sensor.
     // namely D415/D435 and SR300. The implementation WILL NOT work properly for different setups
@@ -150,10 +193,11 @@ namespace librealsense
                    {
                        points_ptr = points + uv_index;
                        uv_map_ptr = uv_map + uv_index;
+                       auto scan_win_size = maxDivisorRange(rotated_depth_height, rotated_depth_width, 1, VERTICAL_SCAN_WINDOW_SIZE);
 
-                       if (j >= VERTICAL_SCAN_WINDOW_SIZE) {
+                       if (j >= scan_win_size) {
                            maxInLine = (uv_map_ptr - 1 * points_width)->y;
-                           for (size_t y = 0; y <= VERTICAL_SCAN_WINDOW_SIZE; ++y)
+                           for (size_t y = 0; y <= scan_win_size; ++y)
                            {
                                if (((uv_map_ptr + y * points_width)->y < maxInLine))
                                {
diff --git a/src/rs.cpp b/src/rs.cpp
index 2fff29c..d55188f 100644
--- a/src/rs.cpp
+++ b/src/rs.cpp
@@ -1264,7 +1264,8 @@ const char* rs2_extension_to_string(rs2_extension type)
 const char* rs2_frame_metadata_value_to_string(rs2_frame_metadata_value metadata)         { return rs2_frame_metadata_to_string(metadata); }
 const char* rs2_l500_visual_preset_to_string(rs2_l500_visual_preset preset)               { return get_string(preset); }
 const char* rs2_sensor_mode_to_string(rs2_sensor_mode mode)                               { return get_string(mode); }
-const char* rs2_ambient_light_to_string( rs2_ambient_light ambient ) { return get_string( ambient ); }
+const char* rs2_ambient_light_to_string( rs2_ambient_light ambient )                      { return get_string(ambient); }
+const char* rs2_cah_trigger_to_string( rs2_cah_trigger mode )                             { return get_string(mode); }
 const char* rs2_calibration_type_to_string(rs2_calibration_type type)                     { return get_string(type); }
 const char* rs2_calibration_status_to_string(rs2_calibration_status status)               { return get_string(status); }
 
diff --git a/src/software-device.cpp b/src/software-device.cpp
index 4db15d1..4a3b7b8 100644
--- a/src/software-device.cpp
+++ b/src/software-device.cpp
@@ -72,7 +72,8 @@ namespace librealsense
 
     software_sensor::software_sensor(std::string name, software_device* owner)
         : sensor_base(name, owner, &_pbs),
-          _stereo_extension([this]() { return stereo_extension(this); })
+          _stereo_extension([this]() { return stereo_extension(this); }),
+          _depth_extension([this]() { return depth_extension(this); })
     {
         _metadata_parsers = md_constant_parser::create_metadata_parser_map();
         _unique_id = unique_id::generate_id();
@@ -180,7 +181,7 @@ namespace librealsense
         {
             if (supports_option(RS2_OPTION_DEPTH_UNITS))
             {
-                *ptr = &(*_stereo_extension);
+                *ptr = &(*_depth_extension);
                 return true;
             }
         }
diff --git a/src/software-device.h b/src/software-device.h
index 716b864..90d7849 100644
--- a/src/software-device.h
+++ b/src/software-device.h
@@ -141,7 +141,23 @@ namespace librealsense
             software_sensor* _owner;
         };
 
+        class depth_extension : public depth_sensor
+        {
+        public:
+            depth_extension(software_sensor* owner) : _owner(owner) {}
+
+            float get_depth_scale() const override {
+                return _owner->get_option(RS2_OPTION_DEPTH_UNITS).query();
+            }
+
+            void create_snapshot(std::shared_ptr<depth_sensor>& snapshot) const override {}
+            void enable_recording(std::function<void(const depth_sensor&)> recording_function) override {}
+        private:
+            software_sensor* _owner;
+        };
+
         lazy<stereo_extension> _stereo_extension;
+        lazy<depth_extension> _depth_extension;
 
         software_recommended_proccesing_blocks _pbs;
 
diff --git a/src/types.cpp b/src/types.cpp
index 875ba0c..5dfc96f 100644
--- a/src/types.cpp
+++ b/src/types.cpp
@@ -75,7 +75,7 @@ namespace librealsense
         rs2_exception_type exception_type) noexcept
         : librealsense_exception(msg, exception_type)
     {
-        LOG_WARNING(msg);
+        LOG_DEBUG("recoverable_exception: " << msg);
     }
 
     bool file_exists(const char* filename)
@@ -174,8 +174,9 @@ namespace librealsense
 #define CASE(X) STRCASE(SENSOR_MODE, X)
         switch (value)
         {
-            CASE(XGA)
             CASE(VGA)
+            CASE(XGA)
+            CASE(QVGA)
         default: assert(!is_valid(value)); return UNKNOWN_VALUE;
         }
 #undef CASE
@@ -186,7 +187,8 @@ namespace librealsense
 #define CASE(X) STRCASE(CALIBRATION, X)
         switch( type )
         {
-            CASE( DEPTH_TO_RGB )
+        CASE( AUTO_DEPTH_TO_RGB )
+        CASE( MANUAL_DEPTH_TO_RGB )
         default: assert( !is_valid( type ) ); return UNKNOWN_VALUE;
         }
 #undef CASE
@@ -197,15 +199,17 @@ namespace librealsense
 #define CASE(X) STRCASE(CALIBRATION, X)
         switch( value )
         {
-            CASE( SPECIAL_FRAME )
-            CASE( STARTED )
-            CASE( NOT_NEEDED )
-            CASE( SUCCESSFUL )
-            
-            CASE( FAILED )
-            CASE( SCENE_INVALID )
-            CASE( BAD_RESULT )
-            CASE( RETRY )
+        CASE( TRIGGERED )
+        CASE( SPECIAL_FRAME )
+        CASE( STARTED )
+        CASE( NOT_NEEDED )
+        CASE( SUCCESSFUL )
+        
+        CASE( BAD_CONDITIONS )
+        CASE( FAILED )
+        CASE( SCENE_INVALID )
+        CASE( BAD_RESULT )
+        CASE( RETRY )
         default: assert( !is_valid( value ) ); return UNKNOWN_VALUE;
         }
 #undef CASE
@@ -223,6 +227,19 @@ namespace librealsense
 #undef CASE
     }
 
+    const char* get_string( rs2_cah_trigger value )
+    {
+#define CASE(X) STRCASE(CAH_TRIGGER, X)
+        switch( value )
+        {
+        CASE( MANUAL )
+        CASE( NOW )
+        CASE( AUTO )
+        default: assert( !is_valid( value ) ); return UNKNOWN_VALUE;
+        }
+#undef CASE
+    }
+
     const char* get_string(rs2_extension value)
     {
 #define CASE(X) STRCASE(EXTENSION, X)
diff --git a/src/types.h b/src/types.h
index ea39944..2716307 100644
--- a/src/types.h
+++ b/src/types.h
@@ -60,6 +60,11 @@ static const double r2d = 180 / pi;
 template<typename T> T deg2rad(T val) { return T(val * d2r); }
 template<typename T> T rad2deg(T val) { return T(val * r2d); }
 
+// global abs() is only defined for int for some GCC impl on Linux, meaning we may
+// get unwanted behavior without any warning whatsoever. Instead, we want to use the
+// C++ version in std!
+using std::abs;
+
 #pragma warning(disable: 4250)
 
 #ifdef ANDROID
@@ -503,9 +508,11 @@ namespace librealsense
     // Enumerated type support //
     /////////////////////////////
 
+// Require the last enumerator value to be in format of RS2_#####_COUNT
 #define RS2_ENUM_HELPERS( TYPE, PREFIX )                                                           \
     RS2_ENUM_HELPERS_CUSTOMIZED( TYPE, 0, RS2_##PREFIX##_COUNT - 1 )
 
+// This macro can be used directly if needed to support enumerators with no RS2_#####_COUNT last value
 #define RS2_ENUM_HELPERS_CUSTOMIZED( TYPE, FIRST, LAST )                                           \
     LRS_EXTENSION_API const char * get_string( TYPE value );                                       \
     inline bool is_valid( TYPE value ) { return value >= FIRST && value <= LAST; }                 \
@@ -518,7 +525,7 @@ namespace librealsense
     }                                                                                              \
     inline bool try_parse( const std::string & str, TYPE & res )                                   \
     {                                                                                              \
-        for( int i = FIRST; i < LAST; i++ )                                                        \
+        for( int i = FIRST; i <= LAST; i++ )                                                       \
         {                                                                                          \
             auto v = static_cast< TYPE >( i );                                                     \
             if( str == get_string( v ) )                                                           \
@@ -549,6 +556,7 @@ namespace librealsense
     RS2_ENUM_HELPERS(rs2_calibration_type, CALIBRATION_TYPE)
     RS2_ENUM_HELPERS_CUSTOMIZED(rs2_calibration_status, RS2_CALIBRATION_STATUS_FIRST, RS2_CALIBRATION_STATUS_LAST )
     RS2_ENUM_HELPERS_CUSTOMIZED(rs2_ambient_light, RS2_AMBIENT_LIGHT_NO_AMBIENT, RS2_AMBIENT_LIGHT_LOW_AMBIENT)
+    RS2_ENUM_HELPERS(rs2_cah_trigger, CAH_TRIGGER)
 
 
     ////////////////////////////////////////////
diff --git a/src/uvc/uvc-device.cpp b/src/uvc/uvc-device.cpp
index 4584663..7eadf7a 100644
--- a/src/uvc/uvc-device.cpp
+++ b/src/uvc/uvc-device.cpp
@@ -160,7 +160,7 @@ namespace librealsense
 
             stop_stream_cleanup(profile, elem);
 
-            if (_profiles.empty())
+            if (!_profiles.empty())
                 _streamers.clear();
         }
 
diff --git a/src/uvc/uvc-streamer.cpp b/src/uvc/uvc-streamer.cpp
index e5c1195..678acbc 100644
--- a/src/uvc/uvc-streamer.cpp
+++ b/src/uvc/uvc-streamer.cpp
@@ -157,7 +157,10 @@ namespace librealsense
 
                 _context.messenger->reset_endpoint(_read_endpoint, RS2_USB_ENDPOINT_DIRECTION_READ);
 
-                _running = true;
+                {
+                    std::lock_guard<std::mutex> lock(_running_mutex);
+                    _running = true;
+                }
 
                 for(auto&& r : _requests)
                 {
@@ -197,14 +200,25 @@ namespace librealsense
 
                 _publish_frame_thread->stop();
 
-                _running = false;
+                {
+                    std::lock_guard<std::mutex> lock(_running_mutex);
+                    _running = false;
+                    _stopped_cv.notify_one();
+                }
 
             }, [this](){ return !_running; });
         }
 
         void uvc_streamer::flush()
         {
-            stop();
+            if(_running)
+                stop();
+
+            // synchronized so do not destroy shared pointers while it's still being running
+            {
+                std::unique_lock<std::mutex> lock(_running_mutex);
+                _stopped_cv.wait_for(lock, std::chrono::seconds(1), [&]() { return !_running; });
+            }
 
             _read_endpoint.reset();
 
diff --git a/src/uvc/uvc-streamer.h b/src/uvc/uvc-streamer.h
index bd669ce..bf71ce3 100644
--- a/src/uvc/uvc-streamer.h
+++ b/src/uvc/uvc-streamer.h
@@ -44,6 +44,8 @@ namespace librealsense
             bool wait_for_first_frame(uint32_t timeout_ms);
 
         private:
+            std::mutex _running_mutex;
+            std::condition_variable _stopped_cv;
             bool _running = false;
             bool _frame_arrived = false;
             bool _publish_frames = true;
diff --git a/tools/depth-quality/depth-quality-model.cpp b/tools/depth-quality/depth-quality-model.cpp
index 2ece0f1..52c0e42 100644
--- a/tools/depth-quality/depth-quality-model.cpp
+++ b/tools/depth-quality/depth-quality-model.cpp
@@ -790,8 +790,7 @@ namespace rs2
 
             auto dev = _pipe.get_active_profile().get_device();
             auto dpt_sensor = std::make_shared<sensor>(dev.first<depth_sensor>());
-            _device_model = std::shared_ptr<rs2::device_model>(new device_model(dev, _error_message, _viewer_model));
-            _device_model->allow_remove = false;
+            _device_model = std::shared_ptr<rs2::device_model>(new device_model(dev, _error_message, _viewer_model,false));
             _device_model->show_depth_only = true;
             _device_model->show_stream_selection = false;
             std::shared_ptr< atomic_objects_in_frame > no_detected_objects;
diff --git a/tools/fw-logger/rs-fw-logger.cpp b/tools/fw-logger/rs-fw-logger.cpp
index 6085f86..5d0cb14 100644
--- a/tools/fw-logger/rs-fw-logger.cpp
+++ b/tools/fw-logger/rs-fw-logger.cpp
@@ -127,9 +127,7 @@ int main(int argc, char* argv[])
                     else
                     {
                         stringstream sstr;
-                        sstr << log_message.get_timestamp();
-                        sstr << " " << log_message.get_severity_str();
-                        sstr << "  FW_Log_Data:";
+                        sstr << datetime_string() << "  FW_Log_Data:";
                         std::vector<uint8_t> msg_data = log_message.data();
                         for (int i = 0; i < msg_data.size(); ++i)
                         {
diff --git a/tools/realsense-viewer/realsense-viewer.cpp b/tools/realsense-viewer/realsense-viewer.cpp
index f5f138a..c4e30ca 100644
--- a/tools/realsense-viewer/realsense-viewer.cpp
+++ b/tools/realsense-viewer/realsense-viewer.cpp
@@ -608,12 +608,7 @@ int main(int argc, const char** argv) try
             window.height() - viewer_model.get_output_height(),
             window.width() - viewer_model.panel_width, viewer_model.get_output_height() };
 
-        std::vector<rs2::device> devices;
-        for (auto&& dev_model : *device_models)
-        {
-            devices.push_back(dev_model->dev);
-        }
-        viewer_model.not_model->output.draw(window, output_rect, devices);
+        viewer_model.not_model->output.draw(window, output_rect, *device_models);
 
         // Set window position and size
         ImGui::SetNextWindowPos({ 0, viewer_model.panel_y });
diff --git a/tools/rs-imu-calibration/README.md b/tools/rs-imu-calibration/README.md
index 533a2ef..c797ac5 100644
--- a/tools/rs-imu-calibration/README.md
+++ b/tools/rs-imu-calibration/README.md
@@ -8,9 +8,12 @@ D435i and L515 cameras arrive from the factory with a calibrated IMU device. How
 
 The rs-imu-calibration tool is a code example that walks you through the calibration steps and saves the calibration coefficients to the EEPROM, to be applied automatically by the driver.
 
+Detailed information, including installation, procedure, and sample calibration demonstration, is described in the following white paper:
+  IMU Calibration Tool for Intel® RealSense™ Depth Camera White Paper
+  https://dev.intelrealsense.com/docs/imu-calibration-tool-for-intel-realsense-depth-camera
+
 ## Limitations
-While the tool achieves good overall results, it has limitations that may impact accuracy. Please refer to following white paper for further information:
-IMU Calibration Tool for Intel® RealSense™ Depth Camera White Paper (https://dev.intelrealsense.com/docs/depth-camera-imu-calibration)
+While the tool achieves good overall results, it has limitations that may impact accuracy. Please refer to the above white paper for further information.
 
 ## Command Line Parameters
 
diff --git a/unit-tests/algo/d2rgb/ac-logger.h b/unit-tests/algo/d2rgb/ac-logger.h
index 872cd2c..a7437a1 100644
--- a/unit-tests/algo/d2rgb/ac-logger.h
+++ b/unit-tests/algo/d2rgb/ac-logger.h
@@ -13,17 +13,17 @@ class ac_logger
 {
     struct dispatch : public el::LogDispatchCallback
     {
-        bool * _p_on;
+        ac_logger * _p_logger;
         
         void handle( const el::LogDispatchData* data ) noexcept override
         {
-            if( !*_p_on )
+            if( ! _p_logger->_on )
                 return;
             char const * raw = data->logMessage()->message().data();
-            if( !strncmp( AC_LOG_PREFIX, raw, AC_LOG_PREFIX_LEN ) )
+            if( ! strncmp( AC_LOG_PREFIX, raw, AC_LOG_PREFIX_LEN ) )
             {
-                std::cout << "-" << *el::LevelHelper::convertToString( data->logMessage()->level() ) << "- ";
-                std::cout << (raw + AC_LOG_PREFIX_LEN) << std::endl;
+                _p_logger->on_log( *el::LevelHelper::convertToString( data->logMessage()->level() ),
+                                   raw + AC_LOG_PREFIX_LEN );
             }
         }
     };
@@ -38,10 +38,17 @@ public:
 
         el::Helpers::installLogDispatchCallback< dispatch >( "our_dispatch" );
         auto dispatcher = el::Helpers::logDispatchCallback< dispatch >( "our_dispatch" );
-        dispatcher->_p_on = &_on;
+        dispatcher->_p_logger = this;
         el::Helpers::uninstallLogDispatchCallback< el::base::DefaultLogDispatchCallback >( "DefaultLogDispatchCallback" );
     }
+    virtual ~ac_logger() {}
 
     void enable( bool on = true ) { _on = on; }
 
+protected:
+    virtual void on_log( char severity, char const * message )
+    {
+        std::cout << "-" << severity << "- ";
+        std::cout << message << std::endl;
+    }
 };
diff --git a/unit-tests/algo/d2rgb/compare-scene.h b/unit-tests/algo/d2rgb/compare-scene.h
dissimilarity index 83%
index e6c59a6..d6957ea 100644
--- a/unit-tests/algo/d2rgb/compare-scene.h
+++ b/unit-tests/algo/d2rgb/compare-scene.h
@@ -1,742 +1,1417 @@
-// License: Apache 2.0. See LICENSE file in root directory.
-// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
-
-
-struct scene_stats
-{
-    size_t n_valid_scene, n_valid_scene_diff;
-    size_t n_valid_result, n_valid_result_diff;
-    size_t n_converged, n_converged_diff;
-    double cost, d_cost;
-    double movement, d_movement;
-};
-
-void compare_vertices_to_los_data( std::string const & scene_dir,
-                                   size_t num_of_vertices,
-                                   size_t cycle,
-                                   std::string const & time,
-                                   algo::convert_norm_vertices_to_los_data const & data )
-{
-
-    CHECK(compare_to_bin_file< algo::double3 >(
-        data.laser_incident,
-        scene_dir,
-        bin_file(time + "laserIncidentDirection", cycle, 3, 1, "double_00.bin")));
-
-    CHECK(compare_to_bin_file< algo::double3 >(
-        data.fovex_indicent_direction,
-        scene_dir,
-        bin_file(time + "fovexIndicentDirection", cycle, 3, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< algo::double3 >(
-        data.mirror_normal_direction,
-        scene_dir,
-        bin_file(time + "mirrorNormalDirection", cycle, 3, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.ang_x,
-        scene_dir,
-        bin_file(time + "angX", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.ang_y,
-        scene_dir,
-        bin_file(time + "angY", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.dsm_x_corr,
-        scene_dir,
-        bin_file(time + "dsmXcorr", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.dsm_y_corr,
-        scene_dir,
-        bin_file(time + "dsmYcorr", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.dsm_x,
-        scene_dir,
-        bin_file(time + "dsmX", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-
-    CHECK(compare_to_bin_file< double >(
-        data.dsm_y,
-        scene_dir,
-        bin_file(time + "dsmY", cycle, 1, num_of_vertices, "double_00") + ".bin",
-        num_of_vertices, 1,
-        compare_same_vectors));
-}
-
-void compare_scene( std::string const & scene_dir, scene_stats * stats = nullptr )
-{
-    TRACE( "Loading " << scene_dir << " ..." );
-
-    camera_params ci = read_camera_params( scene_dir, "camera_params" );
-    dsm_params dsm = read_dsm_params(scene_dir, "DSM_params");
-    ci.dsm_params = dsm.dsm_params;
-    ci.cal_info = dsm.regs;
-    ci.cal_regs = dsm.algo_calibration_registers;
-
-    scene_metadata md( scene_dir );
-
-    algo::optimizer cal;
-
-    /*std::vector<double> in = { 1,2,3,4 };
-    std::vector<double>out(4);
-
-    algo::direct_inv(in,out,2);*/
-
-    init_algo( cal, scene_dir,
-        md.rgb_file,
-        md.rgb_prev_file,
-        md.ir_file,
-        md.z_file,
-        ci );
-
-    auto& z_data = cal.get_z_data();
-    auto& ir_data = cal.get_ir_data();
-    auto& yuy_data = cal.get_yuy_data();
-    auto& depth_data = cal.get_z_data();
-    auto& decision_params = cal.get_decision_params();
-    auto& svm_features = cal.get_extracted_features();
-    
-    auto rgb_h = ci.rgb.height;
-    auto rgb_w = ci.rgb.width;
-    auto z_h = ci.z.height;
-    auto z_w = ci.z.width;
-    auto num_of_calib_elements = 22;
-    auto num_of_p_matrix_elements = sizeof(algo::p_matrix) / sizeof(double);
-    auto num_of_k_matrix_elements = sizeof(algo::k_matrix) / sizeof(double);
-
-    //---
-    CHECK(compare_to_bin_file< uint8_t >(yuy_data.lum_frame, scene_dir, "YUY2_lum", rgb_w, rgb_h, "uint8_00", compare_same_vectors));
-    CHECK( compare_to_bin_file< double >( yuy_data.edges, scene_dir, "YUY2_edge", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDT, scene_dir, "YUY2_IDT", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTx, scene_dir, "YUY2_IDTx", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTy, scene_dir, "YUY2_IDTy", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-
-    // smearing
-    CHECK(compare_to_bin_file< double >(depth_data.gradient_x, scene_dir, "Zx", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.gradient_y, scene_dir, "Zy", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.gradient_x, scene_dir, "Ix", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.gradient_y, scene_dir, "Iy", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.edges, scene_dir, "iEdge", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.edges, scene_dir, "zedge", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(depth_data.section_map_depth, scene_dir, "sectionMapDepth", z_w, z_h, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_edge_pixels_by_ir, scene_dir, "validEdgePixelsByIR", z_w, z_h, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc_x, scene_dir, "gridXValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc_y, scene_dir, "gridYValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_location_rc, scene_dir, "locRC", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(ir_data.valid_section_map, scene_dir, "sectionMapValid", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_gradient_x, scene_dir, "IxValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.valid_gradient_y, scene_dir, "IyValid", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.direction_deg, scene_dir, "directionInDeg", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.direction_per_pixel, scene_dir, "dirPerPixel", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region[0], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region[1], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_01", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region[2], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_02", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region[3], scene_dir, "localRegion", 2, md.n_valid_ir_edges, "double_03", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[0], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[1], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_01", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[2], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_02", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_x[3], scene_dir, "localRegion_x", 1, md.n_valid_ir_edges, "double_03", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[0], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[1], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_01", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[2], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_02", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_region_y[3], scene_dir, "localRegion_y", 1, md.n_valid_ir_edges, "double_03", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.local_edges, scene_dir, "localEdges", 4, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(ir_data.is_supressed, scene_dir, "isSupressed", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(ir_data.fraq_step, scene_dir, "fraqStep", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.local_rc_subpixel, scene_dir, "locRCsub", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.local_x, scene_dir, "localZx", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.local_y, scene_dir, "localZy", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.gradient, scene_dir, "zGrad", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.grad_in_direction, scene_dir, "zGradInDirection", 1, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.local_values, scene_dir, "localZvalues", 4, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.closest, scene_dir, "zValuesForSubEdges", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.edge_sub_pixel, scene_dir, "edgeSubPixel", 2, md.n_valid_ir_edges, "double_00", compare_same_vectors));
-    
-    CHECK(compare_to_bin_file< byte >(depth_data.supressed_edges, scene_dir, "validEdgePixels", 1, md.n_valid_ir_edges, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.grad_in_direction_valid, scene_dir, "validzGradInDirection", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >( depth_data.valid_edge_sub_pixel, scene_dir, "validedgeSubPixel", 2, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >( depth_data.values_for_subedges, scene_dir, "validzValuesForSubEdges", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.valid_direction_per_pixel, scene_dir, "validdirPerPixel", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(depth_data.valid_section_map, scene_dir, "validsectionMapDepth", 1, md.n_valid_pixels, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.valid_directions, scene_dir, "validdirectionIndex", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    
-    //CHECK(compare_to_bin_file< double >(depth_data.valid_edge_sub_pixel_x, scene_dir, "xim", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    //CHECK(compare_to_bin_file< double >(depth_data.valid_edge_sub_pixel_y, scene_dir, "yim", 1, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double>(depth_data.sub_points, scene_dir, "subPoints", 3, md.n_valid_pixels, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< algo::double2 >(depth_data.uvmap, scene_dir, bin_file("uv", 2, md.n_valid_pixels, "double_00") + ".bin", md.n_valid_pixels, 1, compare_same_vectors));
-    CHECK(compare_to_bin_file< byte >(depth_data.is_inside, scene_dir, "isInside", 1, md.n_valid_pixels, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.subpixels_x, scene_dir, "Z_xim", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.subpixels_y, scene_dir, "Z_yim", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.directions, scene_dir, "directionIndexInside", 1, md.n_edges, "double_00", compare_same_vectors));
-    
-    CHECK(compare_to_bin_file< double >(depth_data.subpixels_x_round, scene_dir, "round_xim", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.subpixels_y_round, scene_dir, "round_yim", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(depth_data.weights, scene_dir, "weights", 1, md.n_edges, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(depth_data.relevant_pixels_image, scene_dir, "relevantPixelsImage", z_w, z_h, "uint8_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< algo::double3 >(depth_data.vertices, scene_dir, bin_file("vertices", 3, md.n_edges, "double_00") + ".bin", md.n_edges, 1, compare_same_vectors));
-    CHECK(compare_to_bin_file< uint8_t >(depth_data.section_map_depth_inside, scene_dir, "sectionMapDepthInside", 1, md.n_edges, "uint8_00", compare_same_vectors));
-
-
-    // ---
-    TRACE( "\nChecking scene validity:" );
-
-    bool const is_scene_valid = cal.is_scene_valid();
-    bool const matlab_scene_valid = md.is_scene_valid;
-    CHECK( is_scene_valid == matlab_scene_valid );
-    if( stats )
-    {
-        stats->n_valid_scene = is_scene_valid;
-        stats->n_valid_scene_diff = is_scene_valid != matlab_scene_valid;
-    }
-
-    // edge distribution
-    CHECK( compare_to_bin_file< double >( z_data.sum_weights_per_section, scene_dir, "depthEdgeWeightDistributionPerSectionDepth", 1, 4, "double_00", compare_same_vectors ) );
-
-    //CHECK( compare_to_bin_file< byte >( z_data.section_map, scene_dir, "sectionMapDepth_trans", 1, md.n_edges, "uint8_00", compare_same_vectors ) );
-    //CHECK( compare_to_bin_file< byte >( yuy_data.section_map, scene_dir, "sectionMapRgb_trans", 1, rgb_w*rgb_h, "uint8_00", compare_same_vectors ) );
-
-    CHECK( compare_to_bin_file< double >( yuy_data.sum_weights_per_section, scene_dir, "edgeWeightDistributionPerSectionRgb", 1, 4, "double_00", compare_same_vectors ) );
-
-    // gradient balanced
-    // TODO NOHA
-    CHECK(compare_to_bin_file< double >(z_data.sum_weights_per_direction, scene_dir, "edgeWeightsPerDir", 4, 1, "double_00", compare_same_vectors));
-
-    // movment check
-    // 1. dilation
-    CHECK( compare_to_bin_file< uint8_t >( yuy_data.prev_logic_edges, scene_dir, "logicEdges", rgb_w, rgb_h, "uint8_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< double >( yuy_data.dilated_image, scene_dir, "dilatedIm", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-
-    // 2. gausssian
-    CHECK( compare_to_bin_file< double >( yuy_data.yuy_diff, scene_dir, "diffIm_01", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< double >( yuy_data.gaussian_filtered_image, scene_dir, "diffIm", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-
-    // 3. movement
-    CHECK( compare_to_bin_file< double >( yuy_data.gaussian_diff_masked, scene_dir, "IDiffMasked", rgb_w, rgb_h, "double_00", compare_same_vectors ) );
-    CHECK( compare_to_bin_file< uint8_t >( yuy_data.move_suspect, scene_dir, "ixMoveSuspect", rgb_w, rgb_h, "uint8_00", compare_same_vectors ) );
-
-    //--
-    TRACE( "\nOptimizing:" );
-
-    auto cb = [&]( algo::data_collect const & data )
-    {
-        // data.iteration_data_p is 0-based!
-        //REQUIRE( data.iteration_data_p < md.n_iterations );
-
-        //REQUIRE( data.cycle <= md.n_cycles );
-
-        if (data.type == algo::k_to_dsm_data)
-        {
-            std::cout << std::endl << "COMPARING K_TO_DSM DATA " << data.cycle_data_p.cycle << std::endl;
-            algo::k_matrix old_k = data.k2dsm_data_p.inputs.old_k;
-            algo::k_matrix new_k = data.k2dsm_data_p.inputs.new_k;
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(old_k.k_mat.rot),
-                    std::end(old_k.k_mat.rot)),
-                scene_dir,
-                bin_file("k2dsm_inpus_oldKdepth",
-                    data.cycle_data_p.cycle,
-                    num_of_k_matrix_elements,
-                    1,
-                    "double_00.bin"),
-                num_of_k_matrix_elements, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(new_k.k_mat.rot),
-                    std::end(new_k.k_mat.rot)),
-                scene_dir,
-                bin_file("k2dsm_inpus_newKdepth",
-                    data.cycle_data_p.cycle,
-                    num_of_k_matrix_elements,
-                    1,
-                    "double_00.bin"),
-                num_of_k_matrix_elements, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double3 >(
-                data.k2dsm_data_p.inputs.z.vertices,
-                scene_dir,
-                bin_file("k2dsm_inpus_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                std::vector< algo::double2 >(1, { data.k2dsm_data_p.inputs.previous_dsm_params.h_scale, data.k2dsm_data_p.inputs.previous_dsm_params.v_scale }),
-                scene_dir,
-                bin_file("k2dsm_inpus_acData", data.cycle_data_p.cycle, 2, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-
-            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
-                data.k2dsm_data_p.inputs.new_dsm_regs,
-                scene_dir,
-                bin_file("k2dsm_inpus_dsmRegs", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
-
-
-            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
-                data.k2dsm_data_p.dsm_regs_orig,
-                scene_dir,
-                bin_file("dsmRegsOrig", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< uint8_t >(
-                data.k2dsm_data_p.relevant_pixels_image_rot,
-                scene_dir,
-                bin_file("relevantPixelnImage_rot", data.cycle_data_p.cycle, z_w, z_h, "uint8_00") + ".bin",
-                z_w, z_h,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::los_shift_scaling >(
-                data.k2dsm_data_p.dsm_pre_process_data.last_los_error,
-                scene_dir,
-                bin_file("dsm_los_error_orig", data.cycle_data_p.cycle, 1, 4, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< algo::double3 >(
-                data.k2dsm_data_p.dsm_pre_process_data.vertices_orig,
-                scene_dir,
-                bin_file("verticesOrig", data.cycle_data_p.cycle, 3, md.n_relevant_pixels, "double_00") + ".bin",
-                md.n_relevant_pixels, 1, compare_same_vectors));
-
-
-            compare_vertices_to_los_data(scene_dir, md.n_relevant_pixels, data.cycle_data_p.cycle, "first_", data.k2dsm_data_p.first_norm_vertices_to_los_data);
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.dsm_pre_process_data.los_orig,
-                scene_dir,
-                bin_file("losOrig", data.cycle_data_p.cycle, 2, md.n_relevant_pixels, "double_00") + ".bin",
-                md.n_relevant_pixels, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.k2dsm_data_p.errL2,
-                scene_dir,
-                bin_file("errL2", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.errL2.size(), "double_00") + ".bin",
-                data.k2dsm_data_p.errL2.size(), 1, compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.focal_scaling,
-                scene_dir,
-                bin_file("focalScaling", data.cycle_data_p.cycle, 2, 1, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< std::vector<double>>(
-                data.k2dsm_data_p.sg_mat,
-                scene_dir,
-                bin_file("sgMat", data.cycle_data_p.cycle, data.k2dsm_data_p.sg_mat[0].size(), data.k2dsm_data_p.sg_mat.size(), "double_00") + ".bin",
-                data.k2dsm_data_p.sg_mat.size(), data.k2dsm_data_p.sg_mat[0].size(),
-                data.k2dsm_data_p.sg_mat.size(),
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.k2dsm_data_p.sg_mat_tag_x_sg_mat,
-                scene_dir,
-                bin_file("sg_mat_tag_x_sg_mat", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(), "double_00") + ".bin",
-                data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(), 1, compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.k2dsm_data_p.sg_mat_tag_x_err_l2,
-                scene_dir,
-                bin_file("sg_mat_tag_x_err_l2", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(), "double_00") + ".bin",
-                data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(), 1, compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.k2dsm_data_p.quad_coef,
-                scene_dir,
-                bin_file("quadCoef", data.cycle_data_p.cycle, 1, data.k2dsm_data_p.quad_coef.size(), "double_00") + ".bin",
-                data.k2dsm_data_p.quad_coef.size(), 1, compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.opt_scaling,
-                scene_dir,
-                bin_file("optScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.new_los_scaling,
-                scene_dir,
-                bin_file("newlosScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                std::vector< algo::double2 >(1, { data.k2dsm_data_p.dsm_params_cand.h_scale, data.k2dsm_data_p.dsm_params_cand.v_scale }),
-                scene_dir,
-                bin_file("acDataCand", data.cycle_data_p.cycle, 2, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::algo_calibration_registers >(
-                 data.k2dsm_data_p.dsm_regs_cand,
-                 scene_dir,
-                 bin_file("dsmRegsCand", data.cycle_data_p.cycle, 4, 1, "double_00.bin")));
-
-            compare_vertices_to_los_data(scene_dir, md.n_edges, data.cycle_data_p.cycle, "second_", data.k2dsm_data_p.second_norm_vertices_to_los_data);
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.los_orig,
-                scene_dir,
-                bin_file("orig_los", data.cycle_data_p.cycle, 2, md.n_edges, "double_00") + ".bin",
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.k2dsm_data_p.dsm,
-                scene_dir,
-                bin_file("dsm", data.cycle_data_p.cycle, 2, md.n_edges, "double_00") + ".bin",
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double3 >(
-                data.k2dsm_data_p.vertices,
-                scene_dir,
-                bin_file("new_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            TRACE("\nSet next cycle data from Matlab:");
-        }
-        else if (data.type == algo::cycle_data)
-        {
-            std::cout << std::endl << "COMPARING CYCLE DATA " << data.cycle_data_p.cycle << std::endl;
-
-            algo::k_matrix k_depth;
-            k_depth.k_mat.rot[0] = data.cycle_data_p.new_k_depth.fx;
-            k_depth.k_mat.rot[2] = data.cycle_data_p.new_k_depth.ppx;
-            k_depth.k_mat.rot[4] = data.cycle_data_p.new_k_depth.fy;
-            k_depth.k_mat.rot[5] = data.cycle_data_p.new_k_depth.ppy;
-
-            CHECK(compare_to_bin_file< algo::k_matrix >(
-                k_depth,
-                scene_dir,
-                bin_file("end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin")));
-
-            CHECK(compare_to_bin_file< algo::p_matrix >(
-                data.cycle_data_p.new_params.curr_p_mat,
-                scene_dir,
-                bin_file("end_cycle_p_matrix", data.cycle_data_p.cycle, num_of_p_matrix_elements, 1, "double_00.bin")));
-
-            try
-            {
-
-               /* auto vertices = read_vector_from<algo::double3>(bin_file(bin_dir(scene_dir) + "end_cycle_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"));
-
-                algo::p_matrix p_mat;
-
-                auto p_vec = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_cycle_p_matrix",
-                    data.cycle_data_p.cycle,
-                    num_of_p_matrix_elements, 1,
-                    "double_00.bin"));
-                std::copy(p_vec.begin(), p_vec.end(), p_mat.vals);
-
-                auto dsm_regs_vec = read_vector_from< algo::algo_calibration_registers >(
-                    bin_file(bin_dir(scene_dir) + "end_cycle_dsmRegsCand", data.cycle_data_p.cycle, 4, 1, "double_00.bin"));
-
-                algo::algo_calibration_registers dsm_regs = *(algo::algo_calibration_registers*)(dsm_regs_vec.data());
-                auto ac_data_vec = read_vector_from< algo::double2 >(bin_file(bin_dir(scene_dir) + "end_cycle_acData", data.cycle_data_p.cycle, 2, 1, "double_00.bin"));
-                
-                algo::rs2_dsm_params_double dsm_params;
-                dsm_params.h_scale = ac_data_vec[0].x;
-                dsm_params.v_scale = ac_data_vec[0].y;
-                dsm_params.model = RS2_DSM_CORRECTION_AOT;*/
-
-                //auto Kdepth = read_vector_from<algo::matrix_3x3>(bin_file(bin_dir(scene_dir) + "end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin"));
-                //cal.set_cycle_data(vertices, k_depth, p_mat, dsm_regs, dsm_params);
-            }
-            catch (std::runtime_error &e) {
-                // if device isn't calibrated, get_extrinsics must error out (according to old comment. Might not be true under new API)
-                WARN(e.what());
-            }
-        }
-        else if(data.type == algo::iteration_data)
-        {
-            std::cout << std::endl << "COMPARING ITERATION DATA " << data.cycle_data_p.cycle <<" "<< data.iteration_data_p.iteration + 1 << std::endl;
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(data.iteration_data_p.params.curr_p_mat.vals),
-                    std::end(data.iteration_data_p.params.curr_p_mat.vals)),
-                scene_dir,
-                bin_file("p_matrix_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements,
-                    1,
-                    "double_00.bin"),
-                num_of_p_matrix_elements, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(1, data.iteration_data_p.params.cost),
-                scene_dir,
-                bin_file("cost_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.iteration_data_p.uvmap,
-                scene_dir,
-                bin_file("uvmap_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 2, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.iteration_data_p.d_vals,
-                scene_dir,
-                bin_file("DVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.iteration_data_p.d_vals_x,
-                scene_dir,
-                bin_file("DxVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.iteration_data_p.d_vals_y,
-                scene_dir,
-                bin_file("DyVals_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::double2 >(
-                data.iteration_data_p.xy,
-                scene_dir,
-                bin_file("xy_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 2, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                data.iteration_data_p.rc,
-                scene_dir,
-                bin_file("rc_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, md.n_edges, "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::p_matrix >(data.iteration_data_p.coeffs_p.x_coeffs,
-                scene_dir,
-                bin_file("xCoeff_P_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, md.n_edges,
-                    "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< algo::p_matrix >(data.iteration_data_p.coeffs_p.y_coeffs,
-                scene_dir,
-                bin_file("yCoeff_P_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, md.n_edges,
-                    "double_00.bin"),
-                md.n_edges, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(data.iteration_data_p.params.calib_gradients.vals),
-                    std::end(data.iteration_data_p.params.calib_gradients.vals)),
-                scene_dir,
-                bin_file("grad_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, 1,
-                    "double_00.bin"),
-                num_of_p_matrix_elements, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(1, data.iteration_data_p.grads_norma),
-                scene_dir,
-                bin_file("grad_norma_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(data.iteration_data_p.grads_norm.vals),
-                    std::end(data.iteration_data_p.grads_norm.vals)),
-                scene_dir,
-                bin_file("grads_norm_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, 1,
-                    "double_00.bin"),
-                num_of_p_matrix_elements, 1,
-                compare_same_vectors));
-
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(data.iteration_data_p.normalized_grads.vals),
-                    std::end(data.iteration_data_p.normalized_grads.vals)),
-                scene_dir,
-                bin_file("normalized_grads_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, 1,
-                    "double_00.bin"),
-                num_of_p_matrix_elements, 1,
-                compare_same_vectors));
-
-
-            CHECK(
-                compare_to_bin_file< double >(std::vector< double >(std::begin(data.iteration_data_p.unit_grad.vals),
-                    std::end(data.iteration_data_p.unit_grad.vals)),
-                    scene_dir,
-                    bin_file("unit_grad_iteration",
-                        data.cycle_data_p.cycle,
-                        data.iteration_data_p.iteration + 1,
-                        num_of_p_matrix_elements, 1,
-                        "double_00.bin"),
-                    num_of_p_matrix_elements, 1,
-                    compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(1, data.iteration_data_p.t),
-                scene_dir,
-                bin_file("t_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(1, data.iteration_data_p.back_tracking_line_search_iters),
-                scene_dir,
-                bin_file("back_tracking_line_iter_count_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    1, 1,
-                    "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(std::begin(data.iteration_data_p.next_params.curr_p_mat.vals),
-                    std::end(data.iteration_data_p.next_params.curr_p_mat.vals)),
-                scene_dir,
-                bin_file("next_p_matrix_iteration",
-                    data.cycle_data_p.cycle,
-                    data.iteration_data_p.iteration + 1,
-                    num_of_p_matrix_elements, 1,
-                    "double_00.bin"),
-                num_of_p_matrix_elements, 1,
-                compare_same_vectors));
-
-            CHECK(compare_to_bin_file< double >(
-                std::vector< double >(1, data.iteration_data_p.next_params.cost),
-                scene_dir,
-                bin_file("next_cost_iteration", data.cycle_data_p.cycle, data.iteration_data_p.iteration + 1, 1, 1, "double_00.bin"),
-                1, 1,
-                compare_same_vectors));
-        }
-       
-    };
-
-    // Our code doesn't count the first iteration; the Matlab code starts at 1 even if it doesn't do anything...
-    //REQUIRE( cal.optimize( cb ) + 1 == md.n_iterations );
-    cal.optimize( cb );
-
-    
-    auto new_calibration = cal.get_calibration();
-    auto cost = cal.get_cost();
-    
-    auto filename = bin_file( "new_calib", num_of_calib_elements, 1, "double_00" ) + ".bin";
-    TRACE( "Comparing " << filename << " ..." );
-    algo::calib matlab_calib;
-    double matlab_cost = 0;
-    CHECK( get_calib_from_raw_data( matlab_calib, matlab_cost, scene_dir, filename ) );
-    CHECK( compare_calib( new_calibration, cost, matlab_calib, matlab_cost ));
-    new_calibration.copy_coefs(matlab_calib);
-    if( stats )
-    {
-        stats->cost = cost;
-        stats->d_cost = cost - matlab_cost;
-    }
-
-
-#if 1
-    auto vertices = read_vector_from<algo::double3>(bin_file(bin_dir(scene_dir) + "end_vertices", 3, md.n_edges, "double_00.bin"));
-
-
-    if( stats )
-    {
-        auto our_uvmap = algo::get_texture_map( depth_data.vertices, new_calibration, new_calibration.calc_p_mat() );
-        auto matlab_uvmap = algo::get_texture_map( vertices, matlab_calib, matlab_calib.calc_p_mat() );
-
-        stats->d_movement = cal.calc_correction_in_pixels( our_uvmap, matlab_uvmap );
-    }
-
-
-    algo::p_matrix p_mat;
-
-    auto p_vec = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_p_matrix",
-        num_of_p_matrix_elements, 1,
-        "double_00.bin"));
-
-    std::copy(p_vec.begin(), p_vec.end(), p_mat.vals);
-
-    algo::p_matrix p_mat_opt;
-
-    auto p_vec_opt = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "end_p_matrix_opt",
-        num_of_p_matrix_elements, 1,
-        "double_00.bin"));
-
-    std::copy(p_vec_opt.begin(), p_vec_opt.end(), p_mat_opt.vals);
-
-    cal.set_final_data(vertices, p_mat, p_mat_opt);
-    //--
-    TRACE( "\nChecking output validity:" );
-    // Pixel movement is OK, but some sections have negative cost
-    bool const is_valid_results = cal.is_valid_results();
-    bool const matlab_valid_results = md.is_output_valid;
-    CHECK( is_valid_results == matlab_valid_results );
-    if( stats )
-    {
-        stats->n_valid_result = is_valid_results;
-        stats->n_valid_result_diff = is_valid_results != matlab_valid_results;
-
-        stats->n_converged = is_valid_results && is_scene_valid;
-        bool const matlab_converged = matlab_valid_results && matlab_scene_valid;
-        stats->n_converged_diff = bool(stats->n_converged) != matlab_converged;
-    }
-
-    double const movement_in_pixels = cal.calc_correction_in_pixels(new_calibration);
-    double const matlab_movement_in_pixels = md.correction_in_pixels;
-    CHECK( movement_in_pixels == approx( matlab_movement_in_pixels ) );
-    if( stats )
-    {
-        stats->movement = movement_in_pixels;
-        //stats->d_movement = movement_in_pixels - matlab_movement_in_pixels;
-    }
-
-    CHECK( compare_to_bin_file< double >( z_data.cost_diff_per_section, scene_dir, "costDiffPerSection", 4, 1, "double_00", compare_same_vectors ) );
-
-    //svm - remove xyMovementFromOrigin because its still not implemented
-    auto svm_features_mat = read_vector_from<double>(bin_file(bin_dir(scene_dir) + "svm_featuresMat",
-        10, 1,
-        "double_00.bin"));
-
-    svm_features_mat.erase(svm_features_mat.begin() + 7);
-    auto svm_mat = svm_features;
-    svm_mat.erase(svm_mat.begin()+7);
-   
-    CHECK(compare_same_vectors(svm_features_mat, svm_mat));
-
-    //CHECK(compare_to_bin_file< double >(svm_features, scene_dir, "svm_featuresMat", 10, 1, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(decision_params.distribution_per_section_depth, scene_dir, "svm_edgeWeightDistributionPerSectionDepth", 1, 4, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(decision_params.distribution_per_section_rgb, scene_dir, "svm_edgeWeightDistributionPerSectionRgb", 1, 4, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(decision_params.edge_weights_per_dir, scene_dir, "svm_edgeWeightsPerDir", 4, 1, "double_00", compare_same_vectors));
-    CHECK(compare_to_bin_file< double >(decision_params.improvement_per_section, scene_dir, "svm_improvementPerSection", 4, 1, "double_00", compare_same_vectors));
-#endif
-}
+// License: Apache 2.0. See LICENSE file in root directory.
+// Copyright(c) 2020 Intel Corporation. All Rights Reserved.
+
+struct scene_stats
+{
+    size_t n_valid_scene, n_valid_scene_diff;
+    size_t n_valid_result, n_valid_result_diff;
+    size_t n_converged, n_converged_diff;
+    double cost, d_cost;
+    double movement, d_movement;
+    size_t n_cycles;
+    float memory_consumption_peak;
+};
+
+void compare_vertices_to_los_data( std::string const & scene_dir,
+                                   size_t num_of_vertices,
+                                   size_t cycle,
+                                   std::string const & time,
+                                   algo::convert_norm_vertices_to_los_data const & data )
+{
+
+    CHECK( compare_to_bin_file< algo::double3 >(
+        data.laser_incident,
+        scene_dir,
+        bin_file( time + "laserIncidentDirection", cycle, 3, 1, "double_00.bin" ) ) );
+
+    CHECK( compare_to_bin_file< algo::double3 >(
+        data.fovex_indicent_direction,
+        scene_dir,
+        bin_file( time + "fovexIndicentDirection", cycle, 3, num_of_vertices, "double_00" )
+            + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< algo::double3 >(
+        data.mirror_normal_direction,
+        scene_dir,
+        bin_file( time + "mirrorNormalDirection", cycle, 3, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.ang_x,
+        scene_dir,
+        bin_file( time + "angX", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.ang_y,
+        scene_dir,
+        bin_file( time + "angY", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.dsm_x_corr,
+        scene_dir,
+        bin_file( time + "dsmXcorr", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.dsm_y_corr,
+        scene_dir,
+        bin_file( time + "dsmYcorr", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.dsm_x,
+        scene_dir,
+        bin_file( time + "dsmX", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >(
+        data.dsm_y,
+        scene_dir,
+        bin_file( time + "dsmY", cycle, 1, num_of_vertices, "double_00" ) + ".bin",
+        num_of_vertices,
+        1,
+        compare_same_vectors ) );
+}
+
+void compare_preprocessing_data( std::string const & scene_dir,
+                                 algo::z_frame_data const & depth_data,
+                                 algo::ir_frame_data const & ir_data,
+                                 algo::yuy2_frame_data const & yuy_data,
+                                 scene_metadata const & md )
+{
+    auto z_w = depth_data.width;
+    auto z_h = depth_data.height;
+
+    auto rgb_w = yuy_data.width;
+    auto rgb_h = yuy_data.height;
+
+    // smearing
+    CHECK( compare_to_bin_file< double >( depth_data.gradient_x,
+                                          scene_dir,
+                                          "Zx",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.gradient_y,
+                                          scene_dir,
+                                          "Zy",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.gradient_x,
+                                          scene_dir,
+                                          "Ix",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.gradient_y,
+                                          scene_dir,
+                                          "Iy",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.edges,
+                                          scene_dir,
+                                          "iEdge",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.edges,
+                                          scene_dir,
+                                          "zedge",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( depth_data.section_map_depth,
+                                           scene_dir,
+                                           "sectionMapDepth",
+                                           z_w,
+                                           z_h,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_edge_pixels_by_ir,
+                                          scene_dir,
+                                          "validEdgePixelsByIR",
+                                          z_w,
+                                          z_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_location_rc_x,
+                                          scene_dir,
+                                          "gridXValid",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_location_rc_y,
+                                          scene_dir,
+                                          "gridYValid",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_location_rc,
+                                          scene_dir,
+                                          "locRC",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( ir_data.valid_section_map,
+                                           scene_dir,
+                                           "sectionMapValid",
+                                           1,
+                                           md.n_valid_ir_edges,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_gradient_x,
+                                          scene_dir,
+                                          "IxValid",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.valid_gradient_y,
+                                          scene_dir,
+                                          "IyValid",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.direction_deg,
+                                          scene_dir,
+                                          "directionInDeg",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.direction_per_pixel,
+                                          scene_dir,
+                                          "dirPerPixel",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region[0],
+                                          scene_dir,
+                                          "localRegion",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region[1],
+                                          scene_dir,
+                                          "localRegion",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_01",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region[2],
+                                          scene_dir,
+                                          "localRegion",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_02",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region[3],
+                                          scene_dir,
+                                          "localRegion",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_03",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_x[0],
+                                          scene_dir,
+                                          "localRegion_x",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_x[1],
+                                          scene_dir,
+                                          "localRegion_x",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_01",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_x[2],
+                                          scene_dir,
+                                          "localRegion_x",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_02",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_x[3],
+                                          scene_dir,
+                                          "localRegion_x",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_03",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_y[0],
+                                          scene_dir,
+                                          "localRegion_y",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_y[1],
+                                          scene_dir,
+                                          "localRegion_y",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_01",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_y[2],
+                                          scene_dir,
+                                          "localRegion_y",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_02",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_region_y[3],
+                                          scene_dir,
+                                          "localRegion_y",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_03",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.local_edges,
+                                          scene_dir,
+                                          "localEdges",
+                                          4,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( ir_data.is_supressed,
+                                           scene_dir,
+                                           "isSupressed",
+                                           1,
+                                           md.n_valid_ir_edges,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( ir_data.fraq_step,
+                                          scene_dir,
+                                          "fraqStep",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.local_rc_subpixel,
+                                          scene_dir,
+                                          "locRCsub",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.local_x,
+                                          scene_dir,
+                                          "localZx",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.local_y,
+                                          scene_dir,
+                                          "localZy",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.gradient,
+                                          scene_dir,
+                                          "zGrad",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.grad_in_direction,
+                                          scene_dir,
+                                          "zGradInDirection",
+                                          1,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.local_values,
+                                          scene_dir,
+                                          "localZvalues",
+                                          4,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.closest,
+                                          scene_dir,
+                                          "zValuesForSubEdges",
+                                          1,
+                                          md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.edge_sub_pixel,
+                                          scene_dir,
+                                          "edgeSubPixel",
+                                          2,
+                                          md.n_valid_ir_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< byte >( depth_data.supressed_edges,
+                                        scene_dir,
+                                        "validEdgePixels",
+                                        1,
+                                        md.n_valid_ir_edges,
+                                        "uint8_00",
+                                        compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.grad_in_direction_valid,
+                                          scene_dir,
+                                          "validzGradInDirection",
+                                          1,
+                                          md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.valid_edge_sub_pixel,
+                                          scene_dir,
+                                          "validedgeSubPixel",
+                                          2,
+                                          md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.values_for_subedges,
+                                          scene_dir,
+                                          "validzValuesForSubEdges",
+                                          1,
+                                          md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.valid_direction_per_pixel,
+                                          scene_dir,
+                                          "validdirPerPixel",
+                                          1,
+                                          md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( depth_data.valid_section_map,
+                                           scene_dir,
+                                           "validsectionMapDepth",
+                                           1,
+                                           md.n_valid_pixels,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.valid_directions,
+                                          scene_dir,
+                                          "validdirectionIndex",
+                                          1,
+                                          md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< algo::k_matrix >(
+        depth_data.k_depth_pinv,
+        scene_dir,
+        bin_file( "k_depth_pinv", 3, 3, "double_00.bin" ) ) );
+    // CHECK(compare_to_bin_file< double >(depth_data.valid_edge_sub_pixel_x, scene_dir, "xim", 1,
+    // md.n_valid_pixels, "double_00", compare_same_vectors)); CHECK(compare_to_bin_file< double
+    // >(depth_data.valid_edge_sub_pixel_y, scene_dir, "yim", 1, md.n_valid_pixels, "double_00",
+    // compare_same_vectors));
+    CHECK( compare_to_bin_file< double >( depth_data.sub_points,
+                                          scene_dir, "subPoints",
+                                          3, md.n_valid_pixels,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< algo::double2 >( depth_data.uvmap,
+                                                 scene_dir,
+                                                 bin_file( "uv", 2, md.n_valid_pixels, "double_00" )
+                                                     + ".bin",
+                                                 md.n_valid_pixels, 1,
+                                                 compare_same_vectors ) );
+    CHECK( compare_to_bin_file< byte >( depth_data.is_inside,
+                                        scene_dir, "isInside",
+                                        1, md.n_valid_pixels,
+                                        "uint8_00",
+                                        compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.subpixels_x,
+                                          scene_dir, "Z_xim",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.subpixels_y,
+                                          scene_dir, "Z_yim",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.directions,
+                                          scene_dir, "directionIndexInside",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >( depth_data.subpixels_x_round,
+                                          scene_dir, "round_xim",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.subpixels_y_round,
+                                          scene_dir, "round_yim",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( depth_data.weights,
+                                          scene_dir, "weights",
+                                          1, md.n_edges,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( depth_data.relevant_pixels_image,
+                                           scene_dir, "relevantPixelsImage",
+                                           z_w, z_h,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< algo::double3 >( depth_data.vertices,
+                                                 scene_dir,
+                                                 bin_file( "vertices", 3, md.n_edges, "double_00" )
+                                                     + ".bin",
+                                                 md.n_edges, 1,
+                                                 compare_same_vectors ) );
+    CHECK( compare_to_bin_file< uint8_t >( depth_data.section_map,
+                                           scene_dir, "sectionMapDepthInside",
+                                           1, md.n_edges,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< uint8_t >( yuy_data.debug.lum_frame,
+                                           scene_dir, "YUY2_lum",
+                                           rgb_w, rgb_h,
+                                           "uint8_00",
+                                           compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.debug.edges,
+                                          scene_dir, "YUY2_edge",
+                                          rgb_w, rgb_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDT,
+                                          scene_dir, "YUY2_IDT",
+                                          rgb_w, rgb_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTx,
+                                          scene_dir, "YUY2_IDTx",
+                                          rgb_w, rgb_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( yuy_data.edges_IDTy,
+                                          scene_dir, "YUY2_IDTy",
+                                          rgb_w, rgb_h,
+                                          "double_00",
+                                          compare_same_vectors ) );
+}
+
+
+void compare_scene( std::string const & scene_dir,
+                    bool debug_mode = true,
+                    scene_stats * stats = nullptr )
+{
+    TRACE( "Loading " << scene_dir << " ..." );
+
+    memory_profiler profiler;
+
+    camera_params ci = read_camera_params( scene_dir, "camera_params" );
+    dsm_params dsm = read_dsm_params( scene_dir, "DSM_params" );
+    ci.dsm_params = dsm.dsm_params;
+    ci.cal_info = dsm.regs;
+    ci.cal_regs = dsm.algo_calibration_registers;
+
+    scene_metadata md( scene_dir );
+
+    algo::optimizer::settings settings;
+    read_data_from( bin_dir( scene_dir ) + "settings", &settings );
+
+    algo::optimizer cal( settings, debug_mode );
+    init_algo( cal,
+               scene_dir,
+               md.rgb_file,
+               md.rgb_prev_file,
+               md.rgb_prev_valid_file,
+               md.ir_file,
+               md.z_file,
+               ci,
+               &profiler );
+
+    auto & z_data = cal.get_z_data();
+    auto & ir_data = cal.get_ir_data();
+    auto & yuy_data = cal.get_yuy_data();
+    auto & depth_data = cal.get_z_data();
+    auto & decision_params = cal.get_decision_params();
+    auto & svm_features = cal.get_extracted_features();
+
+    auto rgb_h = ci.rgb.height;
+    auto rgb_w = ci.rgb.width;
+    auto z_h = ci.z.height;
+    auto z_w = ci.z.width;
+    auto num_of_calib_elements = 22;
+    auto num_of_p_matrix_elements = sizeof( algo::p_matrix ) / sizeof( double );
+    auto num_of_k_matrix_elements = sizeof( algo::k_matrix ) / sizeof( double );
+
+    if( debug_mode )
+        compare_preprocessing_data( scene_dir, z_data, ir_data, yuy_data, md );
+
+    // ---
+
+    algo::input_validity_data data;
+    profiler.section( "Checking scene validity" );
+    bool const is_scene_valid = cal.is_scene_valid( debug_mode ? &data : nullptr );
+    profiler.section_end();
+
+    bool const matlab_scene_valid = md.is_scene_valid;
+    CHECK( is_scene_valid == matlab_scene_valid );
+    if( debug_mode )
+    {
+        bool spread = read_from< uint8_t >( bin_dir( scene_dir ) + "DirSpread_1x1_uint8_00.bin" );
+        CHECK( data.edges_dir_spread == spread );
+        bool rgbEdgesSpread
+            = read_from< uint8_t >( bin_dir( scene_dir ) + "rgbEdgesSpread_1x1_uint8_00.bin" );
+        CHECK( data.rgb_spatial_spread == rgbEdgesSpread );
+        bool depthEdgesSpread
+            = read_from< uint8_t >( bin_dir( scene_dir ) + "depthEdgesSpread_1x1_uint8_00.bin" );
+        CHECK( data.depth_spatial_spread == depthEdgesSpread );
+        bool isMovementFromLastSuccess = read_from< uint8_t >(
+            bin_dir( scene_dir ) + "isMovementFromLastSuccess_1x1_uint8_00.bin" );
+        CHECK( data.is_movement_from_last_success == isMovementFromLastSuccess );
+    }
+    if( stats )
+    {
+        stats->n_valid_scene = is_scene_valid;
+        stats->n_valid_scene_diff = is_scene_valid != matlab_scene_valid;
+    }
+
+    // edge distribution
+    CHECK( compare_to_bin_file< double >( z_data.sum_weights_per_section,
+                                          scene_dir,
+                                          "depthEdgeWeightDistributionPerSectionDepth",
+                                          1,
+                                          4,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    // CHECK( compare_to_bin_file< byte >( z_data.section_map, scene_dir, "sectionMapDepth_trans",
+    // 1, md.n_edges, "uint8_00", compare_same_vectors ) ); CHECK( compare_to_bin_file< byte >(
+    // yuy_data.section_map, scene_dir, "sectionMapRgb_trans", 1, rgb_w*rgb_h, "uint8_00",
+    // compare_same_vectors ) );
+
+    CHECK( compare_to_bin_file< double >( yuy_data.sum_weights_per_section,
+                                          scene_dir,
+                                          "edgeWeightDistributionPerSectionRgb",
+                                          1,
+                                          4,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    // gradient balanced
+    // TODO NOHA
+    CHECK( compare_to_bin_file< double >( z_data.sum_weights_per_direction,
+                                          scene_dir,
+                                          "edgeWeightsPerDir",
+                                          4,
+                                          1,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    // movment check
+    // 1. dilation
+    if( debug_mode )
+        CHECK( compare_to_bin_file< uint8_t >( yuy_data.debug.movement_result.logic_edges,
+                                               scene_dir, "logicEdges",
+                                               rgb_w, rgb_h,
+                                               "uint8_00",
+                                               compare_same_vectors ) );
+    if( debug_mode )
+        CHECK( compare_to_bin_file< double >( yuy_data.debug.movement_result.dilated_image,
+                                              scene_dir, "dilatedIm",
+                                              rgb_w, rgb_h,
+                                              "double_00",
+                                              compare_same_vectors ) );
+
+    // 2. gausssian
+    if( debug_mode )
+        CHECK( compare_to_bin_file< double >( yuy_data.debug.movement_result.yuy_diff,
+                                              scene_dir, "diffIm_01",
+                                              rgb_w, rgb_h,
+                                              "double_00",
+                                              compare_same_vectors ) );
+    if( debug_mode )
+        CHECK( compare_to_bin_file< double >( yuy_data.debug.movement_result.gaussian_filtered_image,
+                                              scene_dir, "diffIm",
+                                              rgb_w, rgb_h,
+                                              "double_00",
+                                              compare_same_vectors ) );
+
+    // 3. movement
+    if( debug_mode )
+        CHECK( compare_to_bin_file< double >( yuy_data.debug.movement_result.gaussian_diff_masked,
+                                              scene_dir, "IDiffMasked",
+                                              rgb_w, rgb_h,
+                                              "double_00",
+                                              compare_same_vectors ) );
+    if( debug_mode )
+        CHECK( compare_to_bin_file< uint8_t >( yuy_data.debug.movement_result.move_suspect,
+                                               scene_dir, "ixMoveSuspect",
+                                               rgb_w, rgb_h,
+                                               "uint8_00",
+                                               compare_same_vectors ) );
+
+    //--
+
+    auto cb = [&]( algo::data_collect const & data ) {
+        // data.iteration_data_p is 0-based!
+        // REQUIRE( data.iteration_data_p < md.n_iterations );
+
+        // REQUIRE( data.cycle <= md.n_cycles );
+
+        if( data.type == algo::k_to_dsm_data )
+        {
+            std::cout << std::endl
+                      << "COMPARING K_TO_DSM DATA " << data.cycle_data_p.cycle << std::endl;
+            algo::k_matrix old_k = data.k2dsm_data_p.inputs.old_k;
+            algo::k_matrix new_k = data.k2dsm_data_p.inputs.new_k;
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( old_k.k_mat.rot ), std::end( old_k.k_mat.rot ) ),
+                scene_dir,
+                bin_file( "k2dsm_inpus_oldKdepth",
+                          data.cycle_data_p.cycle,
+                          num_of_k_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_k_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( new_k.k_mat.rot ), std::end( new_k.k_mat.rot ) ),
+                scene_dir,
+                bin_file( "k2dsm_inpus_newKdepth",
+                          data.cycle_data_p.cycle,
+                          num_of_k_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_k_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double3 >( data.k2dsm_data_p.inputs.z.vertices,
+                                                         scene_dir,
+                                                         bin_file( "k2dsm_inpus_vertices",
+                                                                   data.cycle_data_p.cycle,
+                                                                   3,
+                                                                   md.n_edges,
+                                                                   "double_00.bin" ),
+                                                         md.n_edges,
+                                                         1,
+                                                         compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                std::vector< algo::double2 >(
+                    1,
+                    { data.k2dsm_data_p.inputs.previous_dsm_params.h_scale,
+                      data.k2dsm_data_p.inputs.previous_dsm_params.v_scale } ),
+                scene_dir,
+                bin_file( "k2dsm_inpus_acData", data.cycle_data_p.cycle, 2, 1, "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+
+
+            CHECK( compare_to_bin_file< algo::algo_calibration_registers >(
+                data.k2dsm_data_p.inputs.new_dsm_regs,
+                scene_dir,
+                bin_file( "k2dsm_inpus_dsmRegs",
+                          data.cycle_data_p.cycle,
+                          4,
+                          1,
+                          "double_00.bin" ) ) );
+
+
+            CHECK( compare_to_bin_file< algo::algo_calibration_registers >(
+                data.k2dsm_data_p.dsm_regs_orig,
+                scene_dir,
+                bin_file( "dsmRegsOrig", data.cycle_data_p.cycle, 4, 1, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< uint8_t >(
+                data.k2dsm_data_p.relevant_pixels_image_rot,
+                scene_dir,
+                bin_file( "relevantPixelnImage_rot", data.cycle_data_p.cycle, z_w, z_h, "uint8_00" )
+                    + ".bin",
+                z_w,
+                z_h,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::los_shift_scaling >(
+                data.k2dsm_data_p.dsm_pre_process_data.last_los_error,
+                scene_dir,
+                bin_file( "dsm_los_error_orig",
+                          data.cycle_data_p.cycle,
+                          1,
+                          4,
+                          "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< algo::double3 >(
+                data.k2dsm_data_p.dsm_pre_process_data.vertices_orig,
+                scene_dir,
+                bin_file( "verticesOrig",
+                          data.cycle_data_p.cycle,
+                          3,
+                          md.n_relevant_pixels,
+                          "double_00" )
+                    + ".bin",
+                md.n_relevant_pixels,
+                1,
+                compare_same_vectors ) );
+
+
+            compare_vertices_to_los_data( scene_dir,
+                                          md.n_relevant_pixels,
+                                          data.cycle_data_p.cycle,
+                                          "first_",
+                                          data.k2dsm_data_p.first_norm_vertices_to_los_data );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.dsm_pre_process_data.los_orig,
+                scene_dir,
+                bin_file( "losOrig", data.cycle_data_p.cycle, 2, md.n_relevant_pixels, "double_00" )
+                    + ".bin",
+                md.n_relevant_pixels,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.k2dsm_data_p.errL2,
+                                                  scene_dir,
+                                                  bin_file( "errL2",
+                                                            data.cycle_data_p.cycle,
+                                                            1,
+                                                            data.k2dsm_data_p.errL2.size(),
+                                                            "double_00" )
+                                                      + ".bin",
+                                                  data.k2dsm_data_p.errL2.size(),
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.focal_scaling,
+                scene_dir,
+                bin_file( "focalScaling", data.cycle_data_p.cycle, 2, 1, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< std::vector< double > >(
+                data.k2dsm_data_p.sg_mat,
+                scene_dir,
+                bin_file( "sgMat",
+                          data.cycle_data_p.cycle,
+                          data.k2dsm_data_p.sg_mat[0].size(),
+                          data.k2dsm_data_p.sg_mat.size(),
+                          "double_00" )
+                    + ".bin",
+                data.k2dsm_data_p.sg_mat.size(),
+                data.k2dsm_data_p.sg_mat[0].size(),
+                data.k2dsm_data_p.sg_mat.size(),
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                data.k2dsm_data_p.sg_mat_tag_x_sg_mat,
+                scene_dir,
+                bin_file( "sg_mat_tag_x_sg_mat",
+                          data.cycle_data_p.cycle,
+                          1,
+                          data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(),
+                          "double_00" )
+                    + ".bin",
+                data.k2dsm_data_p.sg_mat_tag_x_sg_mat.size(),
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                data.k2dsm_data_p.sg_mat_tag_x_err_l2,
+                scene_dir,
+                bin_file( "sg_mat_tag_x_err_l2",
+                          data.cycle_data_p.cycle,
+                          1,
+                          data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(),
+                          "double_00" )
+                    + ".bin",
+                data.k2dsm_data_p.sg_mat_tag_x_err_l2.size(),
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.k2dsm_data_p.quad_coef,
+                                                  scene_dir,
+                                                  bin_file( "quadCoef",
+                                                            data.cycle_data_p.cycle,
+                                                            1,
+                                                            data.k2dsm_data_p.quad_coef.size(),
+                                                            "double_00" )
+                                                      + ".bin",
+                                                  data.k2dsm_data_p.quad_coef.size(),
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.opt_scaling_1,
+                scene_dir,
+                bin_file( "optScaling1", data.cycle_data_p.cycle, 1, 2, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.opt_scaling,
+                scene_dir,
+                bin_file( "optScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.new_los_scaling,
+                scene_dir,
+                bin_file( "newlosScaling", data.cycle_data_p.cycle, 1, 2, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                std::vector< algo::double2 >( 1,
+                                              { data.k2dsm_data_p.dsm_params_cand.h_scale,
+                                                data.k2dsm_data_p.dsm_params_cand.v_scale } ),
+                scene_dir,
+                bin_file( "acDataCand", data.cycle_data_p.cycle, 2, 1, "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::algo_calibration_registers >(
+                data.k2dsm_data_p.dsm_regs_cand,
+                scene_dir,
+                bin_file( "dsmRegsCand", data.cycle_data_p.cycle, 4, 1, "double_00.bin" ) ) );
+
+            compare_vertices_to_los_data( scene_dir,
+                                          md.n_edges,
+                                          data.cycle_data_p.cycle,
+                                          "second_",
+                                          data.k2dsm_data_p.second_norm_vertices_to_los_data );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.los_orig,
+                scene_dir,
+                bin_file( "orig_los", data.cycle_data_p.cycle, 2, md.n_edges, "double_00" )
+                    + ".bin",
+                md.n_edges,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double2 >(
+                data.k2dsm_data_p.dsm,
+                scene_dir,
+                bin_file( "dsm", data.cycle_data_p.cycle, 2, md.n_edges, "double_00" ) + ".bin",
+                md.n_edges,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::double3 >(
+                data.k2dsm_data_p.vertices,
+                scene_dir,
+                bin_file( "new_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin" ),
+                md.n_edges,
+                1,
+                compare_same_vectors ) );
+
+            TRACE( "\nSet next cycle data from Matlab:" );
+        }
+        else if( data.type == algo::cycle_data )
+        {
+            std::cout << std::endl
+                      << "COMPARING CYCLE DATA " << data.cycle_data_p.cycle << std::endl;
+
+            algo::k_matrix k_depth;
+            k_depth.k_mat.rot[0] = data.cycle_data_p.new_k_depth.fx;
+            k_depth.k_mat.rot[2] = data.cycle_data_p.new_k_depth.ppx;
+            k_depth.k_mat.rot[4] = data.cycle_data_p.new_k_depth.fy;
+            k_depth.k_mat.rot[5] = data.cycle_data_p.new_k_depth.ppy;
+
+            CHECK( compare_to_bin_file< algo::k_matrix >(
+                k_depth,
+                scene_dir,
+                bin_file( "end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< algo::p_matrix >( data.cycle_data_p.new_params.curr_p_mat,
+                                                          scene_dir,
+                                                          bin_file( "end_cycle_p_matrix",
+                                                                    data.cycle_data_p.cycle,
+                                                                    num_of_p_matrix_elements,
+                                                                    1,
+                                                                    "double_00.bin" ) ) );
+
+            try
+            {
+
+                /* auto vertices = read_vector_from<algo::double3>(bin_file(bin_dir(scene_dir) +
+                 "end_cycle_vertices", data.cycle_data_p.cycle, 3, md.n_edges, "double_00.bin"));
+
+                 algo::p_matrix p_mat;
+
+                 auto p_vec = read_vector_from<double>(bin_file(bin_dir(scene_dir) +
+                 "end_cycle_p_matrix", data.cycle_data_p.cycle, num_of_p_matrix_elements, 1,
+                     "double_00.bin"));
+                 std::copy(p_vec.begin(), p_vec.end(), p_mat.vals);
+
+                 auto dsm_regs_vec = read_vector_from< algo::algo_calibration_registers >(
+                     bin_file(bin_dir(scene_dir) + "end_cycle_dsmRegsCand", data.cycle_data_p.cycle,
+                 4, 1, "double_00.bin"));
+
+                 algo::algo_calibration_registers dsm_regs =
+                 *(algo::algo_calibration_registers*)(dsm_regs_vec.data()); auto ac_data_vec =
+                 read_vector_from< algo::double2 >(bin_file(bin_dir(scene_dir) + "end_cycle_acData",
+                 data.cycle_data_p.cycle, 2, 1, "double_00.bin"));
+
+                 algo::rs2_dsm_params_double dsm_params;
+                 dsm_params.h_scale = ac_data_vec[0].x;
+                 dsm_params.v_scale = ac_data_vec[0].y;
+                 dsm_params.model = RS2_DSM_CORRECTION_AOT;*/
+
+                // auto Kdepth = read_vector_from<algo::matrix_3x3>(bin_file(bin_dir(scene_dir) +
+                // "end_cycle_Kdepth", data.cycle_data_p.cycle, 3, 3, "double_00.bin"));
+                // cal.set_cycle_data(vertices, k_depth, p_mat, dsm_regs, dsm_params);
+            }
+            catch( std::runtime_error & e )
+            {
+                // if device isn't calibrated, get_extrinsics must error out (according to old
+                // comment. Might not be true under new API)
+                WARN( e.what() );
+            }
+        }
+        else if( data.type == algo::iteration_data )
+        {
+            std::cout << std::endl
+                      << "COMPARING ITERATION DATA " << data.cycle_data_p.cycle << " "
+                      << data.iteration_data_p.iteration + 1 << std::endl;
+            CHECK( compare_to_bin_file< algo::p_matrix >(
+                data.iteration_data_p.params.curr_p_mat,
+                scene_dir,
+                bin_file( "p_matrix_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ) ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( data.iteration_data_p.c.k_mat.k_mat.rot ),
+                                       std::end( data.iteration_data_p.c.k_mat.k_mat.rot ) ),
+                scene_dir,
+                bin_file( "Krgb_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          9,
+                          1,
+                          "double_00.bin" ),
+                9,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( 1, data.iteration_data_p.params.cost ),
+                scene_dir,
+                bin_file( "cost_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          1,
+                          1,
+                          "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+
+            CHECK(
+                compare_to_bin_file< algo::double2 >( data.iteration_data_p.uvmap,
+                                                      scene_dir,
+                                                      bin_file( "uvmap_iteration",
+                                                                data.cycle_data_p.cycle,
+                                                                data.iteration_data_p.iteration + 1,
+                                                                2,
+                                                                md.n_edges,
+                                                                "double_00.bin" ),
+                                                      md.n_edges,
+                                                      1,
+                                                      compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.iteration_data_p.d_vals,
+                                                  scene_dir,
+                                                  bin_file( "DVals_iteration",
+                                                            data.cycle_data_p.cycle,
+                                                            data.iteration_data_p.iteration + 1,
+                                                            1,
+                                                            md.n_edges,
+                                                            "double_00.bin" ),
+                                                  md.n_edges,
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.iteration_data_p.d_vals_x,
+                                                  scene_dir,
+                                                  bin_file( "DxVals_iteration",
+                                                            data.cycle_data_p.cycle,
+                                                            data.iteration_data_p.iteration + 1,
+                                                            1,
+                                                            md.n_edges,
+                                                            "double_00.bin" ),
+                                                  md.n_edges,
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.iteration_data_p.d_vals_y,
+                                                  scene_dir,
+                                                  bin_file( "DyVals_iteration",
+                                                            data.cycle_data_p.cycle,
+                                                            data.iteration_data_p.iteration + 1,
+                                                            1,
+                                                            md.n_edges,
+                                                            "double_00.bin" ),
+                                                  md.n_edges,
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK(
+                compare_to_bin_file< algo::double2 >( data.iteration_data_p.xy,
+                                                      scene_dir,
+                                                      bin_file( "xy_iteration",
+                                                                data.cycle_data_p.cycle,
+                                                                data.iteration_data_p.iteration + 1,
+                                                                2,
+                                                                md.n_edges,
+                                                                "double_00.bin" ),
+                                                      md.n_edges,
+                                                      1,
+                                                      compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >( data.iteration_data_p.rc,
+                                                  scene_dir,
+                                                  bin_file( "rc_iteration",
+                                                            data.cycle_data_p.cycle,
+                                                            data.iteration_data_p.iteration + 1,
+                                                            1,
+                                                            md.n_edges,
+                                                            "double_00.bin" ),
+                                                  md.n_edges,
+                                                  1,
+                                                  compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::p_matrix >(
+                data.iteration_data_p.coeffs_p.x_coeffs,
+                scene_dir,
+                bin_file( "xCoeff_P_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          md.n_edges,
+                          "double_00.bin" ),
+                md.n_edges,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< algo::p_matrix >(
+                data.iteration_data_p.coeffs_p.y_coeffs,
+                scene_dir,
+                bin_file( "yCoeff_P_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          md.n_edges,
+                          "double_00.bin" ),
+                md.n_edges,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >(
+                    std::begin( data.iteration_data_p.params.calib_gradients.vals ),
+                    std::end( data.iteration_data_p.params.calib_gradients.vals ) ),
+                scene_dir,
+                bin_file( "grad_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_p_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( 1, data.iteration_data_p.grads_norma ),
+                scene_dir,
+                bin_file( "grad_norma_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          1,
+                          1,
+                          "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( data.iteration_data_p.grads_norm.vals ),
+                                       std::end( data.iteration_data_p.grads_norm.vals ) ),
+                scene_dir,
+                bin_file( "grads_norm_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_p_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( data.iteration_data_p.normalized_grads.vals ),
+                                       std::end( data.iteration_data_p.normalized_grads.vals ) ),
+                scene_dir,
+                bin_file( "normalized_grads_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_p_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( std::begin( data.iteration_data_p.unit_grad.vals ),
+                                       std::end( data.iteration_data_p.unit_grad.vals ) ),
+                scene_dir,
+                bin_file( "unit_grad_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_p_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+            CHECK(
+                compare_to_bin_file< double >( std::vector< double >( 1, data.iteration_data_p.t ),
+                                               scene_dir,
+                                               bin_file( "t_iteration",
+                                                         data.cycle_data_p.cycle,
+                                                         data.iteration_data_p.iteration + 1,
+                                                         1,
+                                                         1,
+                                                         "double_00.bin" ),
+                                               1,
+                                               1,
+                                               compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( 1, data.iteration_data_p.back_tracking_line_search_iters ),
+                scene_dir,
+                bin_file( "back_tracking_line_iter_count_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          1,
+                          1,
+                          "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >(
+                    std::begin( data.iteration_data_p.next_params.curr_p_mat.vals ),
+                    std::end( data.iteration_data_p.next_params.curr_p_mat.vals ) ),
+                scene_dir,
+                bin_file( "next_p_matrix_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          num_of_p_matrix_elements,
+                          1,
+                          "double_00.bin" ),
+                num_of_p_matrix_elements,
+                1,
+                compare_same_vectors ) );
+
+            CHECK( compare_to_bin_file< double >(
+                std::vector< double >( 1, data.iteration_data_p.next_params.cost ),
+                scene_dir,
+                bin_file( "next_cost_iteration",
+                          data.cycle_data_p.cycle,
+                          data.iteration_data_p.iteration + 1,
+                          1,
+                          1,
+                          "double_00.bin" ),
+                1,
+                1,
+                compare_same_vectors ) );
+        }
+    };
+
+    // Our code doesn't count the first iteration; the Matlab code starts at 1 even if it doesn't do
+    // anything...
+    // REQUIRE( cal.optimize( cb ) + 1 == md.n_iterations );
+    profiler.section( "Optimizing" );
+    auto n_cycles = cal.optimize( cb );
+    profiler.section_end();
+
+
+    auto new_calibration = cal.get_calibration();
+    auto cost = cal.get_cost();
+
+    auto filename = bin_file( "new_calib", num_of_calib_elements, 1, "double_00" ) + ".bin";
+    TRACE( "Comparing " << filename << " ..." );
+    algo::calib matlab_calib;
+    double matlab_cost = 0;
+    CHECK( get_calib_from_raw_data( matlab_calib, matlab_cost, scene_dir, filename ) );
+    CHECK( compare_calib( new_calibration, cost, matlab_calib, matlab_cost ) );
+    new_calibration.copy_coefs( matlab_calib );
+    if( stats )
+    {
+        stats->cost = cost;
+        stats->d_cost = cost - matlab_cost;
+    }
+
+
+#if 1
+    auto vertices = read_vector_from< algo::double3 >(
+        bin_file( bin_dir( scene_dir ) + "end_vertices", 3, md.n_edges, "double_00.bin" ) );
+
+    if( stats )
+    {
+        auto our_uvmap = algo::get_texture_map( depth_data.vertices,
+                                                new_calibration,
+                                                new_calibration.calc_p_mat() );
+        auto matlab_uvmap
+            = algo::get_texture_map( vertices, matlab_calib, matlab_calib.calc_p_mat() );
+
+        CHECK( our_uvmap.size() == matlab_uvmap.size() );
+        if( our_uvmap.size() == matlab_uvmap.size() )
+            stats->d_movement = cal.calc_correction_in_pixels( our_uvmap, matlab_uvmap );
+        else
+            stats->d_movement = -1;
+    }
+
+
+    algo::p_matrix p_mat;
+
+    auto p_vec = read_vector_from< double >( bin_file( bin_dir( scene_dir ) + "end_p_matrix",
+                                                       num_of_p_matrix_elements,
+                                                       1,
+                                                       "double_00.bin" ) );
+
+    std::copy( p_vec.begin(), p_vec.end(), p_mat.vals );
+
+    algo::p_matrix p_mat_opt;
+
+    auto p_vec_opt
+        = read_vector_from< double >( bin_file( bin_dir( scene_dir ) + "end_p_matrix_opt",
+                                                num_of_p_matrix_elements,
+                                                1,
+                                                "double_00.bin" ) );
+
+    std::copy( p_vec_opt.begin(), p_vec_opt.end(), p_mat_opt.vals );
+
+    cal.set_final_data( vertices, p_mat, p_mat_opt );
+
+    //--
+
+    // Pixel movement is OK, but some sections have negative cost
+    profiler.section( "Checking output validity" );
+    bool const is_valid_results = cal.is_valid_results();
+    profiler.section_end();
+    bool const matlab_valid_results = md.is_output_valid;
+    CHECK( is_valid_results == matlab_valid_results );
+    if( stats )
+    {
+        stats->n_cycles = n_cycles;
+        stats->n_valid_result = is_valid_results;
+        stats->n_valid_result_diff = is_valid_results != matlab_valid_results;
+
+        stats->n_converged = is_valid_results && is_scene_valid;
+        bool const matlab_converged = matlab_valid_results && matlab_scene_valid;
+        stats->n_converged_diff = bool( stats->n_converged ) != matlab_converged;
+    }
+
+    double const movement_in_pixels = cal.calc_correction_in_pixels( new_calibration );
+    double const matlab_movement_in_pixels = md.correction_in_pixels;
+    CHECK( movement_in_pixels == approx( matlab_movement_in_pixels ) );
+    if( stats )
+    {
+        stats->movement = movement_in_pixels;
+        // stats->d_movement = movement_in_pixels - matlab_movement_in_pixels;
+    }
+
+    CHECK( compare_to_bin_file< double >( z_data.cost_diff_per_section,
+                                          scene_dir,
+                                          "costDiffPerSection",
+                                          4,
+                                          1,
+                                          "double_00",
+                                          compare_same_vectors ) );
+
+    // svm - remove xyMovementFromOrigin because its still not implemented
+    auto svm_features_mat = read_vector_from< double >(
+        bin_file( bin_dir( scene_dir ) + "svm_featuresMat", 10, 1, "double_00.bin" ) );
+
+    svm_features_mat.erase( svm_features_mat.begin() + 7 );
+    auto svm_mat = svm_features;
+    svm_mat.erase( svm_mat.begin() + 7 );
+
+    CHECK( compare_same_vectors( svm_features_mat, svm_mat ) );
+
+    // CHECK(compare_to_bin_file< double >(svm_features, scene_dir, "svm_featuresMat", 10, 1,
+    // "double_00", compare_same_vectors));
+    CHECK( compare_to_bin_file< double >( decision_params.distribution_per_section_depth,
+                                          scene_dir,
+                                          "svm_edgeWeightDistributionPerSectionDepth",
+                                          1,
+                                          4,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( decision_params.distribution_per_section_rgb,
+                                          scene_dir,
+                                          "svm_edgeWeightDistributionPerSectionRgb",
+                                          1,
+                                          4,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( decision_params.edge_weights_per_dir,
+                                          scene_dir,
+                                          "svm_edgeWeightsPerDir",
+                                          4,
+                                          1,
+                                          "double_00",
+                                          compare_same_vectors ) );
+    CHECK( compare_to_bin_file< double >( decision_params.improvement_per_section,
+                                          scene_dir,
+                                          "svm_improvementPerSection",
+                                          4,
+                                          1,
+                                          "double_00",
+                                          compare_same_vectors ) );
+#endif
+
+    profiler.stop();
+
+    if( stats )
+        stats->memory_consumption_peak = profiler.get_peak() - profiler.get_baseline();
+}
diff --git a/unit-tests/algo/d2rgb/compare-to-bin-file.h b/unit-tests/algo/d2rgb/compare-to-bin-file.h
index ed63013..d4abca0 100644
--- a/unit-tests/algo/d2rgb/compare-to-bin-file.h
+++ b/unit-tests/algo/d2rgb/compare-to-bin-file.h
@@ -26,7 +26,7 @@ bool compare_and_trace(D val_matlab, D val_cpp, std::string const & compared)
 {
     if (val_cpp != approx(val_matlab))
     {
-        AC_LOG(DEBUG, "... " << std::setprecision(16) << compared << ":  {matlab} " << val_matlab << " !~ " << val_cpp << " {cpp}");
+        AC_LOG(DEBUG, "... " << std::setprecision(16) << compared << ":  {matlab} " << val_matlab << " !~ " << val_cpp << " {cpp} Diff = " << val_matlab - val_cpp);
         return false;
     }
     return true;
@@ -37,10 +37,10 @@ bool is_equal_approximetly<algo::k_matrix, algo::k_matrix>( algo::k_matrix fx, a
 {
     bool ok = true;
 
-    ok = compare_and_trace(dx.get_fx(), fx.get_fx(), "fx");
-    ok = compare_and_trace(dx.get_fy(), fx.get_fy(), "fy");
-    ok = compare_and_trace(dx.get_ppx(), fx.get_ppx(), "ppx");
-    ok = compare_and_trace(dx.get_ppy(), fx.get_ppy(), "ppy");
+    ok = compare_and_trace(dx.get_fx(), fx.get_fx(), "fx") && ok;
+    ok = compare_and_trace(dx.get_fy(), fx.get_fy(), "fy") && ok;
+    ok = compare_and_trace(dx.get_ppx(), fx.get_ppx(), "ppx") && ok;
+    ok = compare_and_trace(dx.get_ppy(), fx.get_ppy(), "ppy") && ok;
 
     return ok;
 }
@@ -56,12 +56,16 @@ bool is_equal_approximetly<algo::rotation_in_angles, algo::rotation_in_angles>(
 template<>
 bool is_equal_approximetly<algo::p_matrix, algo::p_matrix>( algo::p_matrix fx, algo::p_matrix dx, bool print)
 {
+    bool ok = true;
     for( auto i = 0; i < 12; i++ )
     {
-        if( dx.vals[i] != approx( fx.vals[i] ) )
-            return false;
+        if (print)
+            ok = compare_and_trace(dx.vals[i], fx.vals[i], "p_matrix") && ok;
+        else
+            ok = is_equal_approximetly(dx.vals[i], fx.vals[i], false) && ok;
+
     }
-    return true;
+    return ok;
 }
 
 template<>
@@ -138,7 +142,7 @@ template< typename F, typename D >
 void print( size_t x, F f, D d, bool is_approx = false )
 {
     // bytes will be written to stdout as characters, which we never want... hence '+fx'
-    AC_LOG( DEBUG, "... " << AC_D_PREC << x << ": {matlab}" << +f << (is_approx ? " !~ " : " != ") << +d << "{c++}" );
+    AC_LOG( DEBUG, "... " << AC_D_PREC << x << ": {matlab}" << +f << (is_approx ? " !~ " : " != ") << +d << "{c++}"  );
 }
 
 template<>
diff --git a/unit-tests/algo/d2rgb/d2rgb-common.h b/unit-tests/algo/d2rgb/d2rgb-common.h
index e21232e..7cf14c0 100644
--- a/unit-tests/algo/d2rgb/d2rgb-common.h
+++ b/unit-tests/algo/d2rgb/d2rgb-common.h
@@ -12,7 +12,12 @@
 
 
 #include "ac-logger.h"
+#if ! defined( DISABLE_LOG_TO_STDOUT )
 ac_logger LOG_TO_STDOUT;
+#endif
+
+
+#include "../../profiler.h"
 
 
 namespace algo = librealsense::algo::depth_to_rgb_calibration;
@@ -24,26 +29,52 @@ void init_algo( algo::optimizer & cal,
     std::string const & dir,
     std::string const & yuy,
     std::string const & yuy_prev,
+    std::string const & yuy_last_successful,
     std::string const & ir,
     std::string const & z,
-    camera_params const & camera
+    camera_params const & camera,
+    memory_profiler * profiler = nullptr
 )
 {
     algo::calib calibration( camera.rgb, camera.extrinsics );
 
+    std::vector< algo::yuy_t> yuy_last_successful_frame;
+
+    try
+    {
+        yuy_last_successful_frame = read_image_file< algo::yuy_t >(dir + yuy_last_successful, camera.rgb.width, camera.rgb.height);
+    }
+    catch (...) 
+    {
+        yuy_last_successful_frame.clear();
+    };
+
+    if( profiler )
+        profiler->section( "Preprocessing YUY" );
     cal.set_yuy_data(
         read_image_file< algo::yuy_t >( dir + yuy, camera.rgb.width, camera.rgb.height ),
         read_image_file< algo::yuy_t >( dir + yuy_prev, camera.rgb.width, camera.rgb.height ),
+        std::move(yuy_last_successful_frame),
         calibration
     );
+    if( profiler )
+        profiler->section_end();
 
+    if( profiler )
+        profiler->section( "Preprocessing IR" );
     cal.set_ir_data(
         read_image_file< algo::ir_t >( dir + ir, camera.z.width, camera.z.height ),
         camera.z.width, camera.z.height
     );
+    if( profiler )
+        profiler->section_end();
 
+    if( profiler )
+        profiler->section( "Preprocessing DEPTH" );
     cal.set_z_data(
         read_image_file< algo::z_t >( dir + z, camera.z.width, camera.z.height ),
         camera.z, camera.dsm_params, camera.cal_info, camera.cal_regs, camera.z_units
     );
+    if( profiler )
+        profiler->section_end();
 }
diff --git a/unit-tests/algo/d2rgb/scene-data.h b/unit-tests/algo/d2rgb/scene-data.h
index 58813b6..9d04505 100644
--- a/unit-tests/algo/d2rgb/scene-data.h
+++ b/unit-tests/algo/d2rgb/scene-data.h
@@ -174,15 +174,18 @@ struct scene_metadata
     bool is_output_valid;
     std::string rgb_file;
     std::string rgb_prev_file;  // TODO: looks like these need to be turned around!!!
+    std::string rgb_prev_valid_file;
     std::string ir_file;
     std::string z_file;
 
     scene_metadata( std::string const &scene_dir )
     {
-        std::ifstream( bin_dir( scene_dir ) + "yuy_prev_z_i.files" ) >> rgb_file >>
-        rgb_prev_file >> z_file >> ir_file;
+        std::ifstream(bin_dir(scene_dir) + "yuy_prev_z_i.files") >> rgb_file >>
+            rgb_prev_file >> rgb_prev_valid_file >> z_file >> ir_file;
         if( rgb_file.empty() )
             throw std::runtime_error( "failed to read file:\n" + bin_dir( scene_dir ) + "yuy_prev_z_i.files" );
+        if( ir_file.empty() )
+            throw std::runtime_error( "not enough files in:\n" + bin_dir( scene_dir ) + "yuy_prev_z_i.files" );
 
         std::string metadata = bin_dir( scene_dir ) + "metadata";
         std::fstream f = std::fstream( metadata, std::ios::in | std::ios::binary );
diff --git a/unit-tests/algo/d2rgb/test-reproduction.cpp b/unit-tests/algo/d2rgb/test-reproduction.cpp
index f9eb2ef..1e311d3 100644
--- a/unit-tests/algo/d2rgb/test-reproduction.cpp
+++ b/unit-tests/algo/d2rgb/test-reproduction.cpp
@@ -4,20 +4,13 @@
 //#cmake:add-file ../../../src/algo/depth-to-rgb-calibration/*.cpp
 
 
-#ifndef BUILD_SHARED_LIBS
-#include <easylogging++.h>
-INITIALIZE_EASYLOGGINGPP
-#endif
-
-
 // We have our own main
 #define NO_CATCH_CONFIG_MAIN
 //#define CATCH_CONFIG_RUNNER
 
+#define DISABLE_LOG_TO_STDOUT
 #include "d2rgb-common.h"
 
-//INITIALIZE_EASYLOGGINGPP
-
 
 template< typename T >
 void read_binary_file( char const * dir, char const * bin, T * data )
@@ -65,9 +58,85 @@ struct old_algo_calib
     }
 };
 
+
+class custom_ac_logger : public ac_logger
+{
+    typedef ac_logger super;
+
+    std::string _codes;
+
+public:
+    custom_ac_logger() {}
+
+    std::string const & get_codes() const { return _codes; }
+    void reset() { _codes.clear(); }
+
+protected:
+    void on_log( char severity, char const * message ) override
+    {
+        super::on_log( severity, message );
+
+        // parse it for keyword
+        auto cch = strlen( message );
+        if( cch < 4 || message[cch - 1] != ']' )
+            return;
+        char const * end = message + cch - 1;
+        char const * start = end - 1;
+        while( *start != '[' )
+        {
+            if( *start == ' ' )
+                return;
+            if( --start == message )
+                return;
+        }
+        if( start[-1] != ' ' )
+            return;
+        // parse it for parameters
+        char const * param = message;
+        std::string values;
+        while( param < start )
+        {
+            if( *param == '{'  &&  ++param < start )
+            {
+                char const * param_end = param;
+                while( *param_end != '}'  &&  param_end < start )
+                    ++param_end;
+                if( param_end == start || param_end - param < 1 )
+                    break;
+                char const * value = param_end + 1;
+                char const * value_end = value;
+                while( *value_end != ' ' )
+                    ++value_end;
+                if( value_end == value )
+                    break;
+                if( value_end - value > 1  &&  strchr( ".;", value_end[-1] ))
+                    --value_end;
+                std::string param_name( param, param_end - param );
+                std::string param_value( value, value_end - value );
+                if( ! values.empty() )
+                    values += ' ';
+                values += param_name;
+                values += '=';
+                values += param_value;
+                param = value_end;
+            }
+            ++param;
+        }
+        std::string code( start + 1, end - start - 1 );
+        if( ! values.empty() )
+            code += '[' + values + ']';
+        if( ! _codes.empty() )
+            _codes += ' ';
+        _codes += code;
+    }
+};
+
 int main( int argc, char * argv[] )
 {
+    custom_ac_logger logger;
+
     bool ok = true;
+    bool debug_mode = false;
     // Each of the arguments is the path to a directory to simulate
     // We skip argv[0] which is the path to the executable
     // We don't complain if no arguments -- that's how we'll run as part of unit-testing
@@ -80,7 +149,12 @@ int main( int argc, char * argv[] )
             {
                 // The build number is only available within Jenkins and so we have to hard-
                 // code it ><
-                std::cout << RS2_API_VERSION_STR << ".1973" << std::endl;
+                std::cout << RS2_API_VERSION_STR << ".2158" << std::endl;
+                continue;
+            }
+            if( ! strcmp( dir, "--debug" ) || ! strcmp( dir, "-d" ) )
+            {
+                debug_mode = true;
                 continue;
             }
             std::cout << "Processing: " << dir << " ..." << std::endl;
@@ -109,35 +183,86 @@ int main( int argc, char * argv[] )
             read_binary_file( dir, "cal.registers", &camera.cal_regs );
             read_binary_file( dir, "dsm.params", &camera.dsm_params );
 
-            algo::optimizer cal;
-            init_algo( cal, dir, "\\rgb.raw", "\\rgb_prev.raw", "\\ir.raw", "\\depth.raw", camera );
+            if( camera.cal_regs.EXTLdsmXoffset < 0. || camera.cal_regs.EXTLdsmXoffset > 100000.
+                || camera.cal_regs.EXTLdsmXscale < 0. || camera.cal_regs.EXTLdsmXscale > 100000.
+                || camera.cal_regs.EXTLdsmYoffset < 0 || camera.cal_regs.EXTLdsmYoffset > 100000.
+                || camera.cal_regs.EXTLdsmYscale < 0 || camera.cal_regs.EXTLdsmYscale > 100000. )
+            {
+                throw std::invalid_argument( "cal.registers file is malformed! (hexdump -v -e '4/ \"%f  \"')" );
+            }
+
+            algo::optimizer::settings settings;
+            try
+            {
+                read_binary_file( dir, "settings", &settings );
+            }
+            catch( std::exception const & e )
+            {
+                std::cout << "!! failed: " << e.what() << " -> assuming [MANUAL LONG 9 @40degC]" << std::endl;
+                settings.ambient = RS2_AMBIENT_LIGHT_NO_AMBIENT;
+                settings.hum_temp = 40;
+                settings.is_manual_trigger = true;
+                settings.receiver_gain = 9;
+            }
 
+            algo::optimizer cal( settings, debug_mode );
             std::string status;
 
-            TRACE( "\n___\nis_scene_valid" );
-            if( !cal.is_scene_valid() )
             {
-                TRACE("NOT VALID\n");
-                status += "SCENE_INVALID ";
-            }
+                memory_profiler profiler;
+                init_algo( cal,
+                           dir,
+                           "\\rgb.raw",
+                           "\\rgb_prev.raw",
+                           "\\rgb_last_successful.raw",
+                           "\\ir.raw",
+                           "\\depth.raw",
+                           camera,
+                           &profiler );
+
+                status = logger.get_codes();
+                logger.reset();
 
-            TRACE( "\n___\noptimize" );
-            size_t n_iteration = cal.optimize(
-                []( algo::data_collect const & data )
+                profiler.section( "is_scene_valid" );
+                if( ! cal.is_scene_valid() )
                 {
-                } );
+                    TRACE( "-E- SCENE_INVALID" );
+                    if( ! status.empty() )
+                        status += ' ';
+                    status += "SCENE_INVALID";
+                }
+                profiler.section_end();
 
-            TRACE( "\n___\nis_valid_results" );
-            if( !cal.is_valid_results() )
-            {
-                TRACE("NOT VALID\n");
-                status += "BAD_RESULT";
-            }
-            else
-            {
-                status += "SUCCESSFUL";
+                profiler.section( "optimize" );
+                size_t n_iteration = cal.optimize();
+                profiler.section_end();
+
+                std::string results;
+                profiler.section( "is_valid_results" );
+                if( ! cal.is_valid_results() )
+                {
+                    TRACE( "NOT VALID\n" );
+                    results = "BAD_RESULT";
+                }
+                else
+                {
+                    results = "SUCCESSFUL";
+                }
+                profiler.section_end();
+
+                if( ! logger.get_codes().empty() )
+                {
+                    if( ! status.empty() )
+                        status += ' ';
+                    status += logger.get_codes();
+                    logger.reset();
+                }
+                if( ! status.empty() )
+                    status += ' ';
+                status += results;
             }
-            TRACE( "\n___\nRESULTS:  (" << RS2_API_VERSION_STR << " build 1973)" );
+
+            TRACE( "\n___\nRESULTS:  (" << RS2_API_VERSION_STR << " build 2158)" );
 
             auto intr = cal.get_calibration().get_intrinsics();
             auto extr = cal.get_calibration().get_extrinsics();
@@ -151,6 +276,19 @@ int main( int argc, char * argv[] )
             AC_LOG( DEBUG, AC_D_PREC << "extr" << (rs2_extrinsics) extr );
             AC_LOG( DEBUG, AC_D_PREC << "dsm" << cal.get_dsm_params() );
 
+            try
+            {
+                algo::validate_dsm_params( cal.get_dsm_params() );
+            }
+            catch( librealsense::invalid_value_exception const & e )
+            {
+                AC_LOG( ERROR, "Exception: " << e.what() );
+                if( ! status.empty() )
+                    status += ' ';
+                status += logger.get_codes();
+                logger.reset();
+            }
+
             TRACE( "\n___\nVS:" );
             AC_LOG( DEBUG, AC_D_PREC << "dsm" << camera.dsm_params );
          
diff --git a/unit-tests/algo/d2rgb/test-scenes.cpp b/unit-tests/algo/d2rgb/test-scenes.cpp
index 7fe5304..83efbff 100644
--- a/unit-tests/algo/d2rgb/test-scenes.cpp
+++ b/unit-tests/algo/d2rgb/test-scenes.cpp
@@ -7,6 +7,7 @@
 #define NO_CATCH_CONFIG_MAIN
 #define CATCH_CONFIG_RUNNER
 
+#define DISABLE_LOG_TO_STDOUT
 #include "d2rgb-common.h"
 #include "compare-to-bin-file.h"
 
@@ -59,6 +60,10 @@ void print_dividers()
     std::cout << std::right << std::setw( 4 ) << "---";
     std::cout << std::right << std::setw( 2 ) << " ";
     std::cout << std::right << std::setw( 7 ) << "-----";
+    std::cout << std::right << std::setw(2) << " ";
+    std::cout << std::right << std::setw(4) << "---";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 8 ) << "---";
     std::cout << std::endl;
 }
 
@@ -76,6 +81,10 @@ void print_headers()
     std::cout << std::right << std::setw( 4 ) << "Con";
     std::cout << std::right << std::setw( 2 ) << " ";
     std::cout << std::right << std::setw( 7 ) << "dPix";
+    std::cout << std::right << std::setw(2) << " ";
+    std::cout << std::right << std::setw(4) << "nC";
+    std::cout << std::right << std::setw( 2 ) << " ";
+    std::cout << std::right << std::setw( 8 ) << "MEM";
     std::cout << std::endl;
 
     print_dividers();
@@ -102,7 +111,8 @@ void print_scene_stats( std::string const & name, size_t n_failed, scene_stats c
     std::cout << std::left << std::setw( 2 ) << (scene.n_converged_diff ? "!" : "");
 
     std::cout << std::right << std::setw( 7 ) << scene.d_movement;
-
+    std::cout << std::right << std::setw(6) << scene.n_cycles;
+    std::cout << std::right << std::setw( 10 ) << scene.memory_consumption_peak;
     std::cout << std::endl;
 }
 
@@ -110,7 +120,7 @@ void print_scene_stats( std::string const & name, size_t n_failed, scene_stats c
 int main( int argc, char * argv[] )
 {
     Catch::Session session;
-    LOG_TO_STDOUT.enable( false );
+    ac_logger LOG_TO_STDOUT( false );
 
     Catch::ConfigData config;
     config.verbosity = Catch::Verbosity::Normal;
@@ -118,6 +128,7 @@ int main( int argc, char * argv[] )
     bool ok = true;
     bool verbose = false;
     bool stats = false;
+    bool debug_mode = false;
     // Each of the arguments is the path to a directory to simulate
     // We skip argv[0] which is the path to the executable
     // We don't complain if no arguments -- that's how we'll run as part of unit-testing
@@ -131,7 +142,12 @@ int main( int argc, char * argv[] )
                 LOG_TO_STDOUT.enable( verbose = true );
                 continue;
             }
-            if( !strcmp( dir, "--stats" ) )
+            if( ! strcmp( dir, "-d" ) || ! strcmp( dir, "--debug" ) )
+            {
+                debug_mode = true;
+                continue;
+            }
+            if( ! strcmp( dir, "--stats" ) )
             {
                 stats = true;
                 //config.outputFilename = "%debug";
@@ -160,7 +176,8 @@ int main( int argc, char * argv[] )
                     scene_dir = get_parent( scene_dir, &binFiles );
                     if( binFiles != "binFiles" )
                         return;
-                    std::string test_name = scene_dir.substr( strlen( dir ) + 1 );
+                    auto x = strlen( dir ) + 1;
+                    std::string test_name = x > scene_dir.length() ? "." : scene_dir.substr( x );
                     scene_dir += native_separator;
 
                     scene_stats scene;
@@ -169,7 +186,7 @@ int main( int argc, char * argv[] )
                     {
                         redirect_file no( stats ? stdout : stderr );
                         catch_total = ctx.run_test( test_name, [&]() {
-                            REQUIRE_NOTHROW( compare_scene( scene_dir, &scene ) );
+                            REQUIRE_NOTHROW( compare_scene( scene_dir, debug_mode, &scene ) );
                         } );
                     }
                     
@@ -185,6 +202,7 @@ int main( int argc, char * argv[] )
                     total.n_valid_result_diff += scene.n_valid_result_diff;
                     total.n_converged += scene.n_converged;
                     total.n_converged_diff += scene.n_converged_diff;
+                    total.memory_consumption_peak += scene.memory_consumption_peak;
 
                     if( stats )
                         print_scene_stats( test_name, catch_total.assertions.failed, scene );
diff --git a/unit-tests/profiler.h b/unit-tests/profiler.h
new file mode 100644
index 0000000..37b5c51
--- /dev/null
+++ b/unit-tests/profiler.h
@@ -0,0 +1,90 @@
+#pragma once
+
+#ifdef _WIN32
+#include "windows.h"
+#include "psapi.h"
+#else
+#endif
+
+
+float mb_in_use()
+{
+    float mem = 0;
+#ifdef _WIN32
+    PROCESS_MEMORY_COUNTERS_EX pmc;
+    GetProcessMemoryInfo( GetCurrentProcess(), (PROCESS_MEMORY_COUNTERS *)&pmc, sizeof( pmc ) );
+
+    mem = float( pmc.WorkingSetSize / (1024. * 1024.) );
+#else
+#endif
+    return mem;
+}
+class memory_profiler
+{
+    float _baseline;
+    std::atomic< float > _peak{ 0 };
+    std::atomic_bool _alive{ true };
+
+    std::thread _th;
+
+    // section
+    float _s_start = 0.f;
+    std::atomic< float > _s_peak;
+
+public:
+    memory_profiler()
+        : _baseline( mb_in_use() )
+    {
+        _th = std::thread( [&]() {
+            while( _alive )
+            {
+                auto const mb = mb_in_use();
+                _peak = std::max( mb, (float)_peak );
+                _s_peak = std::max( mb, (float)_s_peak );
+                std::this_thread::sleep_for( std::chrono::milliseconds( 10 ) );
+            }
+            } );
+    }
+
+    void section( char const * heading )
+    {
+        _s_start = mb_in_use();
+        _s_peak = _s_start;
+        TRACE( "\n\n-P------------ " << heading << ":" );
+    }
+
+    void section_end()
+    {
+        auto const mb = mb_in_use();
+        _s_peak = std::max( mb, (float)_s_peak );
+        TRACE( "-P------------ " << _s_start << " --> " << mb << "  /  " << _s_peak
+            << " MB        delta  " << (mb - _s_start) << "  /  "
+            << (_s_peak - _s_start) << "  peak\n" );
+    }
+
+    ~memory_profiler()
+    {
+        stop();
+
+        auto const mb = mb_in_use();
+        TRACE( "\n-P------------ FINAL: " << mb << "  /  " << _peak << " peak  (" << _baseline
+            << " baseline)" );
+    }
+
+    void snapshot( char const * desc )
+    {
+        TRACE( "-P------------ " << desc << ": " << mb_in_use() << "  /  " << (float)_peak << " peak" );
+    }
+
+    void stop()
+    {
+        if( _alive )
+        {
+            _alive = false;
+            _th.join();
+        }
+    }
+
+    float get_peak() const { return _peak; }
+    float get_baseline() const { return _baseline; }
+};
diff --git a/unit-tests/unit-test-long.cpp b/unit-tests/unit-test-long.cpp
index 9057d87..a1d53f2 100644
--- a/unit-tests/unit-test-long.cpp
+++ b/unit-tests/unit-test-long.cpp
@@ -1,4 +1,3 @@
-#ifdef __linux__
 #include <cmath>
 #include "unit-tests-common.h"
 #include <librealsense2/hpp/rs_types.hpp>
@@ -8,13 +7,15 @@
 #include <ctime>
 #include <algorithm>
 #include <librealsense2/rsutil.h>
-#include <sys/wait.h>
-#include <semaphore.h>
-#include <fcntl.h>
 
 using namespace rs2;
 using namespace std::chrono;
 
+#ifdef __linux__
+#include <sys/wait.h>
+#include <semaphore.h>
+#include <fcntl.h>
+
 bool stream(std::string serial_number, sem_t* sem2, bool do_query)
 {
     signal(SIGTERM, [](int signum) { std::cout << "SIGTERM: " << getpid() << std::endl; exit(1);});
@@ -204,3 +205,212 @@ TEST_CASE("multicam_streaming", "[live][multicam]")
     }
 }
 #endif // __linux__
+
+struct global_time_test_meta_data : public internal_frame_additional_data
+{
+    double system_time;
+
+    global_time_test_meta_data(const double &ts, const unsigned long long frame_num, const rs2_timestamp_domain& ts_domain, const rs2_stream& strm, const rs2_format& fmt, double& sts) :
+        internal_frame_additional_data(ts, frame_num, ts_domain, strm, fmt)
+    {
+        system_time = sts;
+    }
+};
+
+struct time_results
+{
+    double min_diff, max_diff;
+};
+
+void run_sensor(rs2::sensor subdevice, rs2::stream_profile profile, bool enable_gts, int iter, double& max_diff_system_global_time)
+{
+    const double msec_to_sec = 0.001;
+    const int frames_for_fps_measure(profile.fps() * 1);  // max number of frames
+
+    std::vector<global_time_test_meta_data> frames_additional_data;
+    double start_time;
+    std::condition_variable cv;
+    std::mutex m;
+    auto first = true;
+
+    REQUIRE_NOTHROW(subdevice.open({ profile }));
+
+    disable_sensitive_options_for(subdevice);
+    if (enable_gts)
+        REQUIRE_NOTHROW(subdevice.set_option(RS2_OPTION_GLOBAL_TIME_ENABLED, 1));
+
+    REQUIRE_NOTHROW(subdevice.start([&](rs2::frame f)
+    {
+        double crnt_time(internal::get_time());
+        if (first)
+        {
+            start_time = crnt_time;
+        }
+        first = false;
+
+        if ((frames_additional_data.size() >= frames_for_fps_measure))
+        {
+            cv.notify_one();
+        }
+
+        if (frames_additional_data.size() < frames_for_fps_measure)
+        {
+            global_time_test_meta_data data{ f.get_timestamp(),
+                f.get_frame_number(),
+                f.get_frame_timestamp_domain(),
+                f.get_profile().stream_type(),
+                f.get_profile().format(),
+                crnt_time
+            };
+
+            std::unique_lock<std::mutex> lock(m);
+            frames_additional_data.push_back(data);
+        }
+    }));
+
+    CAPTURE(frames_for_fps_measure);
+
+    std::unique_lock<std::mutex> lock(m);
+    cv.wait_for(lock, std::chrono::seconds(10), [&] {return ((frames_additional_data.size() >= frames_for_fps_measure)); });
+    CAPTURE(frames_additional_data.size());
+
+    auto end = internal::get_time();
+    REQUIRE_NOTHROW(subdevice.stop());
+    REQUIRE_NOTHROW(subdevice.close());
+
+    lock.unlock();
+
+    auto seconds = (end - start_time)*msec_to_sec;
+
+    CAPTURE(start_time);
+    CAPTURE(end);
+    CAPTURE(seconds);
+
+    REQUIRE(seconds > 0);
+
+    if (frames_additional_data.size())
+    {
+        std::stringstream name;
+        name << "test_results_" << iter << "_" << enable_gts << ".txt";
+        std::ofstream fout(name.str());
+        //std::ofstream fout("test_results.txt");
+        for (auto data : frames_additional_data)
+        {
+            fout << std::fixed << std::setprecision(4) << data.system_time << " " << data.timestamp << " " << rs2_timestamp_domain_to_string(data.timestamp_domain) << std::endl;
+        }
+        fout.close();
+
+        rs2_timestamp_domain first_timestamp_domain(frames_additional_data[0].timestamp_domain);
+        auto actual_fps = (double)frames_additional_data.size() / (double)seconds;
+        CAPTURE(actual_fps);
+        max_diff_system_global_time = 0;
+        for (int i = 1; i < frames_additional_data.size(); i++)
+        {
+            const global_time_test_meta_data& crnt_data = frames_additional_data[i];
+            const global_time_test_meta_data& prev_data = frames_additional_data[i - 1];
+            if ((crnt_data.timestamp_domain != first_timestamp_domain) ||
+                (prev_data.timestamp_domain != first_timestamp_domain))
+            {
+                continue;
+            }
+            double system_ts_diff = crnt_data.system_time - prev_data.system_time;
+            double ts_diff = crnt_data.timestamp - prev_data.timestamp;
+            REQUIRE(system_ts_diff > 0);
+            REQUIRE(ts_diff > 0);
+            double crnt_diff(system_ts_diff - ts_diff); //big positive difference means system load. big negative means big global time correction.
+            max_diff_system_global_time = std::max(max_diff_system_global_time, crnt_diff);
+        }
+    }
+}
+
+TEST_CASE("global-time-start", "[live]") {
+    //Require at least one device to be plugged in
+    // This test checks if there are delays caused by GlobalTimeStampReader:
+    // The test finds the maximal system time difference and frame time difference between every 2 consecutive frames.
+    // It then checks that the maximal difference found between system time and frame time is about the same 
+    // for runs with global time stamp on and runs with global time stamp off.
+
+    rs2::context ctx;
+    if (make_context(SECTION_FROM_TEST_NAME, &ctx))
+    {
+        std::vector<sensor> list;
+        REQUIRE_NOTHROW(list = ctx.query_all_sensors());
+        REQUIRE(list.size() > 0);
+
+        const int frames_before_start_measure = 10;
+        const double msec_to_sec = 0.001;
+        const int num_of_profiles_for_each_subdevice = 2;
+        const float max_diff_between_real_and_metadata_fps = 1.0f;
+
+        // Find profile with greatest fps:
+        int max_fps(0);
+        for (auto && subdevice : list) {
+            if (!subdevice.supports(RS2_OPTION_GLOBAL_TIME_ENABLED))
+                continue;
+            std::vector<rs2::stream_profile> modes;
+            REQUIRE_NOTHROW(modes = subdevice.get_stream_profiles());
+            REQUIRE(modes.size() > 0);
+            for (auto profile : modes)
+            {
+                if (max_fps < profile.fps())
+                {
+                    max_fps = profile.fps();
+                }
+            }
+        }
+
+        for (auto && subdevice : list) {
+            if (!subdevice.supports(RS2_OPTION_GLOBAL_TIME_ENABLED))
+                continue;
+            std::vector<rs2::stream_profile> modes;
+            REQUIRE_NOTHROW(modes = subdevice.get_stream_profiles());
+
+            REQUIRE(modes.size() > 0);
+            CAPTURE(subdevice.get_info(RS2_CAMERA_INFO_NAME));
+
+            //the test will be done only on the profile with maximal fps:
+            for (auto profile : modes)
+            {
+                if (profile.fps() < max_fps)
+                    continue;
+
+                CAPTURE(profile.format());
+                CAPTURE(profile.fps());
+                CAPTURE(profile.stream_type());
+                CAPTURE(profile.stream_index());
+                if (auto video = profile.as<video_stream_profile>())
+                {
+                    CAPTURE(video.width());
+                    CAPTURE(video.height());
+                }
+
+                double max_diff_system_global_time;
+                std::vector<double> all_results_gts_on;
+                std::vector<double> all_results_gts_off;
+                const int num_of_runs(30);
+                for (int i = 0; i < num_of_runs; i++)
+                {
+                    run_sensor(subdevice, profile, true, i, max_diff_system_global_time);
+                    all_results_gts_on.push_back(max_diff_system_global_time);
+                    std::cout << "Ran iteration " << i << "/" << num_of_runs << " - gts-ON: max_diff_system_global_time=" << max_diff_system_global_time << std::endl;
+
+                    run_sensor(subdevice, profile, false, i, max_diff_system_global_time);
+                    all_results_gts_off.push_back(max_diff_system_global_time);
+                    std::cout << "Ran iteration " << i << "/" << num_of_runs << " - gts-OFF: max_diff_system_global_time=" << max_diff_system_global_time << std::endl;
+                }
+                std::nth_element(all_results_gts_on.begin(), all_results_gts_on.begin() + all_results_gts_on.size() / 2, all_results_gts_on.end());
+                double median_diff_gts_on = all_results_gts_on[all_results_gts_on.size() / 2];
+                std::nth_element(all_results_gts_off.begin(), all_results_gts_off.begin() + all_results_gts_off.size() / 2, all_results_gts_off.end());
+                double median_diff_gts_off = all_results_gts_off[all_results_gts_off.size() / 2];
+                CAPTURE(median_diff_gts_on);
+                CAPTURE(median_diff_gts_off);
+
+                REQUIRE(median_diff_gts_on > 0.5*median_diff_gts_off);
+                REQUIRE(median_diff_gts_on < 2.0*median_diff_gts_off);
+                
+                break; // Check 1 profile only.
+            }
+        }
+    }
+}
+
diff --git a/wrappers/android/tools/camera/src/main/AndroidManifest.xml b/wrappers/android/tools/camera/src/main/AndroidManifest.xml
index 26e03d7..333911b 100644
--- a/wrappers/android/tools/camera/src/main/AndroidManifest.xml
+++ b/wrappers/android/tools/camera/src/main/AndroidManifest.xml
@@ -24,6 +24,7 @@
         </activity>
         <activity
             android:name=".PreviewActivity"
+            android:launchMode="singleTop"
             android:theme="@style/AppTheme.NoActionBar" />
         <activity
             android:name=".SettingsActivity"
@@ -49,4 +50,4 @@
             android:theme="@style/AppTheme.NoActionBar" />
     </application>
 
-</manifest>
\ No newline at end of file
+</manifest>
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
index ae98812..d820631 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/DetachedActivity.java
@@ -53,28 +53,7 @@ public class DetachedActivity extends AppCompatActivity {
 
         requestPermissionsIfNeeded();
 
-        mPlaybackButton = findViewById(R.id.playbackButton);
-        mPlaybackButton.setOnClickListener(new View.OnClickListener() {
-            @Override
-            public void onClick(View view) {
-                mDetached = false;
-                finish();
-                Intent intent = new Intent(DetachedActivity.this, PlaybackActivity.class);
-                startActivityForResult(intent, PLAYBACK_REQUEST_CODE);
-            }
-        });
-
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                String appVersion = BuildConfig.VERSION_NAME;
-                String lrsVersion = RsContext.getVersion();
-                TextView versions = findViewById(R.id.versionsText);
-                versions.setText("librealsense version: " + lrsVersion + "\ncamera app version: " + appVersion);
-            }
-        });
-
-        mMinimalFirmwares.put(ProductLine.D400, MINIMAL_D400_FW_VERSION);
+        init();
     }
 
     private void requestPermissionsIfNeeded() {
@@ -93,7 +72,7 @@ public class DetachedActivity extends AppCompatActivity {
     @Override
     protected void onResume() {
         super.onResume();
-        mDetached = true;
+
         if (isCameraPermissionGranted()) {
             RsContext.init(getApplicationContext());
             mRsContext.setDevicesChangedCallback(mListener);
@@ -109,12 +88,53 @@ public class DetachedActivity extends AppCompatActivity {
         return ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;
     }
 
+    private synchronized void init()
+    {
+        mPlaybackButton = findViewById(R.id.playbackButton);
+        mPlaybackButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View view) {
+                mDetached = false;
+                finish();
+                Intent intent = new Intent(DetachedActivity.this, PlaybackActivity.class);
+                startActivityForResult(intent, PLAYBACK_REQUEST_CODE);
+            }
+        });
+
+        runOnUiThread(new Runnable() {
+            @Override
+            public void run() {
+                String appVersion = BuildConfig.VERSION_NAME;
+                String lrsVersion = RsContext.getVersion();
+                TextView versions = findViewById(R.id.versionsText);
+                versions.setText("librealsense version: " + lrsVersion + "\ncamera app version: " + appVersion);
+            }
+        });
+
+        mMinimalFirmwares.put(ProductLine.D400, MINIMAL_D400_FW_VERSION);
+    }
+
     private synchronized void validatedDevice(){
         if(mUpdating)
             return;
         try(DeviceList dl = mRsContext.queryDevices()){
-            if(dl.getDeviceCount() == 0)
+            if(dl.getDeviceCount() == 0) {
+                init();
+
+                // kill preview activity if device disconnected
+                if (mDetached) {
+                    mDetached = false;
+
+                    Intent intent = new Intent(this, PreviewActivity.class);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                    intent.putExtra("keepalive", false);
+                    startActivity(intent);
+                }
+
                 return;
+            }
+
             try(Device d = dl.createDevice(0)){
                 if(d == null)
                     return;
@@ -127,10 +147,17 @@ public class DetachedActivity extends AppCompatActivity {
                 else {
                     if (!validateFwVersion(d))
                         return;
+
                     mDetached = false;
 
-                    finish();
+
+                    // launch preview activity and keep it alive
+                    // the activity is single top instance, can be killed later the same instance
+                    // to prevent issues with multiple instances
                     Intent intent = new Intent(this, PreviewActivity.class);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+                    intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                    intent.putExtra("keepalive", true);
                     startActivity(intent);
                 }
             }
@@ -201,11 +228,8 @@ public class DetachedActivity extends AppCompatActivity {
 
         @Override
         public void onDeviceDetach() {
-            if(mDetached)
-                return;
-            finish();
-            Intent intent = new Intent(mAppContext, DetachedActivity.class);
-            startActivity(intent);
+            mDetached = true;
+            validatedDevice();
         }
     };
 }
diff --git a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
index 419d358..f847fe9 100644
--- a/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
+++ b/wrappers/android/tools/camera/src/main/java/com/intel/realsense/camera/PreviewActivity.java
@@ -54,6 +54,8 @@ public class PreviewActivity extends AppCompatActivity {
     private boolean statsToggle = false;
     private boolean mShow3D = false;
 
+    boolean keepalive = true;
+
     public synchronized void toggleStats(){
         statsToggle = !statsToggle;
         if(statsToggle){
@@ -72,6 +74,15 @@ public class PreviewActivity extends AppCompatActivity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         setContentView(R.layout.activity_preview);
+
+        keepalive = true;
+
+        Intent intent = this.getIntent();
+
+        if (intent != null && intent.getExtras() != null ) {
+            keepalive = intent.getExtras().getBoolean("keepalive");
+        }
+
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
 
         mGLSurfaceView = findViewById(R.id.glSurfaceView);
@@ -204,6 +215,11 @@ public class PreviewActivity extends AppCompatActivity {
     protected void onResume() {
         super.onResume();
 
+        if(keepalive == false)
+        {
+            return;
+        }
+
         mStreamingStats  = new StreamingStats();
         mStreamer = new Streamer(this, true, new Streamer.Listener() {
             @Override
@@ -298,4 +314,21 @@ public class PreviewActivity extends AppCompatActivity {
         }
         mFwLogsRunning = false;
     }
+
+    @Override
+    protected void onNewIntent(Intent intent)
+    {
+        super.onNewIntent(intent);
+
+        if (intent != null && intent.getExtras() != null ) {
+            keepalive = intent.getExtras().getBoolean("keepalive");
+        }
+
+        // destroy activity if requested
+        if(keepalive == false)
+        {
+            PreviewActivity.this.finish();
+        }
+    }
+
 }
diff --git a/wrappers/python/examples/box_dimensioner_multicam/readme.md b/wrappers/python/examples/box_dimensioner_multicam/readme.md
index 6e49cca..4d61ae1 100644
--- a/wrappers/python/examples/box_dimensioner_multicam/readme.md
+++ b/wrappers/python/examples/box_dimensioner_multicam/readme.md
@@ -27,7 +27,7 @@ Note: To keep the demo simpler, the clipping of the usable point cloud is done b
 ## Example Output
 Once the calibration is done and the target object's dimensions are calculated, the application will open as many windows as the number of devices connected each displaying a color image along with an overlay of the calculated bounding box.
 In the following example we've used two Intel® RealSense™ Depth Cameras D435 pointing at a common object placed on a 6 x 9 chessboard (checked-in with this demo folder).
-![sampleSetupAndOutput](https://github.com/framosgmbh/librealsense/blob/box_dimensioner_multicam/wrappers/python/examples/box_dimensioner_multicam/samplesetupandoutput.jpg)
+[sampleSetupAndOutput](https://github.com/IntelRealSense/librealsense/blob/master/wrappers/python/examples/box_dimensioner_multicam/samplesetupandoutput.jpg)
 
 ## References
 Rotation between two co-ordinates using Kabsch Algorithm: 
diff --git a/wrappers/python/pyrs_device.cpp b/wrappers/python/pyrs_device.cpp
index d547da1..0d2c730 100644
--- a/wrappers/python/pyrs_device.cpp
+++ b/wrappers/python/pyrs_device.cpp
@@ -96,7 +96,13 @@ void init_device(py::module &m) {
 
     py::class_<rs2::device_calibration, rs2::device> device_calibration( m, "device_calibration" );
     device_calibration.def( py::init<rs2::device>(), "device"_a )
-        .def( "trigger_device_calibration", &rs2::device_calibration::trigger_device_calibration, "TODO", "calibration_type"_a )
+        .def( "trigger_device_calibration",
+            []( rs2::device_calibration & self, rs2_calibration_type type )
+            {
+                py::gil_scoped_release gil;
+                self.trigger_device_calibration( type );
+            },
+            "Trigger the given calibration, if available", "calibration_type"_a )
         .def( "register_calibration_change_callback",
             []( rs2::device_calibration& self, std::function<void( rs2_calibration_status )> callback )
             {
@@ -117,7 +123,7 @@ void init_device(py::module &m) {
                         }
                     } );
             },
-            "TODO", "callback"_a );
+            "Register (only once!) a callback that gets called for each change in calibration", "callback"_a );
 
 
     py::class_<rs2::debug_protocol> debug_protocol(m, "debug_protocol"); // No docstring in C++
diff --git a/wrappers/python/pyrs_sensor.cpp b/wrappers/python/pyrs_sensor.cpp
index dbfd4bc..f57b0aa 100644
--- a/wrappers/python/pyrs_sensor.cpp
+++ b/wrappers/python/pyrs_sensor.cpp
@@ -105,11 +105,24 @@ void init_sensor(py::module &m) {
 
     py::class_<rs2::calibrated_sensor, rs2::sensor> cal_sensor( m, "calibrated_sensor" );
     cal_sensor.def( py::init<rs2::sensor>(), "sensor"_a )
-        .def( "override_intrinsics", &rs2::calibrated_sensor::override_intrinsics, "intrinsics"_a )
-        .def( "override_extrinsics", &rs2::calibrated_sensor::override_extrinsics, "extrinsics"_a )
-        .def( "get_dsm_params", &rs2::calibrated_sensor::get_dsm_params )
-        .def( "override_dsm_params", &rs2::calibrated_sensor::override_dsm_params, "dsm_params"_a )
-        .def( "reset_calibration", &rs2::calibrated_sensor::reset_calibration )
+        .def( "override_intrinsics",
+              &rs2::calibrated_sensor::override_intrinsics,
+              "intrinsics"_a,
+              py::call_guard< py::gil_scoped_release >() )
+        .def( "override_extrinsics",
+              &rs2::calibrated_sensor::override_extrinsics,
+              "extrinsics"_a,
+              py::call_guard< py::gil_scoped_release >() )
+        .def( "get_dsm_params",
+              &rs2::calibrated_sensor::get_dsm_params,
+              py::call_guard< py::gil_scoped_release >() )
+        .def( "override_dsm_params",
+              &rs2::calibrated_sensor::override_dsm_params,
+              "dsm_params"_a,
+              py::call_guard< py::gil_scoped_release >() )
+        .def( "reset_calibration",
+              &rs2::calibrated_sensor::reset_calibration,
+              py::call_guard< py::gil_scoped_release >() )
         .def( "__nonzero__", &rs2::calibrated_sensor::operator bool );
 
     // rs2::depth_stereo_sensor
-- 
2.17.1

